<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Maksim"><title>Objective-C Runtime：Class · Maksim's Website</title><meta name="description" content="Objective-C具有相当多的动态特性，表现在三个方面动态类型（Dynamic typeing）、动态绑定（ggDynamic binding）、动态加载（Dynamic loading），之所以被叫做动态，是因为必须到运行时（Runtime）才会做这些事情。

动态类型：即运行时在决定对象的类"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Maksim's Website</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li><li><a href="/categories/PHP">PHP</a></li><li><a href="/categories/iOS">iOS</a></li><li><a href="/categories/MySQL">MySQL</a></li><li><a href="/categories/Linux">Linux</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Objective-C Runtime：Class</a></h3></div><div class="post-content"><p>Objective-C具有相当多的动态特性，表现在三个方面动态类型（Dynamic typeing）、动态绑定（ggDynamic binding）、动态加载（Dynamic loading），之所以被叫做动态，是因为必须到运行时（Runtime）才会做这些事情。</p>
<ol>
<li><strong>动态类型</strong>：即运行时在决定对象的类型。这类动态特性在日常生活中非常常见，简单说就是id类型。实际上静态类因为固定性与可与执行而使用得更加广泛，静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。</li>
<li><strong>动态绑定</strong>：基于冬天类型，在某个实例对象呗确定后，其类型便被确定了，该对象对应的水泥管和响应的消息也将会被完全确定。</li>
<li><strong>动态加载</strong>：根据需求加载所需要的资源，最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的图通屏幕设备上加载原图。</li>
</ol>
<p>这一切的特性都是由于objective-c的Runtime。</p>
<p>Runtime库主要做了下面的几件事</p>
<ol>
<li>封装：在这个库中对象可以用C语言的结构体表示，而方法可以用C函数来实现，另外再加上一些额外的特性。这些结构体和函数被runtime封装后，我们就可以在程序运行时创建、检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行[object doSometing]时，会想消息接受者（object）发送一条消息，runtime会根据消息接受者是否响应该消息而做出不同的反应。</li>
</ol>
<p>而在我们在了解Runtime之前，我们需要清楚Runtime的数据类型</p>
<p>如果想要进一步的了解，我们可以到苹果开源上下载Runtime的源码来进行学习。</p>
<p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>                             <span class="title">OBJC2_UNAVAILABLE</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>                    <span class="title">OBJC2_UNAVAILABLE</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>                                 <span class="title">OBJC2_UNAVAILABLE</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>                     <span class="title">OBJC2_UNAVAILABLE</span>;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div><div class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></div></pre></td></tr></table></figure>
<ol>
<li>isa:需要注意的是在Objective-C中，所有类的自身也是一个对象这个对象的Class里面有一个isa指针，它指向metaClass（元类），下一章进行详细介绍。</li>
<li>super_class：指向该类的父类，如果该类已经是最顶层的根类，则它的值为NULL。</li>
<li>name：类的名称</li>
<li>info:在运行时使用的一些标识</li>
<li>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。<br>针对cache，我们用下面例子来说明其执行过程：</li>
<li>instance_size 该类实例变量的大小</li>
<li>ivars 该类中所有成员变量的数组</li>
<li>methodLists 该类中自定义方法的数组 </li>
<li>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</li>
<li>protocls 该类遵守协议的数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *array = [[NSArray alloc] init];</div></pre></td></tr></table></figure>
<p>其流程是：</p>
<p>[NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。</p>
<p>检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。</p>
<p>接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。</p>
<p>在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</p>
<p>##参考资料</p>
<ol>
<li><a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/" target="_blank" rel="external">Objective-C Runtime 运行时之一：类与对象</a></li>
<li><a href="http://www.cnblogs.com/whyandinside/archive/2013/02/26/2933552.html" target="_blank" rel="external">Objective-C Runtime的数据类型</a></li>
<li><a href="http://blog.csdn.net/uxyheaven/article/details/38113901" target="_blank" rel="external">Objective-C objc_class 介绍</a></li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-05-31</span><i class="fa fa-tag"></i><a href="/categories/iOS/" title="iOS" class="tag">iOS </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2016/05/31/2/,Maksim's Website,Objective-C Runtime：Class,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/07/20/cj8snj0ix002pt0rdwixn4vwr/" title="对于未来的规划" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/05/08/cj8snj0hs001qt0rdoxtp4lsw/" title="使用 Feedly RSS阅读器订阅技术大牛的博客" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>