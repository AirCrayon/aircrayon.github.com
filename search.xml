<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Nginx的安装</title>
      <link href="/2018/02/27/cjek1d3iq0018rhrdma2piy7p/"/>
      <content type="html"><![CDATA[<p>Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。</p><p>在安装 Nginx 时，我们可以通过以下两种方式进行安装：</p><ol><li>使用包管理器安装 Nginx</li><li>通过源代码安装 Nginx</li></ol><h2 id="使用包管理器安装-Nginx"><a href="#使用包管理器安装-Nginx" class="headerlink" title="使用包管理器安装 Nginx"></a>使用包管理器安装 Nginx</h2><p>使用包管理器安装 Nginx 的机会，是你使用的操作系统已经提供了 Nginx 的安装包。使用包管理器安装 Nginx 的方式很简单，只需要在终端输入：</p><p>Linux(基于 deb，如 Ubunut)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure><p> Linux（基于 rpm，如 CentOS)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>FreeBSD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pkg_install -r nginx</div></pre></td></tr></table></figure><p>通过上述命令，Nginx 将会安装到操作系统的标准位置下。如果使用操作系统的安装包安装 Nginx，那么通过上面的命令来安装是最佳方式。</p><p>Nginx 核心团队也提供了稳定的二进制版本，可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 页面下载可用版本。未发布 Nginx 安装包的系统用户（例如，CentOS），可以使用下面指导来安装预测试、预编译二进制版本。</p><p>通过创建下面的文件，在系统中添加 Nginx 仓库的 yum 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/yum.repos.d/nginx.repo</div><div class="line">[nginx]</div><div class="line">name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure><p>然后，听过执行如下命令来安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>也可以按照前面介绍的 URL 下载 nginx 发行版安装。</p><h2 id="从源代码安装-Nginx"><a href="#从源代码安装-Nginx" class="headerlink" title="从源代码安装 Nginx"></a>从源代码安装 Nginx</h2><p>Nginx 代码提供了两种独立的下载分支——开发版与稳定版。开发分支是一个正处于积极开发状态的版本。在这个版本中，会有一些新功能被集成到其中，在稳定版中是找不到这些功能的。当发布一个“开发”版时，它会经历同样的 QA 和作为稳定版本的一组类似测试功能。因此无论哪一个分支都一颗用于生产环境中，两者主要的不同，在于对第三方模块的支持。在开发板中，内部的 API 可能会发生改变，而稳定版则保持不变。因此，为了与第三方模块向下兼容，在稳定版中第三方模块都可以有效使用。</p><h3 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h3><p>为了从源代码编译 Nginx，系统需要满足某些必要条件，除了编译器外，如果想分别启用 SSL 支持和使用 rewrite 模块，那么还需要提供响应的 OpenSSL 与 PCRE（Perl Compatible Regular Expressions）库及开发头文件。rewrite 模块是默认安装的。如果你还没有 PCRE 库与开发头文件，你需要在配置阶段禁用 rewrite 模块。这依赖于系统，也有可能在系统中已经默认安装了这些必要条件。如果没有安装，则需要从其安装包安装或者从源码下载并且解压安装，在 Nginx 配置脚本中指定他们在系统中的安装位置。</p><p>如果在配置文件中使用了—with-\<library\>=\<path\>选项，那么 Nginx 会视图建立一个静态依赖库。如果你想让 Nginx 不依赖于系统的任何其他部分，或是想获得些 Nginx 的二进制额外性能，那么你可能会使用构建静态库的做法。如果你使用外部库功能只能从某一个版本起有效（例如，NPN[Next Protocol Negotiation]TLS扩展从 OpenSSL1.0.1版有效），那么你就不得不将其指定到特定版本解压后的源代码路径中。</path\></library\></p><p>根据自己的喜好，你可能会提供其他的、可选安装包。你可以为这些安装包提供支持。他们包括 MD5和 SHA-1以支持散列算法、zip 压缩库、libatomic 库。在 Nginx 中，很多地方法会用到散列库，例如为了计算 URI 散列进而计算缓存 key。</p><p>zlib 压缩裤被用来投递 gzip 压缩内容。如果 atomic_ops 库有效，那么 Nginx 会用它来实现自动内存更新操作，以实现高性能的内存锁定代码。</p><h3 id="从源代码编译"><a href="#从源代码编译" class="headerlink" title="从源代码编译"></a>从源代码编译</h3><p>读者可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载 Nginx，在该页面找到.tar.gz 或者.zip 格式的源代码分支，安装如下步骤将下载的安装包解压到一个临时目录中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir ~/bulid</div><div class="line"><span class="meta">$</span> cd ~/bulid &amp;&amp; tar xzf nginx-&lt;version-number&gt;.tar.gz</div></pre></td></tr></table></figure><p>使用下面命令配置 Nginx:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cd ~/bulid/nginx-&lt;version-number&gt; &amp;&amp; ./configure</div></pre></td></tr></table></figure><p>然后，使用下面命令进行编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> make &amp;&amp; sudo make install</div></pre></td></tr></table></figure><p>在编译自己的二进制 nginx 时，你会有很大的灵活性来包含你仅使用的功能。你已经指定使用哪个用户运行 Nginx 了吗?你要使用默认的 logfile 位置，以便不用在 Nginx 的配置文件明确地说明它们吗?表 1-1 所示是配置选项列表，通过它来帮助你设计出自己的 nginx 命令。这些选项对 Nginx 都是有效的，模块可以被独立激活。</p><table><thead><tr><th>选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td>–prefix=\<path\></path\></td><td style="text-align:left">Nginx 安装的根路径，所有其他的安装路径都要依赖于该选项</td></tr><tr><td>–sbin-path=\<path\></path\></td><td style="text-align:left">指定 Nginx 二进制文件的路径。如果没有指定，那么这个路径依赖于——prefix 选项</td></tr><tr><td>–conf-path=\<path\></path\></td><td style="text-align:left">如果在命令行没有指定配置文件，那么将会通过这里指定的路径，Nginx 将会去那里寻找它的配置文件</td></tr><tr><td>–error-log-path=\<path\></path\></td><td style="text-align:left">指定错误文件的路径，Nginx 会将其中写入错误日志文件，除非有其他配置</td></tr><tr><td>–pid-path=\<path\></path\></td><td style="text-align:left">指定的文件将会写入 Nginx master 进程的pid，通常在/var/run 下</td></tr><tr><td>–lock-path=\<path\></path\></td><td style="text-align:left">共享存储器互斥锁文件的路径</td></tr><tr><td>–user=\<user\></user\></td><td style="text-align:left">worker 进程运行的用户</td></tr><tr><td>–group=\<group\></group\></td><td style="text-align:left">worker 进程运行的组</td></tr><tr><td>–with-file-aio</td><td style="text-align:left">为 FreeBSD4.3+和 Linux2.6.22+系统启用异步 I/O</td></tr><tr><td>–with-debug</td><td style="text-align:left">这个选项用于启用调试日志。在生产环境中不推荐使用该选项。</td></tr></tbody></table><p>你可以使用优化编译，单但是如果使用包管理工具进行安装将无法获得这些优化，如下表：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–with-cc=\<path\></path\></td><td>如果想设置一个不再默认 Path 下的编译器</td></tr><tr><td>–with-cpp=\<path\></path\></td><td>设置 C 预处理器的响应路径</td></tr><tr><td>–with-cc-opt=\<options></options></td><td>指定必要的 include 文件路径，可能（-I\<path\>）指出，也可能是优化(-O4)并指定64位构建</path\></td></tr><tr><td>–with-ld-opt=\<options\></options\></td><td>包含连接器库的路径(-L\<path\>)和运行路径(-R\<path\>)</path\></path\></td></tr><tr><td>—with-cpu-opt=\<cpu\></cpu\></td><td>通过该选项为特定的 CPU 构建 Nginx</td></tr></tbody></table><h2 id="配置-SSL-支持"><a href="#配置-SSL-支持" class="headerlink" title="配置 SSL 支持"></a>配置 SSL 支持</h2><p>对于 TLS/SSL 协议，Nginx 使用 OpenSSL 项目。有关此开源工具包的更多信息，请访问 <a href="https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对" target="_blank" rel="noopener">https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对</a> SSL 的支持。如果使用不带–with-ssl 选项的–with-http_ssl_module 或者–with-mail_ssl_module，你正在使用执行了 configure 命令的、安装在计算机上的 OpenSSL 库。如果你想要针对特定版本的 OpenSSL 进行编译，请下载该分发包，将其解压缩到一个目录中，然后将该目录的路径指定为–with-openssl 的参数。使用–with-openssl-opt 选项为 OpenSSL本身指定额外的构建选项。</p><p>例如，为了使用具有优化椭圆曲线的 OpenSSL 来构建 Nginx，您将使用如下的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ./configure --with-http_ssl_module --with-openssl=$&#123;BUILD_DIR&#125;/openssl-1.0.1p --with-openssl-opt=enable-ec_nistp_64_gcc_128</div></pre></td></tr></table></figure><h2 id="查找并安装第三方模块"><a href="#查找并安装第三方模块" class="headerlink" title="查找并安装第三方模块"></a>查找并安装第三方模块</h2><p>由于有多个开源项目，所以在 Nginx 周围就会有一个活跃的开发社区。由于 Nginx 的模块化特性，这个社区能够开发和发布模块，从而为 Nginx 提供额外的功能。它们涵盖了广泛的应用，所以着手开发自己的模块之前应该看看有什么可用模块。</p><p>安装第三方模块的过程相当简单，步骤如下。</p><p>1.定位你想要使用的模块(在 <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 或者是 <a href="http://wiki.nginx.org/3rdPartyModules查找)。" target="_blank" rel="noopener">http://wiki.nginx.org/3rdPartyModules查找)。</a></p><p>2.下载该模块。</p><p>3.解压缩源代码安装包。</p><p>4.如果有 README 文件，那么阅读 README 文件，查看在安装中是否有依赖安装。</p><p>5.通过./configure–add-module=\<path\>选项配置使用该模块。</path\></p><p>这个过程会给你的 nginx 二进制文件与模块附加这个功能。</p><p>需要注意的是，很多第三方模块是实验性质的。因此，在将这些模块用于生产系统之前，首先要测试使用这些模块。另外请记住，Nginx 的开发版本中可能会有 API 的变化，会导致第三方模块出现问题。</p><h2 id="添加对-Lua-的支持"><a href="#添加对-Lua-的支持" class="headerlink" title="添加对 Lua 的支持"></a>添加对 Lua 的支持</h2><p>特别应该提到的是 ngx_lua 这个第三方模块，ngx_lua 模块提供了启用 Lua 的功能，而不是像 Perl 一样在配置时嵌入式脚本语言。该模块对于 perl 模块来说最大的优点就是它的无阻塞性，并与其他第三方模块紧密集成。对于它的安装说明的完整描述详见:<a href="https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过编译你自己的二进制文件，你可以定制 Nginx能够为你提供哪些功能。对于你来说，构建和安装软件应该不会陌生。所以，创造一个构建环境或者确保所有依赖关系都存在，这并不会花费你很多的时间。一个 Nginx 的安装应该是按照你的需要，能随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。</p><p>参考资料：</p><p>《精通 Nginx》第二版</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>function与感叹号</title>
      <link href="/2018/02/01/cjek1d3k6003crhrdu2lf6h07/"/>
      <content type="html"><![CDATA[<h1 id="function与感叹号"><a href="#function与感叹号" class="headerlink" title="function与感叹号"></a>function与感叹号</h1><p>最近有空可以让我静下心来看看各种代码，function与感叹号的频繁出现，让我回想起2个月前我回杭州最后参加团队会议的时候，<a href="http://weibo.com/exqy" target="_blank" rel="noopener">@西子剑影</a>抛出的一样的问题：<strong>如果在function之前加上感叹号 (!) 会怎么样</strong>？比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？</p><p>平时我们可能对添加括号来调用匿名函数的方式更为习惯：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>虽然上述两者括号的位置不同，不过效果完全一样。</p><p>那么，是什么好处使得为数不少的人对这种叹号的方式情有独钟？如果只是为了节约一个字符未免太没有必要了，这样算来即使一个100K的库恐怕也节省不了多少空间。既然不是空间，那么就是说也许还有时间上的考量，事实很难说清，文章的最后有提到性能。</p><p>回到核心问题，为什么能这么做？甚至更为核心的问题是，为什么必须这么做？</p><p>其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是<strong>让一个函数声明语句变成了一个表达式</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// SyntaxError: unexpected_token</span></div></pre></td></tr></table></figure><p>因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 <code>a</code>，就应该以 <code>a();</code> 的方式调用。</p><p>但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。</p><p>所以，<strong>任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别</strong>。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">10</span>&#125;();        <span class="comment">// undefined</span></div><div class="line"><span class="number">1</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;();        <span class="comment">// true</span></div><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;();        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些<strong>一元运算都是有效的</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// -1</span></div></pre></td></tr></table></figure><p>甚至下面这些关键字，都能很好的工作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// undefined</span></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// Object</span></div><div class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// undefined</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。</p><p>最后讨论下性能。我在jsperf上简单建立了一个测试：<a href="http://jsperf.com/js-funcion-expression-speed" target="_blank" rel="noopener">http://jsperf.com/js-funcion-expression-speed</a> ，可以用不同浏览器访问，运行测试查看结果。我也同时将结果罗列如下表所示（由于我比较穷，测试配置有点丢人不过那也没办法：奔腾双核1.4G，2G内存，win7企业版）：</p><table><thead><tr><th>Option</th><th>Code</th><th>Ops/sec</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Chrome 13</td><td>Firefox 6</td><td>IE9</td><td>Safari 5</td><td></td><td></td></tr><tr><td>!</td><td>!function(){;}()</td><td>3,773,196</td><td>10,975,198</td><td>572,694</td><td>2,810,197</td></tr><tr><td>+</td><td>+function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,812,238</td></tr><tr><td>-</td><td>-function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,864,155</td></tr><tr><td>~</td><td>~function(){;}()</td><td>3,551,136</td><td>3,651,652</td><td>572,694</td><td>1,876,002</td></tr><tr><td>(1)</td><td>(function(){;})()</td><td>3,914,953</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>(2)</td><td>(function(){;}())</td><td>4,075,201</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>void</td><td>void function(){;}()</td><td>4,030,756</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>new</td><td>new function(){;}()</td><td>619,606</td><td>299,100</td><td>407,104</td><td>816,903</td></tr><tr><td>delete</td><td>delete function(){;}()</td><td>4,816,225</td><td>12,135,960</td><td>572,694</td><td>2,693,524</td></tr><tr><td>=</td><td>var i = function(){;}()</td><td>4,984,774</td><td>12,135,960</td><td>565,982</td><td>2,602,630</td></tr><tr><td>&amp;&amp;</td><td>1 &amp;&amp; function(){;}()</td><td>5,307,200</td><td>4,393,486</td><td>572,694</td><td>2,565,645</td></tr><tr><td>\</td><td>\</td><td></td><td>0 \</td><td>\</td><td>function(){;}()</td><td>5,000,000</td><td>4,406,035</td><td>572,694</td><td>2,490,128</td></tr><tr><td>&amp;</td><td>1 &amp; function(){;}()</td><td>4,918,209</td><td>12,135,960</td><td>572,694</td><td>1,705,551</td></tr><tr><td>\</td><td></td><td>1 \</td><td>function(){;}()</td><td>4,859,802</td><td>12,135,960</td><td>572,694</td><td>1,612,372</td></tr><tr><td>^</td><td>1 ^ function(){;}()</td><td>4,654,916</td><td>12,135,960</td><td>572,694</td><td>1,579,778</td></tr><tr><td>,</td><td>1, function(){;}()</td><td>4,878,193</td><td>12,135,960</td><td>572,694</td><td>2,281,186</td></tr></tbody></table><p>可见不同的方式产生的结果并不相同，而且，差别很大，因浏览器而异。</p><p>但我们还是可以从中找出很多共性：<strong>new方法永远最慢</strong>——这也是理所当然的。其它方面很多差距其实不大，但有一点可以肯定的是，感叹号并非最为理想的选择。反观<strong>传统的括号，在测试里表现始终很快</strong>，在大多数情况下比感叹号更快——所以平时我们常用的方式毫无问题，甚至可以说是最优的。<strong>加减号在chrome表现惊人</strong>，而且在其他浏览器下也普遍很快，相比感叹号效果更好。</p><p>当然这只是个简单测试，不能说明问题。但有些结论是有意义的：括号和加减号最优。</p><p>但是为什么这么多开发者钟情于感叹号？我觉得这只是一个习惯问题，它们之间的优劣完全可以忽略。一旦习惯了一种代码风格，那么这种约定会使得程序从混乱变得可读。如果习惯了感叹号，我不得不承认，它比括号有更好的可读性。我不用在阅读时留意括号的匹配，也不用在编写时粗心遗忘——</p><p>当我也这么干然后嚷嚷着这居然又节省了一个字符而沾沾自喜的时候，却忘了自己仓皇翻出一本卷边的C语言教科书的窘迫和荒唐……任何人都有忘记的时候，当再捡起来的时候，捡起的就已经不单单是忘掉的东西了。</p><p>2011-10-31更新：如果你使用aptana，那么在使用（!+-）时要注意一点，它们会让aptana的解析失效，导致Outline窗口没有任何显示。但是就代码本身而言，其运行没有任何问题。</p><blockquote><p>本文转自扩葵中剑的博客</p><p>原文地址：<a href="https://swordair.com/function-and-exclamation-mark/" target="_blank" rel="noopener">https://swordair.com/function-and-exclamation-mark/</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>创建型设计模式之抽象工厂</title>
      <link href="/2018/01/10/cjek1etny0000rtrdtvtz7xp0/"/>
      <content type="html"><![CDATA[<p>原文地址：<a href="http://designpatternsphp.readthedocs.io" target="_blank" rel="noopener">http://designpatternsphp.readthedocs.io</a></p><p>在软件工程中，创建型设计模式承担着对象创建的职责，尝试创建适合程序上下文的对象，对象创建设计模式的产生是由于软件工程设计的问题，具体说是向设计中增加复杂度，创建型设计模式解决了程序设计中对象创建的问题。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>创建一系列互相关联或依赖的对象时不需要指定将要创建的对象对应的类，因为这些将被创建的对象对应的类都实现了同一个接口。抽象工厂的使用者不需要关心对象的创建过程，它只需要知道这些对象是如何协调工作的。</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="http://designpatternsphp.readthedocs.io/zh_CN/latest/_images/uml12.png" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在 <a href="https://github.com/domnikl/DesignPatternsPHP/tree/master/Creational/AbstractFactory" target="_blank" rel="noopener">GitHub</a> 上查看代码</p><p>AbstractFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * In this case, the abstract factory is a contract for creating some components</div><div class="line"> * for the web. There are two ways of rendering text: HTML and JSON</div><div class="line"> */</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JsonFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonText($content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HtmlFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HtmlText($content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Text.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> string</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> $text;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $text)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;text = $text;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JsonText.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonText</span> <span class="keyword">extends</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// do something here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HtmlText.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlText</span> <span class="keyword">extends</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// do something here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">Tests</span>;</div><div class="line"></div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">HtmlFactory</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">HtmlText</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">JsonFactory</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">JsonText</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanCreateHtmlText</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $factory = <span class="keyword">new</span> HtmlFactory();</div><div class="line">        $text = $factory-&gt;createText(<span class="string">'foobar'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertInstanceOf(HtmlText::class, $text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanCreateJsonText</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $factory = <span class="keyword">new</span> JsonFactory();</div><div class="line">        $text = $factory-&gt;createText(<span class="string">'foobar'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertInstanceOf(JsonText::class, $text);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DOM本质</title>
      <link href="/2018/01/05/1/"/>
      <content type="html"><![CDATA[<p>抛出问题!</p><ul><li>DOM是那种基本的数据结构？</li><li>DOM操作的常用API都有哪些？</li><li>DOM节点的attr和property有何区别？</li></ul><p>解答问题:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">other</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">other</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="DOM本质"><a href="#DOM本质" class="headerlink" title="DOM本质"></a>DOM本质</h2><p>上面的代码是一段XML，这是一个结构化语言，跟它其同样作用的还有JSON，他们可以用于描述一切可以结构化的数据。</p><p>这段代码快描述了一封信，to收件人，from 来源，title标题，body内容。</p><p>DOM本质上是一个树形结构。我们可以将其理解为，浏览器把拿到的HTML代码，结构化成一个浏览器能够识别且能被js操作的一个模型。</p><p>我们知道HTML本质上就是字符串，计算机处理字符串是一件相当头疼的一件事情，通过DOM，我们就可以将HTML文件抽象成一个树形结构，只要是结构化的数据，计算机处理起来，无论你的逻辑结构有多复杂，他都能够轻松的进行处理。</p><h2 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>) <span class="comment">//元素 </span></div><div class="line"><span class="keyword">var</span> divList = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>) <span class="comment">//集合</span></div><div class="line"><span class="built_in">console</span>.log(divList.length)</div><div class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="keyword">var</span> containerList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'.container'</span>);  <span class="comment">//集合</span></div><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>) <span class="comment">//集合</span></div></pre></td></tr></table></figure><p>上面的代码都是JavaScript的基础API，有的人可能用jQuery或其他的的库时间长了，就把基础API给忘了，或者是基础并不是很牢，一直都在用库，这样的话最好将基础补齐，因为在面试的时候，大多数的面试题都是问的基础。</p><p>在面试的时候有个技巧，不要轻易的撩起用的熟，但是不知道实现原理的东西，比如说你会用jQuery的绑定事件，面试官肯定会问你实现原理。</p><h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</div><div class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</div><div class="line"><span class="built_in">console</span>.log(p.style.width) <span class="comment">//获取样式</span></div><div class="line">p.style.width = <span class="string">'100px;'</span></div><div class="line"><span class="built_in">console</span>.log(p.className)</div><div class="line">p.className = <span class="string">'p1'</span></div><div class="line"></div><div class="line"><span class="comment">//获取nodeName 和 nodeType</span></div><div class="line"><span class="built_in">console</span>.log(p.nodeName)</div><div class="line"><span class="built_in">console</span>.log(p.nodeType)</div></pre></td></tr></table></figure><p>在这里我们需要知道P是个什么东西，它不就是个DOM节点吗？</p><p>其实它本质上就是一个JS对象。上面我们说过DOM的本质是一个JS可识别可操作的。既然本质上是一个对象，我们就可以操作他的属性，那这些属性都是怎么进去的？</p><p>这是浏览器规定的，W3C就是这么规定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj &#123;<span class="attr">x</span>:<span class="number">100</span>, <span class="attr">y</span>:<span class="number">200</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj.x) <span class="comment">// 100</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>]</div><div class="line">cosnole.log(p.nodeName); <span class="comment">//p</span></div></pre></td></tr></table></figure><h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</div><div class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</div><div class="line">p.getAttribute(<span class="string">'data-name'</span>)</div><div class="line">p.setAttribute(<span class="string">'data-name'</span>, <span class="string">'maksim'</span>)</div><div class="line">p.getAttribute(<span class="string">'style'</span>)</div><div class="line">p.setAttribute(<span class="string">'style'</span>, <span class="string">'font-size:30px;'</span>)</div></pre></td></tr></table></figure><p>我们在上述代码中该的 <code>data-name</code> 和 <code>style</code> 到底是什么呢？</p><p>其实就是HTML文档里的标签，并不是JavaScript里的对象。这也是两者之间的区别</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>cookie, sessionStorage和localStorage的区别</title>
      <link href="/2018/01/05/3/"/>
      <content type="html"><![CDATA[<p>在HTML5出来之前，只有cookie作为本地存储的一个方法（JavaScript Web API）。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li>本身用于客户端和服务器端通信的，</li><li>但是它有本地存储的功能， 于是被“借用”</li><li>使用document.cookie = … 获取和修改即可，用起来特别麻烦</li></ul><p>缺点：</p><ul><li>存储量太小，只有4kb</li><li>所有http请求都带着，会影响获取资源的效率，所以cookie只适合保存很小的数据，如会话标识</li><li>API简单，需要封装才能用document.cookie = …</li><li><p>有效时长根据设定的过期时间而定。</p><p>​</p></li></ul><h2 id="sessionStorage-和localStorage"><a href="#sessionStorage-和localStorage" class="headerlink" title="sessionStorage 和localStorage"></a>sessionStorage 和localStorage</h2><ul><li>HTML5专门为存储而设计，因为不需要像服务端发送数据，所以最大容量5M</li><li>API简单易用：</li><li>localStorage.setItem(key, value); localStorage.getItem(key)</li><li>sessionStorage当关闭浏览器后便会被清除，localStorage则不会，即使关闭浏览器localStorage也会一直存在，直到删除</li><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的</li><li>在iOS Safari 隐匿模式下，localStorage.getItem会报错，建议同一使用try-catch</li><li>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者</li></ul>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP基础手札的引用</title>
      <link href="/2017/10/21/cjek1d3j4001trhrd6r6g622d/"/>
      <content type="html"><![CDATA[<p>在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。</p><p>PHP 的指针域这些语言机制相同，即可以用一个变量</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/10/21/cjek1d3i4000drhrdipe4d96n/"/>
      <content type="html"><![CDATA[<hr><p>title:C语言中的内存<br>categories:C/C++<br>date:2017-10-21</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p> C 程序在编译后，会以三种形式使用内存。</p><ul><li><p>静态变量/全局内存</p><p>静态声明的变量分配在这里，全局变量也会使用这部分内存。这些内存在程序开始运行时分配，直到程序终止才会消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。</p></li><li><p>自动内存</p><p>这些变量在函数内部声明，并且在函数被调用时才能创建。它们的作用域局限于函数内部，而且在函数被调用才创建。它们的作用域局限于函数内部，热切声明周期限制在函数的执行时间内。</p></li><li><p>动态内存</p><p>内存分派在堆上，可以根据需要存放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。</p></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>PHP常见的经典面试题</title>
      <link href="/2017/10/21/2/"/>
      <content type="html"><![CDATA[<p>常见经典面试题</p><ol><li>什么是引用变量？在 PHP 当中用什么符号定义引用变量？</li><li>要求写出JQuery 中，可以处理AJAX的几种方法。</li><li>写出尽可能多的Linux 命令</li><li>写出三种以上 MySQL数据存储引擎的名字</li><li>编写在线留言本，实现用户的在线留言功能</li><li>谈谈你对 MVC 的认识，介绍几中目前比较流行的MVC 框架</li><li>请写出常见的排序算法</li><li>PHP 如何解决网站大流量与高并发</li></ol><p>1.什么是引用变量？在 PHP 当中用什么符号定义引用变量。</p><ul><li>考官考点： PHP 的引用变量的概念以及定义方式</li><li><strong>延伸：PHP 引用变量的原理</strong></li></ul><p><strong>概念</strong>： 在 PHP 中引用意味着用不同的名字访问同一个变量内容。</p><p><strong>定义方式</strong> ： 使用&amp;符号</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP 控制反转、依赖注入、依赖查找服务容器？</title>
      <link href="/2017/10/19/cjek1d3j90023rhrdswx0qmjq/"/>
      <content type="html"><![CDATA[<p>控制反转（Inversion of Control，英文缩写为IoC）是框架的重要特征，并非面向对象编程的专用术语。它与依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）并没有关系。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《PHP internals Book》 一本深入PHP 扩展开发的书籍</title>
      <link href="/2017/10/18/10/"/>
      <content type="html"><![CDATA[<p>今天给大家介绍一本 PHP 扩展开发相关的书籍<a href="http://www.phpinternalsbook.com/" target="_blank" rel="noopener">《PHP internals Book》</a>，这本书是几个PHP开发人员之间的协作努力，可以更好地记录和描述PHP内部的工作原理。</p><p>《PHP internals Book》 有三个主要目标：</p><ul><li>记录和描述PHP内部工作原理。</li><li>记录并描述如何使用扩展扩展语言。</li><li>记录并描述如何与社区进行交互以开发PHP本身。</li></ul><p>《PHP internals Book》 主要面向具有C编程语言经验的开发人员。然而，尽管如此，我们将尝试提炼信息并对其进行总结，以便不了解C的开发人员仍然能够理解内容。</p><p>但是，让我们坚持。如果您不知道C语言，您将无法实现高效，稳定（任何平台下的崩溃），性能和实用性。以下是有关C语言本身，生态系统和构建工具以及操作系统API的一些非常好的在线资源：</p><ul><li><a href="http://www.tenouk.com/" target="_blank" rel="noopener">http://www.tenouk.com/</a></li><li><a href="https://en.wikibooks.org/wiki/C_Programming" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/C_Programming</a></li><li><a href="http://c-faq.com/" target="_blank" rel="noopener">http://c-faq.com/</a></li><li><a href="https://www.gnu.org/software/libc/" target="_blank" rel="noopener">https://www.gnu.org/software/libc/</a></li><li><a href="http://www.faqs.org/docs/Linux-HOWTO/Program-Library-HOWTO.html" target="_blank" rel="noopener">http://www.faqs.org/docs/Linux-HOWTO/Program-Library-HOWTO.html</a></li><li><a href="http://www.iecc.com/linker/linker10.html" target="_blank" rel="noopener">http://www.iecc.com/linker/linker10.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP基础解惑： =与==、===的区别</title>
      <link href="/2017/10/18/1/"/>
      <content type="html"><![CDATA[<p>首先等于号（=）在大多数语言中都是赋值操作；</p><p><code>==</code>和<code>===</code>都是比较运算符，用来比较两个变量间的关系，他们两个都有“等于”的含义，不过<code>===</code>是恒等计算符。两侧数据类型不一致时会返回 false，在官方文档中给出如下：</p><p><code>==</code>如果两侧的变量类型不同时，会转化类型后在进行比较。</p><table><thead><tr><th>例子</th><th>名称</th><th>结果</th></tr></thead><tbody><tr><td>$a == $b</td><td>等于</td><td><strong>TRUE</strong>，如果类型转换后 $a 等于 $b。</td></tr><tr><td>$a === $b</td><td>全等</td><td><strong>TRUE</strong>，如果 $a 等于 $b，并且它们的类型也相同。</td></tr></tbody></table><p>上表摘自 PHP 手册。下面来看一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">   $age = <span class="number">18</span>;</div><div class="line">   var_dump($age == <span class="number">18</span>)l    <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age === <span class="number">18</span>);   <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age == <span class="string">'18'</span>);  <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age === <span class="string">'18'</span>); <span class="comment">//bool(false)</span></div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP页面静态化</title>
      <link href="/2017/10/16/cjek1d3jl002frhrd7arohwj6/"/>
      <content type="html"><![CDATA[<h1 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h1><p>要了解静态化页面，首先我们就要知道什么是页面？</p><p>一、静态web页面：</p><p>1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。</p><p>2、为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。</p><p>3、静态web无法连接数据库；</p><p>4、静态web资源开发技术：HTML；</p><p>5、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。</p><p>二、动态web页面：</p><p>动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。</p><p>如果客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</p><p>如果客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</p><p>#静态化</p><p>PHP静态化分为：纯静态化 和 伪静态化；纯静态化又分为：局部静态化 和 完全静态化</p><p>纯静态化：是把PHP生成的动态页面保存成静态的html文件，用户访问该静态页面，而不是用户每一次访问都重新生成一张相同的网页，优点就是减小服务器开销，</p><ul><li>局部静态化：是生成的静态文件中，有局部的数据还是通过ajax技术动态获取的；</li><li>完全静态化：即不存在动态获取数据的情况，所以内容都来自静态的html页面</li></ul><p>伪静态化：其实还是动态访问，其实质是动态生成数据，你访问的网址类似于”<a href="http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化" target="_blank" rel="noopener">http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化</a></p><p>　　伪静态的优点：美观；便于搜索引擎收录</p><p>buffer 概括</p><p>buffer 其实就是缓冲区，一个内存地址空间，主要是用于存储数据的区域。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>PHP基础解惑：省略结束标签</title>
      <link href="/2017/10/16/1/"/>
      <content type="html"><![CDATA[<p>对于PHP编译器来说，脚本的结束标签<code>?&gt;</code>是可选的，在写程序时你可以忽略它。你或许碰见过：在使用include()、require()或输入输出缓冲函数时，页面顶部有时会多空行或者出现<code>“header had send”</code>之类的错误信息，这类问题与结束标签有关。</p><p>省略结束标签适合纯PHP文件。如果是PHP与HTML混合开发，则不可省略。</p><p>忽略结束标签不仅能少些两个字符，而且可以使得我们开发的过程更加顺利。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP基础手札之emtpy、isset、is_null的区别</title>
      <link href="/2017/10/16/2/"/>
      <content type="html"><![CDATA[<p>PHP提供了3个用于测试变量值的函数，分别是isset()、empty()、is_null（从这里就可以看出PHP系统函数变量名命名的混乱，这也是一直被人诟病的地方）.这几个函数均返回布尔值，有时使用不当会造成意想不到的结果。</p><p>比如，用isset()和empty()返回的结果是相反的，但却并非一直如此。</p><p>isset()用来检测一个变量是否已声明且值不为null。只能在变量不是null时返回真。</p><p>empty()用来检测一个变量是否为空，也就是说有如下情况时返回真值：变量是一个空字符串，false，空数组,null,’’,以及被unset删除后的变量。</p><blockquote><p>在PHP5.5之后，empty()函数可以接受任意类型的表达式</p></blockquote><p>is_null()函数用来判断变量内容是否是null，即返回真值的条件仅为变量值是null，值得一提的是，is_null() 是 isset() 的反函数，区别是isset()函数可以应用到未知变量，但is_null()只能针对以声明的变量。</p><table><thead><tr><th>对比项</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>变量值($var)</td><td>isset($var)</td><td>empty($var)</td><td>is_null($var)</td></tr><tr><td>“”（空字符串）</td><td>bool(true)</td><td>bool(true)</td><td>bool(false)</td></tr><tr><td>“ “(空格)</td><td>bool(true)</td><td>bool(false)</td><td>bool(false)</td></tr><tr><td>false</td><td>bool(true)</td><td>bool(true)</td><td>bool(false)</td></tr><tr><td>true</td><td>bool(true)</td><td>bool(false)</td><td>bool(false)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/10/15/cjek1d3ij000xrhrdv57fvp4q/"/>
      <content type="html"><![CDATA[<h1 id="MySQL常用存储引擎之Innodb"><a href="#MySQL常用存储引擎之Innodb" class="headerlink" title="MySQL常用存储引擎之Innodb"></a>MySQL常用存储引擎之Innodb</h1><p>Mysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。</p><p>和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。</p><p>特点：</p><ul><li>灾难恢复性好</li><li>支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的</li><li>使用行级锁</li><li>对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的</li><li>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引</li><li>支持外键</li><li>支持热备份</li></ul><p>Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由<code>innodb_file_per_table</code>这个参数决定。</p><p>如果值为 <code>ON</code>,会为每个 innodb 表建立一个<code>tablename.ibd</code>的系统文件，如果该参数为<code>OFF</code>时会把数据存储到系统的表空间<code>ibdataX</code></p><p>引用</p><p>《打造扛得住的 MySQL》 慕课网</p><p>《高性能 MySQL》</p><p>《My》</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/10/13/cjek1d3in0012rhrdm1dktew0/"/>
      <content type="html"><![CDATA[<hr><p>title:MySQL服务器参数介绍<br>categories:MySQL<br>date:2017-10-18</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p>人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。</p><p>MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。</p><p>从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。</p><p>##　MySQl获取配置信息路径</p><ul><li>命令行参数 <code>mysqld_safe --datadir=/data/sql_data</code></li><li>配置文件 <code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code></li></ul><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171013153125.png" alt=""></p><p>MySQL会先从<code>/etc/my.cnf</code>文件下读取配置信息，然后是<code>/etc/mysql/my.cnf</code>。</p><p>MySQL配置参数的作用域</p><ul><li>全局参数 <ul><li><code>set global 参数名 = 参数值;</code></li><li><code>set @@global。参数名:=参数值;</code></li></ul></li><li>会话参数<ul><li><code>set [session] 参数名=参数值;</code></li><li><code>set @@session.参数名:=参数值;</code></li></ul></li></ul><p>会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。</p><p>在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。</p><h2 id="内存配置相关参数"><a href="#内存配置相关参数" class="headerlink" title="内存配置相关参数"></a>内存配置相关参数</h2><p>MySQL对于内存的使用我们可以分为两个类来看。</p><ul><li>无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存</li><li>可以通过参数配置控制的，各类的缓冲池所需要的内存。</li></ul><p>对内存参数配置之前，我们需要进行考虑：</p><ul><li>确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。</li><li>确定MySQL的每个连接使用的内存，例如排序缓冲和临时表</li><li><p>把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。</p><ul><li><p>sort_buffer_size</p><ul><li>join_buufer_szie</li><li>read_buffer_size</li><li>read_rnd_buffer_size  </li></ul></li></ul></li></ul><h3 id="确定需要为操作系统保留多少内存"><a href="#确定需要为操作系统保留多少内存" class="headerlink" title="确定需要为操作系统保留多少内存"></a>确定需要为操作系统保留多少内存</h3><p>给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。</p><p>数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。</p><p>另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。</p><h3 id="如何为缓冲池分配内存"><a href="#如何为缓冲池分配内存" class="headerlink" title="如何为缓冲池分配内存"></a>如何为缓冲池分配内存</h3><p>Innodb_buffer_pool_size，Innodb缓冲区</p><p>总内存-（每个线程所需要的内存*连接数）- 系统保留内存</p><p>手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。</p><h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos;</div></pre></td></tr></table></figure><h2 id="I-O相关配置参数"><a href="#I-O相关配置参数" class="headerlink" title="I/O相关配置参数"></a>I/O相关配置参数</h2><p>Innodb I/O相关配置</p><h2 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h2><p><code>expire_logs_days</code> 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/10/13/cjek1d3kl003zrhrdqn2bsqsg/"/>
      <content type="html"><![CDATA[<h1 id="业务评估"><a href="#业务评估" class="headerlink" title="业务评估"></a>业务评估</h1><h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ul><li>响应时间（request time）</li><li>数据总量</li><li>每秒请求量</li><li>读写比</li><li>重要程度</li></ul><p><strong>响应时间</strong>是与整个数据库的状态有关，不仅与CPU、数据总量、每秒请求量、读写比以及各种场景都是有关系的。所以说相应时间是一个综合指标。</p><p>对于DBA来说最关心的就是业务的相应时间能不能够满足，在满足的情况下再去优化以下的这些点，才是有意义的。</p><p>数据总量往往需要业务方提供一个一到两年的数据总量，这是因为如果没有数据总量，前期是没有办法规划我们的数据库实例的。当然也有很多的不确定因素，比如互联网行业，比如有的业务会爆发性的增长，这些规划可能是不合理的，但是在我们也要有一个大概的评估，因为这是前期资源申请和资源分配的策略。</p><p>每秒请求量</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>MySQL体系结构</title>
      <link href="/2017/10/13/1/"/>
      <content type="html"><![CDATA[<p>数据库产品的架构一般可以分为应用层、逻辑层、物理层，对于MySQL，同样可以理解为如下3个层次。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/http://images2015.cnblogs.com/blog/676456/201707/676456-20170722164214340-166686649.jpg210050572965263.gif" alt="img"></p><p>其中<code>Connectors</code>可以理解为各种客户端、 应用服务； <code>Connection Pool</code>可以理解为<strong>应用层</strong>，负责和客户端、用户进行交互，需要和不同的客户端（<code>PHP</code>,<code>Java</code>,<code>C API</code>,<code>.Net</code>以及<code>ODBC</code>,<code>JDBC</code>等等）和中间服务器进行交互，这一层主要完成的是链接处理，授权认证，和安全等一些功能，连接到<code>MySQL</code>的客户端在其进程中，都会有一个独立的线程，连接的查询只会在这个登录线程中进行查询。</p><p><code>Management Services&amp;Utilities</code>、<code>SQL Interface</code>、 <code>Parser</code>、 <code>Optimizer</code>、 <code>Caches&amp;Buffers</code>、 <code>Pluggable Storage Engines</code>可以理解为数据库的大脑——<strong>逻辑层</strong>。</p><p>负责具体的查询处理、事务处理、存储管理、恢复管理，以及其他附加功能。查询处理器负责查询的解析、执行。当接收到客户端的查询时，数据库会分配一个县城来处理它。先友查询处理器（优化器）生成执行计划，然后交由计划执行器来执行，执行器有时需要访问更底层的事务管理器、存储管理器来操作数据，事务管理器、存储管理器主要负责事务控制、并发控制、存储管理。在其中，将由事务管理来保证“<code>ACID</code>”特性，通过锁管理器来控制并发，由日志管理器来确保数据持久化，存储故那里器一般还包括一个缓冲管理器，有它来确定磁盘和缓存之间的数据传输。</p><p>根据上面的架构图，我们可以看到在逻辑层中<code>Pluggable Storage Engines</code></p><p>这是MySQL服务逻辑架构中的第三层，是MySQL的存储引擎，MySQL提供出了存储引擎接口，第三方可以根据自己的业务逻辑需求开发自己的存储引擎，Innodb起初就是由Innobase Oy公司所开发，2006年5月被甲骨文公司并购。</p><p>服务器通过API与存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作，但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层和服务的请求。</p><blockquote><p>注意：存储引擎是针对于表的而不是针对于库的，不同的表可以使用不同的引擎；</p></blockquote><p> 最下方的Files&amp;Logs可以理解为物理层，实际物理磁盘（存储）上的数据库文件，比如数据文件、日志文件等等。</p><p>引用：</p><p>《MySQL DBA修炼之道》 作者陈晓勇  出版社：华章图书</p><p>《打造扛得住的MySQL》 电子工业出版社</p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL常用存储引擎之MyISAM</title>
      <link href="/2017/10/13/2/"/>
      <content type="html"><![CDATA[<p>MyISAM存储引擎是MySQL5.5之前版本默认的存储引擎，由于这个原因，现在还有大量的数据库在使用MyISAM的表。</p><p>同时它也是MySQL大部分系统表和临时表使用的而存储引擎，这个临时表并非是我们使用<code>CREATE TEMPORARY TABLE</code>所建立的临时表。</p><p>使用<code>CREATE TEMPORARY TABLE</code>语句创建的临时表，我们可以使用MySQL各种存储引擎的，这里所说的临时表指的是在排序、分组等操作中，当当数量超过一定大小后，由查询优化器所建立的磁盘临时表。</p><p>MyISAM存储引擎表由MYD和MYI组成。</p><p>在这里，我们建立一个myIsam的表，并且存储引擎使用了MyISAM。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`myIsam`</span> (</div><div class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line"><span class="string">`c1`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></div><div class="line">)<span class="keyword">ENGINE</span>= MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</div></pre></td></tr></table></figure><p>下图为MyISAM在文件系统上的存储方式：</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171013110625.png" alt=""></p><p>以frm为扩展名存储的文件并非是MyISAM存储引擎独有，它是用于记录表的结构。MyISAM表可以存储的记录数，一般首选治愈可用磁盘空间，或者是操作系统单个文件最大尺寸的限制。</p><p>作为MySQL最早的存储引擎之一，MyISAM有一些已经开发出来很多年的特性，可以满足用户的实际需求。</p><p><strong>加锁与并发</strong></p><ul><li>MyISAM使用的是表级锁，进行读取操作时会对需要读到的所有表加共享锁，写入时则会对表加排他锁。但是在表有读取查询的同时，可以往表中插入新的记录，这也被称之为并发插入，CONCURRENT INSERT</li></ul><p><strong>修复</strong> </p><ul><li>对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作，但是此处的修复和事务恢复以及崩溃恢复并不是一个概念，执行表的修复可能导致数据的丢失，而且修复操作时非常慢的。可以通过CHECK TABLE table检查表的错误，如果存在错误可以通过REPAIR TABLE table进行修复。在MySQL服务器处于<strong>关闭状态</strong>时，可以通过myisamcheck命令工具进行检查和恢复，切记是处于<strong>关闭状态</strong>。</li></ul><p><strong>索引</strong></p><ul><li>对于MyISAM表，即使是BLOG和TEXT等长字段，也可以基于前500个字符创建索引，而且MyISAM也支持全文索引。</li><li>延迟更新索引（Delayed Key Write）创建MyISAM表的时候，如果制定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃的时候会造成索引损坏，需要执行修复操作。此属性可以再全局设置，也可以为单个表设置。</li></ul><p><strong>压缩</strong></p><ul><li>如果表在创建并导入数据以后，不会再进行修改操作，可以使用myisampa对表进行压缩（打包）。压缩表不能进行修改，除非解除压缩，压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升性能，压缩表支持索引，但索引也是只读的。</li><li>压缩时表中的记录是独立压缩的，所以读取单行的时候不需要去解压整个表。</li></ul><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><ul><li>版本&lt;MySYQL5.0时默认表大小为4G，如存储大表则需要修改MAX_Rows和AVG_ROW_LENGTH这两个参数，调整后表会进行重建，这需要很长的时间。</li><li>版本 &gt; 5.0时默认支持256TB </li></ul><p>适用场景：</p><ul><li>非事务性应用</li><li>只读类应用</li><li>空间类应用（在5.7之前，MyISAM是唯一支持空间函数的存储引擎）</li></ul>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>服务器硬件对MYSQL性能的影响</title>
      <link href="/2017/10/10/1/"/>
      <content type="html"><![CDATA[<p>影响数据库性能的主要因素有很多，主要包括以下几点：</p><ol><li>服务器硬件</li><li>服务器系统</li><li>数据库存储引擎的选择</li><li>数据库参数配置</li><li>数据库结构设计和SQL语句</li></ol><h1 id="服务器硬件："><a href="#服务器硬件：" class="headerlink" title="服务器硬件："></a>服务器硬件：</h1><p>每当大促或者一些活动的时候，我们监控系统时会发现，CPU和可用内存的资源都是很紧张的，特别对于一些计算密集型的应用，CPU的资源可能会变成系统的瓶颈。</p><p>当我们工作所需要的热数据的大小大于可用内存大小的时候，IO系统就会变成我们的瓶颈。</p><p>网络也算是一种IO，它对于性能的影响往往发生在大量的数据被查询时，特别是使用MemCache这类缓存系统时，当缓存大量失效时，就会造成大量的网络传输从而影响服务性能。</p><p>当发生这类问题的时候，我们可以升级I/O子系统，来增加大量的内存。</p><h2 id="如何选择CPU？"><a href="#如何选择CPU？" class="headerlink" title="如何选择CPU？"></a>如何选择CPU？</h2><h4 id="我们是选择更多的CPU，还是更快的CPU？"><a href="#我们是选择更多的CPU，还是更快的CPU？" class="headerlink" title="我们是选择更多的CPU，还是更快的CPU？"></a>我们是选择更多的CPU，还是更快的CPU？</h4><p>Intel Xeon E7-8890 v2</p><p>主频2.5GHz 核心数量：18核36线程</p><p>正常情况下，这两点我们都想要，但是现实是残酷的，44499RMB的价格，并不是所有公司都能够接受的。</p><p>首先，我们需要考虑几个问题。</p><p>####我们的应用是CPU密集型的应用吗？</p><p>如果是CPU密集型的应用要加快SQL的处理速度，显然我们需要的是更快的CPU而不是核心较多的CPU。</p><p>值得注意的是，MySQL目前还不支持多CPU对同一SQL并发处理。</p><p>也就是说，一条SQL只能使用一颗CPU来进行处理，多颗CPU对于一条SQL的处理效率是没有帮助的。</p><p>我们系统的并发量如何？</p><p>虽然单个SQL无法利用到多个CPU资源，如果要提高系统的吞吐量和并发处理量呢？</p><p>这时我们就需要CPU越多越好。</p><p>在Web应用中，CPU的数量就要比频率要重要一些。</p><p>我们所使用的MySQL版本也会决定如何选择CPU，老版本的MySQL对于多核CPU的支持并不好，5.0之前的版本限制是非常严重的，5.6、5.7对多核CPU的支持已经有了很好的改善。</p><h4 id="选择32位还是64位的CPU？"><a href="#选择32位还是64位的CPU？" class="headerlink" title="选择32位还是64位的CPU？"></a>选择32位还是64位的CPU？</h4><p>这个问题已经是多余的了，目前64位已经是默认配置了，而且MySQL对于64位CPU的支持已经很好了。</p><p>不过值得注意的是，<strong>在64位CPU上使用32位操作系统</strong>，意味着我们不能使用大的内存，任何一个单独的进程都不能寻址到4G以上的内存，MySQL是一个单线程的服务，这样就会对MySQL的性能造成极大的影响。</p><h2 id="内存、更大更快？"><a href="#内存、更大更快？" class="headerlink" title="内存、更大更快？"></a>内存、更大更快？</h2><p>内存的大小直接影响数据库的性能，目前内存的IO效率要远远高于磁盘，所以把数据缓存到内存中可以大大提高数据库性能。</p><p>MyISAM会把索引缓存到内存中，数据放到系统上进行缓存。</p><p>InnoDB会在内存上同时缓存索引和数据，所以可以提高运行效率</p><p>内存的确是越多越好，可是数据库的性能影响也是有限的，并不能无限增加性能，数据库可以利用的内存是有限的。</p><p>当所有的数据都被缓存到内后，再增加内存大小就变成没有意义的了。</p><p>如果我们的数据的大小是100G，内存是64G，我们可以通过扩展内存到128G来扩大数据库的缓冲区来提高数据库性能。</p><p>可是如果此时内存以经256G了，并且数据库的缓存池大小已经达到了196G的情况下，就不能指望增加内存来提高数据库心梗了。</p><p>多余的内存可以增加操作系统等其他服务的性能。</p><p>缓存虽然不能避免磁盘的写操作，但是可以起到延缓作用，把多次写入变成一次写入。</p><p>###　内存的选择？</p><p>内存的频率越高读取也就越快，应该选择主板所支持的最高主频，组成购买升级，每个通道的内存最高相同品牌、颗粒、频率、电压、校验技术和型号。单条容量要尽可能的大。</p><p>根据数据库大小选择内存，例如现在热数据有100G，那么我们就可以选择128G的内存。但是还有一个问题，那就是数据的增长率，为了避免短时间内多次升级硬件，可以选择更大一些的内存。</p><p>##I/O子系统（磁盘的配置和选择）</p><p>虽然内存对数据库的性能影响很重要，通过增加内存大小可以解决大部分性能问题，但是并不能忽视I/O子系统对性能影响。</p><p>有时我们需要以牺牲内存为代价提高I/O子系统的性能，因为无论如何最终，数据都要通过磁盘来进行持久化的存储。</p><p>目前主流的四种磁盘配置：</p><ol><li>使用传统机器磁盘</li><li>使用RAID增强传统机器磁盘</li><li>使用固态存储SSD和PCIe卡</li><li>使用网络存储NAS和SAN</li></ol><h3 id="传统机器硬盘"><a href="#传统机器硬盘" class="headerlink" title="传统机器硬盘"></a>传统机器硬盘</h3><p>传统机器磁盘是目前最常见的选择，使用最多，这类磁盘价格低，存储空间大，但是读、写速度较慢，传统机器硬盘的读、写效率取决于它的存储机制。</p><p>传统机器硬盘读取数据的过程：</p><ol><li>移动磁头到磁盘表面的正确位置</li><li>等待磁盘旋转，使所需的数据在磁头之下</li><li>等待磁盘旋转过去，所有所需的数据都被磁头读取</li></ol><p>磁盘执行这些操作有多快，也就决定了磁盘的读取速度，第1,2步骤被称之为访问时间，第3步称之为传输速度。</p><p>如何选择传统机器硬盘</p><ol><li>存储容量</li><li>传输速度</li><li>访问时间</li><li>主轴转速</li><li>物理尺寸</li></ol><h3 id="RAID增强机器硬盘的性能"><a href="#RAID增强机器硬盘的性能" class="headerlink" title="RAID增强机器硬盘的性能"></a>RAID增强机器硬盘的性能</h3><p>首先我们要知道什么是RAID，RAID是磁盘冗余队列的简称（Redundant Arrays of independent Disks）简单来说RAID的作用就是可以把多个容量较小的磁盘组成一组容量更大的磁盘，并提供数据冗余保证数据完整性的技术。</p><h4 id="数据库中使用的RAID-0级别："><a href="#数据库中使用的RAID-0级别：" class="headerlink" title="数据库中使用的RAID 0级别："></a>数据库中使用的RAID 0级别：</h4><p><strong>RAID 0</strong>是最早出现的RAID模式，也称之为数据条带，是组建磁盘阵列中<strong>最简单</strong>的一种形式，只需要两块以上的硬盘即可，<strong>成本低</strong>，可以提高整个磁盘的性能和吞吐量。RAID 0<strong>没有提供冗余或错误修复能力</strong>，但是实现成本是最低的。</p><p><img src="http://www.maixj.net/wp-content/uploads/2015/02/raid0.png" alt="RAID 0"></p><p>RAID 0 就是多个独立的磁盘串联到一起，比如有三块300G的磁盘组合到一起，就可以组成一块900G的磁盘，在写入时可以并发同时对三块磁盘进行写入，理论上写入效率就是普通磁盘的三倍。</p><p>RAID 0可能是性价比最高的解决方案，但是如果考虑到数据的恢复、可靠性因素，RAID 0就变成了一种成本最高的一种解决方案。</p><p>因为在RAID 0 中数据没有冗余，数据损坏的几率要比单块磁盘的几率还要高，因为RAID 0中任意一块磁盘损坏了，都会造成数据丢失。</p><p>所以RAID 0比较适合于不担心数据丢失的情况，比如可以随时从其他数据库克隆的备存，或者是一次性使用的数据。</p><h4 id="数据库中使用的RAID-1级别"><a href="#数据库中使用的RAID-1级别" class="headerlink" title="数据库中使用的RAID 1级别"></a>数据库中使用的RAID 1级别</h4><p><strong>RAID 1</strong>又称磁盘镜像，原理是把一块磁盘的数据镜像到另一个磁盘上，也就是说数据写入一块磁盘的同事，会在另一块限制的磁盘上生成镜像文件，在不影响性能的情况下最大限度的保证系统的可靠性和可修复性。</p><p><img src="http://www.maixj.net/wp-content/uploads/2015/02/raid1.jpg" alt="RAID 1"></p><p>RAID 1当一块硬盘失效时，系统会忽略该硬盘，转而使用剩余的镜像盘来读取数据，拥有很好的冗余能力，虽然这样对数据的安全性而言是绝对安全的，但是却似的成本增加，磁盘的利用率仅有百分之五十，以4块300G的硬盘而言，能够利用的空间仅有600G，出现故障后的RAID系统也不在可靠了，应当及时更换损坏的硬盘，否则其他的镜像盘也出现问题了，会导致系统的崩溃。</p><p>更换硬盘后需要很长的时间同步镜像，虽然对数据的访问不会受到影响，但是对整个系统的性能是会有所下降的。</p><p>RAID 1在读的速度上要比RAID 0快。</p><p>####数据库中使用的RAID 5级别</p><p>RAID 5又称之为分布式奇偶校验磁盘阵列，通过分布式奇偶校验块把数据分散到多个磁盘上，这样如果任何一个盘数据失效，都可以从奇偶校验块中重建。但是如果两块磁盘失效，则整个卷的数据都无法恢复。</p><p><img src="http://www.maixj.net/wp-content/uploads/2015/02/raid5.gif" alt="RAID 5"></p><p>在RAID 5上随机比较慢，因为每次写都需要两次读和两次写，以计算校验位的数值，比较适合以读为主的数据库业务。</p><p>最大的性能问题，发生在磁盘失效的时候，因为数据需要重新分布到其他磁盘上，这样会严重影响数据库性能，如果要使用RAID 5的话，最好使用在从服务器上。</p><h4 id="数据库中使用的RAID-10级别"><a href="#数据库中使用的RAID-10级别" class="headerlink" title="数据库中使用的RAID 10级别"></a>数据库中使用的RAID 10级别</h4><p>RAID 10又称分片的镜像，她是对磁盘先做RAID 1之后对两组RAID 1的磁盘再做RAID 0，所以对读写都有良好的性能，相对于RAID 5重建起来更简单，速度也更快。</p><p><img src="http://www.maixj.net/wp-content/uploads/2015/02/raid01.jpg" alt="RAID 10"></p><h4 id="RAID级别的选择"><a href="#RAID级别的选择" class="headerlink" title="RAID级别的选择"></a>RAID级别的选择</h4><table><thead><tr><th style="text-align:center">等级</th><th style="text-align:center">特点</th><th style="text-align:center">是否冗余</th><th style="text-align:center">盘数</th><th style="text-align:center">读</th><th style="text-align:center">写</th></tr></thead><tbody><tr><td style="text-align:center">RAID 0</td><td style="text-align:center">便宜，快速，危险</td><td style="text-align:center">无</td><td style="text-align:center">N</td><td style="text-align:center">快</td><td style="text-align:center">快</td></tr><tr><td style="text-align:center">RAID 1</td><td style="text-align:center">高速读，简单，安全</td><td style="text-align:center">有</td><td style="text-align:center">2</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">RAID 5</td><td style="text-align:center">安全，成本这种</td><td style="text-align:center">有</td><td style="text-align:center">N+1</td><td style="text-align:center">快</td><td style="text-align:center">取决于最慢的盘</td></tr><tr><td style="text-align:center">RAID 10</td><td style="text-align:center">贵，告诉，安全</td><td style="text-align:center">有</td><td style="text-align:center">2N</td><td style="text-align:center">快</td><td style="text-align:center">快</td></tr></tbody></table><h3 id="固态存储"><a href="#固态存储" class="headerlink" title="固态存储"></a>固态存储</h3><ol><li>拥有更好的随机读写性能。</li><li>能够更好的支持并发</li><li>更容易损坏</li></ol><p>在数据库存储中，我们常用的固态存储设备是SSD和PCI-E SSD。</p><h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><ol><li>使用SATA接口，可以替换传统磁盘而无需任何改变 </li><li>SATA接口的SSD同样支持RAID技术</li></ol><h4 id="PCI-E-SSD"><a href="#PCI-E-SSD" class="headerlink" title="PCI-E SSD"></a>PCI-E SSD</h4><ol><li>无法使用SATA接口，需要独特的驱动和配置</li><li>价格相比SSD要贵，但是性能比SSD更好</li></ol><p>PCI-E会占用服务器的内存。</p><h4 id="固态存储的使用场景"><a href="#固态存储的使用场景" class="headerlink" title="固态存储的使用场景"></a>固态存储的使用场景</h4><ol><li><p>适用于存在大量随机I/O的场景</p></li><li><p>使用于解决单线程负载的I/O场景</p><p>如果只有一块固态存储设备我们更应该将其放在从服务器上，因为从服务器是单线程的，而主DB是多线程的写入，为了产生更少的延迟，我们应该增加从服务器的I/O性能，而且由于固态设备易损耗，在主服务器上使用存在一定的安全隐患。</p></li></ol><h3 id="网络存储SAN和NAS"><a href="#网络存储SAN和NAS" class="headerlink" title="网络存储SAN和NAS"></a>网络存储SAN和NAS</h3><p><strong>SAN</strong>(Storage Area Network)和<strong>NAS</strong>(Network-Attached Storage)是两种外部文件存储设备加载到服务器上的方法</p><p>SAN设备通过光纤连接到服务器，设备通过块接口访问，服务器可以将其当做硬盘使用。</p><p>NAS设备使用网络连接，通过基于文件的协议如NFS或SMB来访问。</p><h4 id="网络存储适用的场景"><a href="#网络存储适用的场景" class="headerlink" title="网络存储适用的场景"></a>网络存储适用的场景</h4><p>网络存储在随机I/O比较差，并不适合MySQL数据库存储数据，有一些人认为可以使用网络存储实现服务的高可用性，比如两台服务器挂在同一网络环境下的磁盘，当主服务器可以由主备服务器来接管磁盘来提供服务，提高系统的可用性。</p><p>虽然能够在一定条件下能够提高系统的可用性，可是却是以牺牲性能为代价，而且，一旦网络存储设备出现问题，则需要更多的时间进行恢复。</p><p>不过，我们可以利用网络存储设备来存储数据库的备份文件，当一台独立服务器出现故障，短时间内无法恢复的情况下，可以利用网络存储设备上存储的备份文件恢复是实例。</p><h3 id="网络接口设备对数据库性能的影响"><a href="#网络接口设备对数据库性能的影响" class="headerlink" title="网络接口设备对数据库性能的影响"></a>网络接口设备对数据库性能的影响</h3><ol><li>网络带宽对性能的影响</li><li>网络质量对性能的影响</li></ol><p>建议</p><ul><li>采用高性能和高贷款的网络设备和交换机</li><li>对多个网卡进行绑定，增强可用性和带宽</li><li>尽可能的进行网络隔离</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>CPU</p><ul><li>64位的CPU一定要工作在64位的系统下</li><li>对于并发比较高的场景CPU的数量比频率更重要</li><li>对于CPU密集性场景和复杂SQL则频率越高越好</li></ul><p>内存</p><ul><li>选择主板所能使用的最高频率的内存</li><li>内存的大小对性能很重要，所以尽可能的大</li></ul><p>I/O子系统</p><ul><li>PCie -&gt; SSD -&gt; Raid10 &gt; 磁盘 -&gt; SAN</li></ul>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>服务器系统对MySQL性能带来的影响</title>
      <link href="/2017/10/10/2/"/>
      <content type="html"><![CDATA[<p>影响数据库性能的主要因素有很多，主要包括以下几点：</p><ol><li>服务器硬件</li><li>服务器系统</li><li>数据库存储引擎的选择</li><li>数据库参数配置</li><li>数据库结构设计和SQL语句</li></ol><h1 id="服务器系统"><a href="#服务器系统" class="headerlink" title="服务器系统"></a>服务器系统</h1><p>MySQL本身支持很多操作系统：</p><ul><li>Windows</li><li>FreeBSD</li><li>Solaris</li><li>Linux</li></ul><p>很多人都习惯将开发环境的数据库部署在Windows上，将生产环境的数据库部署在Linux上，这就会导致一个问题，MySQL 的schema存储方式在文件系统上实际是一个目录，<strong>在Windows平台上，大小写是不敏感的</strong>，而在<strong>Linux上大小写是敏感的</strong>，所以这就会导致，数据库和表的名字在Windows是可以运行的，但是当移植到Linux下就会找不到相关数据库和表的错误。</p><h2 id="CentOS系统参数优化"><a href="#CentOS系统参数优化" class="headerlink" title="CentOS系统参数优化"></a>CentOS系统参数优化</h2><p><strong>内核相关参数</strong>（/etc/sysctl.conf）</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># </div><div class="line">net.core.somaxconn = 65535</div><div class="line">net.core.netdev_max_backlog = 65535</div><div class="line">net.ipv4.tcp_max_syn_backlog = 65535</div><div class="line"></div><div class="line"># TCP连接回收</div><div class="line">net.ipv4.tcp_fin_timeout = 10</div><div class="line">net.ipv4.tcp_tw_reuse = 1</div><div class="line">net.ipv4.tcp_tw_recycle = 1</div><div class="line"></div><div class="line">net.core.wmen_default = 87380</div><div class="line">net.core.wmen_max = 16777216</div><div class="line">net.core.rmem_default = 87380</div><div class="line">net.core_rmem_max = 1677216</div><div class="line"></div><div class="line">net.ipv4.tcp_keeplive_time = 120</div><div class="line">net.ipv4.tcp_keepalive_intvl = 30</div><div class="line">net.ipv4.tcp_keepalive_probes = 3</div><div class="line"></div><div class="line">kernel.shmmax = 4294967295</div><div class="line"># Linux内核参数最重要的参数之一，用于定义单个共享内存段的最大值</div><div class="line"># 1. 这个参数应该设置的足够大，以便能在一个共享内存段下容纳下整个Innodb缓冲池的大小</div><div class="line"># 这个值的大小对于64位Linux系统，可取的最大值为物理内存值-1byte,建议设置为物理内存的一半，一半取决于Innodb缓冲池的大小即可，可以取物理内存-1byte</div><div class="line"></div><div class="line">vm.swappiness = 0 </div><div class="line"># 这个参数当内存不足时会对性能产生较明显的影响</div><div class="line"># Linux系统内存交换区。</div><div class="line"># 禁用交换分区所带来的风险：</div><div class="line">#1. 降低操作系统的性能</div><div class="line">#2。 容易造成内存溢出，崩溃，或者被操作系统kill掉</div><div class="line"># 在MySQL服务器上保留叫分区还是有必要的额，但是要控制何时使用交换分区，vm.swappiness = 0 ，就是告诉内核除非虚拟内存完全满了，否则就不会使用交换分区</div></pre></td></tr></table></figure><p>增加资源限制（/etc/security/limit.conf），这个文件实际上是Linux PAM也就是插入式认证模块的配置文件。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* soft nofile 65535</div><div class="line">* hard nofile 65535</div><div class="line"></div><div class="line"># * 表示对所有用户有效</div><div class="line"># soft 指的是当前系统生效的设置</div><div class="line"># hard 表明系统中所设定的最大值</div><div class="line"># nofile 表示所限制的资源是打开文件的额最大数目</div><div class="line"># 65535 就是限制的数量</div><div class="line"># 把可打开的文件数量增加到65535个，以保证可以打开足够多的文件句柄，这个文件的修改需要重启系统后生效</div></pre></td></tr></table></figure><p>磁盘调度策略(/sys/block/devname/queue/scheduler)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /sys/block/devname/queue/scheduler</div><div class="line">noop anticipatory deadline [cfq]</div></pre></td></tr></table></figure><p><strong>noop</strong>（电梯式调度策略）<br>NOOP实现了一个FIFO队列，它像电梯的工作方式一样对I/O请求进行组织，当有一个新的请求到来时，它将请求合并到最近的请求之后，以此来保证请求同一个介质。NOOP倾向于饿死读而利于写，因此NOOP对于闪存设备，RAM以及嵌入式是最好的选择。</p><p><strong>deadline</strong>（介质时间调度策略）<br>Deadline确保了在一个截至时间内服务请求，这个截至时间是可调整的，而默认读期限短于写期限。这样就防止了写操作因为不能被读取而饿死的现象。Deadline对数据库类应用是最好的选择。</p><p><strong>anticipatory</strong>（预料I/O调度策略）<br>本质上与Deadline一样，但在最后一次读操作后，要等待6ms，才能继续进行对其他I/O请求进行调度。它会在每个6ms中插入新的I/O操作，而会将一些小写入流合并成一个大写入流，用写入延时换取最大的写入吞吐量。AS适合于写入较多的环境，比如文件服务器，AS对数据库环境表现很差。</p><p>通过下面方法修改磁盘策略：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo  deadline &gt;  /sys/block/devname/queue/scheduler</div></pre></td></tr></table></figure><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在Windows环境下，仅有FAT和NTFS两种文件系统，但其实现在只使用NTFS。</p><p>在Linux环境下就不同了，目前主流的文件系统有EXT3、EXT4、XFS。这三种文件系统都带有日志，安全性可以得到保证，江湖传闻XFS新更能更好。</p><p>EXT3/4系统的挂在参数(/etc/fstab)</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 日志写入</div><div class="line">data = writeback | ordered | jouranl</div><div class="line">noatime, nodiratime</div><div class="line">/dev/sda1/ext4 noatime,nodiratime,data=writeback 1 1</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大表会对数据库带来的那些问题！</title>
      <link href="/2017/09/18/1/"/>
      <content type="html"><![CDATA[<h3 id="什么样的表才可以被称之为大表"><a href="#什么样的表才可以被称之为大表" class="headerlink" title="什么样的表才可以被称之为大表?"></a>什么样的表才可以被称之为大表?</h3><p>所谓的大表都是相对而言的，对不同的存储引擎都有不同的限制，Innodb并没有定义每张表的最大行数，只要物理磁盘允许，我们就可以将数据存入数据库中。</p><p>在实际使用过程中，当数据量超过千万行之后，就会对数据库的性能造成影响。</p><ul><li>记录行数巨大，单表超过前往行</li><li>表数据文件巨大，表数据文件超过10G </li></ul><p>当然这也是相对的，也要跟我们的业务场景，磁盘 IO情况而定，如果这个表只是用来记录日志的，只有INSERT、SELECT 操作，而几乎没有 UPDATE 和 DELETE的操作，就算是超过了千万行，对我们的业务操作也没有太大的影响。</p><p>但是也有例外的情况，如果我们要对超过10G 的日志表追加列，如果这个时候，这个表被同步到N台服务器上后，就会变成一场灾难。</p><h4 id="大表对查询的影响"><a href="#大表对查询的影响" class="headerlink" title="大表对查询的影响"></a>大表对查询的影响</h4><p>慢查询：很难在一定的时间内过滤出所需要的重要数据。</p><h4 id="大表对-DDL-操作的影响："><a href="#大表对-DDL-操作的影响：" class="headerlink" title="大表对 DDL 操作的影响："></a>大表对 DDL 操作的影响：</h4><p>建立索引需要很长的时间。</p><p>风险： </p><ul><li>MYSQL 版本 &lt; 5.5 建立索引会锁表</li><li>MYSQL 版本 &gt;= 5.5 虽然不会锁表但会引起长时间的主从延迟</li></ul><h4 id="修改表结构需要长时间锁表"><a href="#修改表结构需要长时间锁表" class="headerlink" title="修改表结构需要长时间锁表"></a>修改表结构需要长时间锁表</h4><p>风险： 会造成长时间的主从延迟，由于主从复制的机制都是现在主库上完成操作，再传输到从库上，在执行相同操作，如果在主库上需要使用480s 的时间来完成 DDL 操作，在从服务器上至少也需要480s。</p><h4 id="影响正常数据库操作。"><a href="#影响正常数据库操作。" class="headerlink" title="影响正常数据库操作。"></a>影响正常数据库操作。</h4><p>进行 DDL 时会被锁表，这样一来就会造成堵塞，在这一个阶段，数据库连接数会被激增，一旦数据库连接数被沾满，前台就会出现500错误。</p><h3 id="如何处理数据库中的大表"><a href="#如何处理数据库中的大表" class="headerlink" title="如何处理数据库中的大表"></a>如何处理数据库中的大表</h3><h4 id="分库分表把一张大表分成多个小表"><a href="#分库分表把一张大表分成多个小表" class="headerlink" title="分库分表把一张大表分成多个小表"></a>分库分表把一张大表分成多个小表</h4><p>难点： </p><p><strong>1.分表主键的选择。</strong></p><p>这个往往根据业务的不同，有多种分表的方式，比如对于订单表来说，可以根据订单号分表，也可以根据供应商和地区域来进行分表，选择合适的分区键对于后期的分表是十分重要的。</p><p><strong>2.分表后跨分区数据的查询和统计</strong></p><p>不要认为选择了好的分区键后就不需要跨分区进行查询了，好的分区键只能尽量避免跨分区查询。</p><h4 id="大表的历史数据归档"><a href="#大表的历史数据归档" class="headerlink" title="大表的历史数据归档"></a>大表的历史数据归档</h4><p>使用这种方法，可以减少对前后端业务的影响，因为表结构并没有发生变化，一切的程序都可以正常的使用，对于历史订单可以开放一个接口。</p><p>而且归档表可以跟正在使用的表放在不同的服务器上，一方面减少了热数据所在服务器的表容量，同时也减少了服务器的查询压力，对于后端业务而言，应该是已经完成相关操作和统计的历史数据。</p><p>难点：</p><ol><li><p>归档时间点的选择。</p></li><li><p>如何进行归档操作，对于大表的增删改查都要十分的小心，既然我们要归档，就要把要归档的数据从数据库中移除，从一个上亿行的数据表中移出上百万行的时候，就要注意方式了，轻则会产生主从延迟，严重会产生大量的阻塞。</p></li></ol>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用 INSERT 命令将表中字段导入到新表中</title>
      <link href="/2017/09/18/1/"/>
      <content type="html"><![CDATA[<p>最近为公司内部系统写了一个爬虫，爬了一个问答社区的三万多条数据，由于一开始的设计不够合理，将所有记录都放入了一个表中，由于是问答系统，合理的数据库设计，应该是将问题和答案分离开来，这样的结构更加合理，也易于未来的扩展。</p><p>我刚开始做iOS 的，转到 PHP 有一年多了，大学时有自学PHP，东学学西搞搞，结果就变成了啥都快记不住了，什么也都懂一些。</p><p>到了现在MYSQL 的基础也忘了许多，你让我扯一扯大规模，主从，分表，优化，我倒是能说上一堆，但是实际操作起来，啧啧。</p><p>这么一个简单的功能一时之间竟然都没有想起来，搜索引擎的确是个好东西（当然不拿医疗盈利的话）。</p><p>现在 iOS 也快忘得差不多了，感叹 ing，Swift 4都出了···</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`new_table_name`</span> <span class="keyword">VALUE</span> (<span class="string">`c1`</span>,<span class="string">`c2`</span>) <span class="keyword">SELECT</span> <span class="string">`c1`</span>,<span class="string">`c2`</span> <span class="keyword">FROM</span> <span class="string">`old_table_name`</span></div></pre></td></tr></table></figure><p>简单的一命令即可将数据导出。</p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> INSERT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大事务对MySQL性能带来的影响</title>
      <link href="/2017/09/16/1/"/>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在我们的日常开发过程当中，为了保持数据的一致性，多多少少都会用到事务。</p><p>当面对大量数据时，使用事务一定要谨小慎微，因为一旦编写的事务中设计的数据量过大，就会严重的影响系统性能，如果操作的数据量特别巨大，则会造成服务器的阻塞，导致业务逻辑无法访问。</p><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>在了解大事务对 MySQL 性能带来的影响之前，我们首先要了解什么是事务，事务又起到了什么样的作用：</p><ol><li><p>事务是关系型数据库系统区分于其他一切文件系统的重要特性，举例说明，对于文件系统来说，为了保证两个文件的一致，在我们修改完一个文件后，系统突然崩溃，这样文件系统在恢复后就很难保持系统的一致了，而数据库系统中，由于使用了事务，在数据库崩溃后，我们可以恢复数据库中的数据，使其保证数据的一致性。</p></li><li><p>事务是一组具有原子性的SQL语句，或是一个单独的工作单元，事务处理中只有两种可能性，事务处理成功，事务处理失败，一旦失败，数据库就会回滚到原始状态。</p></li></ol><p>事务要符合：原子性、一致性、隔离性、持久性</p><h4 id="事务的原子性（ATOMICITY）"><a href="#事务的原子性（ATOMICITY）" class="headerlink" title="事务的原子性（ATOMICITY）"></a>事务的原子性（ATOMICITY）</h4><p>定义：一个事务必须被诗作为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交完成，要么全部失败，对于一个事物来说，不可能只执行其中的一部分操作。</p><p>举个例子（银行），我们有两个账户，一个是理财账户，另外一个是活期存款账户，现在需要从理财账户中转出2000RMB到活期存款账户中，我们需要经过以下步骤。</p><ol><li>检查理财账户中的余额是否高于2000RMB</li><li>从理财账户的余额中减去2000RMB</li><li>在活期存款账户中增加2000RM</li></ol><p>以上步骤必须作为一个整体一起完成，如果运行到第二步骤时系统崩溃，如果没有事务原子性这一特性，用户将损失两千元，这是无法接受的一件事情。</p><p>在事务中执行到第二步崩溃时，在系统恢复后，在日志中有没有完成提交的事务，系统就会回滚，避免了用户的损失。</p><p>整个事务中所有操作要么全部提交成功，要么全部失败回滚。</p><h4 id="事务的一致性（CONSISTENCY）"><a href="#事务的一致性（CONSISTENCY）" class="headerlink" title="事务的一致性（CONSISTENCY）"></a>事务的一致性（CONSISTENCY）</h4><p>定义：一致性是指事务将数据库从一种一致性状态转换到另外一种一致性状态，在事务开始之前和事务结束后数据库中数据的完整性没有被破坏。</p><h4 id="事务的隔离性（ISOLATION）"><a href="#事务的隔离性（ISOLATION）" class="headerlink" title="事务的隔离性（ISOLATION）"></a>事务的隔离性（ISOLATION）</h4><p>定义： 隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其他事务是不可见的。</p><p>SQL标准中定义的四种隔离级别</p><ul><li>未提交读（READ UNCOMMITED）</li><li>已提交读（READ COMMITED）</li><li>可重复读（REPEATABLE READ）</li><li>可串行化（SERIALIZABLE）</li></ul><h4 id="事务的持久性（DURABILITY）"><a href="#事务的持久性（DURABILITY）" class="headerlink" title="事务的持久性（DURABILITY）"></a>事务的持久性（DURABILITY）</h4><p>定义：一旦事务提交，则其所做的修改就会永久</p><p>的保存到数据库中，即使此时系统崩溃，已经提交的修改数据也不会丢失。</p><h3 id="什么是大事务"><a href="#什么是大事务" class="headerlink" title="什么是大事务"></a>什么是大事务</h3><p>定义：运行时间比较长，操作数据比较多的事务。</p><p>余额宝这样的理财产品，每天都会计算前一天的理财收入所得，如果在一个事务中对所有的用户的理财收入都进行计算，并更新到用户余额中，这样数以亿计的用户余额的更新就要数个小时，而且一旦中间出现问题就会回滚，时间会更长。</p><p>这时一旦出现问题，数据库就会加锁，造成用户无法使用余额的问题。</p><p>风险：</p><ol><li>锁定太多的数据，造成大量的阻塞和锁超时，对于innodb为了保证数据的一致性，虽然是行级锁，但是也会把所有相关的记录都加上锁。</li><li>回滚所需要的时间比较长，回滚时数据仍然会被锁定。</li><li>执行时间长，容易造成主从延迟。</li></ol><h3 id="如何处理大事务"><a href="#如何处理大事务" class="headerlink" title="如何处理大事务"></a>如何处理大事务</h3><ol><li>避免一次处理太多数据,当面临成百上千万的数据量时，我们最好分批进行处理，例如每一个事务处理一万条数据。</li><li>移出不必要在事务中的SELECT操作。</li></ol>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用Object.defineProperty()模拟双向数据绑定</title>
      <link href="/2017/09/06/cjek1d3ks004brhrd3ss0hpal/"/>
      <content type="html"><![CDATA[<p>对象是由多键值对组成的无序集合，对象中的每个属性对应任意类型的值。定义对象可以使用构造函数或字面量的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//obj = &#123;&#125;</span></div><div class="line">obj.name = <span class="string">'Maksim'</span>;     <span class="comment">//添加属性</span></div><div class="line">obj.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;; <span class="comment">//添加方法</span></div></pre></td></tr></table></figure><p>为对象添加属性我们还可以使用 Object.defineProperty 定义和修改属性。</p><p>语法：<code>Object.defineProperty(obj, prop, descriptor)</code></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>法律结构条、款、项、目</title>
      <link href="/2017/09/05/1/"/>
      <content type="html"><![CDATA[<p>公司的新项目上线了，我们要为律师团队开发一套内部系统，其中包括爬虫抓来的问答、法律条款的检索。</p><p>而法律条文不能直接以文章的形式存储，因为后期可能会涉及到法律条文的引用，例如：</p><p><em>《烟草专卖法》第二条第二款</em></p><p>一般来讲，一件(部)法律由章、节、条、款、项、目组成，个别重要的法典还分编。</p><p>编、章、节是对法条的归类，所以，在适用法律时只需引用到条、款、项、目即可，无需指出该条所在的编、章、节。因此，弄懂法律规范中条、款、项、目的含义，在执法活动中正确适用法律规范的条、款、项、目，对于规范执法行为，提高执法质量是大有益处的。</p><h2 id="一、“条”"><a href="#一、“条”" class="headerlink" title="一、“条”"></a>一、“条”</h2><h3 id="1-条的概念"><a href="#1-条的概念" class="headerlink" title="1. 条的概念"></a>1. 条的概念</h3><p>法律规范的“条”，又称“法条”，是组成法律规范的基本单位。一部法律，都是由若干法条组成的。如《烟草专卖法》由46个法条组成，《烟草专卖法实施条例》由70个法条组成。</p><p>法律规范的“条”，是法律规范对某一个具体法律问题的完整规定，如：</p><blockquote><p>《烟草专卖法》第三十条  违反本规定擅自收购烟叶的，由烟草专卖行政主管部门处以罚款，并按照国家规定的价格收购违法收购的烟叶；数量巨大的，没收违法收购的烟叶和违法所得。</p></blockquote><p> 这一条就是对擅自收购烟叶法律责任的完整规定。</p><p>###　2. 条的书写</p><p>​    一般来讲，条的数目的书写应使用中文，如《烟草专卖法》第三十条。但也有使用阿拉伯数字的，如《烟草专卖法》第30条。</p><p>​    执法活动中，对一个涉法问题作出决定时，可能要适用多个法条。如对无证运输的人进行处罚时，应同时适用《烟草专卖法》第三十一条第一款、《条例》第五十五条第一项和第六十九条的规定。</p><h2 id="二、“款”"><a href="#二、“款”" class="headerlink" title="二、“款”"></a>二、“款”</h2><h3 id="1-款的概念。"><a href="#1-款的概念。" class="headerlink" title="1. 款的概念。"></a>1. 款的概念。</h3><p> “款”是“条”的组成部分。在一般情况下，每一款都是一个独立的内容或是对其前一款内容的补充表述。如：</p><blockquote><p>《烟草专卖法》第二条　</p><p>本法所称烟草专卖品是指卷烟、雪茄烟、烟丝、复烤烟叶、烟叶、卷烟纸、滤嘴棒、烟用丝束、烟草专用机械。</p><p><em>卷烟、雪茄烟、烟丝复烤烟叶统称烟草制品。</em></p></blockquote><p>《烟草专卖法》第二条有二款。其中第一款界定了烟草专卖品的范围，第二款进一步界定了烟草制品的范围。</p><h3 id="2-款的表现形式。"><a href="#2-款的表现形式。" class="headerlink" title="2. 款的表现形式。"></a>2. 款的表现形式。</h3><p>“款”的表现形式为条中的自然段，每个自然段为一款。</p><p>“款”前不冠以数字以排列其顺序。如《烟草专卖法》第二条的两款，款前均无数字。有数字排列的不称为款。如：</p><blockquote><p>《条例》第七条取得烟草专卖生产企业许可证，应当具备下列条件：</p><p>(一)有与生产烟草专卖品相适应的资金；</p><p>(二)有生产烟草专卖品所需要的技术、设备条件；</p><p>(三)符合国家烟草行业的产业政策要求；</p><p>(四)国务院烟草专卖行政主管部门规定的其他条件。</p></blockquote><p>上条第一段冒号下为：(一) 有与生产烟草专卖品相适应的资金。该段文字虽然是另起一行，但因为上段结束符号是冒号，本段开始前有(一)，因此，该段文字不视为是一个自然段，也不能认为其是一款。</p><h3 id="3-关于款的数目的书写。"><a href="#3-关于款的数目的书写。" class="headerlink" title="3. 关于款的数目的书写。"></a>3. 关于款的数目的书写。</h3><p>款的数目的书写一般应当使用中文，不用阿拉伯数字。如《烟草专卖法》第二条第二款，不写作《烟草专卖法》第二条第2款。</p><h3 id="4-款的适用"><a href="#4-款的适用" class="headerlink" title="4. 款的适用"></a>4. 款的适用</h3><p> 款一般可以独立适用，如《烟草专卖法》第二条第二款，但也有例外的，但与烟草专卖有关的法律法规中少见。</p><p>一个法条有两款或者两款以上的，应当适用到款。一个法条只有一款的，应当直接适用该法条，不应称作该条第一款，如：</p><blockquote><p>《条例》第三条烟草专卖品中的烟丝是指用烟叶、复烤烟叶、烟草薄片为原料加工制成的丝、末、粒状商品。</p></blockquote><p>在引用时，就应该写作“根据《实施条例》第三条”，而不是“根据《实施条例》第三条第一款”。</p><p>参照最高人民法院《关于引用法律、法令等所列条、款、项,目顺序的通知》，如果某一条下面没有分款而直接分列几项的，就不要加“第一款”，例如《条例》第七条只有（一）（二）（三）三项，就不要写“第七条第一款第一项”，而直接写“第七条第一项”。</p><h3 id="三、“项”"><a href="#三、“项”" class="headerlink" title="三、“项”"></a>三、“项”</h3><h3 id="1-项的概念"><a href="#1-项的概念" class="headerlink" title="1. 项的概念"></a>1. 项的概念</h3><p> 一般来讲，“项”是以列举的形式对前段文字的说明。如：</p><blockquote><p>《条例》第四十九条烟草专卖行政主管部门查处违反《烟草专卖法》和本条例的案件时，可以行使下列职权：</p><p>(一)询问违法案件的当事人、嫌疑人和证人；</p><p>(二)检查违法案件当事人的经营场所，依法对违法生产或者经营的烟草专卖品进行处理；</p><p>(三)查阅、复制与违法活动有关的合同、发票、账册、单据、记录、文件、业务函电和其他资料。</p></blockquote><p>​    该条的三个项是对前段文字中“下列职权”的列举式说明。</p><h3 id="2-项的表现形式"><a href="#2-项的表现形式" class="headerlink" title="2. 项的表现形式"></a>2. 项的表现形式</h3><p>含有项的法条，其前段文字中一般都有“下列”二字或相应的文字表述。“项”前冠以数字以对列举的内容进行排列。如《条例》四十九条，各项前都冠以(一)、(二)、(三)等数字，而且这些数字只能以中文数字加括号的形式出现。</p><h3 id="3-项的数目的书写"><a href="#3-项的数目的书写" class="headerlink" title="3. 项的数目的书写"></a>3. 项的数目的书写</h3><p>项的数目的书写一般应当使用中文加括号，不用阿拉伯数字。如《条例》第四十九条第（三）项，不写作《条例》第四十九条第3项。</p><h3 id="4-项的适用"><a href="#4-项的适用" class="headerlink" title="4. 项的适用"></a>4. 项的适用</h3><p>对含有项的法条，适用时应当适用到项；如对无证运输的处罚，应当适用《条例》第五十五条第(一)项。适用到项，是对被处罚的无证运输行为性质和情节的一种界定。如果不适用到项，该无证运输的行为就不知是四种行为之中的哪一种行为，有适用法律不准确之嫌。</p><p>根据立法技术的不同需要，“项”可以依附于条，也可以依附于款。即条中可以有项，款中也可以有项。</p><h3 id="四、“目”"><a href="#四、“目”" class="headerlink" title="四、“目”"></a>四、“目”</h3><h3 id="1-目的概念"><a href="#1-目的概念" class="headerlink" title="1. 目的概念"></a>1. 目的概念</h3><p> “目”隶属于项，是法律规范中最小的单位。“目”的特性与作用与“项”相似，不同的是项对条或款的列举式说明，而“目”是对项的列举式说明。如《条例》第五十五条第(二)项：</p><blockquote><p>(二)有下列情形之一的，没收违法运输的烟草专卖品和违法所得：</p><ol><li>非法运输的烟草专卖品价值超过5万元或者运输卷烟数量超过100件（每1万支为1件）的；</li><li>被烟草专卖行政主管部门处罚两次以上的；</li><li>抗拒烟草专卖行政主管部门的监督检查人员依法实施检查的；</li><li>非法运输走私烟草专卖品的；</li><li>运输无烟草专卖生产企业许可证的企业生产的烟草专卖品的；</li><li>利用伪装非法运输烟草专卖品的；</li><li>利用特种车辆运输烟草专卖品逃避检查的；</li><li>其他非法运输行为，情节严重的。</li></ol></blockquote><p>​    这八种情形，就是该项的八个目，列举没收违法运输的烟草专卖品和违法所得的八种情况。</p><h3 id="2-目的表现形式"><a href="#2-目的表现形式" class="headerlink" title="2. 目的表现形式"></a>2. 目的表现形式</h3><p>​    目的前面冠以阿拉伯数字，并在阿拉伯数字后加点(在具体引用法条的目时，只注明阿拉伯数字，无须加点)，例如《条例》第五十五条第(二)项第7目。</p><h3 id="3-目的适用"><a href="#3-目的适用" class="headerlink" title="3. 目的适用"></a>3. 目的适用</h3><p>如果某个法条或款的内容有“项”，而“项”下还有“目”的，在适用法律时就应当适用到“目”。如烟草专卖局在对非法运输走私烟草专卖品的行为进行处罚时，就应当适用《条例》第五十五条第(二)项第4目。当然，如果既非法运输走私烟草专卖品又利用特种车辆运输逃避检查，在作出处罚决定时就应同时适用相应的两个目。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Invert a Binary Tree</title>
      <link href="/2017/08/13/2/"/>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     4                          4</div><div class="line">   /    \                     /    \</div><div class="line">  2      7         to        7      2 </div><div class="line"> / \    /  \                / \    /  \</div><div class="line">1   3  6    9              9   6  3    1</div></pre></td></tr></table></figure><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * strcut TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode (index x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode *<span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        TreeNoe * tmpNode = root-&gt;left;</div><div class="line">        root-&gt;left = invertTree(root-&gt;right);</div><div class="line">        root-&gt;right = invertTree(tmpNode);</div><div class="line">        <span class="keyword">return</span> root; </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>利用的递归这个概念，短短几行就完成了一个翻转二叉树，只是在翻转二叉树的左右子数。</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++,算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法笔试入门题目Memmove</title>
      <link href="/2017/08/13/1/"/>
      <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">//implementation here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是 C 语言中的一个库函数，他的功能是吧内存中一块内容从src拷贝到dest，固定的长度是n。</p><p>这是笔试中的一个入门体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *scr, <span class="keyword">size_t</span> n)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">char</span> *p1 = dest;</div><div class="line"><span class="keyword">char</span> *p2 = src;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (*p2 != \<span class="number">0</span>)</div><div class="line">*p1++ = *p2++;</div><div class="line"></div><div class="line"><span class="keyword">return</span> p1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的这份代码，可以完成要求，可是却存在一些问题，我们先来看一下，C语言中的一些让人进场不会注意到的陷阱。</p><ul><li>内存重叠的处理，从一个指针，它指向的内存地址，拷贝到另外一个地址，那么有没有可能是完全重合，或者有一部分是重合的。</li><li>临时变量太多 或者没有安全释放</li><li>没有测试内存越界，size 是否小于零，指针是否为空？</li><li>指针操作熟悉</li></ul><p>内存是否重叠？</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-13%2014.45.22.png" alt="内存重叠">)</p><p>正确的写法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span> <span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *scr, <span class="keyword">size_t</span> n)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">char</span> *p1 = dest;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p2 = src;<span class="comment">//o用常量表示src</span></div><div class="line"></div><div class="line"><span class="comment">//判断src 和 dest 的位置关系</span></div><div class="line"><span class="keyword">if</span>  (p2 &lt; p1) &#123; </div><div class="line">p2 += n;</div><div class="line">p1 += n;</div><div class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span>) </div><div class="line">*--p1 = *--p2;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</div><div class="line">*p1++ = *p2++;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> p1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Array&amp;String算法</title>
      <link href="/2017/08/12/1/"/>
      <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Returns the position of the first occurrence of string target in string source or -1 if target is not part of source.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span> <span class="params">(String source, String target)</span> </span>&#123;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>希望在 <code>string</code> 里面寻找<code>target</code>，如果找到一个完全匹配的话，就返回他所在的位置，如果不存在就返回<code>-1</code>;</p><h1 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h1><p>两种比较容易实现的字符串比较算法。</p><p>假设在长度为 n的沐川中匹配长度为 m的子串。</p><p><code>Brute-Force</code> 算法： 顺序遍历母串，将每个字符作为匹配的起始字符，判断是否匹配子串。时间复杂度 O(m*n)</p><p><em>Brute-Force</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">StrStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *target)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!*target) <span class="keyword">return</span> str;</div><div class="line">    <span class="keyword">char</span> *p1 = (<span class="keyword">char</span> *)str;</div><div class="line">    <span class="keyword">while</span>(*p1) &#123;</div><div class="line">        <span class="keyword">char</span> *p1Begin = p1, *p2 = (<span class="keyword">char</span>*)target;</div><div class="line">        <span class="keyword">while</span>(*p1 &amp;&amp; *p2 &amp;&amp; *p1 == *p2) &#123;</div><div class="line">            p1++;</div><div class="line">            p2++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!*p2)<span class="comment">//发现p2走到了末尾，就意味着有匹配到的字符串，那么直接返回p1Begin;所记录的位置</span></div><div class="line">            <span class="keyword">return</span> p1Begin;</div><div class="line">        p1 = p1Begin + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux 和 GNU 工程</title>
      <link href="/2017/08/10/3/"/>
      <content type="html"><![CDATA[<p>每天都有许多计算机用户使用一个被改动过的GNU 系统 (18k 字节)，但是他们并没有意识到它。 经过一系列的事件，现在被广泛使用的 GNU 版本则经常被称作“Linux”，可是许多用户并不了解与之相关的 GNU 工程。</p><p>Linux 确实存在；它是一个内核，许多人都在使用它。但是你不能仅使用内核本身。内核只有作为整个系统的一个部分才有用处。Linux 是和 GNU 操作系统结合在一起使用：系统本身是 GNU，与 Linux 作为内核一起工作。</p><p>许多用户没有并不完全了解 Linux 内核和被称作“Linux”的整个系统的区别。而不加区别地使用这个名字并不能对理解有帮助。</p><p>程序员一般都知道 Linux 是一个内核。但是因为他们也听到整个系统被称作“Linux”，他们会根据名字去想象历史。比如，很多人认为当 Linus Torvalds 完成了内核后，他的朋友四处寻找其他的自由软件，而且所有的可以被组装成一个类似 Unix 系统的程序都是现成的。</p><p>他们的发现不是巧合 – 这就是 GNU 系统。 可用的自由软件加在一起就组成了一个完整的系统，这是由于自 1984 年就开始的 GNU 工程一直在为此努力。GNU 宣言(31k 字节) 早已设立了开发一个类似 Unix 的自由系统的目标，称作 GNU。GNU 工程的最初公告 也勾画了 GNU 系统的原始提纲。在 Linux 被编写时，这个系统几乎已经完成。</p><p>大多数自由软件的工程都是为了特定的工作开发特定的程序。比方说，Linus Torvalds 编写类似 Unix 的内核(Linux); Donald Knuth 编写一个文本格式化工具(TeX); Bob Scheifler 开发一个窗口系统(X Window System)。对于这项工程编写的程序都作出了贡献，对这些贡献进行评估是很自然的。</p><p>如果以这种方法来衡量对 GNU 工程的贡献，我们会得出什么结论？一个 CD-ROM的提供商发现在他们的“Linux 发行版”中，GNU 软件 占最大的比重，大约占全部源代码的 28% ，而且这还包括一些关键的部件，没有这些部件，系统就无法工作。Linux 本身占大约 3%。所以如果你要根据程序的作者来选择一个名字的话，最合适的选择是“GNU”。</p><p>但是我们不认为这是一个解决问题的适当方法。GNU 工程以前不是，现在也不是一个开发某个软件包的工程。它不是一个 开发 C 编译器的工程, 尽管我们做了。它也不是一个开发一个文本编辑器的工程，尽管我们也做了。GNU 工程的目标是开发一个完全自由的类似 Unix 的系统: GNU。</p><p>许多人已经为系统中的自由软件作出了重大贡献，他们都应该获得荣誉。但 GNU 是一个系统而不是一些实用程序的组合的原因是，GNU 工程的最初目标就是做一个完整系统。我们曾经为完成一个完整的系统做了一个所需程序清单，而且我们有系统地寻找，编写这些程序，并且寻找别人编写清单上的每一个程序。我们编写了关键的但是十分枯燥的主要部件，比如汇编语言和连接器，因为这是系统所必需的。除了编程工具，一个完整的系统还需要更多的东西， Bourne Again SHell 程序, PostScript 解释器 Ghostscript, 和 GNU C 库 同样是很重要的。</p><p>到了 90 年代初期，我们曾经把除了内核以外的东西放到一起组成了一个系统（我们同时也在做内核的工作）称为 GNU Hurd, 运行在 Mach 上)。开发这个内核比我们想象的要难得多，我们现在仍然在 为此工作。</p><p>庆幸的是，你不必再等了，因为 Linux 开发成功。当 Linus Torvalds 写成了 Linux，他填补了一个重要的空白。人们可以将 Linux 和 GNU 系统组成一个完整的自由系统：基于 Linux 的 GNU 系统（或简称为 GNU/Linux 系统）。</p><p>把它们组合到一起听起来很容易，但是这并不是一个简单的工作。 GNU C 库 (简称 glibc) 需要作大量的修改。集成到一个完整的发行系统中也是一项很大的工作。它需要对如何安装和启动系统进行定位 – 这个问题直到现在还在完善，因为我们还没有抓住要点。那些开发了不同的发行系统的人们作出了巨大贡献。</p><p>除了 GNU，还有一个独立进行的工程开发了一个自由的类似 Unix 的操作系统。这个系统被称为 BSD，它是由 UC Berkeley 开发的。 在 GNU 工程的鼓舞下，BSD 的开发者开始进行他们自己的自由软件的开发工作，并时常受到 GNU 人士的鼓励，但是他们的实际工作与 GNU 差别不大。今天 BSD 系统采用一些 GNU 软件，就象不同版本的 GNU 系统也采用 BSD 的软件一样。总的说来，它们是两套独立开发的不同的系统。今天一个免费的操作系统几乎都是采用 GNU 或 BSD 系统的一个派生版本。</p><p>GNU 工程支持 GNU/Linux 系统，就象支持 GNU 系统一样 – 包括资金的支持。我们为重写与 Linux 相关的 GNU C 库提供资金，以至于它们现在可以很好地集成在一起，直到最新版本的 GNU/Linux 仍在使用这个库而无需修改。我们也为早期 Debian GNU/Linux 的开发提供资金。</p><p>今天我们的绝大多数的工作都在基于 Linux 的 GNU 系统上完成，我们希望你也如此。但是请不要含糊地使用 Linux 而使公众迷惑。Linux 是内核，系统的关键部件之一。系统或多或少实际上都应该是 GNU 系统，再加上 Linux。当你在讨论到这个组合系统时，请使用 “GNU/Linux”。</p><p>如果要为 GNU/Linux 作链接，本页和 <a href="http://www.gnu.org/gnu/the-gnu-project.html" target="_blank" rel="noopener">http://www.gnu.org/gnu/the-gnu-project.html</a> 都是很好的选择。如果你想为 Linux（内核）作链接，<a href="http://www.kernel.org/是一个很好" target="_blank" rel="noopener">http://www.kernel.org/是一个很好</a> URL。</p><p>本文摘 <a href="https://www.gnu.org/gnu/linux-and-gnu.html" target="_blank" rel="noopener">https://www.gnu.org/gnu/linux-and-gnu.html</a></p><p>Copyright 1997, 1998 Richard Stallman</p><p>中文翻译：白若玉<br>翻译校正：刘昭宏</p><p>全文在保证完整性的前提下可以在任意媒体转载 - 须保留此标注。</p><p>Updated: 30 Nov 2000 paulv</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,GNU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Virtualbox下安装 CentOS  minimal 后设置上网</title>
      <link href="/2017/08/10/2/"/>
      <content type="html"><![CDATA[<p>在虚拟机中以minimal安装 CentOS 后无法上网，因为CentOS的默认网卡未激活。</p><p>可以设置 </p><p>文件 /etc/sysconfig/network-scripts/ifcfg-enp0s3</p><p> 将 <code>ONBOOT=no</code> 改为 <code>ONBOOT=yes</code></p><p> <img src="http://www.maksim.website/images/linux/networkonboot.png" alt="激活"></p><p> 保存后重启网卡： <code>service network restart</code></p><p>  <img src="http://www.maksim.website/images/linux/ping.png" alt="ping"></p><p> 这样就可以上网了，我用的是桥接模式。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,Centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS中Live、netinstall、minimal、DVD 等版本的区别</title>
      <link href="/2017/08/10/1/"/>
      <content type="html"><![CDATA[<p><code>LiveCD</code> 和<code>LiveDVD</code> 是可以直接光盘运行的胸痛，但不能安装，两者差别在于容量大小，DVD 包含的软件要多一些。</p><p><code>netinstall</code> 用于网络安装和系统救援的镜像文件。</p><p><code>minimal</code> 这个镜像文件用于安装一个非常基本的 CentOS系统,包含了一些基本所需的最小安装包。</p><p><code>DVD</code> 镜像包含了完整的发布版，可以用于安装完整的 CentOS 系统。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,Centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/08/06/cjek1d3ii000urhrdngd8nhos/"/>
      <content type="html"><![CDATA[<hr><p>title:MySQL索引<br>categories:MySQL</p><h2 id="date-2017-8-6"><a href="#date-2017-8-6" class="headerlink" title="date:2017-8-6"></a>date:2017-8-6</h2><p>数据库索引，是数据库管理系统中一个排序的数据结构，用于协助快速查询、更新数据库表中的数据。它类似于书本上的索引，通过索引可以更便捷地找到书里面的内容而不需要查阅整本书。对于海量数据的检索，索引往往是最有效的。</p><p>目前MySQL主要支持的几种索引有:B树索引(B-tree)、散列索引(hash)、空间索引(R-tree)和全文索引(full-text)。如果没有特别指明，本书指的就是B-Tree索引。由于索引是在存储引擎层实现的，所以不同的存储引擎的索引实现会有一些差异。以下所述的是一些较通用的索引知识。</p><p>逻辑上又可以分为:单列索引、复合索引(多列索引)、唯一(Unique)索引和非唯一(Non Unique)索引。</p><p>如果索引键值的逻辑顺序与索引所服务的表中相应行的物理顺序相同，那么该索引被称为簇索引(cluster index)，也称为聚集索引、聚簇索引，也就是说数据和索引(B+树)在一起，记录被真实地保存在索引的叶子中，簇索引也称为索引组织表，反之为非聚集索引。我们常用的InnoDB表其实使用的就是聚集索引。</p><p>簇索引是一个很重要的概念，InnoDB作为最常使用的引擎，只有在熟悉了它的数据存储方式之后，才可能有针对性地对它进行调优。</p><p>簇索引的一些优点如下。</p><ul><li>将相关的的数据保持在一起，叶子节点内可保存相邻近的记录。·因为索引和数据存储在一起，所以查找数据通常比非簇索引更快。由于主键是有序的，很显然，对于InnoDB表，最高效的存取方式是按主键存取唯一记录或进行小范围的主键扫描。  如果充分利用簇索引，它可以极大地提升性能，但簇索引也有许多不足之处。</li><li>簇索引对I/O密集型的负荷性能提升最佳，但如果数据是在内存中(访问次序不怎么重要)，那么簇索引并没有明显益处。</li><li>插入操作很依赖于插入的顺序，按primary key的顺序插入是最快的。</li><li>更新簇索引列的成本比较高，因为InnoDB不得不将更新的行移动到新的位置。</li><li>全表扫描的性能不佳，尤其是数据存储得不那么紧密时，或者因为页分裂(page split)而导致物理存储不连续。</li><li>二级索引的叶节点中存储了主键索引的值，如果主键采用的是较长的字符，那么索引可能会很大，且通过二级索引查找数据也需要进行两次索引查找。</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>在Mac上编译安装线程安全的PHP7.2</title>
      <link href="/2017/08/05/1/"/>
      <content type="html"><![CDATA[<p>因为项目需求后期可能会需要使用到进程守护和消息队列，于是上网查了一下，看到<a href="http://netkiller.github.io/php/index.html" target="_blank" rel="noopener">Netkiller <em>PHP 手札</em></a>中有介绍到PHP使用 Pthread实现优雅守护进程的方法。</p><p>可是由于我本地的 PHP 是使用brew进行安装的，在 Linux 下使用 yum或者 apt进行安装的 PHP 同样不支持线程安全。</p><p>于是开始折腾起来，将 PHP 卸载掉后使用编译进行重新安装，开启<code>--enable-maintainer-zts</code> 后在编译过程中遇到了 Clang 报错，经过了一番 Google、百度过后，原来是编译器在作怪。Mac 由于 Xcode 的原因，默认使用的编译器是 Clang，在编译到 pthread 的时候，就会报错。</p><p>解决方法也很简单，在./configure 命令的最后加上 CC=gcc ，告诉make 我要使用 GCC 编译器进行编译即可。</p><p>其实在日常的开发中PHP开发者，很少会接触到多线程这一块。甚至有的PHP 开发者都搞不清楚什么是线程、进程和协程。</p><p>那是因为在 Web 开发中根本使用不了多线程，因为 PHP 本身并不提供多线程API，其多线程的支持是由 Pthread 扩展提供的，而 Pthread 扩展的文档中有说明：</p><blockquote><p><strong>Warning</strong>    不可以在 web 服务器环境中使用 pthreads 扩展，PHP 多线程开发仅限于命令行模式的应用。</p></blockquote><p>Windows版的PHP从版本5.2.1开始有Thread Safe(线程安全)和None Thread Safe(NTS，非线程安全)之分，这两者不同在于何处？到底应该用哪种？</p><p>从2000年 10月20日发布的第一个Windows版的PHP3.0.17开始的都是线程安全的版本，这是由于与Linux/Unix系统是采用多进程的工作方式不同的导致的。</p><p>Windows系统是采用多线程的工作方式。如果在IIS下以CGI方式运行PHP会非常慢，这是由于CGI模式是建立在多进程的基础之上的，而非多线程。一般我们会把PHP配置成以ISAPI的方式来运行，ISAPI是多线程的方式，这样就快多了。</p><p>但存在一个问题，很多常用的PHP扩展是以 Linux/Unix的多进程思想来开发的，这些扩展在ISAPI的方式运行时就会出错搞垮IIS。因此在IIS下CGI模式才是PHP运行的最安全方式，但CGI模式对于每个HTTP请求都需要重新加载和卸载整个PHP环境，其消耗是巨大的。</p><p>为了兼顾IIS下PHP的效率和安全，微软 给出了FastCGI的解决方案。FastCGI可以让PHP的进程重复利用而不是每一个新的请求就重开一个进程。同时FastCGI也可以允许几个进程同时执行。这样既解决了CGI进程模式消耗太大的问题，又利用上了CGI进程模式不存在线程安全问题的优势。</p><p>因此，如果是使用ISAPI 的方式来运行PHP就必须用Thread Safe(线程安全)的版本；而用FastCGI模式运行PHP的话就没有必要用线程安全检查了，用None Thread Safe(NTS，非线程安全)的版本能够更好的提高效率。</p><p>从上面这段描述我们可以清楚的知道，如果不是使用 ISAPI 的话，不使用多线程特性，那么基本上就用不Thread Safe。</p><p>查看自己的 PHP版本是否是线程安全你的只需要在命令行中输入 <code>PHP -v</code>查看 PHP 的版本即可，如下：</p><p><img src="http://www.maksim.website/images/threadsafe.png" alt="线程安全"></p><p>引用：</p><p><em>PHP线程安全和非线程安全有什么区别</em>  <a href="http://www.cnblogs.com/T8881/p/6397264.html" target="_blank" rel="noopener">http://www.cnblogs.com/T8881/p/6397264.html</a></p><p><em>PHP Internals Book（《PHP内部书》PHP 内核开发者合著)</em> <a href="http://www.phpinternalsbook.com/index.html" target="_blank" rel="noopener">http://www.phpinternalsbook.com/index.html</a></p><p><em>PHP运行模式</em> <a href="http://www.cnblogs.com/xia520pi/p/3914964.html" target="_blank" rel="noopener">http://www.cnblogs.com/xia520pi/p/3914964.html</a></p><p><em>Netkiller <em>PHP 手札</em></em> <a href="http://netkiller.github.io/php/index.html" target="_blank" rel="noopener">http://netkiller.github.io/php/index.html</a></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程,PHP7.2,编译安装,GCC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在SQL中使用变量</title>
      <link href="/2017/08/05/602/"/>
      <content type="html"><![CDATA[<p>MySQL 李的变量可分为用户变量和系统变量</p><p><strong>1. 用户变量</strong></p><p>MySQL允许用户在语句中自定义变量，对于用户变量的值，可以先保存在用户变量中，然后在引用它；这样就可以将值从一个语句传到另外一个语句。</p><p>用户变量与连接有关。一个客户端定义的变量不能被其他客户端看到货使用。当客户端退出时，该客户端连接的所有变量将自动释放。这点不同于在函数或存储过程中通过 <code>DECLAER</code> 药监局声明的局部变量，局部变量的生存周期在它被声明的“<code>BEGIN...END</code>”块内。</p><p>用户变量的表现形式为：@var_name</p><p>设置用户变量的一个途径是执行 SET 语句，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SET</span> @var_name= expr[, @var_name= expr] ...</div></pre></td></tr></table></figure><p>对于SET，可以使用“=”或“:=”作为分配符。分配给每个变量的expr可以为整数、实数、字符串或NULL值。如:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SET @t1=0, @t2=0, @t3=0;</div></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SET</span> @minMid=(<span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> table_name) ;</div></pre></td></tr></table></figure><p><strong>2.系统变量</strong></p><p>MySQL服务器维护着两种系统变量:</p><ul><li>全局变量影响MySQL服务的整体运行方式</li><li>会话变量影响具体客户端连接的操作</li></ul><p>当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中对指定的选项进行更改。服务器启动后，通过连接服务器并执行<code>SET</code> <code>GLOBAL var_name</code>语句，可以动态更改这些全局变量。要想更改全局变量，必须具有<code>SUPER</code>权限。</p><p>服务器还为每个连接的客户端维护一系列的会话变量。在连接时使用相应全局变量的当前值对客户端的会话变量进行初始化。对于动态会话变量，客户端可以通过<code>SET SESSION var_name</code>语句更改它们。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其他客户端的会话变量。</p><p>访问全局变量的任何客户端都可以看见对全局变量所做的更改。然而，它只影响更改后连接的客户的相应会话变量，而不会影响目前已经连接的客户端的会话变量(即使客户端执行<code>SET GLOBAL</code>语句也不影响)。</p><p>也就是说，如果你的连接是短连接，那么修改全局变量后，客户端有重连的操作，就会立刻影响到客户端。而对于长连接、连接池来说，连接可能一直在MySQL里没有被销毁，也就不会有重连的操作，所以这种情况下对全局变量的修改一般不会影响到客户端。</p><p>可以使用如下几种语法形式来设置或检索全局变量或会话变量(下面的例子使用<code>sort_buffer_size</code>作为示例变量名)。</p><p>要想设置一个<code>GLOBAL</code>变量的值，可使用下面的语法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SET GLOBAL sort_buffer_size=value; </div><div class="line">mysql&gt; SET @@global.sort_buffer_size=value;</div></pre></td></tr></table></figure><p>要想设置一个SESSION变量的值，可使用下面的语法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SET SESSION sort_buffer_size=value; </div><div class="line">mysql&gt; SET @@session.sort_buffer_size=value; </div><div class="line">mysql&gt; SET sort_buffer_size=value;</div></pre></td></tr></table></figure><p>如果设置变量时不指定<code>GLOBAL</code>、<code>SESSION</code>或<code>LOCAL</code>，则默认使用<code>SESSION</code>。</p><p>要想检索一个<code>GLOBAL</code>变量的值，可使用下面的语法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@global.sort_buffer_size;</div><div class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE 'sort_buffer_size';</div></pre></td></tr></table></figure><p>要想检索一个SESSION变量的值，可使用下面的语法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @@sort_buffer_size;</div><div class="line">mysql&gt; SELECT @@session.sort_buffer_size; mysql&gt; SHOW VARIABLES LIKE 'sort_buffer_size';</div></pre></td></tr></table></figure><p>当用<code>SELECT@@var_name</code>搜索一个变量时(也就是说，不指定<code>GLOBAL</code>、<code>SESSION</code>)，MySQL会返回<code>SESSION</code>值(如果存在<code>SESSION</code>变量的话)，否则返回<code>GLOBAL</code>值。</p><p>对于<code>SHOW VARIABLES</code>，如果不指定<code>GLOBAL</code>、<code>SESSION的</code>话，MySQL会返回SESSION值。</p><p>引用</p><p>《MySQLDBA 修炼之道》 作者：陈晓勇</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/user-variables.html" target="_blank" rel="noopener">MySQL 官方文档 9.4 User-Defined Variables</a></p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础很重要，你真的知道什么是数据库吗？</title>
      <link href="/2017/08/04/601/"/>
      <content type="html"><![CDATA[<p>“数据库基础”可不是一件小事。问题是，有时人们认为他们知道的很多。</p><p>例如，这个问题:什么是数据库?</p><p>我敢说大多数的人相信他们知道这个问题的答案。但其中一部分人(或者很多)都会答错。SQL Server 不是数据库，它只是一种 DBMS(数据库管理系统)。你可以使用 SQL Server 来创建数据库，但 SQL Server 本身不是一种数据库。</p><p>那么，什么是数据库?数据库是一种有组织的数据存储，其中的数据可以通过指定的数据元素(比如，字段、记录和文件)来访问(详见图 1-1)。</p><p><img src="http://www.maksim.website/images/whatis.png" alt="数据库"></p><p>数据库是一种有组织的数据存储，其中的数据可以通过指定的数据元素来访问。</p><p>DBMS 是一种使终端用户或程序员能够共享数据的软件。它提供了一套操作数据库的系</p><p>统性方法:创建、更新、检索和存储信息。DBMS 通常还负责数据完整性、数据安全性、数据访问控制和优化、自动回退、重起和恢复。</p><p>对外行人来说，你可以把数据库想象成一个文件夹，把 DBMS 想象成文件柜，且所容纳的所有文件都贴有标签。DBMS 管理着数据库，通过 DBMS 来实现和访问数据库实例。所以说，DB2、Oracle 和 SQL Server 都是数据库管理系统。工资单应用使用工资单的数据库，该数据库可以使用 DB2、Oracle 或者 SQL Server 来实现。</p><p>摘自DBA 《修炼之道：数据库管理员的第一本书》</p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用 MySQL 权限机制设置用户权限</title>
      <link href="/2017/08/04/600/"/>
      <content type="html"><![CDATA[<p>MySQL 权限控制包含如下两个阶段。</p><p>阶段1： 服务器检测是否允许你链接。</p><p>阶段2： 假定你能连接，服务器将检测你发出的每一个请求，查看你是否有足够的权限实施它。例如你从数据库表中选择（SELECT）行或从数据库中删除表，那么服务器要确定你是否对表有SELECT权限或对数据库有DROP权限。</p><p>MySQL是通过用户名、密码、IP(主机名)3个要素来验证用户的。当你想要访问MySQL服务器时，MySQL客户端程序一 般会要求你指定如下参数。</p><ul><li>MySQL服务器的IP(主机名)，</li><li>端口</li><li>用户名</li><li>密码 </li></ul><p>以下是连接MySQL服务器的一个示例，你需要以实际的IP、端口、用户名、密码代替相应的内容。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -h host_ip_address -u user_name -pyour_password -P server_port</div></pre></td></tr></table></figure><p>一般在生产环境下，程序账号有增加、删除、查询、修改这4项功能即可。</p><p>如下命令用于赋予查询、插入、修改、删除权限，并进行密码设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span> <span class="keyword">on</span> db_name.* <span class="keyword">to</span> user_name@ <span class="string">'10.%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'password'</span>;</div></pre></td></tr></table></figure><p>如下命令用于回收上面所赋予的权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">revoke</span> <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span> <span class="keyword">on</span> db_name.* <span class="keyword">from</span> user_name@ <span class="string">'10.%'</span>;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP7 微信支付不能回调，让我们的团队损失1.00CNY。</title>
      <link href="/2017/07/14/cjek1d3ix001krhrdgj2l4yra/"/>
      <content type="html"><![CDATA[<p>公司目前正在使用一套基于 TP5的开源商城，在线上测试过程中碰到了一个问题，微信支付完成后无法进行回调更新订单状态，简单点说就是钱没了，啥也没得到。</p><p><code>What？</code>这可是一个无法容忍的错误。</p><p>原本以为是微信支付配置环节出了问题，于是便去查看微信官网给出的帮助手册，又顺着流程走了一边，信心满满的又测试了一边，结果尴尬了，又损失了0.01人民币。</p><p>反复确认流程后，确认并不是配置的问题，于是便开始了百度，原来这一切都是在微信官网给出的SDK中的一段代码惹的祸，就这么一段代码让我们团队损失了接近1人民币。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取通知的数据</span></div><div class="line">$xml = $GLOBALS[<span class="string">'HTTP_RAW_POST_DATA'</span>];  <span class="comment">//  WxPay.Api.php  414 line</span></div></pre></td></tr></table></figure><p>这段代码如果放在PHP7之前的版本是不会有任何问题的，但是在 PHP7版本中却已经<strong>废除</strong>了 <code>HTTP\_RAW\_POST\_DATA</code>    。</p><p>在官方文档中给了说明：</p><blockquote><p><strong>Warning</strong> This feature was DEPRECATED in PHP 5.6.0, and REMOVED as of PHP 7.0.0.</p></blockquote><p>在<code>PHP5.6.0</code>发布的时候，就已经不推荐只用这种方法，于是在PHP 社区在开发 PHP7.0的时候直接就将其废弃掉了。</p><p>而官方也给出了替代的方案，那就是<code>php://input</code></p><p><code>php://input</code> 是个可以访问请求的原始数据的只读流。 </p><p><code>POST</code> 请求的情况下，最好使用 <code>php://input</code> 来代替 <code>$HTTP\_RAW\_POST\_DATA</code>，因为它不依赖于特定的<code>php.ini</code>指令。 </p><p> 而且，这样的情况下 <code>$HTTP\_RAW\_POST\_DATA</code> 默认没有填充， 比激活 <code>always\_populate\_raw\_post\_data</code>潜在需要更少的内存。 <code>enctype=&quot;multipart/form-data&quot;</code> 的时候 <code>php://input</code> 是无效的。</p><blockquote><p><code>Note</code>: 在 PHP 5.6 之前 php://input 打开的数据流只能读取一次； 数据流不支持 seek 操作。 不过，依赖于 SAPI 的实现，请求体数据被保存的时候， 它可以打开另一个 php://input 数据流并重新读取。 通常情况下，这种情况只是针对 POST 请求，而不是其他请求方式，比如 PUT 或者 PROPFIND。 </p></blockquote><p>于是我将这段代码改为了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取通知的数据</span></div><div class="line">$xml = file_get_contents(<span class="string">"php://input"</span>); <span class="comment">//  WxPay.Api.php  414 line</span></div></pre></td></tr></table></figure><p>最后我又以0.01人民币的代价确认修复了这个 BUG。</p><p><code>PHP7:&quot;怪我喽，让你经常看文档，哼！&quot;</code></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wechat pay, php, php7, php://input </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>提高 MySQL 的性能，从数据库设计规范开始</title>
      <link href="/2017/06/23/2/"/>
      <content type="html"><![CDATA[<p>这几日一直都在看慕课网的一篇有关于数据库设计的实战教程，在其中讲述了关于数据库设计的一些相关规范，可以说是受益匪浅，于是便将学习所得记录下来，如果有想要看视频版的同学可以到慕课网查看。</p><p><a href="http://coding.imooc.com/class/79.html" target="_blank" rel="noopener">点我跳转到慕课网观看视频</a></p><h2 id="数据库名称规范"><a href="#数据库名称规范" class="headerlink" title="数据库名称规范"></a>数据库名称规范</h2><h3 id="1-所有数据库对象名称必须使用小写字母并使用下划线分割"><a href="#1-所有数据库对象名称必须使用小写字母并使用下划线分割" class="headerlink" title="1.所有数据库对象名称必须使用小写字母并使用下划线分割"></a>1.所有数据库对象名称必须使用小写字母并使用下划线分割</h3><p>由于 MySQL数据库的对象名称默认情况下是大小写敏感的，特别是在 Linux 系统下，MySQL 的数据库和表实际上的存储方式就是 Linux 下的一个文件，由于 Linux 系统是对大小写敏感的，所以 MySQL 也就对大小写敏感，这就意味着 DbName dbname 是完全不同的两个数据库。</p><p>如果在开发过程中使用大小写混用的情况下，就会对未来的开发工作造成很多不必要的麻烦，要时刻注意数据库对象的大小写。</p><h3 id="2-所有的数据库对象名称禁止使用-MySQL-的保留字段"><a href="#2-所有的数据库对象名称禁止使用-MySQL-的保留字段" class="headerlink" title="2.所有的数据库对象名称禁止使用 MySQL 的保留字段"></a>2.所有的数据库对象名称禁止使用 MySQL 的保留字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select id,username from ,age from tb_user;</div></pre></td></tr></table></figure><p>在上述SQL 语句中存在两个 from，由于 MySQL 并不知道这两个 from 有什么区别，若是执行这条 SQL 语句肯定会报错，但是在建表的时候却不会报错。</p><p>若是已经使用了关键字做了字段名，那就需要在字段名前后加上反引号，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select id,username `from` ,age from tb_user;</div></pre></td></tr></table></figure><blockquote><p>反引号是为了区分MySQL关键字和保留字与普通字符而引入的符号，保留字的列表请点击此网页查看 <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/keywords.html</a></p></blockquote><h3 id="3-数据库对象的命名要做到见名识义，而且最好不要超过32个字符"><a href="#3-数据库对象的命名要做到见名识义，而且最好不要超过32个字符" class="headerlink" title="3. 数据库对象的命名要做到见名识义，而且最好不要超过32个字符"></a>3. 数据库对象的命名要做到见名识义，而且最好不要超过32个字符</h3><p>MySQL 的限制长度是64个字符，但是表名和列名一旦过长，在使用过程中将会很不方便，而且还会增加网络传输的开销。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">用户数据库： ex_userdb</div><div class="line">用户账户表： user_account</div></pre></td></tr></table></figure><h3 id="4-所有的临时表必须以-tmp为前缀并以日期为后缀"><a href="#4-所有的临时表必须以-tmp为前缀并以日期为后缀" class="headerlink" title="4. 所有的临时表必须以 tmp为前缀并以日期为后缀"></a>4. 所有的临时表必须以 tmp为前缀并以日期为后缀</h3><p>在我们的日常工作中，会在数据库中建立一些临时表或者中间表，往往无法第一时间将其清理掉，时间一长便无法分清，哪些是临时表或者是持久化表，这样一来就会造成很多的垃圾数据。</p><h3 id="5-备份表必须以bak为前缀并以日期为后缀"><a href="#5-备份表必须以bak为前缀并以日期为后缀" class="headerlink" title="5.备份表必须以bak为前缀并以日期为后缀"></a>5.备份表必须以bak为前缀并以日期为后缀</h3><p>在日常工作中，我们会对数据库进行备份，在备份的时候，以 bak 开头可以清晰的表示出这是一个备份表，并且以时间结尾标注了这个表是在什么时间进行的备份，这样一来能够设计出更加整洁的数据库，并且结构清晰。</p><h3 id="6-所有存储相同数据的列明和列类型必须一致。"><a href="#6-所有存储相同数据的列明和列类型必须一致。" class="headerlink" title="6.所有存储相同数据的列明和列类型必须一致。"></a>6.所有存储相同数据的列明和列类型必须一致。</h3><p>通着这这种字段都是以关联字段进行使用的，如果两个表的关联字段的数据类型不一致，在关联时MySQL 会进行隐式类型转换，造成字段索引失效，影响数据库的运行性能，导致不必要的开销。</p><h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h2><h3 id="1-在没有特殊要求的情况下，所有表必须使用-Innodb-存储引擎"><a href="#1-在没有特殊要求的情况下，所有表必须使用-Innodb-存储引擎" class="headerlink" title="1. 在没有特殊要求的情况下，所有表必须使用 Innodb 存储引擎"></a>1. 在没有特殊要求的情况下，所有表必须使用 Innodb 存储引擎</h3><p>比如列存储、在5.7版本之前存储空间数据，如果还在使用MyISAM 引擎如果在升级到5.6之后应该尽快将存储引擎升级到 Innodb，因为在5.6之后的默认引擎就是 Innodb，Innodb 支持事务，行级锁，更好的恢复性，高并发下性能更好。</p><h3 id="2-数据库和表的字符集使用-UTF8"><a href="#2-数据库和表的字符集使用-UTF8" class="headerlink" title="2.数据库和表的字符集使用 UTF8"></a>2.数据库和表的字符集使用 UTF8</h3><p>统一的字符集可以避免由于字符集转换禅城的乱码，MySQL 中 UTF8字符集汉字站3个字节，ASCII 码占用1个字节，若我们定了一个 varchar(255)的列，并且存储中文的话，255个中文字符将会占用725个字节。</p><h3 id="3-所有的表和字段都需要添加注释"><a href="#3-所有的表和字段都需要添加注释" class="headerlink" title="3.所有的表和字段都需要添加注释"></a>3.所有的表和字段都需要添加注释</h3><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典维护。</p><h4 id="4-尽量控制单表数据量的大小，建议控制在500万行以内"><a href="#4-尽量控制单表数据量的大小，建议控制在500万行以内" class="headerlink" title="4.尽量控制单表数据量的大小，建议控制在500万行以内"></a>4.尽量控制单表数据量的大小，建议控制在500万行以内</h4><p>500万并不是 MySQL数据库的限制，MySQL 的存储数据量取决于存储设置和文件系统，修改表结构，备份，恢复都会有很大问题。</p><p>可以使用历史数据归档，分库分表等手段来控制数据量的大小，历史数据归档常用语系统日志，分库分表主要应用在业务表上。</p><h4 id="5-谨慎的使用-MySQL-分区表。"><a href="#5-谨慎的使用-MySQL-分区表。" class="headerlink" title="5.谨慎的使用 MySQL 分区表。"></a>5.谨慎的使用 MySQL 分区表。</h4><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表。谨慎的选择分区键，跨分区查询效率可能更低。</p><p>建议采用物理分表的方式管理大数据。</p><h4 id="6-尽量做到冷热数据分离，减小表单的宽度"><a href="#6-尽量做到冷热数据分离，减小表单的宽度" class="headerlink" title="6.尽量做到冷热数据分离，减小表单的宽度"></a>6.尽量做到冷热数据分离，减小表单的宽度</h4><p>MySQL 限制最多存储4096列，并且每一行的大小是不能超过65535个字节的。最好将经常用到的列放到一个表中，这样一来可以减少磁盘 IO，保证热数据的内存缓存命中率。利用更有效的利用缓存，避免读入无用的冷数据。</p><h4 id="7-禁止在表中建立预留字段"><a href="#7-禁止在表中建立预留字段" class="headerlink" title="7.禁止在表中建立预留字段"></a>7.禁止在表中建立预留字段</h4><p>预留字段的命名很难做到见名识义，预留字段无法确认存储的数据类型，所以无法选择合适的类型。对预留字段类型的修改，会对表进行锁定，修改一个字段类型的成本远高于新建一个字段。</p><h4 id="8-禁止在数据库中存储图片，文件等二进制数据"><a href="#8-禁止在数据库中存储图片，文件等二进制数据" class="headerlink" title="8.禁止在数据库中存储图片，文件等二进制数据"></a>8.禁止在数据库中存储图片，文件等二进制数据</h4><p>这类文件都会很大，会在短时间内造成数据量的疯涨，在数据库读取的时会产生大量的 IO 操作，非常好事，影响数据库性能，常规的做法是将图片保存在对应的文件服务器上，然后在数据库中保存地址信息就可以了。</p><h4 id="9-禁止在线上做数据库压力测试"><a href="#9-禁止在线上做数据库压力测试" class="headerlink" title="9.禁止在线上做数据库压力测试"></a>9.禁止在线上做数据库压力测试</h4><p>如果使用生产环境进行压力测试一方面会对正常的业务访问造成影响，另一方面也会对数据库造成影响，产生大量的垃圾数据。</p><h4 id="8-禁止从开发环境，测试环境直接连生产环境数据库"><a href="#8-禁止从开发环境，测试环境直接连生产环境数据库" class="headerlink" title="8.禁止从开发环境，测试环境直接连生产环境数据库"></a>8.禁止从开发环境，测试环境直接连生产环境数据库</h4><p>会对生产环境的数据的完整性进行破坏。</p><h2 id="数据库索引设计规范"><a href="#数据库索引设计规范" class="headerlink" title="数据库索引设计规范"></a>数据库索引设计规范</h2><h3 id="1-限制每张表上的索引数量，建议单标索引不超过5个"><a href="#1-限制每张表上的索引数量，建议单标索引不超过5个" class="headerlink" title="1.限制每张表上的索引数量，建议单标索引不超过5个"></a>1.限制每张表上的索引数量，建议单标索引不超过5个</h3><p>索引数量是和列的数量是成正比的，通常列的数量越多索引的数量也会越多，索引并不是越多越好，索引可以提高效率单同样也可以鉴定效率，索引可以增加查询效率，单同样也会降低插入和更新的效率。</p><p>由于 MySQL 优化器在选择优化查询时，会根据统计信息对每一个可以用到的索引进行评估，以生成出一个最好的执行计划，如果同时有很多索引都可以用于查询，就会增加 MySQL优化器生成优化器的时间，同样机会降低 SQL 查询的性能。</p><p>禁止给表中的每一个列都建立单独的索引。</p><h3 id="2-每一个-Innodb表都必须有一个主键"><a href="#2-每一个-Innodb表都必须有一个主键" class="headerlink" title="2.每一个 Innodb表都必须有一个主键"></a>2.每一个 Innodb表都必须有一个主键</h3><p>Innodb 是一种索引组织表，数据存储的逻辑顺序与索引的顺序是相同的，每一个表上上都会有很多索引，但是存储顺序只有一种，Innodb是按照主键索引进行组织表的。</p><p>如果没有主键，那么 Innodb 会优先以第一非空，唯一索引当做主键，在没有非空唯一所以的情况下，MySQL 会生成一个站位6个字节的主键，这个自动生成的主键性能并不是最好的。</p><p>在表的设计中不要使用更新频繁的列作为主键，不使用多列主键（联合索引），因为 Innodb是一个索引组织表的缘故，如果主键频繁被更新，那么久意味着，数据存储的顺序就会频繁的变动，必然会带来大量的 IO 操作。</p><p>不要使用 UUID，MD5，HASH，字符串列作为主键。因为这类数据无法保证数据的顺序增长，如果后面插入的值比已经存在的值还要小，则为了保证索引的顺序，则会把新的数据插入到前面，这样就会造成所有大于这个值的数据要想后移带来大量的 IO 操作。</p><p>建议使用自增 ID 作为主键。</p><h3 id="3-常见索引列建议"><a href="#3-常见索引列建议" class="headerlink" title="3.常见索引列建议"></a>3.常见索引列建议</h3><p>1.SELECT、UPDATE、DELETE语句的WHERE 从句中的列出现的字段中添加索引<br>2.包含在 ORDER BY、GROUP BY、DISTINCT 中的字段<br>3.多表JOIN的关联列</p><h3 id="4-如何选择索引列的顺序"><a href="#4-如何选择索引列的顺序" class="headerlink" title="4.如何选择索引列的顺序"></a>4.如何选择索引列的顺序</h3><p>在联合索引中索引的使用顺序是由从左到右的顺序来使用的。所以我们需要将区分度最高的列放在联合索引的最左侧，尽量把字段长度小的列房子啊联合索引的最左侧，私用最频繁的列放在联合索引的左侧。</p><p>###避免建立冗余索引和重复索引</p><p>重复索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">primary key(id)、index(id)、unique index(id)</div></pre></td></tr></table></figure></p><p>冗余索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index(a,b,c) 、index(a,b)、index(a)</div></pre></td></tr></table></figure></p><h3 id="5-对于频繁的查询优先考虑使用覆盖索引"><a href="#5-对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="5.对于频繁的查询优先考虑使用覆盖索引"></a>5.对于频繁的查询优先考虑使用覆盖索引</h3><p>覆盖索引：就是包含了所有查询字段的索引</p><p>避免 Innodb 表进行索引的二次查找，</p><h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h2><h3 id="1-优先选择符合存储需要的最小的数据类型"><a href="#1-优先选择符合存储需要的最小的数据类型" class="headerlink" title="1.优先选择符合存储需要的最小的数据类型"></a>1.优先选择符合存储需要的最小的数据类型</h3><ul><li>将字符串转换为数字类型存储</li><li>INET_ATON(‘255.255.255.255’) = 4294967295</li><li>INET_NTOA(4294967295) = ‘255.255.255.255’</li><li>对于非负型的数据来说，要有限选用无符号整型来存储，无符号相对于有符号可以多出一倍的存储空间</li><li>VARCHAR（N）中的 N 代表的是字符数，而不是字节数</li><li>使用 UTF8存储汉字 VARCHAR(255)=765个字节</li><li>过大的长度会消耗更多的内存，因为当数据被载入到内存时为了提高效率是按照所定义的类型长度来申请内存的。</li></ul><h3 id="2-避免使用-Text、BLOG-的数据类型"><a href="#2-避免使用-Text、BLOG-的数据类型" class="headerlink" title="2.避免使用 Text、BLOG 的数据类型"></a>2.避免使用 Text、BLOG 的数据类型</h3><p>Text列分为四种 TinyText、Text、MidumText、LongText，Text 类型可以存储下64K的数据，备注或者说明很少会使用到64K 这么庞大的数据，使用 Varchar 类型就可以了。另外由于MySQL 内存表是不支持 Text 和 Blog 的，因此我们在对这种大数据类型进行排序的时候无法使用内存表，而必须使用磁盘内置表，这类数据MySQL 在读取数据时会进行二次查询，所以会使得 SQL 的性能变的很差。</p><p>建议把 BLOG 或是 TEXT列分离到单独的扩展表中    ，并且在查询时一定不要使用 select * 的方式，而是取出必要的列，在使用 BOLOG 或者 TEXT 类型的时候就不要查询该列。</p><p>TEXT或 BLOG 类型只能使用前缀索引，并且 TEXT 的列上是不能有默认值的。</p><h3 id="3-避免使用-ENUM-数据类型"><a href="#3-避免使用-ENUM-数据类型" class="headerlink" title="3.避免使用 ENUM 数据类型"></a>3.避免使用 ENUM 数据类型</h3><p>枚举类型是一个很特别的类型，在其他关系型数据库中并不存在这一类型，枚举本身是一个字符串类型，但是其本身却是以整数类型，所以能够存储65535种不同的枚举值，前面提到要将字符串类型转换成整数进行存储，从这一点看枚举是一种很好的数据类型，有助于我们很好的进行优化。</p><p>但是枚举类型也存在着很大的缺陷，修改 ENUM 值需要使用 ALTER 语句，频繁的对表结构进行修改很容易造成失误，在修改元数据的时候会生成元数据锁，在大量数据访问的时候会造成数据库系统的阻塞，对枚举数据进行操作的时候是存在一定的操作风险的。</p><p>ENUM 类型的 ORDER BY 操作效率低，需额外操作，由于是按照整型进行存储的，所以在查询的时候会对其进行字符串转化然后在进行排序，这种装换是无法使用索引的，所以枚举值排序性能比较差。</p><p>禁止使用数值作为 ENUM 的枚举值，因为枚举本身是索引顺序存储的，如果枚举值也是用整型进行存储，很容易会造成逻辑上的一种混淆，一般情况下枚举值是整型，通常建议使用整型代替。</p><h3 id="4-尽量可能把所有列定义为-NOT-NULL"><a href="#4-尽量可能把所有列定义为-NOT-NULL" class="headerlink" title="4.尽量可能把所有列定义为 NOT NULL"></a>4.尽量可能把所有列定义为 NOT NULL</h3><p>索引 NULL 列需要额外的空间来保存，所以需要占用更多的空间，索引空间占用的越低越好。</p><p>进行比较和计算时候对 NULL 值做特别的处理，所以可能会造成索引失效。</p><h3 id="5-使用-TIMESTAMP-或DATETIME-类型存储时间"><a href="#5-使用-TIMESTAMP-或DATETIME-类型存储时间" class="headerlink" title="5.使用 TIMESTAMP 或DATETIME 类型存储时间"></a>5.使用 TIMESTAMP 或DATETIME 类型存储时间</h3><p>字符串存储日期型的数据（不正确的做法）</p><p>缺点1：无法用日期函数进行计算和比较。<br>缺点2：用字符串存储日期要占用更多的空间</p><p>TIMESTAMP 1970-01-01 00：00：01 ~ 2038-01-19 03：14：07</p><p>其实 TIMESTAMP 是以 INT 类型存储的，但是以日期格式显示，TIMESTAMP占用4字节和 INT 相同，单比 INT 可读性高，</p><p>当超出 TIMESTAMP 类型的存储范围时我们需要使用 DATETIME 类型来进行存储。</p><h3 id="6-同财务相关的金额类数据，必须使用-decimal-类型"><a href="#6-同财务相关的金额类数据，必须使用-decimal-类型" class="headerlink" title="6.同财务相关的金额类数据，必须使用 decimal 类型"></a>6.同财务相关的金额类数据，必须使用 decimal 类型</h3><p>Decimal 类型为精准浮点数，在计算时不会丢失精度，占用空间油定义的宽度决定，可用于存储比 bigint 更大的整数数据。</p><h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h2><h3 id="1-建议使用预编译语句进行数据库"><a href="#1-建议使用预编译语句进行数据库" class="headerlink" title="1.建议使用预编译语句进行数据库"></a>1.建议使用预编译语句进行数据库</h3><ol><li>只传参数，比传递 SQL 语句更高效</li><li>相同语句可以一次解析，多次使用，提高处理效率</li><li>防范 SQL 注入的风险</li></ol><h3 id="2-避免数据类型的隐式转换"><a href="#2-避免数据类型的隐式转换" class="headerlink" title="2.避免数据类型的隐式转换"></a>2.避免数据类型的隐式转换</h3><p>隐式转换一般发生在 Where 从句中，当列类型和参数类型不一致时就会出现隐式转换。， 隐式转换会导致索引失效</p><h3 id="3-充分利用表上已经存在的索引"><a href="#3-充分利用表上已经存在的索引" class="headerlink" title="3.充分利用表上已经存在的索引"></a>3.充分利用表上已经存在的索引</h3><p>尽量避免用%号的查询 例如 a like ‘%123%’<br> 一个 SQL 只能利用到符合索引中的一列进行范围查询<br> 使用 left join 活 not exists 来优化 not in 操作。</p><h3 id="4-程序链接不同的数据库使用不同的账号，禁止跨库查询。"><a href="#4-程序链接不同的数据库使用不同的账号，禁止跨库查询。" class="headerlink" title="4.程序链接不同的数据库使用不同的账号，禁止跨库查询。"></a>4.程序链接不同的数据库使用不同的账号，禁止跨库查询。</h3><ol><li>为了数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免由于权限过大产生的安全风险</li></ol><h3 id="5-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#5-禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="5.禁止使用 SELECT *必须使用 SELECT&lt;字段列表&gt;查询"></a>5.禁止使用 SELECT *必须使用 SELECT&lt;字段列表&gt;查询</h3><ol><li>消耗更多的 CPU 和 IO 以及网络带宽资源</li><li>无法使用覆盖索引</li><li>可减少表结构变更带来的影响</li></ol><h3 id="6-禁止使用不含字段列表的-insert-语句"><a href="#6-禁止使用不含字段列表的-insert-语句" class="headerlink" title="6.禁止使用不含字段列表的 insert 语句"></a>6.禁止使用不含字段列表的 insert 语句</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insert into t values (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); //不包含字段列表的 insert</div><div class="line">insert into t(c1,c2,c3) values(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); //正确的写</div></pre></td></tr></table></figure><p> 可以减少表结构变更带来的影响</p><h3 id="7-避免使用子查询，可以把子查询优化为join"><a href="#7-避免使用子查询，可以把子查询优化为join" class="headerlink" title="7.避免使用子查询，可以把子查询优化为join"></a>7.避免使用子查询，可以把子查询优化为join</h3><p> 并不是所有的子查询都可以使用 join进行优化，一般情况下只有子查询在 IN 子句中，并且子查询是一个简单的 SQL ，例如其中不包含 order by之类的复杂查询，才可以进行转换。</p><ol><li>子查询的结果集无法使用索引</li><li>子查询会产生临时表操作，如果子查询数据量大则严重影响性能</li><li>临时表会消耗过多 CPU 以及 IO 资源</li></ol><h3 id="8-避免使用-JOIN-关联太多的表"><a href="#8-避免使用-JOIN-关联太多的表" class="headerlink" title="8.避免使用 JOIN 关联太多的表"></a>8.避免使用 JOIN 关联太多的表</h3><ol><li>每Join 一个表会占用一部分内存（join <em> buffer </em> size）</li><li>会产生临时表操作，影响查询效率</li><li>MySQL 最多允许关联61个表，建议不超过五个</li></ol><h3 id="9-减少同数据库的交互次数"><a href="#9-减少同数据库的交互次数" class="headerlink" title="9.减少同数据库的交互次数"></a>9.减少同数据库的交互次数</h3><ol><li>数据库更适合处理批量操作</li><li>合并多个相同的操作到一起，可以提高处理效率</li></ol><h3 id="10-使用-in-代替or"><a href="#10-使用-in-代替or" class="headerlink" title="10.使用 in 代替or"></a>10.使用 in 代替or</h3><ol><li>in 的值不要超过500个</li><li>in 操作可以有效的利用索引</li></ol><h3 id="11-禁止使用-order-by-rand-）进行随机排序"><a href="#11-禁止使用-order-by-rand-）进行随机排序" class="headerlink" title="11.禁止使用 order by rand(）进行随机排序"></a>11.禁止使用 order by rand(）进行随机排序</h3><ol><li>会把表中所有符合条件的数据装载到内存中进行排序</li><li>会消耗大量的 CUP 和 IO 以及内存支援</li><li>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式</li></ol><h3 id="12-WHERE-从句中禁止对列进行函数转换和计算"><a href="#12-WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="12.WHERE 从句中禁止对列进行函数转换和计算"></a>12.WHERE 从句中禁止对列进行函数转换和计算</h3><ol><li>对列进行函数转换或计算会导致无法使用索引</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wehre date(createtime) = &apos;20160901&apos;</div><div class="line">where createtime &gt;= &apos;20160901&apos; and createtime&lt; &apos;20160902&apos;</div></pre></td></tr></table></figure><h3 id="13-有明显不会重复值时使用-UNION-ALL-而不是UNION"><a href="#13-有明显不会重复值时使用-UNION-ALL-而不是UNION" class="headerlink" title="13.有明显不会重复值时使用 UNION ALL 而不是UNION"></a>13.有明显不会重复值时使用 UNION ALL 而不是UNION</h3><ol><li>UNION 会把所有数据放到临时表中然后进行去重操作</li><li>UNION ALL 不会对结果集进行去重操作</li></ol><h3 id="14-拆分复杂的大-SQL-为多个小-SQL"><a href="#14-拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="14.拆分复杂的大 SQL 为多个小 SQL"></a>14.拆分复杂的大 SQL 为多个小 SQL</h3><ol><li>MySQL 一个 SQL 只能使用一个 CPU进行计算</li><li>SQL 拆分后可以进行并行执行来提高处理效率</li></ol><h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h2><h3 id="1-超100万行的批量写操作，需分批多次进行操作"><a href="#1-超100万行的批量写操作，需分批多次进行操作" class="headerlink" title="1.超100万行的批量写操作，需分批多次进行操作"></a>1.超100万行的批量写操作，需分批多次进行操作</h3><ol><li>大批量操作可能会造成严重的主从延迟</li><li>binlog 日志为row 格式时会产生大量的日志</li><li>避免产生大事务操作</li></ol><h3 id="2-对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。"><a href="#2-对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。" class="headerlink" title="2.对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。"></a>2.对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。</h3><p>对于大表使用 pt-online-schema-change 修改表结构，可以避免主从延时、表锁的问题。</p><h3 id="3-禁止为程序使用的账户赋予-super-权限"><a href="#3-禁止为程序使用的账户赋予-super-权限" class="headerlink" title="3.禁止为程序使用的账户赋予 super 权限"></a>3.禁止为程序使用的账户赋予 super 权限</h3><ol><li>当达到最大连接数贤之士，MySQL 允许1个有 super 权限的用户连接</li><li>super 权限只能留给 DBA 处理问题的账户使用</li></ol><h3 id="4-对于程序链接数据库账户，遵循权限最小原则"><a href="#4-对于程序链接数据库账户，遵循权限最小原则" class="headerlink" title="4.对于程序链接数据库账户，遵循权限最小原则"></a>4.对于程序链接数据库账户，遵循权限最小原则</h3><ol><li>程序使用数据库账号只能在一个 DB下使用，不准夸库</li><li>程序使用账号原则上不准有 drop权限</li></ol>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL 设计规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用规约设计模式（Specification）开发整洁的规格校验（PHP 语言描述）</title>
      <link href="/2017/06/01/1/"/>
      <content type="html"><![CDATA[<p>规格校验是使我们在日常的开发过程中中比较常见的一种业务需求，最直观的使用是我们在开发电商类网站时我们会对商品的一些规格进行限定，例如重量大小不能超过 N（kg） 。</p><p>如果是一个刚刚加入业界的程序员，很有可能会编写出大量的<code>if</code>语句来进行解决此类的业务逻辑，这样编码可行吗？</p><p>答案是可以，因为顺利的完成了业务逻辑代码的编写任务，但是却违反了类设计中的<code>开闭原则</code>，而且一看就是没有经过正规的训练，没有对于 OOP 编程有更深的了解。</p><p>那么有没有一种设计模式可以让我们设计出优雅而又整洁的逻辑代码呢，答案是显而易见的，要不然也就不会出现这篇文章，它就是——规模设计模式。</p><p>我们可以利用规约模式来解决这一实际问题，开发出优雅而又健全的业务逻辑代码。</p><p>规约设计模式的主要设计目的就是为了生成业务规则的明确规范，通过<code>isSatisfiedBy</code>方法来检测对象是否符合规范。</p><p>下图是规约模式 UML 类图（不懂的同学推荐去看由谭云杰所编写的《大象：Thinking in UML》）</p><p><img src="http://designpatternsphp.readthedocs.io/zh_CN/latest/_images/uml7.png" alt=""></p><p>即使看不懂 UML 类图也没有关系，编码能力的提高是要根据不断的实践才能有所增长的。当你顺着我的思路打完代码，你就已经可以明白规约设计模式的设计理念以及作用。</p><p>当然我还是要解释一下这个类图所代表的含义。</p><p>既然是规格校验，那么一个规格校验到底包括什么呢？</p><p>一般而言主要有：区间、大于、小于、不等于，这几样，那么我们是不是可以将其抽象成一个类呢？</p><p>这就是上面那张 UML 的简单含义，其中主要是用于描述其类的关系，UML 就是帮助我们对类进行抽象的一个工具。</p><p>下面让我们撸起袖子打代码。首先我们应该新建了 Goods类用于表示被规约的产品，其中包含一个 Price 价格属性，然后在建立对 Price 属性的规约，用来检验最新实例化的 Goods 是否满足约定。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//商品类</span></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> float</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> $price;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(float $price)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;price = $price;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrice</span><span class="params">()</span>: <span class="title">float</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;price;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在建立规约之前，我们需要建立一个接口，这个接口中定了了一个方法<code>isSatisfiedBy</code>,也就是上文提到的那个检测对象是否满足规约条件的那个方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SpecificationInterface</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isSatisfiedBy</span><span class="params">(Goods $goods)</span>: <span class="title">bool</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Ok，在我们编写其余代码之前，我们需要来做一个思考，在程序语言当中，判断条件中的操作符是不是有或、与、非这三个判断条件，对应着 ||、&amp;&amp;、！。</p><p>那么我们是否可以将其抽象成一个又一个的类呢？</p><p>OrSpecification规约用来表示 Or 的关系，与我们的逻辑判断一样，表示在两个规约之间只要满足一条便返回 true。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrSpecification</span> <span class="keyword">implements</span> <span class="title">SpecificationInterface</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> SpecificationInterface[]</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> $specifications;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> SpecificationInterface[] ...$specifications</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(SpecificationInterface ...$specifications)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;specifications = $specifications;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * if at least one specification is true, return true, else return false</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isSatisfiedBy</span><span class="params">(Item $item)</span>: <span class="title">bool</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;specifications <span class="keyword">as</span> $specification) &#123;</div><div class="line">            <span class="keyword">if</span> ($specification-&gt;isSatisfiedBy($item)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>AndSpecification 用于表示 And 关系，两条以上规约时，必须都满足条件才会返回 true否则返回false.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndSpecification</span> <span class="keyword">implements</span> <span class="title">SpecificationInterface</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> SpecificationInterface[]</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> $specifications;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> SpecificationInterface[] ...$specifications</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(SpecificationInterface ...$specifications)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;specifications = $specifications;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * if at least one specification is false, return false, else return true.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isSatisfiedBy</span><span class="params">(Item $item)</span>: <span class="title">bool</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;specifications <span class="keyword">as</span> $specification) &#123;</div><div class="line">            <span class="keyword">if</span> (!$specification-&gt;isSatisfiedBy($item)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>NotSpecification.php 用于表示Not。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotSpecification</span> <span class="keyword">implements</span> <span class="title">SpecificationInterface</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> SpecificationInterface</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> $specification;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(SpecificationInterface $specification)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;specification = $specification;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isSatisfiedBy</span><span class="params">(Item $item)</span>: <span class="title">bool</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;specification-&gt;isSatisfiedBy($item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>逻辑判断抽编码好了之后，我们就要开始真正的规约了，我们建立一个 Price 规约，其中主要设定了 Price 的范围，构造函数中包含最大值与最小值，并且实现<code>isSatisfiedBy</code>用来判断输入的值是否符合范围。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceSpecification</span> <span class="keyword">implements</span> <span class="title">SpecificationInterface</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> float|null</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> $maxPrice;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> float|null</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> $minPrice;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> float $minPrice</div><div class="line">     * <span class="doctag">@param</span> float $maxPrice</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($minPrice, $maxPrice)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;minPrice = $minPrice;</div><div class="line">        <span class="keyword">$this</span>-&gt;maxPrice = $maxPrice;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isSatisfiedBy</span><span class="params">(Item $item)</span>: <span class="title">bool</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;maxPrice !== <span class="keyword">null</span> &amp;&amp; $item-&gt;getPrice() &gt; <span class="keyword">$this</span>-&gt;maxPrice) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;minPrice !== <span class="keyword">null</span> &amp;&amp; $item-&gt;getPrice() &lt; <span class="keyword">$this</span>-&gt;minPrice) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面我们进行单元测试，如果不懂单元测试的朋友，也可以直接使用上面的代码进行测试。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>\<span class="title">Tests</span>;</div><div class="line"></div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>\<span class="title">Item</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>\<span class="title">NotSpecification</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>\<span class="title">OrSpecification</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>\<span class="title">AndSpecification</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Behavioral</span>\<span class="title">Specification</span>\<span class="title">PriceSpecification</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecificationTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanOr</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $spec1 = <span class="keyword">new</span> PriceSpecification(<span class="number">50</span>, <span class="number">99</span>);</div><div class="line">        $spec2 = <span class="keyword">new</span> PriceSpecification(<span class="number">101</span>, <span class="number">200</span>);</div><div class="line"></div><div class="line">        $orSpec = <span class="keyword">new</span> OrSpecification($spec1, $spec2);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertFalse($orSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">100</span>)));</div><div class="line">        <span class="keyword">$this</span>-&gt;assertTrue($orSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">51</span>)));</div><div class="line">        <span class="keyword">$this</span>-&gt;assertTrue($orSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">150</span>)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanAnd</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $spec1 = <span class="keyword">new</span> PriceSpecification(<span class="number">50</span>, <span class="number">100</span>);</div><div class="line">        $spec2 = <span class="keyword">new</span> PriceSpecification(<span class="number">80</span>, <span class="number">200</span>);</div><div class="line"></div><div class="line">        $andSpec = <span class="keyword">new</span> AndSpecification($spec1, $spec2);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">150</span>)));</div><div class="line">        <span class="keyword">$this</span>-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">1</span>)));</div><div class="line">        <span class="keyword">$this</span>-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">51</span>)));</div><div class="line">        <span class="keyword">$this</span>-&gt;assertTrue($andSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">100</span>)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanNot</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $spec1 = <span class="keyword">new</span> PriceSpecification(<span class="number">50</span>, <span class="number">100</span>);</div><div class="line">        $notSpec = <span class="keyword">new</span> NotSpecification($spec1);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertTrue($notSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">150</span>)));</div><div class="line">        <span class="keyword">$this</span>-&gt;assertFalse($notSpec-&gt;isSatisfiedBy(<span class="keyword">new</span> Item(<span class="number">50</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来，我们就设计出了优雅而又健壮的代码。</p><p>说明：</p><p>本文章代码，来自于 Github 开源项目，点击链接进入查看<a href="http://designpatternsphp.readthedocs.io/" target="_blank" rel="noopener">http://designpatternsphp.readthedocs.io/</a></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/03/16/cjek1d3kw004hrhrdokqk9d1i/"/>
      <content type="html"><![CDATA[<h1 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 - Singleton"></a>单例模式 - Singleton</h1><p>单例模式确保每一个指定的类只存在一个实例对象，并且可以全局访问那个实例。一般情况下会用延时加载的策略，指在第一次需要使用的时候初始化。</p><blockquote><p>设计模式并不局限于某一个语言，他是一种编程思维</p></blockquote><p>在 iOS 开发中单例模式h很常见，NSUserDefaults.standardUserDefaults()等等。</p><p>如果多于一个实例又会怎么样呢？代码和内存还没精贵到这个地步吧？</p><p>某些场景下，保持实例对象仅有一份是很有意义的。举个例子，你的应用实例 (UIApplication)，应该只有一个吧，显然是指你的当前应用。还有一个例子：设备的屏幕 (UIScreen) 实例也是这样，所以对于这些类的情况，你只想要一个实例对象。</p><p>单例模式的应用还有另一种情况：你需要一个全局类来处理配置文件。我们很容易通过单例模式实现线程安全的实例访问，而如果有多个类可以同时访问配置文件，那可就复杂多了。</p><h1 id="使用单例模式"><a href="#使用单例模式" class="headerlink" title="使用单例模式"></a>使用单例模式</h1><p><img src="https://swift-design-patterns.books.yourtion.com/images/singleton1.png" alt=""></p><p>这是一个日志类，有一个属性（是以单例对象）和两个方法（sharedInstance()和 init()）。</p><p>第一吊用 sharedInstance()的时候，instance 属性还没有初始化，所以我们必须创建一个新的实例并且返回。</p><p>下一次再调用 sharedInstance()的时候，instance 已经完成了初始化，直接返回即可，这个逻辑就确保了只有一个实例对象。</p><p>接下来我们继续完善单例模式，通过这个类来管理专辑数据。</p><p>注意到在我们前面的截图里，分组中有个 API 分组，这里可以放那些提供后台服务的类。在这个分组中创建一个新的文件 LibraryAPI.swift ，继承自 NSObject 类。</p><p>在 LibraryAPI 里添加下面这段代码：</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/03/16/cjek1d3kz004lrhrdi9qrt1u2/"/>
      <content type="html"><![CDATA[<hr><p>title:iOS图层树<br>categories:iOS<br>date:2015-12-21</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><h1 id="图层树"><a href="#图层树" class="headerlink" title="图层树"></a>图层树</h1><p>Core Animation 是一个符合引擎，塔的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分分解成独立的图层，存储在一个叫做图层数的体系中，于是这个树形成了 UIKit 以及在 iOS 10应用程序当中你所看能在屏幕上看见的一切的基础。</p><h2 id="图层与视图"><a href="#图层与视图" class="headerlink" title="图层与视图"></a>图层与视图</h2><p>如果你曾经在 iOS 10或MacOS 平台上面写过应用程序，你可能能会对视图的概念比较熟悉。一个视图就是在屏幕上显示一个矩形块（比如图片，文字或者视频），它能拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系。</p><p><img src="https://zsisme.gitbooks.io/ios-/content/chapter1/1.1.jpeg" alt=""></p><p>图1.1一种典型的 iOS 屏幕（左边）和型城市图的层级关系（右边）</p><p>在 iOS 中，所有的视图都从一个叫做 UIview 的基类派生而来，UIView 可以处理触摸事件，可以支持基于 Core Graphics 绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><p>CALayer类在概念上和 UIView 类似，同样也是一些被层级关系树管理的矩形块，同样可以包含一些内容（像图片，文本或者背景色），管理子视图的位置。它们有一些方法和尚需经用来做动画和变换。</p><p>和 UIview 最大的不同是 CALayer 不处理用户的交互。</p><p>CALayer 兵不清楚具体的响应链（iOS通过视图层级关系用来传递触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触电在图层的范围之内。</p><h2 id="平行的层级关系"><a href="#平行的层级关系" class="headerlink" title="平行的层级关系"></a>平行的层级关系</h2><p>每一个 UIView 都有一个 CALayer 实例的图层属性，也就是所谓的 Backing layer,视图的职责就是创建并管理这个图层，以确保子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应是在层级关系树当中有相同的操作（见图1.2）</p><p><img src="https://zsisme.gitbooks.io/ios-/content/chapter1/1.2.jpeg" alt=""></p><p>图1.2 图层的树状结构（左边）以及对应的视图层级（右边）</p><p>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView 仅仅是对它的一个封装，提供了一些 iOS 类似于处理触摸事件的具体功能，以及 Core Animation 底层方法的高级借口。</p><p>但是为什么 iOS 要基于 UIview 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这也是能避免很多重复代码。在 iOS 和 Mac OS两个平台上，时间和用户交互有很多地方不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么 iOS有 UIKit 和 UIView，但是 MacOS 有 APPKit 和 NSView 的元婴。他们功能上很类似，但是在实现上有着显著的区别。</p><p>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。+</p><p>实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>PHP Closures</title>
      <link href="/2017/03/15/1/"/>
      <content type="html"><![CDATA[<p>闭包函数（closures）也就做匿名函数（Anonymous functions），是指在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。</p><blockquote><p>理论上，闭包和匿名函数是不同的概念，不过 PHP 将其视作相同的概念，所以闭包与匿名函数相等。</p></blockquote><p>匿名函数其实就是没有名字的函数。匿名函数可以赋值给变量，还能像其他任何 PHP 对象那样传递。不过匿名函数仍然是函数，因此可以调用，还可以传入参数。匿名函数特别适合作为函数或方法的回调。</p><h3 id="创建闭包"><a href="#创建闭包" class="headerlink" title="创建闭包"></a>创建闭包</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$closure = <span class="function"><span class="keyword">function</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sprintf(<span class="string">'Hello %s'</span>, $name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">echo</span> $closure(<span class="string">'Maksim'</span>);</div><div class="line"><span class="comment">//输出 Hello Maksim</span></div></pre></td></tr></table></figure><p>创建一个闭包对象，然后将其复制给<code>$closure</code> 变量。闭包和普通的 PHP 函数很想：使用语句相同，也接受参数，而且能返回值。不过，匿名函数没有名称。</p><p>我们通常把 PHP 闭包当做函数和方法的回调使用。很多 PHP 函数都会用到回调函数，例如 <code>array_map()</code>和 <code>preg_replace_callback()</code>。这是使用 PHP 匿名函数的最佳时机！</p><p>记住，闭包和其他值一样，可以作为参数传入其他 PHP 函数，我们把一个闭包对象当做回调参数，传给 array_map()函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$numbersPlusOne = array_map(<span class="function"><span class="keyword">function</span> <span class="params">($number)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> $number + <span class="number">1</span>;</div><div class="line">&#125;,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line">print_r($numbersPlusOne);</div><div class="line"><span class="comment">//([0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4)</span></div></pre></td></tr></table></figure><p>在闭包出现之前，PHP 开发者只能单独创建普通函数，然后使用名称引用那个函数，这么做，代码执行的稍微慢一点，而且把回调场景和使用场景分割开了，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$numbersPlusOne = array_map(<span class="string">'incrementNumber'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span><span class="params">($number)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> $number + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">print_r($numbersPlusOne);</div><div class="line"><span class="comment">//([0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4)</span></div></pre></td></tr></table></figure><p>这样的代码虽然可用，但是没有使用闭包来的间接。如果只需要使用一次回调，没有必要单独定义具名函数。把闭包当做回调使用，写出的代码更加简洁、清晰。</p><h3 id="使用附加状态"><a href="#使用附加状态" class="headerlink" title="使用附加状态"></a>使用附加状态</h3><p>前面演示了如何把匿名函数当做回调使用，下面探讨如何为 PHP 闭包附加兵封装状态。JavaScript 开发者可能对 PHP 的闭包感到奇怪，因为 PHP 闭包不会像真正的 JavaScript 闭包那样自动封装应用状态。在 PHP 中，必须手动调用闭包对象的 bindTo()方法或者使用 use 关键字，把状态附加到 PHP 闭包上。</p><p>使用 use 关键字附加闭包状态常见得多，因此我们先看这种方式。使用 use 关键字把变量附加到闭包上时，附加的变量会记住附加时赋给它的值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enclosePerson</span><span class="params">($name)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($doCommand)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sprintf(<span class="string">'%s, %s'</span>, $name, $doCommand);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//把字符串“Maksim”封装在闭包中</span></div><div class="line">$clay = enclosePerson(<span class="string">'Clay'</span>);</div><div class="line"></div><div class="line"><span class="comment">//掺入参数，调用闭包</span></div><div class="line"><span class="keyword">echo</span> $clay(<span class="string">'get sweet tea'</span>);</div><div class="line"><span class="comment">// Clay, get sweet tea</span></div></pre></td></tr></table></figure><blockquote><p>使用 use 关键字可以把多个参数传入闭包，此时要像 PHP 函数或者方法的参数一样，使用逗号分割多个参数</p></blockquote><p>PHP 闭包是对象。与其他 PHP 对象类似，每个闭包实例都可以使用$this 关键字获取闭包的内部状态。闭包对象的默认状态没什么用，不过有一个__invoke()魔术方法和 bindTo()方法，仅此而已。</p><p>但是，bindTo()方法为闭包增加了一些有趣的潜力。我们可以把使用这个方法把 Closure 对象的内部状态绑定到其他对象上。bindTo()方法的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的 PHP 类。因此闭包可以访问绑定闭包的对象中受保护和私有的成员变量。</p><p>你会发现，PHP 框架经常使用 bindTo()方法把路由 URL 映射到匿名回调函数上。框架会把匿名函数绑定到应用对象上，这么做可以把这个匿名函数中使用$this 关键字引用重要的应用对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">protected</span> $routes = <span class="keyword">array</span>();</div><div class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">'200 Ok'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseContentType = <span class="string">'text/html'</span>;</div><div class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">'Hello world'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span> </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>,<span class="keyword">__CLASS__</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callback) &#123;</div><div class="line">            <span class="keyword">if</span> ($currentPath === $currentPath) &#123;</div><div class="line">                $callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        header(<span class="string">'HTTP/1.1 '</span>. <span class="keyword">$this</span>-&gt;responseStatus);</div><div class="line">        header(<span class="string">'Content-type: '</span> . <span class="keyword">$this</span>-&gt;responseContentType);</div><div class="line">        header(<span class="string">'Content-length: '</span> . mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 我们要特别注意 addRoute（）方法。这个方法的参数分别是一个路由路径（例如/users/josh）和一个路由回调。dispatch()方法的参数是当前 HTTP 请求的路径，它调用匹配的路由回调。第10行是重点所在，我们把路由回调绑定到了当前 APP 实例上。这么做能够在回调函数中处理 APP 实例的状态。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$app =  <span class="keyword">new</span> App();</div><div class="line">$app-&gt;addRoute(<span class="string">'/users/josh'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</div><div class="line">    <span class="keyword">$this</span>-&gt;responseBody = <span class="string">'&#123;"name":"json"&#125;'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$app-&gt;dispatch(<span class="string">'/users/josh'</span>);</div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>现代 PHP</li><li>官方手册</li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Closures </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/03/14/cjek1d3jh002crhrdwv24oiv2/"/>
      <content type="html"><![CDATA[<h2 id="RESTFul-是什么？"><a href="#RESTFul-是什么？" class="headerlink" title="RESTFul 是什么？"></a>RESTFul 是什么？</h2><p>RESTful的本质是一种软件架构风格，核心是面向资源，主要用来解决降低开发的复杂性，提高系统的可伸缩性。随着互联网的发展，各种终端层出不穷，手机浏览器，手机 APP 为了节约成本，我们可以使用 RESTful 架构，只需要封装好一套完善的API就可以为多套终端提供服务。</p><p>设计概念和准则</p><ul><li>网络上所有事物都可以被抽象为资源</li><li>每一个资源都有唯一的标识符，对资源的操作不会改变这些标识</li><li>所有的操作都是无状态的</li></ul><p>所谓的资源就是网络上的一个实体，或者说是网络上一个具体的信息。</p><p>HTTP 协议 - URL</p><p>HTTP 是一个属于应用层的协议，特点是简捷、快速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">schema://host[:port]/path[?query-string][#anchor]</div></pre></td></tr></table></figure><ul><li>schema 指定底层使用的协议（如：http,https）</li><li>host   服务器的 IP 地址或者域名</li><li>port 服务器端口</li><li>path 访问资源的路径</li><li>query-string 发送给 http 服务器的数据</li><li>anchor     锚</li></ul><p>HTTP</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2017/03/14/cjek1d3kr0047rhrdusu4nrf9/"/>
      <content type="html"><![CDATA[<h1 id="光源色、物体色、固有色"><a href="#光源色、物体色、固有色" class="headerlink" title="光源色、物体色、固有色"></a>光源色、物体色、固有色</h1><h2 id="什么是光源色"><a href="#什么是光源色" class="headerlink" title="什么是光源色"></a>什么是光源色</h2><p>光源色指的是发光体所发出光线的颜色。例如，阳光、月光、火光和各种灯光等的光色。光源色的不同会引起物体的固有颜色的变化。例如，一块红布在白天看起来和在晚上灯光下看起来颜色是有所不同的。许多女同志都懂得这一点，她们避免晚上去商店购买衣料，因为晚上灯光下看到的黄色，和白天看到的是有些不一样的。就是同样的眼光来说，在早晨、正午和傍晚其光色也是不相同的，会引起同一景物的色调的显著变化。</p><p>物体在不同颜色的光照下会呈现出跟光颜色比较接近的色彩，这些都是收到光源色彩的影响。</p><h2 id="什么是物体色"><a href="#什么是物体色" class="headerlink" title="什么是物体色"></a>什么是物体色</h2><p>物体色是指光源色经过物体有选择的吸收和反射，反映到人的视觉中的光色感觉。物体本身并不会发光，但都具有对各种波长的光有所选择性的吸收、反射或者投射的特性，因此形成千变万化的不相同的物体色彩。</p><p>物体可以分为透明物体和不透明物体，不透明物体呈现的色彩是由它反射的光色决定的，而透明物体呈现的色彩则是由它透过的色彩决定的。</p><p>如绿色树叶吸收太阳光除绿色光的其他色光，所以我们看到的是绿色，而蓝色玻璃只透过蓝色光吸收其他光所以看起来呈现的是蓝色。</p><h2 id="什么是固有色"><a href="#什么是固有色" class="headerlink" title="什么是固有色"></a>什么是固有色</h2><p>固有色指的是一个物体在通常情况下给人的色彩印象（概念）例如，红旗是红色的，草地是绿色的，中国人的皮肤是黄色的等等。</p><p>从色彩的光学原理知道物体并不存在固定不变的固有颜色，物体的颜色是与光密切相关的，是在一定的条件下变化的，是具体的，而不是一种概念。讲中国人皮肤是黄色的，其实不可能指出是哪一种具体的光色。然而，物体的颜色景观是变化的、复杂的，单扔给我们一定的色彩印象。所以我们既不要受固有色概念的束缚，又不能完全故事固有色。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>色彩基础</title>
      <link href="/2017/03/11/cjek1d3ln005wrhrdofnxdioe/"/>
      <content type="html"><![CDATA[<h1 id="色彩的基本构成和使用方法"><a href="#色彩的基本构成和使用方法" class="headerlink" title="色彩的基本构成和使用方法"></a>色彩的基本构成和使用方法</h1><ol><li>色彩的定义是什么</li><li>色彩的种类</li><li>色彩3大特点</li></ol><h2 id="色彩的定义是什么"><a href="#色彩的定义是什么" class="headerlink" title="色彩的定义是什么"></a>色彩的定义是什么</h2><p>我们平时看到的所有东西都会有自己的色彩，有难以感觉到的灰暗，也有鲜艳耀眼的成色等，其实色彩是依赖于光存在的，没有光就不会有色彩，色彩是物体对光谱的反射给人眼传达的一种视觉信息。</p><p>我们可以把颜色通过可见光的波长来划分，这有点跟 PS 软件上面的取色板上的色彩排列相似（如下图）。</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=423413218,2703533471&amp;fm=116&amp;gp=0.jpg" alt="image"></p><p>光其实也是电磁波的一种，我们知道电磁波的传播速度是一样的，而决定我们看到颜色光的色彩的就是电磁波的波长，我们可以从图中看到不同颜色对应的波长范围，如红色光的波长在760纳米之间，蓝色光的波长范围在380纳米之间，所以可见光的范围在380-760之间（如下图）。</p><p><img src="http://p1.bpimg.com/4851/967f41bc84c70788.jpg" alt="image"></p><h2 id="色彩种类划分"><a href="#色彩种类划分" class="headerlink" title="色彩种类划分"></a>色彩种类划分</h2><p>我们可以看到的可见光的范围是380-760纳米波长之间的光谱，通过三棱镜折射出太阳光我们可以看到红橙光绿青蓝紫7中颜色，而实际上我们可以把颜色归类成红黄蓝三追踪原色，这3种颜色可以通过组合搭配调配处其他任意颜色。</p><p>色光三颜色 ： 红黄蓝 RGB（PS 案例）<br>物体三颜色： 红蓝黄（水彩绘画）</p><h2 id="色彩的三要素"><a href="#色彩的三要素" class="headerlink" title="色彩的三要素"></a>色彩的三要素</h2><ol><li>色相</li><li>明度</li><li>纯度（饱和度）</li></ol><h3 id="色相"><a href="#色相" class="headerlink" title="色相"></a>色相</h3><p>色相其实就是指色彩，物体所呈现的颜色状态叫做色相，如红旗的颜色就是红色，天空的颜色是蓝色，荷叶的颜色是绿色，我们可以很简单的识别一种物体的色相。</p><p>在 RGB 色彩模式中，色彩用红，绿，蓝三种色彩来合成表现的，每种色彩分成255个阶，通过不同的比例调配出千变万化的色彩。</p><h3 id="明度"><a href="#明度" class="headerlink" title="明度"></a>明度</h3><p>明度是指色彩的明暗程度，也称深浅度，是表现颜色层次感的基础。</p><p>我们知道色彩的表现是以光反射的形式表现的，比如同一个橙子的颜色是橙色的，但是在明度上的变化让我们可以看出这个橙子的立体感(如下图)。</p><p><img src="http://p1.bqimg.com/4851/87c2f84e88619477.jpg" alt=""></p><p>在无彩色系中，白色明度最高，黑色明度最低，在黑白之间存在一系列灰色，靠近白色的部分称之为名灰色，靠近黑色的部分称之为暗灰色。在有色系中，黄色明度最高，紫色明度最低。任何一个有色彩，当它掺入白色时，明度提高，当掺入黑色时，明度降低。同时其混度也响应降低。</p><p>在 RGB 色彩模式中，RGB 色彩3个数值相加越大就代表色彩明度越高，我们可以简单理解为月亮的颜色明度越高，就比如R：255是红色，那么 R255，G：50，B：50就是加了亮度的红色，会显得亮而且轻(如图)。</p><p><img src="http://p1.bqimg.com/4851/16411dd0ff23090b.jpg" alt=""></p><h3 id="纯度（饱和度）"><a href="#纯度（饱和度）" class="headerlink" title="纯度（饱和度）"></a>纯度（饱和度）</h3><p>纯度通常是指色彩的鲜艳程度。从科学的角度看，一种颜色的鲜艳度取决于这一色相发射光的单一程度，也就是指原色在色彩中所占的百分比。人眼能识别的有单色光特征的颜色，都具有一定的鲜艳度。不同色相不仅明度不同，纯度也不相同。</p><p><img src="http://p1.bpimg.com/4851/4982b8808e9be06d.jpg" alt=""></p><p>通常纯色的纯度最高，也就是不加入黑白灰的颜色，同一色相的色彩，不掺杂白色或者黑色，则被称为纯色。在纯色中加入不同明度的无彩色，会出现不同的纯度。以蓝色为例，向纯蓝色中加入一点白色，纯度下降而明度上升，变为淡蓝色。继续加入白色的量，颜色会越来越淡，纯度下降，而明度持续上升。反之，加入黑色或灰色，则相应的纯度和明度同时下降。</p>]]></content>
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 色彩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 Vagrant 统一公司内开发环境</title>
      <link href="/2016/12/13/cjek1d3ki003vrhrdy5k0ya6r/"/>
      <content type="html"><![CDATA[<p><strong>Vagrant 是什么?</strong></p><p>简单地说，Vagrant让我们可以通过代码的方式快速地、可重复地创建针对不同虚拟环境的虚拟机，包括Virtualbox、AWS、Docker等。它使得我们可以一次性地、自动创建多个环境相同的虚拟机，对于软件开发和测试尤其有用。本文我们将以Virtualbox为例，看看Vagrant的基本使用。</p><p><strong>Vagrantd的作用?</strong></p><ul><li>统一开发环境。一次配置打包，统一分发给团队成员，统一团队开发环境，解决诸如“编码问题”，“缺少模块”，“配置文件不同”带来的问题；</li><li>避免重复搭建开发环境。新员工加入，不用浪费时间搭建开发环境，快速加入开发，减少时间成本的浪费；</li><li>多个相互隔离开发环境。可以在不用box里跑不同的语言，或者编译安装同一语言不同版本，搭建多个相互隔离的开发环境，卸载清除时也很快捷轻松。</li></ul><p><strong>Vagrant 适用范围</strong></p><ul><li>开发环境</li><li><p>项目配置比较复杂</p><p><strong>官网：</strong><a href="https://www.vagrantup.com/" target="_blank" rel="noopener">https://www.vagrantup.com/</a></p><p>vagrant与 VirtualBox的版本需要注意匹配，在官网有详细介绍，如果版本不匹配会出现一些错误。</p></li></ul><p><strong>常用命令</strong></p><ul><li>vagrant box list 查看目前已有的box</li><li>vagrant box add 新增加一个box</li><li>vagrant box remove 删除指定box</li><li>vagrant init 初始化</li><li>vagrant up 启动虚拟机</li><li>vagrant ssh SSH 登陆虚拟机</li><li>vagrant suspend 挂起虚拟机</li><li>vagrant reload 重启虚拟机</li><li>vagrant halt 关闭虚拟机</li><li>vagrant status 查看虚拟机运行状态</li><li>vagrant destroy 销毁当前虚拟机</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用策略模式敲开设计模式的大门(PHP语言描述)</title>
      <link href="/2016/09/23/108/"/>
      <content type="html"><![CDATA[<blockquote><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>本系列文章不会直接上代码直接进行解释，我一直认为带着问题来学习是效率最高的学习方式。</p></li><li><p>本系列文章不会有演示截图，你为什么不敲一遍加深印象呢，另外说不定我的代码有错。</p></li><li><p>我所写的文章只是我对于编程的理解，如果有错误希望能够得到指正以免误人子弟。</p></li></ul><h2 id="怎么样才可以进行设计模式的学习"><a href="#怎么样才可以进行设计模式的学习" class="headerlink" title="怎么样才可以进行设计模式的学习"></a>怎么样才可以进行设计模式的学习</h2><p>步子迈大了容易扯到蛋，如果在没有熟悉 OOP 编程思想前就开始学习设计模式，我感觉会有两种可能，不是“扯蛋”，就是“拉跨”。</p><p><img src="http://wanzao2.b0.upaiyun.com/system/pictures/17809564/original/5a08021694a003ca.gif" alt=""></p><p>当然上面的话是一句玩笑话，学习设计模式可以有效的提高我们的代码质量与深入的理解 OOP 编程理念，如但是果在没有扎实的功底（至少要要理解了抽象、接口、多态）前就开始学习设计模式会越学越难，脑子越来越浑，那就真变成了从入门到放弃了，因为你的思维还没有真正的走进 OOP(单身狗表示完全无法面向对象^_^)。</p><p>对于设计模式的不理解我感觉主要分为两种，一种是不知道怎么实现的，原因就是如上所述，另外一种是不知道为什么要这么用的，其实没有必要纠结于为什么这么用，这么用了有啥作用，设计模式不过是与算法一样只是为了实现某个特定环境下可以使用的一种更好的选择。</p><p>更好一点的例子就是当我们对一些数据进行排序的时候，我们首先想到就是那几个排序算法一样，当我们打着打着代码突然灵光一闪，好像这个地方用这个设计模式写起来会轻松一点。</p><p>当碰到不懂得地方，思考一下，想不通，就出去走走，把这个东西放下来，反正就算看到第二天凌晨也也是无用的，当真正遇到问题的时候，灵光一闪这个东西可以这么写，然后去实践，这就是我的学习之道。还有就是尽量去学实例，而不是去死扣概念，当你真正用起来了，你也就差不多懂了，算法与数据结构亦是如此。</p><p>本系列文章尽量以推导的形式来进行书写，而不是以现成的代码来进行讲解，让读者知道设计模式是怎么来的也就是如何演化出来的，希望各位能够喜欢。<strong>另外本系列的文章并不会提供运行界面的截图，如果想看看结果是否正确，为什么不自己试试呢？</strong></p><h2 id="设计模式尝鲜（策略模式）"><a href="#设计模式尝鲜（策略模式）" class="headerlink" title="设计模式尝鲜（策略模式）"></a>设计模式尝鲜（策略模式）</h2><p>开头引用的话来自于百度百科，我相信很多刚刚开始接触编程的人都会犯晕，因为所有人都不喜欢被学术化的文字，我们以设计模式中较为常用的策略模式来进行演示，当我们编写一个广告模块的时候，公司给的要求是根据访问者的性别来进行显示广告以提高转化率，那我们应该怎么写呢？</p><p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1474639306&amp;di=8cd977b3c8e7d09c8a22672b95423266&amp;src=http://img01.taopic.com/151015/234716-15101509225378.jpg" alt=""></p><p>首先我们想到的是在每一个广告位上面都使用 if 判断来判断访客的性别，这样就能够解决这样的需求，那么我们的每一个广告代码的代码块可能是这个样子的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">判断 男 <span class="keyword">or</span> 女&#123;</div><div class="line">如果是男的就是男人的广告</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">显示女人的广告</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>既然伪代码想好了，那么我们就可以着手进行开发了，然后我们在 if 代码块中添加各自的家在广告代码，于是就变成了下面的样子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ($_GET[<span class="string">'sex'</span>] == <span class="string">'man'</span>) &#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">'外星人大减价现在购买立即送电竞瑞文皮肤'</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">'卡西欧美颜相机不要钱免费送！'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是这是属于一种硬编码的编程方式，一旦我们增加了某种需求，要求其年龄大于23岁显示什么样的广告，那么我们就不得不在每一个 if 判断处再加上新的判断条件，这样的设计就是不合理的，为了提高可读性与可维护性，我们会考虑建立两个不同的类来对两个广告类来对其进行管理。于是代码变成了下面的样子。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.php</span></div><div class="line"><span class="keyword">include</span> <span class="string">'GenderAD.php'</span>;</div><div class="line"><span class="keyword">include</span> <span class="string">'ManAD.php'</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ($_GET[<span class="string">'sex'</span>] == <span class="string">'man'</span>) &#123;</div><div class="line">$ad = <span class="keyword">new</span> ManAD();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">$ad = <span class="keyword">new</span> GenderAD();</div><div class="line">&#125;</div><div class="line">$ad-&gt;show();</div><div class="line"></div><div class="line"><span class="comment">//GenderAD.php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenderAD</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span> algorithm()&#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">'卡西欧美颜相机不要钱免费送！'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ManAD.php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManAD</span></span>&#123;</div><div class="line"><span class="keyword">public</span> algorithm()&#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">'外星人大减价现在购买立即送电竞瑞文皮肤'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>algorithm    英[ˈælgərɪðəm] 美[ˈælɡəˌrɪðəm] n.    演算法; 运算法则; 计算程序;</p></blockquote><p>其实到了这一步就已经算是一个简单的策略模式了，因为他已经具有策略的特质了，只不过还不够完善，如果说这不算什么的话我也没有办法，因为所有的设计模式其实都是思维模式与表现形式罢了，就像上面的引用中提到的一样，设计模式只不过是为了能够让代码可以重用，更容易他让人理解，因为你的代码并不是你一个人在维护，那么问题来了，只是简单的对其进行封装真的就提高代码的可维护性了么，其实并没有，我们还没有将 OOP 的设计概念发挥到极致。</p><p>经过分析我们发现其实 ManAD类和 GenderAD最终都要进行显示，他们的方法的显示方法都是 show，如果是你一个人在开发那么没有什么问题，可是若是两个人开发呢，你们可以直接可以对话的方式进行沟通，协定好都是 show方法来显示，可是为什么不用更工程化的方式来实现呢？</p><p>我们可以使用接口来实现这一目的，如果对接口还不了解，可以去查阅一下资料，很快你就能够明白，在本文结束后我会在下方标注出参考范例。</p><p>我们可以新建一个接口来对这些策略进行控制。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ADinterface</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">algorithm</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManAD</span> <span class="keyword">implements</span> <span class="title">ADInterface</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">algorithm</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">'外星人大减价现在购买立即送电竞瑞文皮肤'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenderAD</span> <span class="keyword">implements</span> <span class="title">ADInterface</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">algorithm</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">'卡西欧美颜相机不要钱免费送！'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来广告策略必须遵循这个接口进行开发，就保证了所有策略类都需要实现 show 方法。</p><p>到目前为止，策略模式已经相对的完善了，但是还是不够完美，因为代码依旧并不是很 OOP，我们其实还可以更进一步，让他更 OOP，我们可以对那些策略外面套一个壳子，给外面一个选择器。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategySelect</span> </span>&#123;</div><div class="line"><span class="comment">//具体策略对象</span></div><div class="line">    <span class="keyword">private</span> $strategyInstance;</div><div class="line">    </div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($instance)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;strategyInstance = $instance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">algorithm</span><span class="params">($strategy)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;strategyInstance-&gt;algorithm();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们通过构造函数接收到具体的执行策略，然后使用algorithm()执行相对应的策略。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ADinterface</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">algorithm</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategySelect</span> </span>&#123;</div><div class="line"><span class="comment">//具体策略对象</span></div><div class="line">    <span class="keyword">private</span> $strategyInstance;</div><div class="line">    </div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($instance)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;strategyInstance = $instance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">algorithm</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;strategyInstance-&gt;algorithm();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManAD</span> <span class="keyword">implements</span> <span class="title">ADInterface</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">algorithm</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">'外星人大减价现在购买立即送电竞瑞文皮肤'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenderAD</span> <span class="keyword">implements</span> <span class="title">ADInterface</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">algorithm</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">'卡西欧相机免费赠送啦'</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">header(<span class="string">"Content-type:text/html;charset=utf-8"</span>);</div><div class="line"><span class="keyword">if</span> ($_GET[<span class="string">'sex'</span>] == <span class="string">'man'</span>) &#123;</div><div class="line">$stratey = <span class="keyword">new</span> StrategySelect(<span class="keyword">new</span> ManAD());</div><div class="line">$stratey-&gt;algorithm();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">$stratey = <span class="keyword">new</span> StrategySelect(<span class="keyword">new</span> GenderAD());</div><div class="line">$stratey-&gt;algorithm();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Strategy其实算是一个策略选择器，当满足一定条件的时候，我们通过这个策略选测器来进行选择相对应的策略。这样一来更符合逻辑。是不是很 OOP？</p><p>如果有什么不懂得可以在评论区进行留言，有时间我会一一答复，如果发现本文中有什么错误请指出，我也害怕误人子弟，特别是概念上的东西，在最后StrategySelect类的讲解上我依旧感觉写的很模糊，有些差强人意。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>《Leaning PHP Design Patterns》 William Sanders 著 苏金国 王宇飞等译</p></li><li><p>《PHP之道》</p></li><li><p>《PHP大话设计模式》 Rango(韩天峰) 录制者 慕课网视频教程</p></li></ul>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AV Foundation那些事系列（一）AVFunction入门了解</title>
      <link href="/2016/07/30/194/"/>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hello，大家好，先做一个简短的自我介绍，我是AirCrayon，目前就职于齐齐哈尔的一家创业型公司，从今天开始，每周末我都将为大家带来一篇博文，今天为大家带阿里的是 AVFunction 的那些事系列博文的第一章——AV Foundation入门。</p><p>苹果公司一直以来都是一家擅长引领潮流的一家公司，不论是产品设计开始技术革新，1991年苹果公司推出了QuickTime首次将数字音频和数字视频展现在用户面前。</p><blockquote><p>QuickTime不仅仅是一个媒体播放器，而且是一个完整的多媒体架构，可以用来进行多种媒体的创建、生产和分发，并为这一过程提供端到端的支持：包括媒体的实时捕捉，以编程的方式合成媒体，导入和导出现有的媒体，还有编辑和制作、压缩、分发，以及用户回放等多个环节。</p></blockquote><p>在2001年苹果公司推出了iTunes和iPod，从根本上改变了用户收听音乐的方式，iTunes store的出现彻底改变了国外的传统音乐行业（多么牛的一家公司）。</p><h2 id="AV-Foundation-的含义"><a href="#AV-Foundation-的含义" class="headerlink" title="AV Foundation 的含义"></a>AV Foundation 的含义</h2><p>AV Foundation是MacOS（目前还叫 OS X ，但最新版本的名字将叫做 MacOS）和 iOS 系统中用于处理基于时间的媒体数据的高级Objective-C框架。通过开发所需要的工具提供了大量的功能集，让开发者能够基于 Apple 平台创建媒体应用程序。AV Foundation 的构建考虑到了目前的硬件环境和应用程序，其设计过程高度依赖于多线程机制。充分利用了多和设备的有时并且使用了大量的 block 和 GCD 机制将复杂的计算放在后台线程中会自动提供硬件加速操作，确保在大部分设备上应用程序以最佳的性能运行。AV Foundation 的设计也充分考虑了电量效率来满足注入 iPhone 和 iPad 这类的移动设备，此外从一开始该框架就是针对于64位处理器设计，可以发挥64为处理器的所有优势。</p><p>在iOS7下的AVFoundation下增加了一个类用于文字转成语音,需要注意的是其转换的语音与你的手机语言环境有关,如果手机是英文环境,则无法读取中文字符串,但是中文环境下可以读取英文.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AVSpeechSynthesizer *xx = [[AVSpeechSynthesizer alloc]init]; //开始播放</div><div class="line">[xx speakUtterance:[AVSpeechUtterance speechUtteranceWithString:@&quot;语音转换&quot;]];</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对于未来的规划</title>
      <link href="/2016/07/20/cjek1d3kf003prhrd8zc8ba92/"/>
      <content type="html"><![CDATA[<h2 id="我现在在做什么"><a href="#我现在在做什么" class="headerlink" title="我现在在做什么"></a>我现在在做什么</h2><p>很久没有写博客了，其实是不知道写什么了，目前在做一个 PHP的项目，这也算是大学没有白白浪费，至少还学了一门语言，虽然并没有一上来就做 iOS 心里有点小遗憾。我并没有回北京而是选择留在了齐齐哈尔，这是一座很美的城市，其中也有很多回忆，留下来的一个原因就是这里的回忆实在是太多了，等回忆被齐齐哈尔的大风吹散也就该是离开这里的时候了。</p><h2 id="对于未来的规划"><a href="#对于未来的规划" class="headerlink" title="对于未来的规划"></a>对于未来的规划</h2><p>规划这种东西规划的太久也没有用，谁都不可能预料到以后会发生什么，只能说是大致心里有一个方向，最近打算在看 swfit 的同时也看一下安卓。本身我就会 PHP，说不定在齐齐哈尔的这段时间里我会成为一个全栈工程师。</p><p>毕业了，虽然闲散的时间少了，但是这个时候我可以去做一些我喜欢做的事情，因为可以自己赚钱了，昨天在网上买了一个瑜伽垫准备开始健身，健康的身体才是未来的保障，我还买了一套美术教程，其实我还想买一个尤克里里，但是想了想还是算了，可能是在我出生的时候身上的音乐细胞就全都被消灭掉了。</p><p>我目前每天11点半睡觉，早晨五点钟起床，从五点到六点半的这个时间段我分配出了半个小时锻炼，一个小时的晨读，读的并不是技术类的书籍而是一些读物，目前正在读《百年孤独》，这样做只是希望自己能够得到精神上的满足还有活跃一下脑子，害怕有一天变成了代码脑袋。</p><p>以下是我这一年要读的书：</p><ul><li>《百年孤独》</li><li>《摆渡人》</li></ul><p>在齐齐哈尔这段时间要掌握的技能：</p><ul><li>安卓开发</li><li>跨平台开发</li></ul><p>自己的爱好：</p><ul><li>可以画简单的插画</li><li>新书收藏超过500</li></ul><p>这样今年简单的计划就算是完成了</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Objective-C Runtime：Class</title>
      <link href="/2016/05/31/2/"/>
      <content type="html"><![CDATA[<p>Objective-C具有相当多的动态特性，表现在三个方面动态类型（Dynamic typeing）、动态绑定（ggDynamic binding）、动态加载（Dynamic loading），之所以被叫做动态，是因为必须到运行时（Runtime）才会做这些事情。</p><ol><li><strong>动态类型</strong>：即运行时在决定对象的类型。这类动态特性在日常生活中非常常见，简单说就是id类型。实际上静态类因为固定性与可与执行而使用得更加广泛，静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。</li><li><strong>动态绑定</strong>：基于冬天类型，在某个实例对象呗确定后，其类型便被确定了，该对象对应的水泥管和响应的消息也将会被完全确定。</li><li><strong>动态加载</strong>：根据需求加载所需要的资源，最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的图通屏幕设备上加载原图。</li></ol><p>这一切的特性都是由于objective-c的Runtime。</p><p>Runtime库主要做了下面的几件事</p><ol><li>封装：在这个库中对象可以用C语言的结构体表示，而方法可以用C函数来实现，另外再加上一些额外的特性。这些结构体和函数被runtime封装后，我们就可以在程序运行时创建、检查，修改类、对象和它们的方法了。</li><li>找出方法的最终执行代码：当程序执行[object doSometing]时，会想消息接受者（object）发送一条消息，runtime会根据消息接受者是否响应该消息而做出不同的反应。</li></ol><p>而在我们在了解Runtime之前，我们需要清楚Runtime的数据类型</p><p>如果想要进一步的了解，我们可以到苹果开源上下载Runtime的源码来进行学习。</p><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>                             <span class="title">OBJC2_UNAVAILABLE</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>                    <span class="title">OBJC2_UNAVAILABLE</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>                                 <span class="title">OBJC2_UNAVAILABLE</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>                     <span class="title">OBJC2_UNAVAILABLE</span>;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div><div class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></div></pre></td></tr></table></figure><ol><li>isa:需要注意的是在Objective-C中，所有类的自身也是一个对象这个对象的Class里面有一个isa指针，它指向metaClass（元类），下一章进行详细介绍。</li><li>super_class：指向该类的父类，如果该类已经是最顶层的根类，则它的值为NULL。</li><li>name：类的名称</li><li>info:在运行时使用的一些标识</li><li>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。<br>针对cache，我们用下面例子来说明其执行过程：</li><li>instance_size 该类实例变量的大小</li><li>ivars 该类中所有成员变量的数组</li><li>methodLists 该类中自定义方法的数组 </li><li>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</li><li>protocls 该类遵守协议的数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *array = [[NSArray alloc] init];</div></pre></td></tr></table></figure><p>其流程是：</p><p>[NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。</p><p>检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。</p><p>接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。</p><p>在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</p><p>##参考资料</p><ol><li><a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/" target="_blank" rel="noopener">Objective-C Runtime 运行时之一：类与对象</a></li><li><a href="http://www.cnblogs.com/whyandinside/archive/2013/02/26/2933552.html" target="_blank" rel="noopener">Objective-C Runtime的数据类型</a></li><li><a href="http://blog.csdn.net/uxyheaven/article/details/38113901" target="_blank" rel="noopener">Objective-C objc_class 介绍</a></li></ol>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 Feedly RSS阅读器订阅技术大牛的博客</title>
      <link href="/2016/05/08/cjek1d3js002orhrd5aghkv0x/"/>
      <content type="html"><![CDATA[<p>这几天一直都在自己看书，可是书上面的东西都比较落后一点，而且没有大牛博文上的东西讲的深入，可是来回跳转各位大牛的博客又非常的麻烦，有一些公众账号虽然也会推荐一些知识内容，可是你应该有过看到多个公众号发一篇博文的经历吧。</p><p>这个时候我想起了一个叫做 RSS 订阅的一个功能，可是国产的RSS 订阅器的 UI 是一个很大的槽点，而且功能相对于臃肿，很多功能都用不到，最终选择了 Feedly 这款 APP，UI 清爽，功能简单，完全符合我的需要，而且还支持 OPML 导入。</p><p>AirCrayon 是一名 iOS 程序员，所以我订阅的大多都是 iOS 的技术大牛，大牛唐巧一直在维护一个中文博文列表的项目地：<a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="noopener">https://github.com/tangqiaoboy/iOSBlogCN</a></p><a id="more"></a><p>在其中为广大 iOS 程序员提供了一个OPML 文件，将其文件下载来进入Feedly 的官网。</p><p>没有账户的同学请先注册账户，虽然是英文的但是一般都应该能看的懂，也就不做注册介绍了。</p><p>第一步,登录后点击 AddContent</p><p><img src="http://www.aircrayon.xyz/uploads/Snip20160508_3.png" alt=""></p><p>第二步，右侧栏拉倒底部点击 Import OPML</p><p><img src="http://www.aircrayon.xyz/uploads/Snip20160508_5.png" alt=""></p><p>第三步，上传 OPML 文件</p><p><img src="http://www.aircrayon.xyz/uploads/Snip20160508_8.png" alt=""></p><p>这样一来就已经大功告成了，进入 AppStore 或者安卓市场下载一个 Feedly 后登陆自己的账户后便可以使用手机直接查看技术大牛的最新博文了。</p><p><img src="http://www.aircrayon.xyz/uploads/Snip20160508_9.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内存管理 Form《Objectivce-C编程全解》&amp;《Objectivce-C编程》</title>
      <link href="/2016/05/06/cjek1d3l2004qrhrdx44l46uw/"/>
      <content type="html"><![CDATA[<blockquote><p>Xcode4.2之后可以使用自动引用计数（ARC,Automatic Reference Counting）的管理方式进行说明，ARC 是 Mac OS X 10.7和 iOS5引入的新特性，也是苹果公司推荐使用的内存管理方式。弃用 ARC 后，编译器会在适当的地方自动加入 retaion、release、autorelease 等语句，来简化 Objective-C 编程在内存管理方面的工作量</p></blockquote><h1 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h1><h2 id="内存管理的必要性"><a href="#内存管理的必要性" class="headerlink" title="内存管理的必要性"></a>内存管理的必要性</h2><p>C 语言中需要手动利用 malloc()和 free()对内存进行管理。当程序运行结束时，操作系统会释放掉为其分配的内存。如果是很小、运行时间短的程序，就算是内存没有释放也没有问题，程序结束时操作系统会进行自动释放。而对于长时间运行的程序，则需要程序员释放不再使用的内存，否则程序就会崩溃。</p><p>如果程序没能妥善管理内存，运行过程中就不但不能释放不再使用的内存，而且还会不停的分配内容村，这样所占用的内存就会越来越多，程序速度也会越来越慢，最后甚至会出现内存耗尽而崩溃。</p><p>就好像滴水一样，程序未能释放已不使用的内存叫做<strong>内存泄漏</strong>(memory leak)。C 语言中要特别注意内存的动态分配和释放，以防内存泄漏。有效地管理内存，会提高程序的执行效率。</p><p>如果访问了以被释放的内存，则会造成数据错误，严重时甚至会导致程序异常终止。在指针指向已被释放或回收的情况下，该指针就称之为<strong>悬垂指针</strong>（danling pointer）或野指针。继续使用这种指针会造成程序崩溃。</p><p>Objective—C 会通过向对象发送 alloc 消息来生成实例对象，alloc 的作用就是分配内存。alloc 方法的返回值是 id 类型，我们之前介绍过 id 其实就是指针类型，而其指向的就是为实例对象分配的内存。生成的实例对象用完之后如果不被释放的话，就会发生内存泄漏。另一方面，如果给已经被释放了的实例对象发送消息，运气好的话会得到警告，告诉你已被释放的对象发送了消息，运气不好的话则会程序错误甚至异常终止，所以 Objective-C 的程序一定要注意内存管理。</p><p>在面向对象的语言中，对象是程序的核心。而对象也有生命周期，既有从头到尾一直存在的对象，也有声明起短暂的临时对象。对象之间也可能相互引用，构成结构复杂的数据结构。同面向过程的语言相比，面向对象语言的内存管理更复杂一些。</p><h3 id="引用计数器、自动引用计数和自动垃圾回收"><a href="#引用计数器、自动引用计数和自动垃圾回收" class="headerlink" title="引用计数器、自动引用计数和自动垃圾回收"></a>引用计数器、自动引用计数和自动垃圾回收</h3><p>Coca 环境的 Objective-C 提供了一种动态内存管理方式，称之为<strong>引用计数</strong>（reference counter）。这种方式会跟踪每一个对象被引用的次数，当对象的引用次数为0的时候，系统会释放掉这个对象所占用的内存。这种内存管理方式也被称之为基于引用计数器的内存管理。</p><p>比引用计数内存管理更高级一点的就是<strong>自动引用计数</strong>（Automatic Reference Counting，简写 ARC）的内存管理。自动引用计数使开发人员不需要考虑何时使用 retain、release、autorelease 来管理内存，它提供了自动评估对象生存期的工恩给你，在编译期间会自动加入何时的内存管理方法，为了同自动引用计数器进行区分，将引用计数内存管理方式称之为手动引用技术内存管理。</p><p>除了 ARC 外，Objective-C2.0还引入了另外一种自动内存管理机制——<strong>垃圾回收</strong>，使用垃圾回收时，就不需要通过引用计数来刮泥创建的对象，系统会自动识别那些对象仍在使用，那些对象可以回收。</p><p>程序员可以从手动引用计数管理、ARC 和垃圾回收中选择任意一种内存管理方式来进行开发，不过还是推荐大家使用 ARC 的方式来进行内存管理。</p><table><thead><tr><th>内存管理方式</th><th style="text-align:center">难易度</th><th style="text-align:center">Mac</th><th style="text-align:center">iOS</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td>手动引用计数</td><td style="text-align:center">较难</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center"></td></tr><tr><td>自动引用计数</td><td style="text-align:center">容易</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">现在已经默认使用此方式</td></tr><tr><td>垃圾回收</td><td style="text-align:center">容易</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr></tbody></table><h3 id="兼容方法"><a href="#兼容方法" class="headerlink" title="兼容方法"></a>兼容方法</h3><p>在ARC的程序中,有一些类使用MRC实现的.</p><p>如果希望某些指定的类还是使用MRC. 那么这个时候可以在</p><pre><code>在targets的build phases选项下Compile Sources下选择要不使用arc编译的文件，双击它，输入 -fno-objc-arc 即可</code></pre><p>MRC工程中也可以使用ARC的类。方法如下：</p><p>在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可</p><h2 id="手动引用计数内存管理"><a href="#手动引用计数内存管理" class="headerlink" title="手动引用计数内存管理"></a>手动引用计数内存管理</h2><p>本节将说明如何基于引用计数器来管理内存。手中引用计数是内存引用计数的基础，就算程序使用自动引用计数的内存管理，也需要了解手动引用计数的原理。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Cocoa 环境的 Objective-C 使用了一种叫做引用计数的计数来管理对象所占的内存。每个对象都有一个与之相关的整数——引用计数，当某段代码需要使用一个对象时，就将该对象的引用计数值加1。当这段代码不再使用这个对象的时候，则将对象的引用计数器减1.换而言之，引用计数就是指程序中到底有多少个地方需要访问这个对象。</p><p>使用 alloc 和初始化方法创建一个对象的时候，该对象的引用计数初始值为1.假设有一个类 A 在进行某些处理的过程中需要使用到实例 B，为了防止实例化 B被别的对象随意释放，类 A 会实现给实例 B 发送一个 retain 消息。这样，没执行一次 retain，实例 B 的引用计数就会加1。</p><p>反之，不需要某个对象时，可以发送 release 消息，使对象的引用计数减1。</p><p>实际上，释放内存的并不是 release，而是 dealloc 方法。同 alloc 不同，dealloc 不是类方法而是一个实例方法。没收到一个 release 消息，对象的引用计数器就会减一。当对象的引用计数器达到0的时候，系统就知道这个对象不需要了。这时，Objectivce—C 会自动向对象发送一条 delloc 消息来释放内存。通常允许在程序内直接调用 dealloc。</p><p>retain、release和 dealloc 的定义如下所示。retain 的返回值是接收消息的对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)<span class="keyword">retain</span>;</div><div class="line">-(<span class="keyword">oneway</span> <span class="keyword">void</span>)release;</div><div class="line">-(<span class="keyword">void</span>)dealloc;</div></pre></td></tr></table></figure><p>retain 是“保持”的意思，给一个对象发送 retain 消息，就意味着“保持”这个对象。生成对象或通过给对象发送 retain 消息来保持对象这种状态，都可以说是拥有这个对象的<strong>所有权</strong>（ownership）拥有实例所有权的对象叫做<strong>所有者</strong>（owner）。</p><p>这里需要注意的是，所有权是一个虚拟的概念。既无法通过语法标记，也无法通过这个对象的某个属性表示出来。程序在运行时没发确认某个对象的所有者是谁。所有权仅仅是人们分析阅读程序时，为了说明对象之间的关系而加上去的一个属性。</p><p>通过引用计数能够表现出一个对象有几个所有者。只要某个对象的引用计数器大于0就表示这个对象有所有者。引用计数变为0的时候，说明这个对象没有所有者，会被释放。</p><p><strong>图1 没有使用引用计数器的例子</strong></p><p><img src="http://i2.piimg.com/1aa5fe7fdc3d7b06.png" alt=""></p><p>让我们通过例子来说明一下基于应用技术的内存管理。首先，假设图（1）中对象 A 的方法把一个新生成的一个实例对象复制给了 A 的实例变量。这个时候新生成的对象的引用计数为1，他的所有者是对象 A，然后，图（2）中把这个对象的指针付给了对象 B 的某个实例变量。因为对象鼻没有发送 retain 消息，所以并不是这个对象的所有者，这个独享的引用计数器还是1.最后图（3）中对象 A 不再使用这个对象的时候发送了一个 release 消息，于是，虽然对象 B 还在使用这个对象，但该对象也被释放了。而此时如果对象 B 给已经释放的消息在发送消息，就会发生运行错误，程序将会异常终止！</p><p>为了防止这样的情况发生，一定要给动态生成的对象发送 retain 消息来增加它的引用计数。只要对对象的引用次数大于零，系统就不会释放它。</p><h3 id="测试引用计数"><a href="#测试引用计数" class="headerlink" title="测试引用计数"></a>测试引用计数</h3><p>让我们通过一个例子来看引用计数到底是如何工作的。</p><p>retain 和 release 方法是类 NSObject 的实例方法，方法 retainCount 可以获得对象的引用计数的当前值。retainCount 方法并没有太大的使用价值，一般在调试程序的时候使用。</p><p>代码清单的程序显示了对象生成后收到 retain、release 消息时引用计数器的变化。retainCount 的返回值是 NSUInteger 类型，使用 printf 输出返回值的时候需要进行类型转换。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"init:%d"</span>,(<span class="keyword">int</span>)[obj retainCount]);</div><div class="line">    [obj <span class="keyword">retain</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retain:%d"</span>,(<span class="keyword">int</span>)[obj retainCount]);</div><div class="line">    [obj <span class="keyword">retain</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retain:%d"</span>,(<span class="keyword">int</span>)[obj retainCount]);</div><div class="line">    [obj release];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"release:%d"</span>,(<span class="keyword">int</span>)[obj retainCount]);</div><div class="line">    [obj release];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"release:%d"</span>,(<span class="keyword">int</span>)[obj retainCount]);</div><div class="line">    [obj release];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"release:%d"</span>,(<span class="keyword">int</span>)[obj retainCount]); </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>程序的输出如下所示。我们可以看出，对象刚生成的时候引用计数器的值为1，没收到一次 retain 消息，引用计数器的值就会加1；而收到 release 消息，引用计数器的值就减少1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">2016-05-06 13:19:16.761 引用计数器学习[6574:600738] init:1</div><div class="line">2016-05-06 13:19:16.762 引用计数器学习[6574:600738] retain:2</div><div class="line">2016-05-06 13:19:16.762 引用计数器学习[6574:600738] retain:3</div><div class="line">2016-05-06 13:19:16.762 引用计数器学习[6574:600738] release:2</div><div class="line">2016-05-06 13:19:16.763 引用计数器学习[6574:600738] release:1</div><div class="line">2016-05-06 13:19:16.763 引用计数器学习[6574:600738] release:1</div><div class="line">Program ended with exit code: 0</div></pre></td></tr></table></figure><h3 id="释放对象的方法"><a href="#释放对象的方法" class="headerlink" title="释放对象的方法"></a>释放对象的方法</h3><p>在自定义类的时候，如果累的实例变量是一个对象类型，那么，在销毁类的对象的时候，也要给类的实例变量发送 release 消息。</p><p>通过给对象发送 release 消息可以放弃对这个对象的所有权，但如前所述，真正释放对象占用的内存方法是 dealloc方法。</p><p>释放一个类的实例对象时，为了彻底释放该实例对象的所有对象的所有权，需要为该类重写 dealloc 方法，在其中释放已经分配的资源，放弃实例变量的所有权。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc&#123; <span class="comment">//重写的是 dealloc 方法而不是 release 方法</span></div><div class="line"><span class="comment">/*</span></div><div class="line">这里通过 release 方法放弃子类中所有实例变量的所有权</div><div class="line">其他用于释放前的善后操作也都卸载这里</div><div class="line">*/</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在重写 dealloc 犯法中，在释放自身之前，首先做好“善后工作”（释放所有需要释放的资源）。一般情况下，“善后工作”包括通过使用 release 放弃自身的实例变量的所有权。销毁对象的时候，不允许直接使用 dealloc，而是使用 release。release 会让引用计数减少1，只有当引用计数等于0的时候系统才会自动调用 dealloc 真正的销毁这个对象。</p><p>子类“善后工作”完成后，调用父类的 dealloc 方法来释放父类中定义的实例变量，这样，内存的释放会从子类一直向上知道 NSObject，最终这个对象就会被彻底释放掉。<br>下面的分数计算器的例子中展示了如何重写 dealloc。</p><h3 id="Retain计数原则"><a href="#Retain计数原则" class="headerlink" title="Retain计数原则"></a>Retain计数原则</h3><p>当使用Objective-C编写程序时，如果没有使用 ARC，就必须遵守特定的内存管理约定，否则可以由 ARC 来自动完成相关任务。</p><p>下面为 retain 计数总结若干规则，规则中的“你”代表“当前正在使用的某个类实例”。这是一种很有用的带入形式：请读者将自己想象成是在正在编写的那个对象。例如，“如果你保留了某个 NSString 对象，那么该实例就不会被释放掉”的真是意思是“如果读者正在使用的实例保留了某个 NSString 实例，那么该实例就不会被释放。”</p><p>下面列出规则（袁阔闹中的是实现细节）</p><ul><li>如果用来创建对象的方法，其方法名是以 alloc 或new 开头的，或者包含 copy，那么你已经得到了该对象的所有权（即可以假设新对象的 retain计数是1，而且该对象不再 NSAutoreleasePool 对象中）。你要负责不再需要使用该对象的时候释放掉他。以下是部分常见的、会“传输”所有权的方法：alloc（后面总会跟一个 init 方法）、copy 和 mutableCopy</li><li>通过任何其他途径创建的对象（例如通过便捷方法），你是没有所有权的（即可以假设新对象的 retain 计数是1，而且该对象已经在 NSAutoreleasePool 对象中。如果没有保留该对象，那么当NSAutoreleasePool被“排干”时，这个对象会被释放）。</li><li>如果你不拥有某个对象，但是要确保该对象能继续存在，那么可以通过响起发送 retain 消息来获得所有权。</li><li>当你拥有某个对象并且不再需要使用该对象的时候，可以向其方发送 release 消息或者 autorelease 消息</li><li>只要对象还有只要一个拥有方，该对象就会继续存在下去。</li></ul><p>##参考文献：</p><p>① Objectivce-C编程全解（第三版） [日]荻原刚志 著 唐璐 翟俊杰 译</p><p>② Objectivce-C编程 [美]Aaron Hillegass 著 夏伟频 译</p>]]></content>
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书总结之NSObject</title>
      <link href="/2016/05/06/cjek1d3io0017rhrdaehx2988/"/>
      <content type="html"><![CDATA[<blockquote><p>使用 Objectvice-C 进行全面对象编程时，除了需要知道语言本身的语法和面向对象的知识外，还需要了解Objectvice-C的根类 NSObject 的信息。</p></blockquote><h2 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h2><h3 id="根类的作用"><a href="#根类的作用" class="headerlink" title="根类的作用"></a>根类的作用</h3><p>作为一门动态编程语言，Objectstvice-C有很多动态的特性，因此，Objectvice-C不进需要编译环境，同时还需要一个<strong>运行时系统</strong>（runtime system）来执行编译好的代码。运行时系统扮演的角色类似于Objectvice-C的操作系统，他负责完成对象生成、释放时的内存管理、发来的消息查找对应的处理方法等工作。</p><p>通常情况下，程序无法直接使用运行时系统提供的功能。根类方法提供了运行时系统的基本工恩给你。继承了 NSObject 的所有类都可以自由的使用运行时系统的功能，也就是说，根类就想到于系统的一个借口。</p><p>根类通过哪些方式提供了哪些功能对系统有很大的影响。因此，根类不同的系统之间是无法开发出通用的程序的。</p><p>Cocoa 是以OPENSTEPDE的核心 API 为基础发展起来的。OPENSTEP的前身为 NeXTstep。在 NeXTstep 时代，根类是累 Object,而在 OPENSTEP 时代，根类则变为了 NSObject，同时类的设计也得到了大幅度的改进。</p><a id="more"></a><blockquote><p>NSArray,NSString 等等NS前缀类、函数归属于cocoa Fundation基础类库,其”NS”的由来据说是这样的：乔布斯被苹果开除后,创立了NeSt公司,而cocoa Fundation基础类库就是出自于NeST公司,NeST中的”NS”被作为Fundation中所有成员的前缀</p></blockquote><h3 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h3><p>NSObject 只是一个实例变量，就是 Class 类型的变量 isa。isa 用于表示实例对象属于哪个类对象。因为 isa 决定着实例变量和类的关系，非常重要，所以子类不可以修改 isa 的值。另外，也不能通过直接访问 isa 来查询实例变量到底属于哪个类，而是要通过实例方法 class 来完成查询。</p><p>在运行时的代码中我们可以查看到objc_class的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line"></div><div class="line"><span class="comment">/// Represents an instance of a class.</span></div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>下面对类和实例变量的相关方法进行说明。NSObject 的方法与其说是为自己定义的，不如说是为了其子类和所有实例对象而定义的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">class</span>) <span class="keyword">class</span></div><div class="line">返回消息接收者所属类的类对象</div><div class="line"></div><div class="line">+ (<span class="keyword">class</span>) <span class="keyword">class</span></div><div class="line">返回类型对</div><div class="line">虽然可以使用类名作为消息的接受者来调用类方法，但类对象是其他消息的参数，或者将类对象赋值给变量的时候，需要通过这个方法来获取类的参数</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>) <span class="keyword">self</span></div><div class="line">返回接受者自身。是一个无任何实际动作但很有用的方法。</div><div class="line"></div><div class="line">-(<span class="built_in">BOOL</span>) isMemberOfClass: (Class) aClass</div><div class="line">判断消息接受者是不是参数 aClass 类的对象</div><div class="line"></div><div class="line">-(<span class="built_in">BOOL</span>) isKindOfClass: (Class) aClass</div><div class="line">判断消息接受者是否是参数 aClass 类或者 aClass 的子类的实例。这个函数和 isMemberOfClass:的区别在于当消息的接受者是 aClass 的子类的实例时也返回 <span class="literal">YES</span>。</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>) isSubclassOfClass: (Class) aClass</div><div class="line">判断消息接受者是不是参数 aClass 的子类或自身，如果是则返回 <span class="literal">YES</span></div><div class="line"></div><div class="line">- (Class) superclass</div><div class="line">返回消息接受者所在类的父类的类对象。</div><div class="line"></div><div class="line">+ (Class) superclass</div><div class="line">返回消息接收类的父类和类对象</div></pre></td></tr></table></figure><h3 id="实例对象的生成和释放"><a href="#实例对象的生成和释放" class="headerlink" title="实例对象的生成和释放"></a>实例对象的生成和释放</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>) alloc</div><div class="line">生成消息接收类的实例对象。通常和 init 或者 init 开头的方法连用，生成实例化对象的同事需要对其进行初始化。子类中不润徐重写 alloc 方法</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>) dealloc</div><div class="line">释放实例对象。dealloc 被称之为 release 的结果调用。除了在子类中重写 dealloc 的情况之外，程序不润徐直接调用 dealloc</div><div class="line"></div><div class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release</div><div class="line">将消息接受者的引用计数减<span class="number">1.</span>引用计数变为<span class="number">0</span>时，dealloc 方法被调用，消息接受者被释放</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span></div><div class="line">为消息接收者的引用计数加<span class="number">1</span>，同事返回消息接收者</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)autorelease</div><div class="line">把消息的接受者加入到自动释放池中，同事返回消息接受者</div><div class="line"></div><div class="line">- (<span class="built_in">NSUinteger</span>) retainCount</div><div class="line">返回消息接受者的引用计数，可在调试时使用这个方法。<span class="built_in">NSUInteger</span> 是无符号证书类型</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)finalize</div><div class="line">垃圾收集器在释放接受者对象之前会执行该 finalize 方法。</div></pre></td></tr></table></figure><p>上面从 dealloc 到 retainCount 都是手动引用计数管理内存时使用的方法，使用 ARC 时不可用。finalize 仅供垃圾回收有效时使用。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>) init</div><div class="line">init 可对 alloc 生成的实例对象进行初始化。子类中可以重写 init 或者自定义的心的以 init 开头的初始化函数。</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)initialize</div><div class="line">被用于类的初始化，也就是对类中共同使用的变量进行初始化设定等。这个方法会在类收到第一个消息之前被自动执行，不需手动调用</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>) new</div><div class="line">new 是 alloc 和 init 的组合。new 方法返回的实例对象的所有者就是调用 new 方法的对象。但是把 alloc 和 init 组合定义为 new 没有什么优点，并不建议使用。</div><div class="line">根据类的实现不同，new 方法并不会每次都返回一个全新的实例对象。有时new 方法会返回对象池中预先生成的对象，也有可能每次都返回同一个对象。</div></pre></td></tr></table></figure><h3 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>) isEqual: (<span class="keyword">id</span>) anObject</div><div class="line">消息的接受者如果和参数 anObject 相等则返回 <span class="literal">YES</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>) hash</div><div class="line">把对象放入容器的时候，返回系统内部用的散列表</div></pre></td></tr></table></figure><p>原则上来讲，具有相同 id 值也就是同一个指针指向的对象被认为是相等的。而子类在这个基础上进行了扩展，把拥有相同值认为是相等。我们可以根据需求对“想通知”激进型定义，但一般都会让具备“相同值”的对象返回相同的散列表，因此就需要对散列表方法进行重新定义。而反之则并不成立，也就是说，散列值相等的两个对象不一定相等。</p><p>另外，有的累中还自定义了 compare:或者isEqualTo 之类的方法。至于到底是哪个方法或者自定义类的时候是否需要定义比较的方法，都需要根据目的和类的内容做具体分析。</p><h3 id="对象的内容描述"><a href="#对象的内容描述" class="headerlink" title="对象的内容描述"></a>对象的内容描述</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSString</span>*) description</div><div class="line">返回一个 <span class="built_in">NSString</span> 类型的字符串，表示消息接受者所属类的内容。通常是这个类的名称。</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span>*)description</div><div class="line">返回一个 <span class="built_in">NSString</span> 类型的字符串，表示消息接受者的实例对象的内容。通常是类名家 <span class="keyword">id</span> 值。子类中可以重新定义 description 的返回值。例如 <span class="built_in">NSString</span>的实例会返回字符串的内容，<span class="built_in">NSArray</span> 的实例会对数组中的每一个元素调用 description，然后将调用结果用句号进行分割，并且一起返回。</div></pre></td></tr></table></figure><h2 id="消息发送机制"><a href="#消息发送机制" class="headerlink" title="消息发送机制"></a>消息发送机制</h2><h3 id="选择器和-SEL-类型"><a href="#选择器和-SEL-类型" class="headerlink" title="选择器和 SEL 类型"></a>选择器和 SEL 类型</h3><p>至今为止我们把选择器（方法名）和消息关键字放在一起进行说明。程序中的方法名（选择器）在便有被一个内部标识符所代替，这个内部标识符所对应的数据类型就是 SEL 类型。</p><p>Objective-C为了能够在程序中操作编译后的选择器，定义了@selector()指令。通过使用@selector()指令，就可以直接饮用编译后的选择器。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@selector(mutableCopy)</div><div class="line">@selector(compare:)</div><div class="line">@selector(replaceObjectAtIndex:withObject:)</div></pre></td></tr></table></figure><p>也可以声明 SEL 类型的变量</p><p>选择器不同的情况下，编译器转换后生成的 SEL 类型的值也一定不同，相同的算择期对应的 SEL 类型的值一定相同。Objective-C的程序员不需要知道选择器对应的 SEL 类型的值到底是什么，具体的值是和处理器相关的。但是如果 SEL 类型的便利功能无效的话，可设其为 NULL，或者也可以使用(SEL)0这种常见的表达方式</p><p>可以使用 SEL 类型的变量来发送消息，为此，NSObject 中准备了如下方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)performSelector: (SEL) aSelector</div><div class="line">向消息的接收者发送 aSelector代表的消息，返回这个消息的执行结果</div><div class="line"></div><div class="line">-(<span class="keyword">id</span>)performSelector: (SEL) aSelector </div><div class="line">withObject: (<span class="keyword">id</span>) anObject</div><div class="line">与上面的方法一直，不过可以传递参数</div></pre></td></tr></table></figure><p>例如下面两个消息表达式进行的处理是相同的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[target description]</div><div class="line">[targ performSelector: <span class="keyword">@selector</span>(description)];</div></pre></td></tr></table></figure><p>下面的例子展示了如何根据条件动态决定执行那个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SEL method = (void1) ? <span class="keyword">@selector</span>(activate:) : <span class="keyword">@selector</span>(hide:);</div><div class="line"><span class="keyword">id</span> obj = (cond2) ? MyDocument : defaultDocument;</div><div class="line">[target performSelector:method withObject:obj]</div></pre></td></tr></table></figure><p>这种调用方式很想 C 语言中函数指针的用法，使用函数指针可以实现和上面的程序同样的功能。</p><p>函数指针是函数在内存中的地址。指针对应的函数是在编译的时候决定的，不能够执行指定之外的函数。SEL 类型就相当于方法名，根据消息接受者的不同（上例子中 target 的赋值），来动态执行不同的方法。</p><p>通过 SEL 类型来指定要中子星的方法，这就是 Objectivce-C消息发送的方式。也正是通过这种方法才实现了 Objectivce-C的动态性</p><h3 id="消息搜索"><a href="#消息搜索" class="headerlink" title="消息搜索"></a>消息搜索</h3><p>对象收到一个消息后执行哪个方法是动态决定的。</p><p>所有的实例变量都存在一个 Class 类型的 isa 变量，它就是类对象。当收到消息后，运行时系统会检查类内是否有和这个消息选择器相同的方法，如果有就执行对应的方法，如果没有就通过类对象中指向父类的指针来查找父类中是否有对应的方法。如果一直找到根类都没有找到对应的方法，就会提示执行时错误。</p><p>如果每次收到消息都需要查找对应的方法的话，消息发送过程的开销就会很大，是针对这种情况，运行时内部会缓存一个散列表，表中记录着某个类拥有和什么样的选择器相对应的方法、方法被定义在何处等信息。这样一来，当下次在收到同样的消息时，直接利用上次缓存好的信息即可。</p><p>NSObject 中定义了可以动态检查一个对象是否能够响应某个选择器的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>) respondsToSelector: (SEL) aSelector</div><div class="line">查询消息的接收者中是否能够响应 aSelector 的方法，包括从父类继承来的方法，如果存在的话则返回 <span class="literal">YES</span></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>) instancesRespondToSelector: (SEL) aSelector</div><div class="line">查询消息的接收者所属的类中是否能够响应 aSelector 的实例方法，如果存在的话则返回 <span class="literal">YES</span></div></pre></td></tr></table></figure><h3 id="一函数的形式来调用方法"><a href="#一函数的形式来调用方法" class="headerlink" title="一函数的形式来调用方法"></a>一函数的形式来调用方法</h3><p>类中定义的方法通常是以函数的形式来实现的，但通常在编程的时候并不会直接操作方法所对应的函数。</p><p>但如果想尽可能第让程序更快一点，或者需要按照 C 语言的管理传递函数指针的时候，可以直接调用方法对应的函数，以节省发送消息的开销。另外执行时动态加载方法的定义等时，也可以将方法作为函数调用。但是需要注意的是，如果以函数的形式来调用方法的话，将无法利用面向对象的动态绑定等功能。虽然消息发送同函数调用相比确实慢一点，但却有面向对象的动态绑定、多态等优点。同这些优点相比，速度上略微的损失是不值得一提的。而其实消息发送的速度也非常的快。</p><p>通过使用下面的方法，可以获得某个对象持有的方法的函数指针，这些方法都被定义在 NSObject 中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (IMP) methodForSelector: (SEL) aSelector</div><div class="line">搜索和执行选择器对应的方法，并返回指向该方法实现的函数指针。实例对象和类对象都可以使用这个方法。对实例对象使用时，会返回实例方法对应的函数，对类对象使用时，会返回类对象对应的函数</div><div class="line">+ (IMP) instanceMethodForSelector: (SEL)aSelector;</div><div class="line">搜索和制定选择器相对应的实例方法，并返回该指向实例方法实现的函数指针</div></pre></td></tr></table></figure><p>IMP 是“implemention”的缩写，它是一个函数指针，指向了方法实现代码的入口</p><p>IMP 的定义为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*IMP)(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> ); </div><div class="line"><span class="meta">#else</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...); </div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure><p>这个被指向的函数包括 id(self 指针)、调用的 SEL（方法名），以及其他参数</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)setBox:(<span class="keyword">id</span>)obj1 title:(<span class="keyword">id</span>)obj2;</div></pre></td></tr></table></figure><p>foo 是这个方法所属类的一个实例变量。获取指向 setBox 的函数指针，并且通过该指针进行函数调用的过程如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IMP funcp;</div><div class="line">funcp = [foo methodForSelector:<span class="keyword">@selector</span>[setBox:title]];</div><div class="line">xyz = (*funcp)(foo,<span class="keyword">@selector</span>[setBox:title:],param1,param2)</div></pre></td></tr></table></figure><h3 id="类对象和跟对象"><a href="#类对象和跟对象" class="headerlink" title="类对象和跟对象"></a>类对象和跟对象</h3><p>因为累对象也是一个对象，所以累对象可以作为根类 NSObject 的某个子类的对象来使用。下面这句话看上去好像比较奇怪，但是实际上他是正确的，会返回 YES</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSString</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]</div></pre></td></tr></table></figure><p>这就说明了相当于类对象的类的对象是存在的。而类对象的类就被叫做元类(metaclass)。实例对象(instance object)所属的类是 class，类对象(class object)所属的类是 metaclass。</p><p>Objective-C 中的很多概念都来源于 Smalltalk，元类的概念就是其中之一。但现在的 Objective-C中已经不存在元类的概念了，程序中不能操作元类。用于表示对象的 id 类型和表示类的 Class 类实际上都是指向结构体的指针。被详细定义在/usr/include/objc 下面的 objc.h 头文件中。通过查看 objc.h 中 id和 Class 的定义，就会发现类和元类的关系如图所示。Objective-C2.0更新了基本的数据结构，但是没有改变类和元类的关系。</p><p><img src="http://i3.buimg.com/1eb8e25c5b87d1ec.jpg" alt=""></p><p>类 A 是 NSObject 的子类，类 B是 A 的子类。类对象和实例对象都存在一个成员变量 isa，它是一个 objc_class 类型的指针</p><p>图中带有 isa 的实现表明了 isa 指向的对象，带有 super_class 的虚线则表明了父类的关系。</p><p>类对象中保存的是实例方法，元对象中保存的是累方法。通过这样的定义能够统一实现实例方法和类方法的调用机制。</p><p>因为编程时不可以直接操作元类，所以并不需要完全了解图中的细节。大家只需要记住任何一个类对象都是继承了根类的元对象的一个实例即可。也就是说，类对象可以执行根类对象的实例方法。</p><p>例如，类对象可以执行 NSObject 的实例方法 performSelector:和 respondsToSelector:。当然提前是没有将这些方法作为类方法再次定义。</p><p>下面让我们总结一下。其中（1）和（2）我们已经介绍过了。（3）比较不容易理解，</p><ol><li><p>所有类的实例对象都可以执行根类的实例方法</p><ul><li>如果在派生类中重新定义了实例方法，新定义的方法会被执行</li></ul></li><li><p>所有类的类对象都可以执行根类的类方法</p><ul><li>如果在派生类中重新定义了类方法，新定义的方法会被执行</li></ul></li><li><p>所有类的类对象都可以执行根类的实例方法</p><ul><li>即使在派生类中重新定义了实例方法，根类中的方法也会被执行</li><li>如果在派生类中将实例方法作为类方法重新定义了的话，新定义的方法会被执行</li></ul></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>① Objectivce-C编程全解（第三版） [日]荻原刚志 著 唐璐 翟俊杰 译</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UITableView 系统 API实现滑动删除Cell</title>
      <link href="/2016/04/23/cjek1d3k0002zrhrdft1x8f6q/"/>
      <content type="html"><![CDATA[<p>#UITableView 系统 API实现滑动删除Cell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">import UIKit</div><div class="line"></div><div class="line">class ViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    private lazy var tableview:UITableView = &#123;</div><div class="line">        let tb = UITableView(frame: CGRectZero,style: UITableViewStyle.Plain)</div><div class="line">        tb.dataSource = self</div><div class="line">        tb.delegate = self</div><div class="line">        tb.registerClass(UITableViewCell.self, forCellReuseIdentifier: &quot;Cell&quot;)</div><div class="line">        return tb</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    private var dataArray = [&quot;lazy&quot;,&quot;make&quot;,&quot;help&quot;,&quot;papa&quot;]</div><div class="line">    </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        view = tableview</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">extension ViewController:UITableViewDataSource&#123;</div><div class="line">    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</div><div class="line">        return dataArray.count;</div><div class="line">    &#125;</div><div class="line">    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</div><div class="line">        let cell = tableview.dequeueReusableCellWithIdentifier(&quot;Cell&quot;, forIndexPath: indexPath)</div><div class="line">        cell.textLabel?.text = dataArray[indexPath.row]</div><div class="line">        return cell</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension ViewController:UITableViewDelegate&#123;</div><div class="line">    //1.设置Cell 可编辑</div><div class="line">    func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool &#123;</div><div class="line">        return true</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //2.进入编辑模式，滑动初选删除按钮</div><div class="line">      func tableView(tableView: UITableView, titleForDeleteConfirmationButtonForRowAtIndexPath indexPath: NSIndexPath) -&gt; String? &#123;</div><div class="line">        return &quot;删除&quot;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    //3.响应删除按钮事件</div><div class="line">    func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) &#123;</div><div class="line">        tableview.setEditing(false, animated: true)</div><div class="line">        print(&quot;删除\(dataArray[indexPath.row])&quot;)</div><div class="line">        dataArray.removeAtIndex(indexPath.row)</div><div class="line">        tableview.reloadData()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个新的开始</title>
      <link href="/2016/03/27/cjek1d3km0042rhrdrdo6uwg1/"/>
      <content type="html"><![CDATA[<p>人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。</p><a id="more"></a><p>于是在不甘，与短暂的刺激后，我又开始了写作，其实也是想试一试，自己到底能不能够成功，我所谓的成功其实就是写一个完整的故事，记得小时候抓周，我抓的就是个笔，奶奶曾经说我以后是个笔杆子，可惜现在虽然现在也是在写东西，不过写的是代码，而不是小说。</p><p>记得那是还在上初中的时候，我接触到了网络文学，我记得我看的第一本网络小说应该是木子心写的《现代修罗》，可惜最后太监了，那个时候我对太监这件事当真是有些厌恶，可是没想到到最后，我也踏入了后宫那洪流之中，成为了诸多太监中的一份子。我朋友曾经对我说过一句话，要是能在我生儿子之前能看到你一本完本的小说就行了。</p><p>其实这段时间一直在思考我要不要继续写东西，我能否坚持下去，最终还是决定试一试，思前想后决定写一篇科幻类的小说，希望能够做到不落俗套，写出自己心目中的网络文学。</p><p>以后每个月我都会更新一篇关于网络文学的文章，主要是去分析曾经红极一时或者是现在当红的网络小说的写作手法。看一看那些大神是如何进行网络文学创作的，同时也是去提升自己的能力。</p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的碎片化时间都在做什么?</title>
      <link href="/2016/03/26/cjek1d3k9003jrhrdx15ldxzg/"/>
      <content type="html"><![CDATA[<p>一直都没太仔细的时间管理,基本上就是想要去做什么就去做,但就算如此有的时候回想一下自己这一天都在做什么了,却发现一天过得有些苍白,可能是精神上还是没有获得太多的满足,日记现在还在坚持写,不过一般都是有什么事情发生了才会去写上那么一笔.</p><p>最近一直在想自己的时间去了哪里,现在正在处于学习状态,满脑子都是成片的代码,倒是没有更多的碎片化时间.</p><p>那么我平时大部分碎片化时间都在干什么呢.</p><a id="more"></a><ul><li>微信朋友圈</li><li>刷微博</li><li>QQ空间</li><li>网络小说</li><li>百度各种稀奇古怪的东西</li></ul><p>这么算下来,我的碎片化时间并没有被合理的利用起来,仔细分析一下,以上种种对我来说,除了看网络小说以外,对自己的进步没有任何实质性的帮助,当然,我看网络小说并非是只是为了爽,主要是去分析一本网络小说的具体写作手法,以及伏笔,高潮等如何去写,以提高自己网络小说写作的水平.</p><p>那么其他的几项呢,基本上对自己没有任何帮助,除了可以获得短暂的心情愉悦,可是却并有得到任何的营养,精神上只是短暂的得到了满足,但这份满足却在短暂的愉悦过后变得苍白无力,因为自己并没有因此得到知识以及改变.</p><p>那么我该如何安排自己的碎片化时间呢?</p><blockquote><p>①时间：物质存在的可用钟表来量度的属性。某一过程的发生、发展、终止，既反映了过程的持续性也反映了顺序性。过程的持续性表现为时间间隔，顺序性表现为日期和时刻。</p><p>②碎片时间：所谓的碎片时间，即指日常工作、学习之余闲散的，零碎的时间，这些时间不是很长，如等车、排队、等人等情况所用的时间，这些时间不适宜做比较有深度的事情，一般用来手机阅读，玩游戏等。<br>来源在线 新华词典</p></blockquote><p>对于碎片化的时间的定义中说道这些时间不是以做比较深度的事情,那么什么叫做比较深度的事情,我对于这句话的理解就是需要耗时非常多的事情,例如看代码,读有深度的技术文章,因为这不是短暂的时间就可以完成的.</p><p>但是却可以用这一段时间去读一些比较短效精干的文章,在互联网如此发达的年代,倒是很好可以解决这样的需求,自媒体,微信公众号等都可以进行实现.这时候还真是要感谢网络的快速发展,使得只是的传播变得廉价.</p><p>分析了这些之后,简单的做了一些事情</p><ol><li>删除低质量的微信公众账号</li><li>取消关注了娱乐圈的大V们</li><li>关闭了微信朋友圈功能</li><li>重新梳理了一遍亚马逊电子书城</li><li>删除了手机中并不算火的网络小说</li><li>删除了无用的社交软件</li></ol><p>并且将我的书单进行了调整,将自己兴趣的书籍进行了筛选最终选出了要读的三本书.</p><ol><li>中国通史</li><li>塔木德</li><li>李鸿章传</li></ol><p>经过简单的梳理过后,倒是有了一些明确的目标,也知道接下来要怎么做了.</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多线程</title>
      <link href="/2016/03/22/cjek1d3l8004zrhrds6xq97az/"/>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>多线程是所有程序员都应该知道的一个概念，因为当一个程序开始运行，进程就已经开启了！</p><h3 id="多线程基本概念"><a href="#多线程基本概念" class="headerlink" title="多线程基本概念"></a>多线程基本概念</h3><p>进程(process)和文件(files)是UNIX/Linux操作系统最基本的抽象。进程是处于执行期的程序和它所包含的资源的综合，也就是说一个进程就是处于执行期的程序。一个线程（thread）就是运行在一个程序上下文中的一个逻辑刘，不难看出，线程是进程中最基本的活动对象。</p><blockquote><p>在软件工程中，上下文是一种属性的有序序列，它们为主流在环境内的对象定义环境，在对象的激活过程中创建上下文，对象呗配置为要求某些自动服务，如同步、事务、实时激活、安全性等等。又比如计算机技术中，对象鱼进程而言，上下文就是进程执行时候的环境，具体来就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。</p></blockquote><p>在传统系统中，一个进程只包含一个线程。但是在现代系统中，润徐一个进程里面可以同时运行多个县城，这类程序被称之为多线程程序。所有的程序都有一个主线程（main thread，在iOS开发中，主线程主要用于UI呈现，要将耗时操作放到其他线程之中，否则UI界面会被卡死），主直选成是进程的控制流或者执行线程在多线程程序中，主线可以创建一个活多个对等线程（peer thread），从这个时间点开始，这些线程就开始兵法执行，主线程和对等线程的区别仅在于主线程总是进程中第一个运行的线程。从某种程度上看，线程可以看做是轻量级的进程（lightweight process）。</p><p>每个程序都拥有独立的线程上下文（thread context），线程ID（Thread ID，TID），程序计数器（PC），线程栈（stack），一组寄存器（register）和条件码，其中内核正式通过线程ID（TID）来识别线程，进行线程调度的。</p><p>上面的内容是否晦涩难懂，那么我们看一看百度百科是如何解释多线程的：</p><p>在百度百科中，多线程是指软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多余一个线程，今儿提高整体处理性能。就这样的一句话就解释了什么是线程和线程的作用，就是为了提高程序的执行效率，能够在同一时间段执行多个任务。</p><p>这样一来是否就容易理解了，其实每一个软件都是一个进程，每个进程中包含一个到多个的线程，我们在window有的时候程序卡死，我们使用任务管理器结束程序的时候就是杀死那个进程。进程也可能是整个程序或者是部分程序的动态执行，线程是一组指令的集合，或者是程序的特殊段，它可以在程序里面单独执行，也可以把它理解成为代码运行的上下文，所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。</p><p>线程是程序中一个单一的顺序控制流程，在单个程序中同时运行多个线程完成不同的工作，成为多线程。</p><p>线程和进程的主要区别在于子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其知心上下文，多线程主要是为了节省CPU时间，发挥利用，根据具体情况而定。线程的运行需要使用计算机的内存资源和CPU。</p><p>到了这里你应该已经知道了什么是多线程了，首先让我们来整理一下然后再进行进行学习。</p><ol><li>进程:就是指在系统中运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间中</li><li>线程:一个进程要执行任务，必须得有线程（每一个进程只要有一条线程），一个进程的所有任务都是放在线程中完成的<ul><li>线程的串行：一个线程中执行的任务是串行的，如果在一个线程中赤星多个任务，只能一个一个的按照顺序执行</li></ul></li><li>多线程：一个进程中可以开启多条线程，每条线程可以并行（同时），执行不同的任务。</li></ol><h3 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h3><h4 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h4><ol><li>能适当提高程序的执行效率</li><li>能适当提高资源利用率（CPU、内存利用率）</li></ol><h4 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h4><ol><li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li><li>线程越多，CPU在调度线程上的开销就越大</li><li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li></ol><h4 id="多线程在iOS开发中的应用"><a href="#多线程在iOS开发中的应用" class="headerlink" title="多线程在iOS开发中的应用"></a>多线程在iOS开发中的应用</h4><p>主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”<br>主线程的主要作用<br>显示、刷新UI界面<br>处理UI事件（比如点击事件、滚动事件、拖拽事件等）<br>主线程的使用注意:别将比较耗时的操作放到主线程中。<br>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</p><h2 id="Pthread"><a href="#Pthread" class="headerlink" title="Pthread"></a>Pthread</h2><p>POSIX线程（POSIX threads）简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一套API，在类Unix系统中，都是用Pthreads作为系统的线程。在这里只讲一下其基本使用，因为在日常的开发之中并不是很常用这种方式进行多线程的开发。</p><h3 id="Pthread的基本使用"><a href="#Pthread的基本使用" class="headerlink" title="Pthread的基本使用"></a>Pthread的基本使用</h3><p>由于Pthreads是使用C语言进行开发的，所以其使用都是C语法。</p><h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pthread_create(pthread_t *thread,pthread_attr_t * attr,void*(*start_routine)(void*),void*arg);</div></pre></td></tr></table></figure><h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><p>thread:返回创建的线程ID</p><p>attr:线程属性，调度策略、优先级等都在这里设置，如果为NULL则标识默认属性</p><p>start_rountine:线程入口函数，可以返回一个void*类型的返回值，该返回值可由pthread_join()捕获<br>arg:传给start_rountine的参数，可以为NULL</p><h5 id="设置线程属性"><a href="#设置线程属性" class="headerlink" title="设置线程属性"></a>设置线程属性</h5><p>线程属性通过attr进行设置<br>设置与查询attr结构为pthread_attr_get<del>()与pthread_attr_set</del>()两个系列函数，也可以在创建时通过pthread_create参数参数，有些必须在线程创建时进行设置比如跳读策略。</p><h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h5><p>POSIX定义一种优先级调度模型，此模型确定任何两个线程相对于对方的重要程度。当两个线程同时准备就绪的时候，系统就会自动选择具有最高优先级的线程。</p><p>SCHED_OTHER：非实时、正常<br>SCHED_RR：实时、轮询法<br>SCHED_FIFO：实时、先入先出，与vxworks的调度机制一致</p><p>例程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pthread_attr_t attr;</div><div class="line">pthread_attr_init(&amp;attr);</div><div class="line">pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);//sched_policy</div></pre></td></tr></table></figure><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>NSThread 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切,通过NSThread这个API我们可以实现简单的多线程编程,但需要管理线程的声明周期、同步、加锁等问题，这样会导致一定的性能开销，当我们进行多线程开发的时候，并不推荐此方法。</p><h3 id="NSThread的初始化"><a href="#NSThread的初始化" class="headerlink" title="NSThread的初始化"></a>NSThread的初始化</h3><h4 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 初始化线程</div><div class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</div><div class="line">// 设置线程的优先级(0.0 - 1.0，1.0最高级)</div><div class="line">thread.threadPriority = 1;</div><div class="line">// 开启线程</div><div class="line">[thread start];</div><div class="line">参数解析：</div><div class="line">selector ：线程执行的方法，这个selector最多只能接收一个参数</div><div class="line">target ：selector消息发送的对象</div><div class="line">argument : 传给selector的唯一参数，也可以是nil</div></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</div><div class="line">// 调用完毕后，会马上创建并开启新线程</div></pre></td></tr></table></figure><h4 id="隐式创建线程的方法"><a href="#隐式创建线程的方法" class="headerlink" title="隐式创建线程的方法"></a>隐式创建线程的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self performSelectorInBackground:@selector(run) withObject:nil];</div></pre></td></tr></table></figure><h3 id="获取当前线程"><a href="#获取当前线程" class="headerlink" title="获取当前线程"></a>获取当前线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSThread *current = [NSThread currentThread];</div></pre></td></tr></table></figure><h3 id="获取主线程"><a href="#获取主线程" class="headerlink" title="获取主线程"></a>获取主线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSThread *main = [NSThread mainThread];</div></pre></td></tr></table></figure><h3 id="暂停当前线程"><a href="#暂停当前线程" class="headerlink" title="暂停当前线程"></a>暂停当前线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 暂停2s</div><div class="line">[NSThread sleepForTimeInterval:2];</div><div class="line"></div><div class="line">// 或者</div><div class="line">NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];</div><div class="line">[NSThread sleepUntilDate:date];</div></pre></td></tr></table></figure><h3 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1.在指定线程上执行操作</div><div class="line">[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES];</div><div class="line"></div><div class="line">2.在主线程上执行操作</div><div class="line">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];</div><div class="line"></div><div class="line">3.在当前线程执行操作</div><div class="line">[self performSelector:@selector(run) withObject:nil];</div></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>1.优点：NSThread比其他两种多线程方案较轻量级，更直观地控制线程对象<br>2.缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</p><h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>NSOperation的作用</p><ul><li>配合使用NSOperation和NSOperationQueue实现多线程编程</li><li>NSOperation和NSOperationQueue实现多线程的具体步骤<ol><li>先将需要执行的操作封装到一个NSOperation对象中</li><li>然后将NSOperation对象添加到NSOperationQueue中</li><li>系统会自动的将NSOperationQueue中的NSOperation中取出来</li><li>将取出的NSOperation封装的操作放到一条线程中执行</li></ol></li></ul><h3 id="NSOperation的子类"><a href="#NSOperation的子类" class="headerlink" title="NSOperation的子类"></a>NSOperation的子类</h3><p>NSOperation是一个抽象的类,它并不具备封装操作的能力,当我们进行多线程编程的时候,必须使用它的子类.</p><ol><li>NSInvocationOperation</li><li>NSBlockOperation</li><li>自定义子类继承NSOperation,实现内部相对应的方法</li></ol><h3 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h3><p><em>创建NSInvocationOperation对象</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;</div></pre></td></tr></table></figure><p><em>调用start方法开启线程</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)start;</div></pre></td></tr></table></figure><blockquote><p>一旦执行操作，就会调用target的sel方法默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作<br>只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作</p></blockquote><h3 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h3><p><em>创建NSBlockOperation对象</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+(id)blockOperationWithBlock:(void (^)(void))block;</div></pre></td></tr></table></figure><p><em>通过addExecutionBlock:方法添加更多的操作</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)addExecutionBlock:(void (^)(void))block;</div></pre></td></tr></table></figure><blockquote><p>只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作</p></blockquote><h3 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h3><p>NSOperationQueue可以调用start放啊来进行执行任务,但是默认是同步执行的</p><p>如果将NSOperationQueue添加到NSOperationQueue操作队列中,系统会自动异步执行.</p><p>添加操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(void)addOperation:(NSOperation *)op;</div><div class="line">-(void)addOperationWithBlock:(void (^)(void))bloc</div></pre></td></tr></table></figure><h3 id="最大并发数"><a href="#最大并发数" class="headerlink" title="最大并发数"></a>最大并发数</h3><p><strong>什么是并发数</strong></p><p>同时执行的任务数<br>比如，同时开3个线程执行3个任务，并发数就是3</p><p><strong>最大并发数的相关方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(NSInteger)maxConcurrentOperationCount;</div><div class="line">-(void)setMaxConcurrentOperationCount:(NSInteger)cnt;</div></pre></td></tr></table></figure><h3 id="队列的取消-暂停-回复"><a href="#队列的取消-暂停-回复" class="headerlink" title="队列的取消,暂停,回复"></a>队列的取消,暂停,回复</h3><p><strong>取消队列的所有操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)cancelAllOperations;</div></pre></td></tr></table></figure><blockquote><p>提示：也可以调用NSOperation的 -(void)cancel方法取消单个操作</p></blockquote><p><em>暂停和恢复队列</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列</div><div class="line">-(BOOL)isSuspended;</div></pre></td></tr></table></figure><h3 id="操作依赖"><a href="#操作依赖" class="headerlink" title="操作依赖"></a>操作依赖</h3><p>NSOperation之间可以设置依赖来保证执行顺序<br>比如一定要让操作A执行完后，才能执行操作B，可以这么写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[operationB addDependency:operationA]; // 操作B依赖于操作A</div></pre></td></tr></table></figure><p>可以在不同queue的NSOperation之间创建依赖关系</p><h3 id="操作监听"><a href="#操作监听" class="headerlink" title="操作监听"></a>操作监听</h3><p>可以监听一个操作的执行完毕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(void (^)(void))completionBlock;</div><div class="line">-(void)setCompletionBlock:(void (^)(void))block;</div></pre></td></tr></table></figure><h3 id="自定义NSOperation"><a href="#自定义NSOperation" class="headerlink" title="自定义NSOperation"></a>自定义NSOperation</h3><p><em>自定义NSOperation的步骤</em></p><p>重写<code>-(void)main</code>方法，在里面实现想执行的任务</p><p>重写<code>-(void)main</code>方法的注意点<br>自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）<br>经常通过<code>- (BOOL)isCancelled</code>方法检测操作是否被取消，对取消做出响应</p><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>GCD 是 libdispatch 的市场名称，而 libdispatch 作为 Apple 的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点：</p><ol><li>GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。</li><li>GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。</li><li>GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力</li></ol><p>（未完待续）</p><p>参考文献：</p><p>[1] <a href="http://blog.chinaunix.net/uid-20528014-id-333508.html" target="_blank" rel="noopener">fireaxe - Pthread编程基础 </a></p>]]></content>
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>将博客迁移到了github</title>
      <link href="/2016/03/08/cjek1d3kh003trhrds1yctu57/"/>
      <content type="html"><![CDATA[<p>折腾了一天终于将博客迁移到了github上,以前一直用的都是WordPress,这几天看一些大牛的微博发现有很多人用的都是hexo于是在好奇心的驱使下搜了一下,发现很有逼格,身为一个不折腾就会死的人我便开始了迁移之路,这篇博文并不会讲如何迁移,因为今天没有时间了,等过两天进行一下总结,熟悉一下hexo.</p><p>在用WordPress的时候,有的博文中有html标签,hexo用的markdown很多标签不兼容,这样就导致了,导入WordPress文章的时候会出现错误,要删除其中的标签,头晕了一个晚上,一激动把一些博文删掉了.</p><p>之前的博文有很多人转载的东西,我也全都删除了,就留下了一些比较有用的东西,以后的博文也我要尽量的去试着原创,毕竟那也是一种不错的挑战.</p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动info.plist后无法运行</title>
      <link href="/2016/03/04/cjek1d3li005lrhrd5awwejo0/"/>
      <content type="html"><![CDATA[<p>今天做项目的时候,不小心将info.plist移动了,再移动回项目中的时候直接报错,查了一下百度找到了解决办法.</p><p>只需要在bulid Phases中的Copy Bundle Resources重新加入info.plist即可</p><a id="more"></a><p><img src="http://www.aircrayon.xyz/uploads/123.png" alt="info.plist"></p>]]></content>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>统一设置tabBarItem字体样式</title>
      <link href="/2016/03/04/cjek1d3lm005urhrdot8jc1ul/"/>
      <content type="html"><![CDATA[<p>一般我们在使用tabBar的时候都需要进行自定义,统一设置其字体样式的方法如下.</p><p>在iOS开发中有两个方法:load与initialize.</p><p>load是在类加载的时候会自动调用,iOS工程在运行的时候,会自动将工程内的类加载到内存之中,这个时候就是load执行的时候.</p><p>initialize是在第一次使用或者调用子类的时候回自动执行,具有初始化类的功能,我们可以通过这两个方式的执行特性来对tabBarItem的样式进行设置.</p><p>tabBarItem其实是一个模型(Item是苹果对模型的一种命名规范),我们并不能够对模型直接格式操作,但是我们可以对控件的格式进行设置,这样也就是使用到了文本属性(富文本)来进行设置.</p><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+(void)initialize&#123;</div><div class="line">    //获取所有的tabBarItem 获取所有的外观</div><div class="line">    UITabBarItem *item = [UITabBarItem appearance];</div><div class="line">    NSMutableDictionary *att = [[NSMutableDictionary alloc]init];</div><div class="line">    [att setObject:[UIColor grayColor] forKey:NSForegroundColorAttributeName];</div><div class="line">    NSMutableDictionary *selectedAtt = [[NSMutableDictionary alloc]init];</div><div class="line">    [selectedAtt setObject:[UIColor orangeColor] forKey:NSForegroundColorAttributeName];</div><div class="line">    [item setTitleTextAttributes:att forState:UIControlStateNormal];</div><div class="line">    [item setTitleTextAttributes:selectedAtt forState:UIControlStateSelected];    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样一来我们就完成了样式的设置,appearance在英语中的意思是外观,在iOS中算是一个标记,通过这个标记,我们可以取得UITabBarItem中所有Item的外观.</p>]]></content>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用iOS本地通知</title>
      <link href="/2016/03/03/244/"/>
      <content type="html"><![CDATA[<p>在 iOS 开发中推送通知被分为两种，本地通知与推送通知，</p><p>本地通知是应用在后台运行时，把一些消息提示给用户，一个很好的例子就是基于定位的应用，这类应用在后台运行，到他发现到达某个特殊地点是给予用户提醒，本地通知只能使用在 iOS 设备中，他可以立即发出通知也可以在计划时间后发出。</p><p>本地通知只是应用所在设备上给用户通知，而推送通知是远程通知，它是由远程服务器推送过来的。无论是哪一种，通知的形式都是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//本地推送,主要用于一些常规类的提醒</div><div class="line">    /**</div><div class="line">     *  1.健康类 定时几点运动</div><div class="line">     *  2.社交类 几点约会</div><div class="line">     *  3.游戏类 到时见领取奖励</div><div class="line">     *  4.新闻类 每日早间提醒阅读</div><div class="line">     *  5.医药类 你该吃药了,药别停</div><div class="line">     */</div><div class="line">     </div><div class="line">    //在iOS8下需要注册一下本地推送</div><div class="line">    [[UIApplication sharedApplication] registerUserNotificationSettings: [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge|UIUserNotificationTypeAlert|UIUserNotificationTypeSound categories:nil]];</div><div class="line">    //初始创建本地推送</div><div class="line">    UILocalNotification *local = [[UILocalNotification alloc]init];</div><div class="line">    //设置推送时间</div><div class="line">    local.fireDate = [NSDate dateWithTimeIntervalSinceNow:5];</div><div class="line">    //设置推送的内容</div><div class="line">    local.alertBody = @&quot;你该吃药了!&quot;;</div><div class="line">    //设置时区 根据当前手机时区设置的</div><div class="line">    local.timeZone = [NSTimeZone defaultTimeZone];</div><div class="line">    //设置重复的间隔</div><div class="line">    local.repeatInterval = kCFCalendarUnitDay;</div><div class="line">    //设置推送声音(本地需要有相对应的声音,该声音需要少于三十秒)</div><div class="line">    //local.soundName = UILocalNotificationDefaultSoundName;</div><div class="line">    local.soundName = @&quot;音效.caf&quot;;</div><div class="line">    local.userInfo = @&#123;@&quot;name&quot;:@&quot;王花花&quot;&#125;;</div><div class="line">    local.applicationIconBadgeNumber = 9999;</div><div class="line">    //加入到系统级推送</div><div class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:local];</div></pre></td></tr></table></figure><p>清除本地推送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//如何取消推送</div><div class="line">//获取目前已经加入本地消息推送的有几个.</div><div class="line">NSArray *array = [[UIApplication sharedApplication]scheduledLocalNotifications];</div><div class="line">//遍历推送内容</div><div class="line">for (UILocalNotification *notification in array) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;,notification.userInfo);</div><div class="line">    //如果遇到我们想要取消的本地推送</div><div class="line">    [[UIApplication sharedApplication] cancelLocalNotification:notification];</div><div class="line">&#125;</div><div class="line">//如果全部取消</div><div class="line">//[[UIApplication sharedApplication]cancelAllLocalNotifications];</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS推送通知</title>
      <link href="/2016/03/03/244/"/>
      <content type="html"><![CDATA[<p>iOS 于2008年问世时，只能有一个第三方应用处于活动状态（位于前台）。这意味着应用需要执行的任务都必须在应用位于前台时完成，佛泽任务将暂停并在应用下次启动时接着执行。iOS4退出后，向第三方应用提供了后台功能。鉴于 iOS 设备的系统资源有限，且节省电量至关重要，对后台处理有些限制，那就是不能干扰前台引用，也不能消耗太多电量。通过妥善的利用后台功能，引用能做很多事情。</p><p>iOS 支持两种后台任务处理方式</p><ul><li>第一种方式是在后台完成耗时操作。这种方式适合用于完成大量数据下载或更新等任务，他们需要的时间超过了用户与应用交互的时间。</li><li>第二种方式是执行 iOS 润徐的后台活动，如播放音乐、蓝牙交互、监视 GPS 数据以及获取位置变化、维持永久网络连接让 VoIP应用能够正常运行。</li></ul><h2 id="检查设备是否支持后台处理"><a href="#检查设备是否支持后台处理" class="headerlink" title="检查设备是否支持后台处理"></a>检查设备是否支持后台处理</h2><p>能够运行 iOS6或者 iOS5的设备都支持在后台执行活动，这在 Apple 文档中称之为多任务，如果应用需要支持 iOS4就需要注意了，因为有些设备不支持多任务。编写使用多任务功能的代码，需要检测设备是否支持多任务。</p>]]></content>
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多线程.01 简介</title>
      <link href="/2016/03/01/cjek1d3lk005orhrdl58npypn/"/>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们为何需要多线程呢？多线程其实是为了实现并发执行，而且线程是并发执行多个代码路径的多种技术之中比较轻量级的一种（对应较重的实现是多进程）。</p><p>在单核 CPU 时代，支持多线程的操作系统会通过分配 CPU 计算时间，来实现软件层面的多线程。创建线程，线程间切换都是有成本开销的。但由于多线程可以避免阻塞所造成的 CPU 计算时间浪费，所以多线程所带来的开销成本总体看来是值得的。任务一般都可以被拆分成多个子任务，如果一个子任务发生了阻塞，计算时间就可以分配给其他子任务。这样就提高了 CPU 的利用率。</p><p>在多核 CPU 时代，就更好理解了。由于硬件上就支持多线程技术，就可以让多个线程真正同时地运行。如果任务能够被拆分，各个子任务就能并行地在 CPU 上运行，这就能显著加快运行速度。</p><p>总结说来，多线程的目的是，通过并发执行提高 CPU 的使用效率，进而提供程序运行效率。</p><p>OS X 和 iOS 是多线程操作系统，它们追随 UNIX 系统使用了 POSIX 线程模型。OS X 和 iOS 都提供了一套底层的 C 语言 POSIX 线程 API 来创建和管理线程。但实际应用开发中，除非需要跨平台，我们并不常直接使用 POSIX 线程 API，而是使用系统或语言提供的其他一些更为简单的方案。</p><h1 id="多线程基本概念"><a href="#多线程基本概念" class="headerlink" title="多线程基本概念"></a>多线程基本概念</h1><p>在了解多线程之前，我们应该先搞懂几个概念，首先了解几个基本概念</p><ol><li>进程</li><li>线程</li><li>多线程</li><li>主线程</li></ol><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程（process），是计算机中已运行程序的实体。在面向线程设计的系统中，进程是线程的容器。程序本身只是指令、数据以及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，而且每个进程皆可以同步或者异步的方法独立运行。现代计算机系统刻在统一时间内以进程的形式将多个程序加载到存储器中，并且借由时间共享（分时复用），在一个处理器上表选出同时运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><h2 id="多线程（软件多线程）"><a href="#多线程（软件多线程）" class="headerlink" title="多线程（软件多线程）"></a>多线程（软件多线程）</h2><p>多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个执行绪，进而提升整体处理性能。</p><p>软件多线程。即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。</p><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在一个 iOS 程序运行后，默认会开启1条线程。称之为主线程或者是 UI 线程。</p><p>主线程是进程的控制流或者执行线程在多线程程序中，主线可以创建一个或多个对等线程（peer thread），从这个时间点开始，这些线程就开始兵法执行，主线程和对等线程的区别仅在于主线程总是进程中第一个运行的线程。从某种程度上看，线程可以看做是轻量级的进程（lightweight process）。</p><p>每个程序都拥有独立的线程上下文（thread context），线程ID（Thread ID，TID），程序计数器（PC），线程栈（stack），一组寄存器（register）和条件码，其中内核正式通过线程ID（TID）来识别线程，进行线程调度的。</p><p>我们要知道，一条线程只能处理一个任务，如果将大规模运算放到主线程之中，就会造成 UI 界面卡顿的现象。</p><h1 id="线程进程的主要区别"><a href="#线程进程的主要区别" class="headerlink" title="线程进程的主要区别"></a>线程进程的主要区别</h1><p>线程和进程的主要区别在于子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其知心上下文，多线程主要是为了节省CPU时间，发挥利用，根据具体情况而定。线程的运行需要使用计算机的内存资源和CPU。<br>​    </p><h2 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h2><h3 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h3><ol><li>能适当提高程序的执行效率</li><li>能适当提高资源利用率（CPU、内存利用率）</li></ol><h3 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h3><ol><li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li><li>线程越多，CPU在调度线程上的开销就越大</li><li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] 维基百科</p><p>[3] <a href="http://www.infoq.com/cn/articles/os-x-ios-multithread-technology" target="_blank" rel="noopener">OS X 和 iOS 中的多线程技术 infoq</a></p><p>[2] <a href="http://blog.chinaunix.net/uid-20528014-id-333508.html" target="_blank" rel="noopener">fireaxe - Pthread编程基础 </a></p>]]></content>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Objective-C Block的基本使用</title>
      <link href="/2016/02/17/231/"/>
      <content type="html"><![CDATA[<h2 id="一、Block-的定义"><a href="#一、Block-的定义" class="headerlink" title="一、Block 的定义"></a>一、Block 的定义</h2><p>定义和使用Block，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">  </div><div class="line">//（1）定义无参无返回值的Block</div><div class="line">void (^printBlock)() = ^()&#123;</div><div class="line">printf(&quot;no number&quot;);</div><div class="line">&#125;;</div><div class="line">  </div><div class="line">printBlock();</div><div class="line">printBlock(9);</div><div class="line">  </div><div class="line">int mutiplier = 7;</div><div class="line">//（3）定义名为myBlock的代码块，返回值类型为int</div><div class="line">int (^myBlock)(int) = ^(int num)&#123;</div><div class="line">return num*mutiplier;</div><div class="line">&#125;</div><div class="line">//使用定义的myBlock</div><div class="line">int newMutiplier = myBlock(3);</div><div class="line">printf(&quot;newMutiplier is %d&quot;,myBlock(3));</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义在-viewDidLoad方法外部</div><div class="line">//（2）定义一个有参数，没有返回值的Block</div><div class="line">void (^printNumBlock)(int) = ^(int num)&#123;</div><div class="line">printf(&quot;int number is %d&quot;,num);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>定义Block变量，就相当于定义了一个函数。但是区别也很明显，因为函数肯定是在-viewDidLoad方法外面定义，而Block变量定义在了viewDidLoad方法内部。当然，我们也可以把Block定义在-viewDidLoad方法外部，例如上面的代码块printNumBlock的定义，就在-viewDidLoad外面。</p><p>再来看看上面代码运行的顺序问题，以第（3）个myBlock距离来说，在定义的地方，并不会执行Block{}内部的代码，而在myBlock(3)调用之后才会执行其中的代码，这跟函数的理解其实差不多，就是只要在调用Block（函数）的时候才会执行Block体内（函数体内）的代码。所以上面的简单代码示例，我可以作出如下的结论，</p><ol><li>在类中，定义一个Block变量，就像定义一个函数；</li><li>Block可以定义在方法内部，也可以定义在方法外部；</li><li>只有调用Block时候，才会执行其{}体内的代码；</li></ol><p>（PS：关于第（2）条，定义在方法外部的Block，其实就是文件级别的全局变量）</p><p>那么在类中定义一个Block，特别是在-viewDidLoad方法体内定义一个Block到底有什么意义呢？我表示这时候只把它当做私有函数就可以了。我之前说过，Block其实就相当于代理，那么这时候我该怎样将其与代理类比以了解呢。这时候我可以这样说：本类中的Block就相当于类自己服从某个协议，然后让自己代理自己去做某个事情。很拗口吧？看看下面的代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//定义一个协议</div><div class="line">@protocol ViewControllerDelegate</div><div class="line">- (void)selfDelegateMethod;</div><div class="line">@end</div><div class="line">//本类实现这个协议ViewControllerDelegate</div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic, assign) id delegate;</div><div class="line">@end</div></pre></td></tr></table></figure><p>接着在-viewDidLoad中的代码如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line">// Do any additional setup after loading the view from its nib.</div><div class="line">self.delegate = self;</div><div class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(selfDelegateMethod)] &#123;</div><div class="line">[self.delegate selfDelegateMethod];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">        </div><div class="line">#pragma mark - ViewControllerDelegate method</div><div class="line">//实现协议中的方法</div><div class="line">- (void)selfDelegateMethod&#123;</div><div class="line">NSLog(@&quot;自己委托自己实现的方法&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>看出这种写法的奇葩地方了吗？自己委托自己去实现某个方法，而不是委托别的类去实现某个方法。本类中定义的一个Block其实就是闲的蛋疼，委托自己去字做某件事情，实际的意义不大，所以你很少看见别人的代码直接在类中定义Block然后使用的，Block很多的用处是跨越两个类来使用的，比如作为property属性或者作为方法的参数，这样就能跨越两个类了。</p><h2 id="二、-block关键字的使用"><a href="#二、-block关键字的使用" class="headerlink" title="二、__block关键字的使用"></a>二、__block关键字的使用</h2><p>在Block的{}体内，是不可以对外面的变量进行更改的，比如下面的语句，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">//将Block定义在方法内部</div><div class="line">int x = 100;</div><div class="line">void (^sumXAndYBlock)(int) = ^(int y)&#123;</div><div class="line">x = x+y;</div><div class="line">printf(&quot;new x value is %d&quot;,x);</div><div class="line">&#125;;</div><div class="line">sumXAndYBlock(50);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码有什么问题呢，Xcode会提示x变量错误信息：Variable is not assigning (missing__block type)，这时候给int x = 100;语句前面加上__block关键字即可，如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__block int x = 100;</div></pre></td></tr></table></figure><p>这样在Block的{}体内，就可以修改外部变量了。</p><h2 id="三、Block作为Property属性实现页面之间传值"><a href="#三、Block作为Property属性实现页面之间传值" class="headerlink" title="三、Block作为Property属性实现页面之间传值"></a>三、Block作为Property属性实现页面之间传值</h2><p>需求：在ViewController中，点击Button，push到下一个页面NextViewController，在NextViewController的输入框TextField中输入一串字符，返回的时候，在ViewController的Label上面显示文字内容，</p><p><strong>（1）第一种方法：首先看看通过“协议/代理”是怎么实现两个页面之间传值的吧，</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//NextViewController是push进入的第二个页面</div><div class="line">//NextViewController.h 文件</div><div class="line">//定义一个协议，前一个页面ViewController要服从该协议，并且实现协议中的方法</div><div class="line">@protocol NextViewControllerDelegate</div><div class="line">- (void)passTextValue:(NSString *)tfText;</div><div class="line">@end</div><div class="line">  </div><div class="line">@interface NextViewController : UIViewController</div><div class="line">@property (nonatomic, assign) id delegate;</div><div class="line">@end</div></pre></td></tr></table></figure><p>//NextViewController.m 文件<br>//点击Button返回前一个ViewController页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (IBAction)popBtnClicked:(id)sender &#123;</div><div class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(passTextValue:)]) &#123;</div><div class="line">//self.inputTF是该页面中的TextField输入框</div><div class="line">    [self.delegate passTextValue:self.inputTF.text];</div><div class="line">&#125;</div><div class="line">[self.navigationController popViewControllerAnimated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来我们在看看ViewController文件中的内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//ViewController.m 文件</div><div class="line">@interface ViewController ()</div><div class="line">@property (strong, nonatomic) IBOutlet UILabel *nextVCInfoLabel;</div><div class="line">@end</div><div class="line">//点击Button进入下一个NextViewController页面</div><div class="line">- (IBAction)btnClicked:(id)sender</div><div class="line">&#123;</div><div class="line">NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil];</div><div class="line">nextVC.delegate = self;//设置代理</div><div class="line">[self.navigationController pushViewController:nextVC animated:YES];</div><div class="line">&#125;</div><div class="line">//实现协议NextViewControllerDelegate中的方法</div><div class="line">#pragma mark - NextViewControllerDelegate method</div><div class="line">- (void)passTextValue:(NSString *)tfText</div><div class="line">&#123;</div><div class="line">//self.nextVCInfoLabel是显示NextViewController传递过来的字符串Label对象</div><div class="line">self.nextVCInfoLabel.text = tfText;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是通过“协议/代理”来实现的两个页面之间传值的方式。<br><strong>（2）第二种方法：使用Block作为property，实现两个页面之间传值，</strong><br>先看看NextViewController文件中的内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//NextViewController.h 文件</div><div class="line">@interface NextViewController : UIViewController</div><div class="line">@property (nonatomic, copy) void (^NextViewControllerBlock)(NSString *tfText);</div><div class="line">@end</div><div class="line">//NextViewContorller.m 文件</div><div class="line">- (IBAction)popBtnClicked:(id)sender &#123;</div><div class="line">if (self.NextViewControllerBlock) &#123;</div><div class="line">self.NextViewControllerBlock(self.inputTF.text);</div><div class="line">&#125;</div><div class="line">[self.navigationController popViewControllerAnimated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再来看看ViewController文件中的内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (IBAction)btnClicked:(id)sender&#123;</div><div class="line">NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil];</div><div class="line">nextVC.NextViewControllerBlock = ^(NSString *tfText)&#123;</div><div class="line">[self resetLabel:tfText];</div><div class="line">&#125;;</div><div class="line">[self.navigationController pushViewController:nextVC animated:YES];</div><div class="line">&#125;</div><div class="line">#pragma mark - NextViewControllerBlock method</div><div class="line">- (void)resetLabel:(NSString *)textStr &#123;</div><div class="line">self.nextVCInfoLabel.text = textStr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好了就这么多代码，可以使用Block来实现两个页面之间传值的目的，实际上就是取代了Delegate的功能。</p><p>另外，博客中的代码Sample Code可以再Github下载，如果因为Github被墙了，可以在终端使用git clone + 完整链接，即可克隆项目到本地。</p><p>Github中的代码，可以开启两种调试模式，你需要在项目的配置文件BlockSamp-Prefix.pch中注释或者解注释下面的代码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define Debug_BlcokPassValueEnable</div></pre></td></tr></table></figure><p>即可开启两种调试的方式，如果注释了上面的语句就是使用Delegate进行调试；否则使用Block进行调试。</p>]]></content>
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CGFloat、CGPoint、CGSize和CGRect</title>
      <link href="/2016/01/31/2/"/>
      <content type="html"><![CDATA[<p>CGFloat、CGPoint、CGSize和CGRect主要是用来描述UI控件的几何属性的基本类型。</p><ul><li>CGFloat: 浮点值的基本类型</li><li>CGPoint: 表示一个二维坐标系中的点</li><li>CGSize: 表示一个矩形的宽度和高度</li><li>CGRect: 表示一个矩形的位置和大小</li></ul><h2 id="CGFloat"><a href="#CGFloat" class="headerlink" title="CGFloat"></a>CGFloat</h2><p>CGFloat是这四种类型中最基本的类型，这是一个浮点型的数据，他就是一个数值，下面三种类型都需要使用该数值来进行赋值，当我们使用CMD键进入CGBase.h文件后，可以清楚的看到关于CGFloat的定义，映入眼帘的是一个别名定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> CGFLOAT_TYPE CGFloat;</div></pre></td></tr></table></figure><p>当我们CMD点击CGFLOAT_TYPE的时候，我们可以跳转到宏定义的代码区域，其实就在其上面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__) &amp;amp;&amp;amp; __LP64__</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> CGFLOAT_TYPE double</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> CGFLOAT_IS_DOUBLE 1</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> CGFLOAT_MIN DBL_MIN</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> CGFLOAT_MAX DBL_MAX</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> CGFLOAT_TYPE float</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> CGFLOAT_IS_DOUBLE 0</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> CGFLOAT_MIN FLT_MIN</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> CGFLOAT_MAX FLT_MAX</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>我们可以清晰的看到这就是一段宏定义，#if defined(<strong>LP64</strong>) &amp;&amp; <strong>LP64</strong>这一段代码主要使用来判断操作系统是64位还是32位，如果是64位那么CGFloat就是double类型，如果不是那边是32位操作系统，则会被系统定义为float类型,接下来的三种类型都是基于CGFloat的结构体。</p><h2 id="CGPoint"><a href="#CGPoint" class="headerlink" title="CGPoint"></a>CGPoint</h2><p>CGPoint用于表示二维坐标系中的某一个点，在IOS中以左上角（0，0）为起始坐标。<br>CMD进入CGGeometry.h中便可以直接查看其类型的定义如下（CGSize、CGRect都在此文件中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CGPoint</span> &#123;</span></div><div class="line">    CGFloat x;</div><div class="line">    CGFloat y;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CGPoint</span> <span class="title">CGPoint</span>;</span></div></pre></td></tr></table></figure><h2 id="CGSize"><a href="#CGSize" class="headerlink" title="CGSize"></a>CGSize</h2><p>CGSize主要用于描述UI控件的宽与高</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CGSize</span> &#123;</span></div><div class="line">    CGFloat width;</div><div class="line">    CGFloat height;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CGSize</span> <span class="title">CGSize</span>;</span></div></pre></td></tr></table></figure><h2 id="CGRect"><a href="#CGRect" class="headerlink" title="CGRect"></a>CGRect</h2><p>CGRect同样也是一个结构体，通过上面的了解，我们知道了原来CGRect是由CGSize和CGPoint组成，这样一来便可以确定一个UI空间的大小与位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CGRect</span> &#123;</span></div><div class="line">    CGPoint origin;</div><div class="line">    CGSize size;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CGRect</span> <span class="title">CGRect</span>;</span></div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>懒加载与模型转换</title>
      <link href="/2016/01/30/219/"/>
      <content type="html"><![CDATA[<p>所谓的懒加载其实就是重写getter方法，以实现实例化类的同时自动加载数据，简化代码的一个作用,代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//这是一个实例</div><div class="line">-(NSArray*)question&#123;</div><div class="line">if (!_question) &#123;</div><div class="line">//判断是否为空</div><div class="line">_question = [GZModelName questionList];</div><div class="line">&#125;</div><div class="line">return _question;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来便是模型转化,因为使用点语法写起来的方法也非常简单，只需要重新定义构造方法即可,其中用到的plist文件如下图：</p><p><a href="http://www.aircrayon.xyz/wp-content/uploads/2016/01/1.png" target="_blank" rel="noopener"><img src="http://www.aircrayon.xyz/wp-content/uploads/2016/01/1-300x97.png" alt="1"></a></p><p>.h文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface GZQuestion : NSObject</div><div class="line">@property (nonatomic,copy) NSString *answer;</div><div class="line">@property (nonatomic,copy) NSString *icon;</div><div class="line">@property (nonatomic,copy) NSString *title;</div><div class="line">@property (nonatomic,strong) NSArray *options;</div><div class="line">-(instancetype)initWithDic:(NSDictionary *)dic;</div><div class="line">+(instancetype)questionWithDic:(NSDictionary *)dic;</div><div class="line">+(NSArray*)questionList;</div><div class="line">@end</div></pre></td></tr></table></figure><p>.m文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">-(instancetype)initWithDic:(NSDictionary *)dic&#123;</div><div class="line">if (self = [super init]) &#123;</div><div class="line">//KVC 直接从字典中读取对应的值，需要注意的是，定义的属性名称，要与字典的key值相对应，否则会崩溃</div><div class="line">[self setValuesForKeysWithDictionary:dic];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line">+(instancetype)questionWithDic:(NSDictionary *)dic&#123;</div><div class="line">return [[self alloc]initWithDic:dic];</div><div class="line">&#125;</div><div class="line">+(NSArray *)questionList&#123;</div><div class="line">//加载plist</div><div class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;questions&quot; ofType:@&quot;plist&quot;];</div><div class="line">NSArray *dicArray = [NSArray arrayWithContentsOfFile:path];</div><div class="line">//字典转模型</div><div class="line">NSMutableArray *tempArray = [NSMutableArray array];</div><div class="line">for (NSDictionary *dic in dicArray) &#123;</div><div class="line">GZQuestion *question = [GZQuestion questionWithDic:dic];</div><div class="line">[tempArray addObject:question];</div><div class="line">&#125;</div><div class="line">return tempArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Objective-C 简单的数组排序</title>
      <link href="/2016/01/05/3/"/>
      <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *array  = [NSMutableArray arrayWithObjects:@"8123",@"456",@"378", nil];</div><div class="line"></div><div class="line">NSComparator cmp = ^(id obj,id obj1)</div><div class="line">&#123;</div><div class="line">return [obj compare:obj1];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[array sortUsingComparator:cmp];</div><div class="line"></div><div class="line">NSLog(@"%@",array);&lt;/pre&gt;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS多线程</title>
      <link href="/2015/12/10/1/"/>
      <content type="html"><![CDATA[<p>NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在制定的线程中、或者立即、延迟执行某个方法调用个。这个方法给用户实现多线程编程最简单的方法。</p><p>在当前线程中执行方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay</div><div class="line"></div><div class="line">- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay: (NSTimeInterval)delay inModes:(NSArray *)modes</div></pre></td></tr></table></figure><p>在指定线程中执行方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread </div><div class="line">withObject:(id)arg waitUntilDone:(BOOL)wait</div><div class="line"></div><div class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:</div><div class="line">(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array</div></pre></td></tr></table></figure><p>在主线程中执行方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)performSelectorOnMainThread: (SEL)selector withObject:(id)argument </div><div class="line">waitUntilDone:(BOOL)wait</div><div class="line"></div><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg </div><div class="line">waitUntilDone:(BOOL)wait modes:(NSArray *)array</div></pre></td></tr></table></figure><p>在后台线程中执行方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg</div></pre></td></tr></table></figure><p>这一系列方法简单易用，但只提供了有限的几个选择：指定执行的方法（但传入方法的参数数量有限制）；指定是在当前线程，还是在主线程，还是在后台线程执行；指定是否需要阻塞当前线程等待结果。</p><p>例如，以下代码使得方法 foo: 在一个新的后台线程执行，并传入了 object 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SEL selector ＝ @selector(foo:);</div><div class="line">[self performSelectorInBackground:selector withObject:object];</div></pre></td></tr></table></figure><p>以下代码使得 updateUI 方法在主线程内得到执行，并且当前线程会被阻塞，直到主线程执行完该函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self performSelectorOnMainThread:@selector(updateUI) withObject:nil waitUntilDone:YES];</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objc,多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>域名即将到期了，也不打算续费了。</title>
      <link href="/2015/08/28/108/"/>
      <content type="html"><![CDATA[<p>额，以前一直没有注意，就这样的一个pw结尾的域名竟然都会被劫持，我也真是醉了。</p><p>以前DNSPOD提示我有异常登陆，我也没在意，结果今天site了一下域名，结果尴尬的发现被泛解析了，我也真是醉了，全都是博彩网站。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DATA URI image封装类</title>
      <link href="/2015/08/17/94/"/>
      <content type="html"><![CDATA[<p>Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class DataBase64&#123;</div><div class="line">public $file = &apos;&apos;;</div><div class="line">public function __construct($file)&#123;</div><div class="line">$this-&gt;file = $file;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public function getBase64()&#123;</div><div class="line">$type = getimagesize($this-&gt;file);</div><div class="line">$fp = fopen($this-&gt;file, &apos;r&apos;) or die(&quot;Can&apos;t open file&quot;);</div><div class="line">$file_content= chunk_split(base64_encode(fread($fp, filesize($this-&gt;file)))) ;</div><div class="line">switch($type[2])&#123;//判读图片类型  </div><div class="line">case 1:$img_type=&quot;gif&quot;;break;  </div><div class="line">case 2:$img_type=&quot;jpg&quot;;break;  </div><div class="line">case 3:$img_type=&quot;png&quot;;break;  </div><div class="line">&#125;  </div><div class="line">return $img=&apos;data:image/&apos;.$img_type.&apos;;base64,&apos;.$file_content;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">$data = new DataBase64(&apos;image/1.jpg&apos;);</div><div class="line">$img = $data-&gt;getBase64();</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>目录常量：PATH_SEPARATOR和DIRECTORY_SEPARATOR</title>
      <link href="/2015/07/30/46/"/>
      <content type="html"><![CDATA[<p><strong>DIRECTORY_SEPARATOR（string）</strong></p><p>目录分隔符，这是PHP内置的一个常量，代表着”/“或“”</p><p>因为系统原因，目录的分隔符被分为两种，在windows中目录的分割符号可以使用‘/’或者‘’，但是在linux中目录分隔符只能使用’/‘;</p><p><strong>PATH_SEPARATOR</strong></p><p>路径分隔符，同样是PHP内置的一个常量，在windows系统中，如果使用include包含多个路径可以使用分号（;）来进行分割，可是在linux系统中却要使用冒号（：）。</p><p>这两个常量主要就是用来解决linux与windows的兼容问题，避免因为系统差异出现的错误，可以增强移植性。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>deepin下安装 php的扩展</title>
      <link href="/2015/05/26/36/"/>
      <content type="html"><![CDATA[<p>一直没用过linux开发PHP，昨天试了一下，却发现deepin下安装的php默认是不开其扩展的，可是PHP.INI中却没有开启扩展的选项，无奈之下百度了一番，却发现文章很少，但是却找到了ubuntu的命令，型号deepin的命令跟ubuntu一样，到是解决了PHP扩展的一些问题，原来只需要将所需要的扩展下载下来，重启服务器便可。</p><p>代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install php5-你所需要的扩展。</div><div class="line"></div><div class="line">sudo service apache2 restart</div></pre></td></tr></table></figure><p>这样用来扩展就可以使用了。</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Smarty3封装类</title>
      <link href="/2015/05/21/200/"/>
      <content type="html"><![CDATA[<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// load Smarty library </span></div><div class="line">   <span class="keyword">require</span>(<span class="string">'Smarty.class.php'</span>); </div><div class="line"><span class="comment">// The setup.php file is a good place to load </span></div><div class="line"><span class="comment">// required application library files, and you </span></div><div class="line"><span class="comment">// can do that right here. An example: </span></div><div class="line">   <span class="keyword">require</span>(<span class="string">'guestbook/guestbook.lib.php'</span>); </div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Smarty_GuestBook</span> <span class="keyword">extends</span> <span class="title">Smarty</span> </span>&#123;    </div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;         </div><div class="line"><span class="comment">// Class Constructor.         </span></div><div class="line"><span class="comment">// These automatically get set with each new instance.         </span></div><div class="line">        <span class="keyword">parent</span>::__construct();         </div><div class="line">        <span class="keyword">$this</span>-&gt;setTemplateDir(<span class="string">'/web/www.example.com/guestbook/templates/'</span>);</div><div class="line">        <span class="keyword">$this</span>-&gt;setCompileDir(<span class="string">'/web/www.example.com/guestbook/templates_c/'</span>);</div><div class="line">        <span class="keyword">$this</span>-&gt;setConfigDir(<span class="string">'/web/www.example.com/guestbook/configs/'</span>);</div><div class="line">        <span class="keyword">$this</span>-&gt;setCacheDir(<span class="string">'/web/www.example.com/guestbook/cache/'</span>);</div><div class="line">        <span class="keyword">$this</span>-&gt;caching = Smarty::CACHING_LIFETIME_CURRENT;</div><div class="line">        <span class="keyword">$this</span>-&gt;assign(<span class="string">'app_name'</span>, <span class="string">'Guest Book'</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP框架编写（二）单入口路由</title>
      <link href="/2015/04/30/cjek1d3ja0026rhrd4c6r1mxw/"/>
      <content type="html"><![CDATA[<h1 id="PHP框架编写（二）单入口路由"><a href="#PHP框架编写（二）单入口路由" class="headerlink" title="PHP框架编写（二）单入口路由"></a>PHP框架编写（二）单入口路由</h1><p>基本思路是浏览器端通过URL字符串提供控制器类的名字和方法的名字，PHP据此找到对应的类和方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/******************************************************* </span></div><div class="line"> * </div><div class="line"> * URL 路由原理展示代码 </div><div class="line"> * </div><div class="line"> * 浏览器访问地址: http://server/index.php?C=Controler1&amp;M=Method1 </div><div class="line"> * 根据C找到控制器类，再根据M找到方法，然后执行这个方法 </div><div class="line"> *  </div><div class="line"> * ****************************************************/ </div><div class="line">  </div><div class="line">$C = <span class="keyword">isset</span>($_GET[<span class="string">'C'</span>]) ? $_GET[<span class="string">'C'</span>]: <span class="keyword">null</span>;  </div><div class="line">$M = <span class="keyword">isset</span>($_GET[<span class="string">'M'</span>]) ? $_GET[<span class="string">'M'</span>]: <span class="keyword">null</span>;  </div><div class="line">  </div><div class="line"><span class="keyword">if</span>($C != <span class="keyword">NULL</span> &amp;&amp; $M != <span class="keyword">NULL</span> &amp;&amp; class_exists($C) &amp;&amp; method_exists($C, $M)) &#123;  </div><div class="line">    $cObj = <span class="keyword">new</span> $C();  </div><div class="line">    $cObj-&gt;$M();  </div><div class="line">&#125;<span class="keyword">else</span>&#123;  </div><div class="line">    <span class="keyword">echo</span> <span class="string">'找不到控制器或方法'</span>;  </div><div class="line">    <span class="keyword">exit</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">// 控制器1  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controler1</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Method1</span><span class="params">()</span>  </span></div><div class="line">    &#123;     </div><div class="line">        <span class="keyword">echo</span> <span class="string">'Controler1, Method1'</span>;  </div><div class="line">    &#125;     </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Method2</span><span class="params">()</span>  </span></div><div class="line">    &#123;     </div><div class="line">        <span class="keyword">echo</span> <span class="string">'Controler1, Method2'</span>;  </div><div class="line">    &#125;     </div><div class="line">&#125;  </div><div class="line"><span class="comment">// 控制器2  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controler2</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Method1</span><span class="params">()</span>  </span></div><div class="line">    &#123;     </div><div class="line">        <span class="keyword">echo</span> <span class="string">'Controler2, Method1'</span>;  </div><div class="line">    &#125;     </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Method2</span><span class="params">()</span>  </span></div><div class="line">    &#123;     </div><div class="line">        <span class="keyword">echo</span> <span class="string">'Controler2, Method2'</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP框架编写（一）：框架运行流程</title>
      <link href="/2015/04/29/6/"/>
      <content type="html"><![CDATA[<p>  首先欢迎各位进入我的博客，我感觉非常荣幸，我并不是什么高手，现在的我不过是个在校的大学生，写这篇系列的博文只不过是为了加深自己对PHP的理解，以及对之前的学习做一个总结，同时也希望各位能够给我提一些意见。</p><p>  PHP框架总给人以高大上的感觉，很多人学框架都学的头晕脑胀，百思不得其解，看完这篇博文后应该可以让还处于迷茫中的学习者找到一个入门的道路。</p><p>  PHP框架到底是什么，框架不过是其他程序员提供的一个快速开发的一个代码而已，他帮助PHP开发者能够快速的开发，免去一些代码而已，PHP框架目前的核心就是MVC和数据库操作，更加大白话一点其实就是编程中最基础的增删改查，不过就是将他变的更加漂亮而已。</p><p>  那么什么是MVC呢，M模型,V显示,C控制器。</p><p>  这基本上是所有教程和书中都会提及的概念，也就不再多进行赘述模糊不清的概念了。</p><p>  M是啥，字面上理解太费劲了，其实M模型我感觉表面上就是对数据库的操作，以及业务逻辑的梳理，这便是M模型，主要进行逻辑分析，将分析的结果传递给C也就是控制器，M就是一个深藏功与名的人，他默默就默默地站在幕后，干着最累的工作。</p><p>V就是显示，也就是其中最好面子的人，他们两个人忙活半天，其实都是在给我忙活，所有东西都处理完了，拿到他这里来显示。</p><p>C控制器，这个字面上就好理解了，那就是起到控制的作用，他控制着全局，属于M和C的一个中间层。（如果说错了，还请高手指正）</p><p>  现在市面上的PHP框架基本上都是单一入口的文件。下面就是一个PHP框架的运行的简单流程图。</p><p>  对PHP框架有了一定的了解之后，我们下一篇就开始讲PHP框架的目录结构了。</p><p>  仅以此文先给刚刚入门的菜鸟，和正在努力奋斗的程序员们，祝各位早日成为攻城狮！出任CTO，赢取白富美，走向人生巅峰。</p><p>  （如有转载，请注明出处，小弟感激不尽。）</p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
