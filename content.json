{"meta":{"title":"Maksim's Website","subtitle":null,"description":null,"author":"Maksim","url":"http://www.maksim.website"},"pages":[{"title":"About","date":"2017-07-04T03:28:00.000Z","updated":"2017-07-04T03:28:00.000Z","comments":true,"path":"about/index.html","permalink":"http://www.maksim.website/about/index.html","excerpt":"","text":"生活很艰辛，没有人是轻松的。 我可能不是很聪明，所以我在努力学习有关于如何学习的方法。 读书对于我来说可能是目前能够让我最快乐的一件事情，虽然我并不经常读书。 找到一份自己喜欢的事情不容易，请不要放弃它，坚持下去，可能你现在所从事的行业与他无关，但时间久了，你坚持说不定会会给你带来意外的惊喜。 如果可以，我想以码字为生，因为当年抓阄我抓的是个笔杆子。‘’ 偶尔也会孤独，偶尔也会迷茫，想想大学里的荒唐，也就不迷茫了、不孤独了。 ————国柱(Maksim)一名开发者的自述。"},{"title":"Categories","date":"2017-06-01T01:17:24.000Z","updated":"2017-06-01T01:17:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.maksim.website/categories/index.html","excerpt":"","text":""},{"title":"Search","date":"2018-03-09T13:45:59.000Z","updated":"2018-03-09T13:45:59.772Z","comments":true,"path":"Search/index.html","permalink":"http://www.maksim.website/Search/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-01T01:17:31.000Z","updated":"2017-06-01T01:17:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.maksim.website/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"未命名","date":"2018-03-09T14:43:55.932Z","updated":"2018-03-09T14:45:17.219Z","comments":true,"path":"2018/03/09/cjek1zh7d005sx9rds2aj2jdw/","link":"","permalink":"http://www.maksim.website/2018/03/09/cjek1zh7d005sx9rds2aj2jdw/","excerpt":"","text":"title:深入理解JavaScript系列（2）：揭秘命名函数表达式date:2018-3-9categories:javascript id:2 2011-12-29 09:02 by 汤姆大叔 原地址：http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html 前言网上还没用发现有人对命名函数表达式进去重复深入的讨论，正因为如此，网上出现了各种各样的误解，本文将从原理和实践两个方面来探讨JavaScript关于命名函数表达式的优缺点。 简单的说，命名函数表达式只有一个用户，那就是在Debug或者Profiler分析的时候来描述函数的名称，也可以使用函数名实现递归，但很快你就会发现其实是不切实际的。当然，如果你不关注调试，那就没什么可担心的了，否则，如果你想了解兼容性方面的东西的话，你还是应该继续往下看看。 我们先开始看看，什么叫函数表达式，然后再说一下现代调试器如何处理这些表达式，如果你已经对这方面很熟悉的话，请直接跳过此小节。 函数表达式和函数声明在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者期间的区别是有点晕，因为ECMA规范只明确了一点：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符： 函数声明: function 函数名称 (参数：可选){ 函数体 } 函数表达式： function 函数名称（可选）(参数：可选){ 函数体 } 所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称的话，如何判断是函数声明还是函数表达式呢？ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。 12345678function foo()&#123;&#125; // 声明，因为它是程序的一部分var bar = function foo()&#123;&#125;; // 表达式，因为它是赋值表达式的一部分new function bar()&#123;&#125;; // 表达式，因为它是new表达式(function()&#123; function bar()&#123;&#125; // 声明，因为它是函数体的一部分&#125;)(); 还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式，我们来看几个例子： 12345678function foo()&#123;&#125; // 函数声明(function foo()&#123;&#125;); // 函数表达式：包含在分组操作符内try &#123; (var x = 5); // 分组操作符，只能包含表达式而不能包含语句：这里的var就是语句&#125; catch(err) &#123; // SyntaxError&#125; 你可以会想到，在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval(‘(‘ + json + ‘)’)，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。 1234567try &#123; &#123; &quot;x&quot;: 5 &#125;; // &quot;&#123;&quot; 和 &quot;&#125;&quot; 做解析成代码块&#125; catch(err) &#123; // SyntaxError&#125;(&#123; &quot;x&quot;: 5 &#125;); // 分组操作符强制将&quot;&#123;&quot; 和 &quot;&#125;&quot;作为对象字面量来解析 表达式和声明存在着十分微妙的差别，首先，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，参考如下例子，函数fn是在alert之后声明的，但是在alert执行的时候，fn已经有定义了： 12345alert(fn());function fn() &#123; return &apos;Hello world!&apos;;&#125; 另外，还有一点需要提醒一下，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式： 12345678910111213141516171819202122232425262728// 千万别这样做！// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个if (true) &#123; function foo() &#123; return &apos;first&apos;; &#125;&#125;else &#123; function foo() &#123; return &apos;second&apos;; &#125;&#125;foo();// 相反，这样情况，我们要用函数表达式var foo;if (true) &#123; foo = function() &#123; return &apos;first&apos;; &#125;;&#125;else &#123; foo = function() &#123; return &apos;second&apos;; &#125;;&#125;foo(); 函数声明的实际规则如下： 函数声明只能出现在程序或函数体内。从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 函数语句在ECMAScript的语法扩展中，有一个是函数语句，目前只有基于Gecko的浏览器实现了该扩展，所以对于下面的例子，我们仅是抱着学习的目的来看，一般来说不推荐使用（除非你针对Gecko浏览器进行开发）。 1.一般语句能用的地方，函数语句也能用，当然也包括Block块中： 123456if (true) &#123; function f()&#123; &#125;&#125;else &#123; function f()&#123; &#125;&#125; 2.函数语句可以像其他语句一样被解析，包含基于条件执行的情形 123456789if (true) &#123; function foo()&#123; return 1; &#125;&#125;else &#123; function foo()&#123; return 2; &#125;&#125;foo(); // 1// 注：其它客户端会将foo解析成函数声明 // 因此，第二个foo会覆盖第一个，结果返回2，而不是1 3.函数语句不是在变量初始化期间声明的，而是在运行时声明的——与函数表达式一样。不过，函数语句的标识符一旦声明能在函数的整个作用域生效了。标识符有效性正是导致函数语句与函数表达式不同的关键所在（下一小节我们将会展示命名函数表达式的具体行为）。 1234567891011// 此刻，foo还没用声明typeof foo; // &quot;undefined&quot;if (true) &#123; // 进入这里以后，foo就被声明在整个作用域内了 function foo()&#123; return 1; &#125;&#125;else &#123; // 从来不会走到这里，所以这里的foo也不会被声明 function foo()&#123; return 2; &#125;&#125;typeof foo; // &quot;function&quot; 不过，我们可以使用下面这样的符合标准的代码来模式上面例子中的函数语句： 1234567var foo;if (true) &#123; foo = function foo()&#123; return 1; &#125;;&#125;else &#123; foo = function foo() &#123; return 2; &#125;;&#125; 4.函数语句和函数声明（或命名函数表达式）的字符串表示类似，也包括标识符： 1234if (true) &#123; function foo()&#123; return 1; &#125;&#125;String(foo); // function foo() &#123; return 1; &#125; 5.另外一个，早期基于Gecko的实现（Firefox 3及以前版本）中存在一个bug，即函数语句覆盖函数声明的方式不正确。在这些早期的实现中，函数语句不知何故不能覆盖函数声明： 1234567891011121314// 函数声明function foo()&#123; return 1; &#125;if (true) &#123; // 用函数语句重写 function foo()&#123; return 2; &#125;&#125;foo(); // FF3以下返回1，FF3.5以上返回2// 不过，如果前面是函数表达式，则没用问题var foo = function()&#123; return 1; &#125;;if (true) &#123; function foo()&#123; return 2; &#125;&#125;foo(); // 所有版本都返回2 再次强调一点，上面这些例子只是在某些浏览器支持，所以推荐大家不要使用这些，除非你就在特性的浏览器上做开发。 命名函数表达式函数表达式在实际应用中还是很常见的，在web开发中友个常用的模式是基于对某种特性的测试来伪装函数定义，从而达到性能优化的目的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式： 1234567891011121314151617181920// 该代码来自Garrett Smith的APE Javascript library库(http://dhtmlkitchen.com/ape/) var contains = (function() &#123; var docEl = document.documentElement; if (typeof docEl.compareDocumentPosition != &apos;undefined&apos;) &#123; return function(el, b) &#123; return (el.compareDocumentPosition(b) &amp; 16) !== 0; &#125;; &#125; else if (typeof docEl.contains != &apos;undefined&apos;) &#123; return function(el, b) &#123; return el !== b &amp;&amp; el.contains(b); &#125;; &#125; return function(el, b) &#123; if (el === b) return false; while (el != b &amp;&amp; (b = b.parentNode) != null); return el === b; &#125;;&#125;)(); 提到命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效： 123456var f = function foo()&#123; return typeof foo; // foo是在内部作用域内有效&#125;;// foo在外部用于是不可见的typeof foo; // &quot;undefined&quot;f(); // &quot;function&quot; 既然，这么要求，那命名函数表达式到底有啥用啊？为啥要取名？ 正如我们开头所说：给它一个名字就是可以让调试过程更方便，因为在调试的时候，如果在调用栈中的每个项都有自己的名字来描述，那么调试过程就太爽了，感受不一样嘛。 调试器中的函数名如果一个函数有名字，那调试器在调试的时候会将它的名字显示在调用的栈上。有些调试器（Firebug）有时候还会为你们函数取名并显示，让他们和那些应用该函数的便利具有相同的角色，可是通常情况下，这些调试器只安装简单的规则来取名，所以说没有太大价格，我们来看一个例子： 123456789101112131415161718function foo()&#123; return bar();&#125;function bar()&#123; return baz();&#125;function baz()&#123; debugger;&#125;foo();// 这里我们使用了3个带名字的函数声明// 所以当调试器走到debugger语句的时候，Firebug的调用栈上看起来非常清晰明了 // 因为很明白地显示了名称bazbarfooexpr_test.html() 通过查看调用栈的信息，我们可以很明了地知道foo调用了bar, bar又调用了baz（而foo本身有在expr_test.html文档的全局作用域内被调用），不过，还有一个比较爽地方，就是刚才说的Firebug为匿名表达式取名的功能： 12345678910111213141516function foo()&#123; return bar();&#125;var bar = function()&#123; return baz();&#125;function baz()&#123; debugger;&#125;foo();// Call stackbazbar() //看到了么？ fooexpr_test.html() 然后，当函数表达式稍微复杂一些的时候，调试器就不那么聪明了，我们只能在调用栈中看到问号： 12345678910111213141516171819202122232425function foo()&#123; return bar();&#125;var bar = (function()&#123; if (window.addEventListener) &#123; return function()&#123; return baz(); &#125;; &#125; else if (window.attachEvent) &#123; return function() &#123; return baz(); &#125;; &#125;&#125;)();function baz()&#123; debugger;&#125;foo();// Call stackbaz(?)() // 这里可是问号哦fooexpr_test.html() 另外，当把函数赋值给多个变量的时候，也会出现令人郁闷的问题： 12345678910111213141516function foo()&#123; return baz();&#125;var bar = function()&#123; debugger;&#125;;var baz = bar;bar = function() &#123; alert(&apos;spoofed&apos;);&#125;;foo();// Call stack:bar()fooexpr_test.html() 这时候，调用栈显示的是foo调用了bar，但实际上并非如此，之所以有这种问题，是因为baz和另外一个包含alert(‘spoofed’)的函数做了引用交换所导致的。 归根结底，只有给函数表达式取个名字，才是最委托的办法，也就是使用命名函数表达式。我们来使用带名字的表达式来重写上面的例子（注意立即调用的表达式块里返回的2个函数的名字都是bar）： 12345678910111213141516171819202122232425function foo()&#123; return bar();&#125;var bar = (function()&#123; if (window.addEventListener) &#123; return function bar()&#123; return baz(); &#125;; &#125; else if (window.attachEvent) &#123; return function bar() &#123; return baz(); &#125;; &#125;&#125;)();function baz()&#123; debugger;&#125;foo();// 又再次看到了清晰的调用栈信息了耶!bazbarfooexpr_test.html() OK，又学了一招吧？不过在高兴之前，我们再看看不同寻常的JScript吧。 JScript的Bug比较恶的是，IE的ECMAScript实现JScript严重混淆了命名函数表达式，搞得现很多人都出来反对命名函数表达式，而且即便是最新的一版（IE8中使用的5.8版）仍然存在下列问题。下面我们就来看看IE在实现中究竟犯了那些错误，俗话说知已知彼，才能百战不殆。我们来看看如下几个例子：例1：函数表达式的标示符泄露到外部作用域 12var f = function g()&#123;&#125;;typeof g; // &quot;function&quot; 上面我们说过，命名函数表达式的标示符在外部作用域是无效的，但JScript明显是违反了这一规范，上面例子中的标示符g被解析成函数对象，这就乱了套了，很多难以发现的bug都是因为这个原因导致的。 注：IE9貌似已经修复了这个问题例2：将命名函数表达式同时当作函数声明和函数表达式 12typeof g; // &quot;function&quot;var f = function g()&#123;&#125;; 特性环境下，函数声明会优先于任何表达式被解析，上面的例子展示的是JScript实际上是把命名函数表达式当成函数声明了，因为它在实际声明之前就解析了g。这个例子引出了下一个例子。例3：命名函数表达式会创建两个截然不同的函数对象！ 12345var f = function g()&#123;&#125;;f === g; // falsef.expando = &apos;foo&apos;;g.expando; // undefined 看到这里，大家会觉得问题严重了，因为修改任何一个对象，另外一个没有什么改变，这太恶了。通过这个例子可以发现，创建2个不同的对象，也就是说如果你想修改f的属性中保存某个信息，然后想当然地通过引用相同对象的g的同名属性来使用，那问题就大了，因为根本就不可能。再来看一个稍微复杂的例子： 例4：仅仅顺序解析函数声明而忽略条件语句块 123456789var f = function g() &#123; return 1;&#125;;if (false) &#123; f = function g()&#123; return 2; &#125;;&#125;g(); // 2 这个bug查找就难多了，但导致bug的原因却非常简单。首先，g被当作函数声明解析，由于JScript中的函数声明不受条件代码块约束，所以在这个很恶的if分支中，g被当作另一个函数function g(){ return 2 }，也就是又被声明了一次。然后，所有“常规的”表达式被求值，而此时f被赋予了另一个新创建的对象的引用。由于在对表达式求值的时候，永远不会进入“这个可恶if分支，因此f就会继续引用第一个函数function g(){ return 1 }。分析到这里，问题就很清楚了：假如你不够细心，在f中调用了g，那么将会调用一个毫不相干的g函数对象。 你可能会文，将不同的对象和arguments.callee相比较时，有什么样的区别呢？我们来看看： 12345678var f = function g()&#123; return [ arguments.callee == f, arguments.callee == g ]; &#125;; f(); // [true, false] g(); // [false, true] 可以看到，arguments.callee的引用一直是被调用的函数，实际上这也是好事，稍后会解释。 还有一个有趣的例子，那就是在不包含声明的赋值语句中使用命名函数表达式： 123(function()&#123; f = function f()&#123;&#125;;&#125;)(); 按照代码的分析，我们原本是想创建一个全局属性f（注意不要和一般的匿名函数混淆了，里面用的是带名字的生命），JScript在这里捣乱了一把，首先他把表达式当成函数声明解析了，所以左边的f被声明为局部变量了（和一般的匿名函数里的声明一样），然后在函数执行的时候，f已经是定义过的了，右边的function f(){}则直接就赋值给局部变量f了，所以f根本就不是全局属性。 了解了JScript这么变态以后，我们就要及时预防这些问题了，首先防范标识符泄漏带外部作用域，其次，应该永远不引用被用作函数名称的标识符；还记得前面例子中那个讨人厌的标识符g吗？——如果我们能够当g不存在，可以避免多少不必要的麻烦哪。因此，关键就在于始终要通过f或者arguments.callee来引用函数。如果你使用了命名函数表达式，那么应该只在调试的时候利用那个名字。最后，还要记住一点，一定要把命名函数表达式声明期间错误创建的函数清理干净。 对于，上面最后一点，我们还得再解释一下。 JScript的内存管理知道了这些不符合规范的代码解析bug以后，我们如果用它的话，就会发现内存方面其实是有问题的，来看一个例子： 123456var f = (function()&#123; if (true) &#123; return function g()&#123;&#125;; &#125; return function g()&#123;&#125;;&#125;)(); 我们知道，这个匿名函数调用返回的函数（带有标识符g的函数），然后赋值给了外部的f。我们也知道，命名函数表达式会导致产生多余的函数对象，而该对象与返回的函数对象不是一回事。所以这个多余的g函数就死在了返回函数的闭包中了，因此内存问题就出现了。这是因为if语句内部的函数与g是在同一个作用域中被声明的。这种情况下 ，除非我们显式断开对g函数的引用，否则它一直占着内存不放。 123456789101112var f = (function()&#123; var f, g; if (true) &#123; f = function g()&#123;&#125;; &#125; else &#123; f = function g()&#123;&#125;; &#125; // 设置g为null以后它就不会再占内存了 g = null; return f;&#125;)(); 通过设置g为null，垃圾回收器就把g引用的那个隐式函数给回收掉了，为了验证我们的代码，我们来做一些测试，以确保我们的内存被回收了。 测试 测试很简单，就是命名函数表达式创建10000个函数，然后把它们保存在一个数组中。等一会儿以后再看这些函数到底占用了多少内存。然后，再断开这些引用并重复这一过程。下面是测试代码： 123456789101112131415161718192021222324252627function createFn()&#123; return (function()&#123; var f; if (true) &#123; f = function F()&#123; return &apos;standard&apos;; &#125;; &#125; else if (false) &#123; f = function F()&#123; return &apos;alternative&apos;; &#125;; &#125; else &#123; f = function F()&#123; return &apos;fallback&apos;; &#125;; &#125; // var F = null; return f; &#125;)();&#125;var arr = [ ];for (var i=0; i&lt;10000; i++) &#123; arr[i] = createFn();&#125; 通过运行在Windows XP SP2中的任务管理器可以看到如下结果： 123456789IE6: without `null`: 7.6K -&gt; 20.3K with `null`: 7.6K -&gt; 18KIE7: without `null`: 14K -&gt; 29.7K with `null`: 14K -&gt; 27K 如我们所料，显示断开引用可以释放内存，但是释放的内存不是很多，10000个函数对象才释放大约3M的内存，这对一些小型脚本不算什么，但对于大型程序，或者长时间运行在低内存的设备里的时候，这是非常有必要的。 关于在Safari 2.x中JS的解析也有一些bug，但介于版本比较低，所以我们在这里就不介绍了，大家如果想看的话，请仔细查看英文资料。 SpiderMonkey的怪癖大家都知道，命名函数表达式的标识符只在函数的局部作用域中有效。但包含这个标识符的局部作用域又是什么样子的吗？其实非常简单。在命名函数表达式被求值时，会创建一个特殊的对象，该对象的唯一目的就是保存一个属性，而这个属性的名字对应着函数标识符，属性的值对应着那个函数。这个对象会被注入到当前作用域链的前端。然后，被“扩展”的作用域链又被用于初始化函数。 在这里，有一点十分有意思，那就是ECMA-262定义这个（保存函数标识符的）“特殊”对象的方式。标准说“像调用new Object()表达式那样”创建这个对象。如果从字面上来理解这句话，那么这个对象就应该是全局Object的一个实例。然而，只有一个实现是按照标准字面上的要求这么做的，这个实现就是SpiderMonkey。因此，在SpiderMonkey中，扩展Object.prototype有可能会干扰函数的局部作用域： 12345678910111213141516171819Object.prototype.x = &apos;outer&apos;;(function()&#123; var x = &apos;inner&apos;; /* 函数foo的作用域链中有一个特殊的对象——用于保存函数的标识符。这个特殊的对象实际上就是&#123; foo: &lt;function object&gt; &#125;。 当通过作用域链解析x时，首先解析的是foo的局部环境。如果没有找到x，则继续搜索作用域链中的下一个对象。下一个对象 就是保存函数标识符的那个对象——&#123; foo: &lt;function object&gt; &#125;，由于该对象继承自Object.prototype，所以在此可以找到x。 而这个x的值也就是Object.prototype.x的值（outer）。结果，外部函数的作用域（包含x = &apos;inner&apos;的作用域）就不会被解析了。 */ (function foo()&#123; alert(x); // 提示框中显示：outer &#125;)();&#125;)(); 不过，更高版本的SpiderMonkey改变了上述行为，原因可能是认为那是一个安全漏洞。也就是说，“特殊”对象不再继承Object.prototype了。不过，如果你使用Firefox 3或者更低版本，还可以“重温”这种行为。另一个把内部对象实现为全局Object对象的是黑莓（Blackberry）浏览器。目前，它的活动对象（Activation Object）仍然继承Object.prototype。可是，ECMA-262并没有说活动对象也要“像调用new Object()表达式那样”来创建（或者说像创建保存NFE标识符的对象一样创建）。 人家规范只说了活动对象是规范中的一种机制。那我们就来看看黑莓里都发生了什么： 12345678910111213141516171819Object.prototype.x = &apos;outer&apos;;(function()&#123; var x = &apos;inner&apos;; (function()&#123; /* 在沿着作用域链解析x的过程中，首先会搜索局部函数的活动对象。当然，在该对象中找不到x。 可是，由于活动对象继承自Object.prototype，因此搜索x的下一个目标就是Object.prototype；而 Object.prototype中又确实有x的定义。结果，x的值就被解析为——outer。跟前面的例子差不多， 包含x = &apos;inner&apos;的外部函数的作用域（活动对象）就不会被解析了。 */ alert(x); // 显示：outer &#125;)();&#125;)(); 不过神奇的还是，函数中的变量甚至会与已有的Object.prototype的成员发生冲突，来看看下面的代码： 123456789101112131415(function()&#123; var constructor = function()&#123; return 1; &#125;; (function()&#123; constructor(); // 求值结果是&#123;&#125;（即相当于调用了Object.prototype.constructor()）而不是1 constructor === Object.prototype.constructor; // true toString === Object.prototype.toString; // true // …… &#125;)();&#125;)(); 要避免这个问题，要避免使用Object.prototype里的属性名称，如toString, valueOf, hasOwnProperty等等。 JScript解决方案 12345678910111213141516171819202122232425var fn = (function()&#123; // 声明要引用函数的变量 var f; // 有条件地创建命名函数 // 并将其引用赋值给f if (true) &#123; f = function F()&#123; &#125; &#125; else if (false) &#123; f = function F()&#123; &#125; &#125; else &#123; f = function F()&#123; &#125; &#125; // 声明一个与函数名（标识符）对应的变量，并赋值为null // 这实际上是给相应标识符引用的函数对象作了一个标记， // 以便垃圾回收器知道可以回收它了 var F = null; // 返回根据条件定义的函数 return f;&#125;)(); 最后我们给出一个应用上述技术的应用实例，这是一个跨浏览器的addEvent函数代码： 12345678910111213141516171819202122232425262728293031323334// 1) 使用独立的作用域包含声明var addEvent = (function()&#123; var docEl = document.documentElement; // 2) 声明要引用函数的变量 var fn; if (docEl.addEventListener) &#123; // 3) 有意给函数一个描述性的标识符 fn = function addEvent(element, eventName, callback) &#123; element.addEventListener(eventName, callback, false); &#125; &#125; else if (docEl.attachEvent) &#123; fn = function addEvent(element, eventName, callback) &#123; element.attachEvent(&apos;on&apos; + eventName, callback); &#125; &#125; else &#123; fn = function addEvent(element, eventName, callback) &#123; element[&apos;on&apos; + eventName] = callback; &#125; &#125; // 4) 清除由JScript创建的addEvent函数 // 一定要保证在赋值前使用var关键字 // 除非函数顶部已经声明了addEvent var addEvent = null; // 5) 最后返回由fn引用的函数 return fn;&#125;)(); 替代方案其实，如果我们不想要这个描述性名字的话，我们就可以用最简单的形式来做，也就是在函数内部声明一个函数（而不是函数表达式），然后返回该函数： 123456789101112131415var hasClassName = (function()&#123; // 定义私有变量 var cache = &#123; &#125;; // 使用函数声明 function hasClassName(element, className) &#123; var _className = &apos;(?:^|\\\\s+)&apos; + className + &apos;(?:\\\\s+|$)&apos;; var re = cache[_className] || (cache[_className] = new RegExp(_className)); return re.test(element.className); &#125; // 返回函数 return hasClassName;&#125;)(); 显然，当存在多个分支函数定义时，这个方案就不行了。不过有种模式貌似可以实现：那就是提前使用函数声明来定义所有函数，并分别为这些函数指定不同的标识符： 12345678910111213141516171819202122var addEvent = (function()&#123; var docEl = document.documentElement; function addEventListener()&#123; /* ... */ &#125; function attachEvent()&#123; /* ... */ &#125; function addEventAsProperty()&#123; /* ... */ &#125; if (typeof docEl.addEventListener != &apos;undefined&apos;) &#123; return addEventListener; &#125; elseif (typeof docEl.attachEvent != &apos;undefined&apos;) &#123; return attachEvent; &#125; return addEventAsProperty;&#125;)(); 虽然这个方案很优雅，但也不是没有缺点。第一，由于使用不同的标识符，导致丧失了命名的一致性。且不说这样好还是坏，最起码它不够清晰。有人喜欢使用相同的名字，但也有人根本不在乎字眼上的差别。可毕竟，不同的名字会让人联想到所用的不同实现。例如，在调试器中看到attachEvent，我们就知 道addEvent是基于attachEvent的实现。当 然，基于实现来命名的方式也不一定都行得通。假如我们要提供一个API，并按照这种方式把函数命名为inner。那么API用户的很容易就会被相应实现的 细节搞得晕头转向。 要解决这个问题，当然就得想一套更合理的命名方案了。但关键是不要再额外制造麻烦。我现在能想起来的方案大概有如下几个： 12345&apos;addEvent&apos;, &apos;altAddEvent&apos;, &apos;fallbackAddEvent&apos;// 或者&apos;addEvent&apos;, &apos;addEvent2&apos;, &apos;addEvent3&apos;// 或者&apos;addEvent_addEventListener&apos;, &apos;addEvent_attachEvent&apos;, &apos;addEvent_asProperty&apos; 另外，这种模式还存在一个小问题，即增加内存占用。提前创建N个不同名字的函数，等于有N-1的函数是用不到的。具体来讲，如果document.documentElement 中包含attachEvent，那么addEventListener 和addEventAsProperty则根本就用不着了。可是，他们都占着内存哪；而且，这些内存将永远都得不到释放，原因跟JScript臭哄哄的命名表达式相同——这两个函数都被“截留”在返回的那个函数的闭包中了。 不过，增加内存占用这个问题确实没什么大不了的。如果某个库——例如Prototype.js——采用了这种模式，无非也就是多创建一两百个函数而已。只要不是（在运行时）重复地创建这些函数，而是只（在加载时）创建一次，那么就没有什么好担心的。 WebKit的displayNameWebKit团队在这个问题采取了有点儿另类的策略。介于匿名和命名函数如此之差的表现力，WebKit引入了一个“特殊的”displayName属性（本质上是一个字符串），如果开发人员为函数的这个属性赋值，则该属性的值将在调试器或性能分析器中被显示在函数“名称”的位置上。Francisco Tolmasky详细地解释了这个策略的原理和实现。 未来考虑将来的ECMAScript-262第5版（目前还是草案）会引入所谓的严格模式（strict mode）。开启严格模式的实现会禁用语言中的那些不稳定、不可靠和不安全的特性。据说出于安全方面的考虑，arguments.callee属性将在严格模式下被“封杀”。因此，在处于严格模式时，访问12 // 此前，你可能会使用arguments.callee (function(x) { if (x &lt;= 1) return 1; return x * arguments.callee(x - 1); })(10); // 但在严格模式下，有可能就要使用命名函数表达式 (function factorial(x) { if (x &lt;= 1) return 1; return x * factorial(x - 1); })(10); // 要么就退一步，使用没有那么灵活的函数声明 function factorial(x) { if (x &lt;= 1) return 1; return x * factorial(x - 1); } factorial(10);``` 致谢理查德· 康福德（Richard Cornford），是他率先解释了JScript中命名函数表达式所存在的bug。理查德解释了我在这篇文章中提及的大多数bug，所以我强烈建议大家去看看他的解释。我还要感谢Yann-Erwan Perio和道格拉斯·克劳克佛德（Douglas Crockford），他们早在2003年就在comp.lang.javascript论坛中提及并讨论NFE问题了。 约翰-戴维·道尔顿（John-David Dalton）对“最终解决方案”提出了很好的建议。 托比·兰吉的点子被我用在了“替代方案”中。 盖瑞特·史密斯（Garrett Smith）和德米特里·苏斯尼科（Dmitry Soshnikov）对本文的多方面作出了补充和修正。 英文原文：http://kangax.github.com/nfe/ 参考译文：连接访问 (SpiderMonkey的怪癖之后的章节参考该文) 同步与推荐本文已同步至目录索引：深入理解JavaScript系列 深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。","categories":[],"tags":[]},{"title":"","slug":"深入理解JavaScript系列（1）：编写高质量JavaScript代码的基本要点","date":"2018-03-09T14:42:42.933Z","updated":"2018-03-09T14:45:09.950Z","comments":true,"path":"2018/03/09/cjek1zh7j0062x9rd9f4lovqc/","link":"","permalink":"http://www.maksim.website/2018/03/09/cjek1zh7j0062x9rd9f4lovqc/","excerpt":"","text":"title:深入理解JavaScript系列（1）：编写高质量JavaScript代码的基本要点date:2018-3-9categories:javascript id:1 2011-12-28 23:00 by 汤姆大叔 原地址：http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html 才华横溢的Stoyan Stefanov，在他写的由O’Reilly初版的新书《JavaScript Patterns》(JavaScript模式)中，我想要是为我们的读者贡献其摘要，那会是件很美妙的事情。具体一点就是编写高质量JavaScript的一些要素，例如避免全局变量，使用单变量声明，在循环中预缓存length(长度)，遵循代码阅读，以及更多。 此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写API文档、执行同行评审以及运行JSLint。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码，这些代码在几个月或是几年之后再回过头看看也是会觉得很自豪的。 书写可维护的代码(Writing Maintainable Code )软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要： 花时间学习和理解这个问题 化时间是了解应该解决的问题代码 还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。 另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。 你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如： bug是暴露的 新功能被添加到应用程序 程序在新的环境下工作（例如，市场上出现新想浏览器） 代码改变用途 代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言 由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。 可维护的代码意味着： 可读的 一致的 可预测的 看上去就像是同一个人写的 已记录 最小全局变量(Minimizing Globals)JavaScript通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。 每个JavaScript环境有一个全局对象，当你在任意的函数外面使用this的时候可以访问到。你创建的每一个全部变量都成了这个全局对象的属 性。在浏览器中，方便起见，该全局对象有个附加属性叫做window，此window(通常)指向该全局对象本身。下面的代码片段显示了如何在浏览器环境 中创建和访问的全局变量： 12345myglobal = &quot;hello&quot;; // 不推荐写法console.log(myglobal); // &quot;hello&quot;console.log(window.myglobal); // &quot;hello&quot;console.log(window[&quot;myglobal&quot;]); // &quot;hello&quot;console.log(this.myglobal); // &quot;hello&quot; 全局变量的问题全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。 web页面包含不是该页面开发者所写的代码也是比较常见的，例如： 第三方的JavaScript库 广告方的脚本代码 第三方用户跟踪和分析脚本代码 不同类型的小组件，标志和按钮 比方说，该第三方脚本定义了一个全局变量，叫做result；接着，在你的函数中也定义一个名为result的全局变量。其结果就是后面的变量覆盖前面的，第三方脚本就一下子嗝屁啦！ 因此，要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。在书中后面提到的一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。 由于JavaScript的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码： 12345function sum(x, y) &#123; // 不推荐写法: 隐式全局变量 result = x + y; return result;&#125; 此段代码中的result没有声明。代码照样运作正常，但在调用函数后你最后的结果就多一个全局命名空间，这可以是一个问题的根源。 经验法则是始终使用var声明变量，正如改进版的sum()函数所演示的： 1234function sum(x, y) &#123; var result = x + y; return result;&#125; 另一个创建隐式全局变量的反例就是使用任务链进行部分var声明。下面的片段中，a是本地变量但是b确实全局变量，这可能不是你希望发生的： 12345// 反例，勿使用 function foo() &#123; var a = b = 0; // ...&#125; 此现象发生的原因在于这个从右到左的赋值，首先，是赋值表达式b = 0，此情况下b是未声明的。这个表达式的返回值是0，然后这个0就分配给了通过var定义的这个局部变量a。换句话说，就好比你输入了： 1var a = (b = 0); 如果你已经准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量，如： 1234function foo() &#123; var a, b; // ... a = b = 0; // 两个均局部变量&#125; 然而，另外一个避免全局变量的原因是可移植性。如果你想你的代码在不同的环境下（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心大胆地使用，实际上对于有些情况并不适用）。 忘记var的副作用(Side Effects When Forgetting var)隐式全局变量和明确定义的全局变量间有些小的差异，就是通过delete操作符让变量未定义的能力。 通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。 无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。 这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过delete操作符删除的，而变量是不能的： 12345678910111213141516// 定义三个全局变量var global_var = 1;global_novar = 2; // 反面教材(function () &#123; global_fromfunc = 3; // 反面教材&#125;());// 试图删除delete global_var; // falsedelete global_novar; // truedelete global_fromfunc; // true// 测试该删除typeof global_var; // &quot;number&quot;typeof global_novar; // &quot;undefined&quot;typeof global_fromfunc; // &quot;undefined&quot; 在ES5严格模式下，未声明的变量（如在前面的代码片段中的两个反面教材）工作时会抛出一个错误。 访问全局对象(Access to the Global Object)在浏览器中，全局对象可以通过window属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的window标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作： 123var global = (function () &#123; return this;&#125;()); 这种方法可以随时获得全局对象，因为其在函数中被当做函数调用了（不是通过new构造），this总 是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。 单var形式（Single var Pattern）在函数顶部使用单var语句是比较有用的一种形式，其好处在于： 提供了一个单一的地方去寻找功能所需要的所有局部变量 防止变量在定义之前使用的逻辑错误 帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的… 少代码（类型啊传值啊单线完成） 单var形式长得就像下面这个样子： 123456789function func() &#123; var a = 1, b = 2, sum = a + b, myobject = &#123;&#125;, i, j; // function body...&#125; 您可以使用一个var语句声明多个变量，并以逗号分隔。像这种初始化变量同时初始化值的做法是很好的。这样子可以防止逻辑错误（所有未初始化但声明的变量的初始值是undefined）和增加代码的可读性。在你看到代码后，你可以根据初始化的值知道这些变量大致的用途，例如是要当作对象呢还是当作整数来使。 你也可以在声明的时候做一些实际的工作，例如前面代码中的sum = a + b这个情况，另外一个例子就是当你使用DOM（文档对象模型）引用时，你可以使用单一的var把DOM引用一起指定为局部变量，就如下面代码所示的： 12345function updateElement() &#123; var el = document.getElementById(&quot;result&quot;), style = el.style; // 使用el和style干点其他什么事...&#125; 预解析：var散布的问题(Hoisting: A Problem with Scattered vars)JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。看下面这个例子： 12345678// 反例myname = &quot;global&quot;; // 全局变量function func() &#123; alert(myname); // &quot;undefined&quot; var myname = &quot;local&quot;; alert(myname); // &quot;local&quot;&#125;func(); 在这个例子中，你可能会以为第一个alert弹出的是”global”，第二个弹出”loacl”。这种期许是可以理解的，因为在第一个alert 的时候，myname未声明，此时函数肯定很自然而然地看全局变量myname，但是，实际上并不是这么工作的。第一个alert会弹 出”undefined”是因为myname被当做了函数的局部变量（尽管是之后声明的），所有的变量声明当被悬置到函数的顶部了。因此，为了避免这种混 乱，最好是预先声明你想使用的全部变量。 上面的代码片段执行的行为可能就像下面这样： 1234567myname = &quot;global&quot;; // global variablefunction func() &#123; var myname; // 等同于 -&gt; var myname = undefined; alert(myname); // &quot;undefined&quot; myname = &quot;local&quot;; alert(myname); // &quot;local&quot;&#125;func(); 为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文 的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了”hoisting”这个概念， 这种ECMAScript标准中并未定义，通常用来描述行为。 for循环(for Loops)在for循环中，你可以循环取得数组或是数组类似对象的值，譬如arguments和HTMLCollection对象。通常的循环形式如下： 1234// 次佳的循环for (var i = 0; i &lt; myarray.length; i++) &#123; // 使用myarray[i]做点什么&#125; 这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当myarray不是数组，而是一个HTMLCollection对象的时候。 HTMLCollections指的是DOM方法返回的对象，例如： 123document.getElementsByName()document.getElementsByClassName()document.getElementsByTagName() 还有其他一些HTMLCollections，这些是在DOM标准之前引进并且现在还在使用的。有： 1234document.images: 页面上所有的图片元素document.links : 所有a标签元素document.forms : 所有表单document.forms[0].elements : 页面上第一个表单中的所有域 集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。 这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的： 123for (var i = 0, max = myarray.length; i &lt; max; i++) &#123; // 使用myarray[i]做点什么&#125; 这样，在这个循环过程中，你只检索了一次长度值。 在所有浏览器下，循环获取内容时缓存HTMLCollections的长度是更快的，2倍(Safari3)到190倍(IE7)之间。//zxx:此数据貌似很老，仅供参考 注意到，当你明确想要修改循环中的集合的时候（例如，添加更多的DOM元素），你可能更喜欢长度更新而不是常量。 伴随着单var形式，你可以把变量从循环中提出来，就像下面这样： 123456789function looper() &#123; var i = 0, max, myarray = []; // ... for (i = 0, max = myarray.length; i &lt; max; i++) &#123; // 使用myarray[i]做点什么 &#125;&#125; 这种形式具有一致性的好处，因为你坚持了单一var形式。不足在于当重构代码的时候，复制和粘贴整个循环有点困难。例如，你从一个函数复制了一个循环到另一个函数，你不得不去确定你能够把i和max引入新的函数（如果在这里没有用的话，很有可能你要从原函数中把它们删掉）。 最后一个需要对循环进行调整的是使用下面表达式之一来替换i++。 12i = i + 1i += 1 JSLint提示您这样做，原因是++和–-促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手如果你直接无视它，JSLint的plusplus选项会是false（默认是default）。 还有两种变化的形式，其又有了些微改进，因为： 少了一个变量(无max) 向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率 1234567891011121314//第一种变化的形式：var i, myarray = [];for (i = myarray.length; i–-;) &#123; // 使用myarray[i]做点什么&#125;//第二种使用while循环：var myarray = [], i = myarray.length;while (i–-) &#123; // 使用myarray[i]做点什么&#125; 这些小的改进只体现在性能上，此外JSLint会对使用i–-加以抱怨。 for-in循环(for-in Loops)for-in循环应该用在非数组对象的遍历上，使用for-in进行循环也被称为“枚举”。 从技术上将，你可以使用for-in循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。 有个很重要的hasOwnProperty()方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。 思考下面一段代码： 123456789101112// 对象var man = &#123; hands: 2, legs: 2, heads: 1&#125;;// 在代码的某个地方// 一个方法添加给了所有对象if (typeof Object.prototype.clone === &quot;undefined&quot;) &#123; Object.prototype.clone = function () &#123;&#125;;&#125; 在这个例子中，我们有一个使用对象字面量定义的名叫man的对象。在man定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举man的时候出现clone()方法，你需要应用hasOwnProperty()方法过滤原型属性。如果不做过滤，会导致clone()函数显示出来，在大多数情况下这是不希望出现的。 12345678910111213141516171819202122232425// 1.// for-in 循环for (var i in man) &#123; if (man.hasOwnProperty(i)) &#123; // 过滤 console.log(i, &quot;:&quot;, man[i]); &#125;&#125;/* 控制台显示结果hands : 2legs : 2heads : 1*/// 2.// 反面例子:// for-in loop without checking hasOwnProperty()for (var i in man) &#123; console.log(i, &quot;:&quot;, man[i]);&#125;/*控制台显示结果hands : 2legs : 2heads : 1clone: function()*/ 另外一种使用hasOwnProperty()的形式是取消Object.prototype上的方法。像是： 12345for (var i in man) &#123; if (Object.prototype.hasOwnProperty.call(man, i)) &#123; // 过滤 console.log(i, &quot;:&quot;, man[i]); &#125;&#125; 其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。 123456var i, hasOwn = Object.prototype.hasOwnProperty;for (i in man) &#123; if (hasOwn.call(man, i)) &#123; // 过滤 console.log(i, &quot;:&quot;, man[i]); &#125;&#125; 严格来说，不使用hasOwnProperty()并不是一个错误。根据任务以及你对代码的自信程度，你可以跳过它以提高些许的循环速度。但是当你对当前对象内容（和其原型链）不确定的时候，添加hasOwnProperty()更加保险些。 格式化的变化（通不过JSLint）会直接忽略掉花括号，把if语句放到同一行上。其优点在于循环语句读起来就像一个完整的想法（每个元素都有一个自己的属性”X”，使用”X”干点什么）： 12345// 警告： 通不过JSLint检测var i, hasOwn = Object.prototype.hasOwnProperty;for (i in man) if (hasOwn.call(man, i)) &#123; // 过滤 console.log(i, &quot;:&quot;, man[i]);&#125; （不）扩展内置原型((Not) Augmenting Built-in Prototypes)扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。 增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。 另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。 因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外： 可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。 如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。 你清楚地文档记录并和团队交流了变化。 如果这三个条件得到满足，你可以给原型进行自定义的添加，形式如下： 12345if (typeof Object.protoype.myMethod !== &quot;function&quot;) &#123; Object.protoype.myMethod = function () &#123; // 实现... &#125;;&#125; switch模式(switch Pattern)你可以通过类似下面形式的switch语句增强可读性和健壮性： 123456789101112var inspect_me = 0, result = &apos;&apos;;switch (inspect_me) &#123;case 0: result = &quot;zero&quot;; break;case 1: result = &quot;one&quot;; break;default: result = &quot;unknown&quot;;&#125; 这个简单的例子中所遵循的风格约定如下： 每个case和switch对齐（花括号缩进规则除外） 每个case中代码缩进 每个case以break清除结束 避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。 以default结束switch：确保总有健全的结果，即使无情况匹配。 避免隐式类型转换(Avoiding Implied Typecasting )JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。 123456789var zero = 0;if (zero === false) &#123; // 不执行，因为zero为0, 而不是false&#125;// 反面示例if (zero == false) &#123; // 执行了...&#125; 还有另外一种思想观点认为==就足够了===是多余的。例如，当你使用typeof你就知道它会返回一个字符串，所以没有使用严格相等的理由。然而，JSLint要求严格相等，它使代码看上去更有一致性，可以降低代码阅读时的精力消耗。（“==是故意的还是一个疏漏？”） 避免(Avoiding) eval()如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单： 1234567// 反面示例var property = &quot;name&quot;;alert(eval(&quot;obj.&quot; + property));// 更好的var property = &quot;name&quot;;alert(obj[property]); 使用eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理Ajax请求得到的JSON 相应的时候。在这些情况下，最好使用JavaScript内置方法来解析JSON相应，以确保安全和有效。若浏览器不支持JSON.parse()，你可 以使用来自JSON.org的库。 同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。在幕后，JavaScript仍需要评估和执行你给程序传递的字符串： 123456789// 反面示例setTimeout(&quot;myFunc()&quot;, 1000);setTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);// 更好的setTimeout(myFunc, 1000);setTimeout(function () &#123; myFunc(1, 2, 3);&#125;, 1000); 使用新的Function()构造就类似于eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用eval()，你 可以考虑使用new Function()代替。有一个小的潜在好处，因为在新Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。 考虑下面这个例子，这里仅un作为全局变量污染了命名空间。 123456789101112131415161718console.log(typeof un); // &quot;undefined&quot;console.log(typeof deux); // &quot;undefined&quot;console.log(typeof trois); // &quot;undefined&quot;var jsstring = &quot;var un = 1; console.log(un);&quot;;eval(jsstring); // logs &quot;1&quot;jsstring = &quot;var deux = 2; console.log(deux);&quot;;new Function(jsstring)(); // logs &quot;2&quot;jsstring = &quot;var trois = 3; console.log(trois);&quot;;(function () &#123; eval(jsstring);&#125;()); // logs &quot;3&quot;console.log(typeof un); // numberconsole.log(typeof deux); // &quot;undefined&quot;console.log(typeof trois); // &quot;undefined&quot; 另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。在下面这个例子中，eval()可以访问和修改它外部作用域中的变量，这是 Function做不来的（注意到使用Function和new Function是相同的）。 12345678910(function () &#123; var local = 1; eval(&quot;local = 3; console.log(local)&quot;); // logs &quot;3&quot; console.log(local); // logs &quot;3&quot;&#125;());(function () &#123; var local = 1; Function(&quot;console.log(typeof local);&quot;)(); // logs undefined&#125;()); parseInt()下的数值转换(Number Conversions with parseInt())使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数。 1234var month = &quot;06&quot;, year = &quot;09&quot;;month = parseInt(month, 10);year = parseInt(year, 10); 此例中，如果你忽略了基数参数，如parseInt(year)，返回的值将是0，因为“09”被当做8进制（好比执行 parseInt( year, 8 )），而09在8进制中不是个有效数字。 替换方法是将字符串转换成数字，包括： 12+&quot;08&quot; // 结果是 8Number(&quot;08&quot;) // 8 这些通常快于parseInt()，因为parseInt()方法，顾名思意，不是简单地解析与转换。但是，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以NaN告终。 编码规范(Coding Conventions)建立和遵循编码规范是很重要的，这让你的代码保持一致性，可预测，更易于阅读和理解。一个新的开发者加入这个团队可以通读规范，理解其它团队成员书写的代码，更快上手干活。 许多激烈的争论发生会议上或是邮件列表上，问题往往针对某些代码规范的特定方面（例如代码缩进，是Tab制表符键还是space空格键）。如果你是 你组织中建议采用规范的，准备好面对各种反对的或是听起来不同但很强烈的观点。要记住，建立和坚定不移地遵循规范要比纠结于规范的细节重要的多。 缩进(Indentation)代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。 一些开发人员更喜欢用tab制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，使用四个空格缩进，这也是JSLint中默认的缩进。 什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do, while, for, for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例： 12345678910111213141516171819function outer(a, b) &#123; var c = 1, d = 2, inner; if (a &gt; b) &#123; inner = function () &#123; return &#123; r: c - d &#125;; &#125;; &#125; else &#123; inner = function () &#123; return &#123; r: c + d &#125;; &#125;; &#125; return inner;&#125; 花括号{}(Curly Braces)花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在in或是for中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。 想象下你有一个只有一条语句的for循环，你可以忽略花括号，而没有解析的错误。 123// 糟糕的实例for (var i = 0; i &lt; 10; i += 1) alert(i); 但是，如果，后来，主体循环部分又增加了行代码？ 1234// 糟糕的实例for (var i = 0; i &lt; 10; i += 1) alert(i); alert(i + &quot; is &quot; + (i % 2 ? &quot;odd&quot; : &quot;even&quot;)); 第二个alert已经在循环之外，缩进可能欺骗了你。为了长远打算，最好总是使用花括号，即时值一行代码： 1234// 好的实例for (var i = 0; i &lt; 10; i += 1) &#123; alert(i);&#125; if条件类似： 123456789101112// 坏if (true) alert(1);else alert(2);// 好if (true) &#123; alert(1);&#125; else &#123; alert(2);&#125; 左花括号的位置(Opening Brace Location)开发人员对于左大括号的位置有着不同的偏好——在同一行或是下一行。 12345678910if (true) &#123; alert(&quot;It&apos;s TRUE!&quot;);&#125;//或if (true)&#123; alert(&quot;It&apos;s TRUE!&quot;);&#125; 这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript是不挑剔的，当你选择不使用分号结束一行代码时JavaScript会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候： 12345678// 警告： 意外的返回值function func() &#123; return // 下面代码不执行 &#123; name : &quot;Batman&quot; &#125;&#125; 如果你希望函数返回一个含有name属性的对象，你会惊讶。由于隐含分号，函数返回undefined。前面的代码等价于： 12345678// 警告： 意外的返回值function func() &#123; return undefined; // 下面代码不执行 &#123; name : &quot;Batman&quot; &#125;&#125; 总之，总是使用花括号，并始终把在与之前的语句放在同一行： 12345function func() &#123; return &#123; name : &quot;Batman&quot; &#125;;&#125; 关于分号注：就像使用花括号，你应该总是使用分号，即使他们可由JavaScript解析器隐式创建。这不仅促进更科学和更严格的代码，而且有助于解决存有疑惑的地方，就如前面的例子显示。 空格(White Space)空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在JavaScript中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。 适合使用空格的地方包括： for循环分号分开后的的部分：如for (var i = 0; i &lt; 10; i += 1) {...} for循环中初始化的多变量(i和max)：for (var i = 0, max = 10; i &lt; max; i += 1) {...} 分隔数组项的逗号的后面：var a = [1, 2, 3]; 对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = {a: 1, b: 2}; 限定函数参数：myFunc(a, b, c) 函数声明的花括号的前面：function myFunc() {} 匿名函数表达式function的后面：var myFunc = function () {}; 使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=等前后都需要空格。 12345678910111213141516171819// 宽松一致的间距// 使代码更易读// 使得更加“透气”var d = 0, a = b + 1;if (a &amp;&amp; b &amp;&amp; c) &#123; d = a % c; a += d;&#125;// 反面例子// 缺失或间距不一// 使代码变得疑惑var d = 0, a = b + 1;if (a&amp;&amp;b&amp;&amp;c) &#123; d=a % c; a+= d;&#125; 最后需要注意的一个空格——花括号间距。最好使用空格： 函数、if-else语句、循环、对象字面量的左花括号的前面({) else或while之间的右花括号(}) 空格使用的一点不足就是增加了文件的大小，但是压缩无此问题。 有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。 命名规范(Naming Conventions)另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。 下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。 以大写字母写构造函数(Capitalizing Constructors)JavaScript并没有类，但有new调用的构造函数： 1var adam = new Person(); 因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。 命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用： 12function MyConstructor() &#123;...&#125;function myFunction() &#123;...&#125; 分隔单词(Separating Words)当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。 对于构造函数，可以使用大驼峰式命名法(upper camel case)，如MyConstructor()。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是myFunction(), calculateArea()和getFirstName()。 要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，first_name, favorite_bands,和old_company_name，这种标记法帮你直观地区分函数和其他标识——原型和对象。 ECMAScript的属性和方法均使用Camel标记法，尽管多字的属性名称是罕见的（正则表达式对象的lastIndex和ignoreCase属性）。 其它命名形式(Other Naming Patterns)有时，开发人员使用命名规范来弥补或替代语言特性。 例如，JavaScript中没有定义常量的方法（尽管有些内置的像Number, MAX_VALUE），所以开发者都采用全部单词大写的规范来命名这个程序生命周期中都不会改变的变量，如： 123// 珍贵常数，只可远观var PI = 3.14, MAX_WIDTH = 800; 还有另外一个完全大写的惯例：全局变量名字全部大写。全部大写命名全局变量可以加强减小全局变量数量的实践，同时让它们易于区分。 另外一种使用规范来模拟功能的是私有成员。虽然可以在JavaScript中实现真正的私有，但是开发者发现仅仅使用一个下划线前缀来表示一个私有属性或方法会更容易些。考虑下面的例子： 123456789101112var person = &#123; getName: function () &#123; return this._getFirst() + &apos; &apos; + this._getLast(); &#125;, _getFirst: function () &#123; // ... &#125;, _getLast: function () &#123; // ... &#125;&#125;; 在此例中，getName()就表示公共方法，部分稳定的API。而_getFirst()和_getLast()则表明了私有。它们仍然是正常的公共方法，但是使用下划线前缀来警告person对象的使用者这些方法在下一个版本中时不能保证工作的，是不能直接使用的。注意，JSLint有些不鸟下划线前缀，除非你设置了noman选项为:false。 下面是一些常见的_private规范： 使用尾下划线表示私有，如name和getElements() 使用一个下划线前缀表_protected（保护）属性，两个下划线前缀表示__private （私有）属性 Firefox中一些内置的变量属性不属于该语言的技术部分，使用两个前下划线和两个后下划线表示，如：proto和parent。 注释(Writing Comments)你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。 很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。 最重要的习惯，然而也是最难遵守的，就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。 关于作者（About the Author ）Stoyan Stefanov是Yahoo!web开发人员，多个O’Reilly书籍的作者、投稿者和技术评审。他经常在会议和他的博客www.phpied.com上发表web开发主题的演讲。Stoyan还是smush.it图片优化工具的创造者，YUI贡献者，雅虎性能优化工具YSlow 2.0的架构设计师。 本文转自：http://www.zhangxinxu.com/wordpress/?p=1173 英文原文：http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/ 同步与结束语本文已同步至目录索引：深入理解JavaScript系列 深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。","categories":[],"tags":[]},{"title":"Nginx的安装","slug":"Nginx的安装","date":"2018-02-26T16:00:00.000Z","updated":"2018-02-27T14:04:44.098Z","comments":true,"path":"2018/02/27/cjek1zh4i0018x9rdg3v391ga/","link":"","permalink":"http://www.maksim.website/2018/02/27/cjek1zh4i0018x9rdg3v391ga/","excerpt":"","text":"Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。 在安装 Nginx 时，我们可以通过以下两种方式进行安装： 使用包管理器安装 Nginx 通过源代码安装 Nginx 使用包管理器安装 Nginx使用包管理器安装 Nginx 的机会，是你使用的操作系统已经提供了 Nginx 的安装包。使用包管理器安装 Nginx 的方式很简单，只需要在终端输入： Linux(基于 deb，如 Ubunut) 1sudo apt-get install nginx Linux（基于 rpm，如 CentOS) 1sudo yum install nginx FreeBSD 1sudo pkg_install -r nginx 通过上述命令，Nginx 将会安装到操作系统的标准位置下。如果使用操作系统的安装包安装 Nginx，那么通过上面的命令来安装是最佳方式。 Nginx 核心团队也提供了稳定的二进制版本，可以从 http://nginx.org/en/download.html 页面下载可用版本。未发布 Nginx 安装包的系统用户（例如，CentOS），可以使用下面指导来安装预测试、预编译二进制版本。 通过创建下面的文件，在系统中添加 Nginx 仓库的 yum 配置： 1234sudo vi /etc/yum.repos.d/nginx.repo[nginx]name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0enabled=1 然后，听过执行如下命令来安装 Nginx： 1sudo yum install nginx 也可以按照前面介绍的 URL 下载 nginx 发行版安装。 从源代码安装 NginxNginx 代码提供了两种独立的下载分支——开发版与稳定版。开发分支是一个正处于积极开发状态的版本。在这个版本中，会有一些新功能被集成到其中，在稳定版中是找不到这些功能的。当发布一个“开发”版时，它会经历同样的 QA 和作为稳定版本的一组类似测试功能。因此无论哪一个分支都一颗用于生产环境中，两者主要的不同，在于对第三方模块的支持。在开发板中，内部的 API 可能会发生改变，而稳定版则保持不变。因此，为了与第三方模块向下兼容，在稳定版中第三方模块都可以有效使用。 准备编译环境为了从源代码编译 Nginx，系统需要满足某些必要条件，除了编译器外，如果想分别启用 SSL 支持和使用 rewrite 模块，那么还需要提供响应的 OpenSSL 与 PCRE（Perl Compatible Regular Expressions）库及开发头文件。rewrite 模块是默认安装的。如果你还没有 PCRE 库与开发头文件，你需要在配置阶段禁用 rewrite 模块。这依赖于系统，也有可能在系统中已经默认安装了这些必要条件。如果没有安装，则需要从其安装包安装或者从源码下载并且解压安装，在 Nginx 配置脚本中指定他们在系统中的安装位置。 如果在配置文件中使用了—with-\\=\\选项，那么 Nginx 会视图建立一个静态依赖库。如果你想让 Nginx 不依赖于系统的任何其他部分，或是想获得些 Nginx 的二进制额外性能，那么你可能会使用构建静态库的做法。如果你使用外部库功能只能从某一个版本起有效（例如，NPN[Next Protocol Negotiation]TLS扩展从 OpenSSL1.0.1版有效），那么你就不得不将其指定到特定版本解压后的源代码路径中。 根据自己的喜好，你可能会提供其他的、可选安装包。你可以为这些安装包提供支持。他们包括 MD5和 SHA-1以支持散列算法、zip 压缩库、libatomic 库。在 Nginx 中，很多地方法会用到散列库，例如为了计算 URI 散列进而计算缓存 key。 zlib 压缩裤被用来投递 gzip 压缩内容。如果 atomic_ops 库有效，那么 Nginx 会用它来实现自动内存更新操作，以实现高性能的内存锁定代码。 从源代码编译读者可以从 http://nginx.org/en/download.html 下载 Nginx，在该页面找到.tar.gz 或者.zip 格式的源代码分支，安装如下步骤将下载的安装包解压到一个临时目录中: 12$ mkdir ~/bulid$ cd ~/bulid &amp;&amp; tar xzf nginx-&lt;version-number&gt;.tar.gz 使用下面命令配置 Nginx: 1$ cd ~/bulid/nginx-&lt;version-number&gt; &amp;&amp; ./configure 然后，使用下面命令进行编译安装： 1$ make &amp;&amp; sudo make install 在编译自己的二进制 nginx 时，你会有很大的灵活性来包含你仅使用的功能。你已经指定使用哪个用户运行 Nginx 了吗?你要使用默认的 logfile 位置，以便不用在 Nginx 的配置文件明确地说明它们吗?表 1-1 所示是配置选项列表，通过它来帮助你设计出自己的 nginx 命令。这些选项对 Nginx 都是有效的，模块可以被独立激活。 选项 解释 –prefix=\\ Nginx 安装的根路径，所有其他的安装路径都要依赖于该选项 –sbin-path=\\ 指定 Nginx 二进制文件的路径。如果没有指定，那么这个路径依赖于——prefix 选项 –conf-path=\\ 如果在命令行没有指定配置文件，那么将会通过这里指定的路径，Nginx 将会去那里寻找它的配置文件 –error-log-path=\\ 指定错误文件的路径，Nginx 会将其中写入错误日志文件，除非有其他配置 –pid-path=\\ 指定的文件将会写入 Nginx master 进程的pid，通常在/var/run 下 –lock-path=\\ 共享存储器互斥锁文件的路径 –user=\\ worker 进程运行的用户 –group=\\ worker 进程运行的组 –with-file-aio 为 FreeBSD4.3+和 Linux2.6.22+系统启用异步 I/O –with-debug 这个选项用于启用调试日志。在生产环境中不推荐使用该选项。 你可以使用优化编译，单但是如果使用包管理工具进行安装将无法获得这些优化，如下表： 选项 说明 –with-cc=\\ 如果想设置一个不再默认 Path 下的编译器 –with-cpp=\\ 设置 C 预处理器的响应路径 –with-cc-opt=\\ 指定必要的 include 文件路径，可能（-I\\）指出，也可能是优化(-O4)并指定64位构建 –with-ld-opt=\\ 包含连接器库的路径(-L\\)和运行路径(-R\\) —with-cpu-opt=\\ 通过该选项为特定的 CPU 构建 Nginx 配置 SSL 支持对于 TLS/SSL 协议，Nginx 使用 OpenSSL 项目。有关此开源工具包的更多信息，请访问 https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对 SSL 的支持。如果使用不带–with-ssl 选项的–with-http_ssl_module 或者–with-mail_ssl_module，你正在使用执行了 configure 命令的、安装在计算机上的 OpenSSL 库。如果你想要针对特定版本的 OpenSSL 进行编译，请下载该分发包，将其解压缩到一个目录中，然后将该目录的路径指定为–with-openssl 的参数。使用–with-openssl-opt 选项为 OpenSSL本身指定额外的构建选项。 例如，为了使用具有优化椭圆曲线的 OpenSSL 来构建 Nginx，您将使用如下的命令: 1$ ./configure --with-http_ssl_module --with-openssl=$&#123;BUILD_DIR&#125;/openssl-1.0.1p --with-openssl-opt=enable-ec_nistp_64_gcc_128 查找并安装第三方模块由于有多个开源项目，所以在 Nginx 周围就会有一个活跃的开发社区。由于 Nginx 的模块化特性，这个社区能够开发和发布模块，从而为 Nginx 提供额外的功能。它们涵盖了广泛的应用，所以着手开发自己的模块之前应该看看有什么可用模块。 安装第三方模块的过程相当简单，步骤如下。 1.定位你想要使用的模块(在 https://github.com 或者是 http://wiki.nginx.org/3rdPartyModules查找)。 2.下载该模块。 3.解压缩源代码安装包。 4.如果有 README 文件，那么阅读 README 文件，查看在安装中是否有依赖安装。 5.通过./configure–add-module=\\选项配置使用该模块。 这个过程会给你的 nginx 二进制文件与模块附加这个功能。 需要注意的是，很多第三方模块是实验性质的。因此，在将这些模块用于生产系统之前，首先要测试使用这些模块。另外请记住，Nginx 的开发版本中可能会有 API 的变化，会导致第三方模块出现问题。 添加对 Lua 的支持特别应该提到的是 ngx_lua 这个第三方模块，ngx_lua 模块提供了启用 Lua 的功能，而不是像 Perl 一样在配置时嵌入式脚本语言。该模块对于 perl 模块来说最大的优点就是它的无阻塞性，并与其他第三方模块紧密集成。对于它的安装说明的完整描述详见:https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。 小结通过编译你自己的二进制文件，你可以定制 Nginx能够为你提供哪些功能。对于你来说，构建和安装软件应该不会陌生。所以，创造一个构建环境或者确保所有依赖关系都存在，这并不会花费你很多的时间。一个 Nginx 的安装应该是按照你的需要，能随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。 参考资料： 《精通 Nginx》第二版","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[]},{"title":"function与感叹号","slug":"function And !","date":"2018-01-31T16:00:00.000Z","updated":"2018-03-09T13:33:02.267Z","comments":true,"path":"2018/02/01/cjek1zh5t003ax9rd12rd8wn3/","link":"","permalink":"http://www.maksim.website/2018/02/01/cjek1zh5t003ax9rd12rd8wn3/","excerpt":"","text":"function与感叹号最近有空可以让我静下心来看看各种代码，function与感叹号的频繁出现，让我回想起2个月前我回杭州最后参加团队会议的时候，@西子剑影抛出的一样的问题：如果在function之前加上感叹号 (!) 会怎么样？比如下面的代码： 1!function()&#123;alert('iifksp')&#125;() // true 在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？ 平时我们可能对添加括号来调用匿名函数的方式更为习惯： 1(function()&#123;alert('iifksp')&#125;)() // true 或者： 1(function()&#123;alert('iifksp')&#125;()) // true 虽然上述两者括号的位置不同，不过效果完全一样。 那么，是什么好处使得为数不少的人对这种叹号的方式情有独钟？如果只是为了节约一个字符未免太没有必要了，这样算来即使一个100K的库恐怕也节省不了多少空间。既然不是空间，那么就是说也许还有时间上的考量，事实很难说清，文章的最后有提到性能。 回到核心问题，为什么能这么做？甚至更为核心的问题是，为什么必须这么做？ 其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是让一个函数声明语句变成了一个表达式。 1function a()&#123;alert('iifksp')&#125; // undefined 这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错： 1function a()&#123;alert('iifksp')&#125;() // SyntaxError: unexpected_token 因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 a，就应该以 a(); 的方式调用。 但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。 所以，任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别。比如： 123var i = function()&#123;return 10&#125;(); // undefined1 &amp;&amp; function()&#123;return true&#125;(); // true1, function()&#123;alert('iifksp')&#125;(); // undefined 赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些一元运算都是有效的： 1234!function()&#123;alert('iifksp')&#125;() // true+function()&#123;alert('iifksp')&#125;() // NaN-function()&#123;alert('iifksp')&#125;() // NaN~function()&#123;alert('iifksp')&#125;() // -1 甚至下面这些关键字，都能很好的工作： 123void function()&#123;alert('iifksp')&#125;() // undefinednew function()&#123;alert('iifksp')&#125;() // Objectdelete function()&#123;alert('iifksp')&#125;() // true 最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的： 12(function()&#123;alert('iifksp')&#125;)() // undefined(function()&#123;alert('iifksp')&#125;()) // undefined 说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。 最后讨论下性能。我在jsperf上简单建立了一个测试：http://jsperf.com/js-funcion-expression-speed ，可以用不同浏览器访问，运行测试查看结果。我也同时将结果罗列如下表所示（由于我比较穷，测试配置有点丢人不过那也没办法：奔腾双核1.4G，2G内存，win7企业版）： Option Code Ops/sec Chrome 13 Firefox 6 IE9 Safari 5 ! !function(){;}() 3,773,196 10,975,198 572,694 2,810,197 + +function(){;}() 21,553,847 12,135,960 572,694 1,812,238 - -function(){;}() 21,553,847 12,135,960 572,694 1,864,155 ~ ~function(){;}() 3,551,136 3,651,652 572,694 1,876,002 (1) (function(){;})() 3,914,953 12,135,960 572,694 3,025,608 (2) (function(){;}()) 4,075,201 12,135,960 572,694 3,025,608 void void function(){;}() 4,030,756 12,135,960 572,694 3,025,608 new new function(){;}() 619,606 299,100 407,104 816,903 delete delete function(){;}() 4,816,225 12,135,960 572,694 2,693,524 = var i = function(){;}() 4,984,774 12,135,960 565,982 2,602,630 &amp;&amp; 1 &amp;&amp; function(){;}() 5,307,200 4,393,486 572,694 2,565,645 \\ \\ 0 \\ \\ function(){;}() 5,000,000 4,406,035 572,694 2,490,128 &amp; 1 &amp; function(){;}() 4,918,209 12,135,960 572,694 1,705,551 \\ 1 \\ function(){;}() 4,859,802 12,135,960 572,694 1,612,372 ^ 1 ^ function(){;}() 4,654,916 12,135,960 572,694 1,579,778 , 1, function(){;}() 4,878,193 12,135,960 572,694 2,281,186 可见不同的方式产生的结果并不相同，而且，差别很大，因浏览器而异。 但我们还是可以从中找出很多共性：new方法永远最慢——这也是理所当然的。其它方面很多差距其实不大，但有一点可以肯定的是，感叹号并非最为理想的选择。反观传统的括号，在测试里表现始终很快，在大多数情况下比感叹号更快——所以平时我们常用的方式毫无问题，甚至可以说是最优的。加减号在chrome表现惊人，而且在其他浏览器下也普遍很快，相比感叹号效果更好。 当然这只是个简单测试，不能说明问题。但有些结论是有意义的：括号和加减号最优。 但是为什么这么多开发者钟情于感叹号？我觉得这只是一个习惯问题，它们之间的优劣完全可以忽略。一旦习惯了一种代码风格，那么这种约定会使得程序从混乱变得可读。如果习惯了感叹号，我不得不承认，它比括号有更好的可读性。我不用在阅读时留意括号的匹配，也不用在编写时粗心遗忘—— 当我也这么干然后嚷嚷着这居然又节省了一个字符而沾沾自喜的时候，却忘了自己仓皇翻出一本卷边的C语言教科书的窘迫和荒唐……任何人都有忘记的时候，当再捡起来的时候，捡起的就已经不单单是忘掉的东西了。 2011-10-31更新：如果你使用aptana，那么在使用（!+-）时要注意一点，它们会让aptana的解析失效，导致Outline窗口没有任何显示。但是就代码本身而言，其运行没有任何问题。 本文转自扩葵中剑的博客 原文地址：https://swordair.com/function-and-exclamation-mark/","categories":[{"name":"javascript","slug":"javascript","permalink":"http://www.maksim.website/categories/javascript/"}],"tags":[]},{"title":"创建型设计模式之抽象工厂","slug":"抽象工厂","date":"2018-01-10T12:44:02.000Z","updated":"2018-03-09T14:29:03.542Z","comments":true,"path":"2018/01/10/cjek1zh6y0056x9rdxzetowkz/","link":"","permalink":"http://www.maksim.website/2018/01/10/cjek1zh6y0056x9rdxzetowkz/","excerpt":"","text":"原文地址：http://designpatternsphp.readthedocs.io 在软件工程中，创建型设计模式承担着对象创建的职责，尝试创建适合程序上下文的对象，对象创建设计模式的产生是由于软件工程设计的问题，具体说是向设计中增加复杂度，创建型设计模式解决了程序设计中对象创建的问题。 抽象工厂目的创建一系列互相关联或依赖的对象时不需要指定将要创建的对象对应的类，因为这些将被创建的对象对应的类都实现了同一个接口。抽象工厂的使用者不需要关心对象的创建过程，它只需要知道这些对象是如何协调工作的。 UML 图 代码在 GitHub 上查看代码 AbstractFactory.php 123456789101112&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;/** * In this case, the abstract factory is a contract for creating some components * for the web. There are two ways of rendering text: HTML and JSON */abstract class AbstractFactory&#123; abstract public function createText(string $content): Text;&#125; JsonFactory.php 1234567891011&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;class JsonFactory extends AbstractFactory&#123; public function createText(string $content): Text &#123; return new JsonText($content); &#125;&#125; HtmlFactory.php 1234567891011&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;class HtmlFactory extends AbstractFactory&#123; public function createText(string $content): Text &#123; return new HtmlText($content); &#125;&#125; Text.php 12345678910111213141516&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;abstract class Text&#123; /** * @var string */ protected $text; public function __construct(string $text) &#123; $this-&gt;text = $text; &#125;&#125; JsonText.php 12345678&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;class JsonText extends Text&#123; // do something here&#125; HtmlText.php 12345678&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;class HtmlText extends Text&#123; // do something here&#125; 测试12345678910111213141516171819202122232425262728&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory\\Tests;use DesignPatterns\\Creational\\AbstractFactory\\HtmlFactory;use DesignPatterns\\Creational\\AbstractFactory\\HtmlText;use DesignPatterns\\Creational\\AbstractFactory\\JsonFactory;use DesignPatterns\\Creational\\AbstractFactory\\JsonText;use PHPUnit\\Framework\\TestCase;class AbstractFactoryTest extends TestCase&#123; public function testCanCreateHtmlText() &#123; $factory = new HtmlFactory(); $text = $factory-&gt;createText('foobar'); $this-&gt;assertInstanceOf(HtmlText::class, $text); &#125; public function testCanCreateJsonText() &#123; $factory = new JsonFactory(); $text = $factory-&gt;createText('foobar'); $this-&gt;assertInstanceOf(JsonText::class, $text); &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"DOM本质","slug":"DOM本质","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-07T10:42:36.852Z","comments":true,"path":"2018/01/05/1/","link":"","permalink":"http://www.maksim.website/2018/01/05/1/","excerpt":"","text":"抛出问题! DOM是那种基本的数据结构？ DOM操作的常用API都有哪些？ DOM节点的attr和property有何区别？ 解答问题: 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;title&gt;Reminder&lt;/title&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt; &lt;other&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;/other&gt;&lt;/note&gt; DOM本质上面的代码是一段XML，这是一个结构化语言，跟它其同样作用的还有JSON，他们可以用于描述一切可以结构化的数据。 这段代码快描述了一封信，to收件人，from 来源，title标题，body内容。 DOM本质上是一个树形结构。我们可以将其理解为，浏览器把拿到的HTML代码，结构化成一个浏览器能够识别且能被js操作的一个模型。 我们知道HTML本质上就是字符串，计算机处理字符串是一件相当头疼的一件事情，通过DOM，我们就可以将HTML文件抽象成一个树形结构，只要是结构化的数据，计算机处理起来，无论你的逻辑结构有多复杂，他都能够轻松的进行处理。 获取DOM节点1234567var div1 = document.getElementById('div1') //元素 var divList = document.getElementByTagName('div') //集合console.log(divList.length)console.log(divList[0])var containerList = document.getElementsByClassName('.container'); //集合var pList = document.querySelectorAll('p') //集合 上面的代码都是JavaScript的基础API，有的人可能用jQuery或其他的的库时间长了，就把基础API给忘了，或者是基础并不是很牢，一直都在用库，这样的话最好将基础补齐，因为在面试的时候，大多数的面试题都是问的基础。 在面试的时候有个技巧，不要轻易的撩起用的熟，但是不知道实现原理的东西，比如说你会用jQuery的绑定事件，面试官肯定会问你实现原理。 Property12345678910var pList = document.querySelectorAll('p')var p = pList[0]console.log(p.style.width) //获取样式p.style.width = '100px;'console.log(p.className)p.className = 'p1'//获取nodeName 和 nodeTypeconsole.log(p.nodeName)console.log(p.nodeType) 在这里我们需要知道P是个什么东西，它不就是个DOM节点吗？ 其实它本质上就是一个JS对象。上面我们说过DOM的本质是一个JS可识别可操作的。既然本质上是一个对象，我们就可以操作他的属性，那这些属性都是怎么进去的？ 这是浏览器规定的，W3C就是这么规定的。 12345var obj &#123;x:100, y:200&#125;;console.log(obj.x) // 100var p = document.getElementsByTagName('p')[0]cosnole.log(p.nodeName); //p Attribute123456var pList = document.querySelectorAll('p')var p = pList[0]p.getAttribute('data-name')p.setAttribute('data-name', 'maksim')p.getAttribute('style')p.setAttribute('style', 'font-size:30px;') 我们在上述代码中该的 data-name 和 style 到底是什么呢？ 其实就是HTML文档里的标签，并不是JavaScript里的对象。这也是两者之间的区别","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maksim.website/categories/JavaScript/"}],"tags":[]},{"title":"cookie, sessionStorage和localStorage的区别","slug":"2018-1-5-cookie,-sessionStorage和localStorage的区别","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-07T10:42:39.757Z","comments":true,"path":"2018/01/05/3/","link":"","permalink":"http://www.maksim.website/2018/01/05/3/","excerpt":"","text":"在HTML5出来之前，只有cookie作为本地存储的一个方法（JavaScript Web API）。 cookie 本身用于客户端和服务器端通信的， 但是它有本地存储的功能， 于是被“借用” 使用document.cookie = … 获取和修改即可，用起来特别麻烦 缺点： 存储量太小，只有4kb 所有http请求都带着，会影响获取资源的效率，所以cookie只适合保存很小的数据，如会话标识 API简单，需要封装才能用document.cookie = … 有效时长根据设定的过期时间而定。 ​ sessionStorage 和localStorage HTML5专门为存储而设计，因为不需要像服务端发送数据，所以最大容量5M API简单易用： localStorage.setItem(key, value); localStorage.getItem(key) sessionStorage当关闭浏览器后便会被清除，localStorage则不会，即使关闭浏览器localStorage也会一直存在，直到删除 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的 在iOS Safari 隐匿模式下，localStorage.getItem会报错，建议同一使用try-catch Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maksim.website/categories/JavaScript/"}],"tags":[]},{"title":"PHP基础手札的引用","slug":"PHP基础手札的引用","date":"2017-10-21T10:06:24.000Z","updated":"2017-10-21T10:06:25.000Z","comments":true,"path":"2017/10/21/cjek1zh4y001qx9rdukb1cfg6/","link":"","permalink":"http://www.maksim.website/2017/10/21/cjek1zh4y001qx9rdukb1cfg6/","excerpt":"","text":"在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。 PHP 的指针域这些语言机制相同，即可以用一个变量","categories":[],"tags":[]},{"title":"","slug":"C语言中的内存","date":"2017-10-21T09:59:26.000Z","updated":"2018-01-07T10:50:24.324Z","comments":true,"path":"2017/10/21/cjek1zh3r000cx9rdgopv52nf/","link":"","permalink":"http://www.maksim.website/2017/10/21/cjek1zh3r000cx9rdgopv52nf/","excerpt":"","text":"title:C语言中的内存categories:C/C++date:2017-10-21 id:1 C 程序在编译后，会以三种形式使用内存。 静态变量/全局内存 静态声明的变量分配在这里，全局变量也会使用这部分内存。这些内存在程序开始运行时分配，直到程序终止才会消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。 自动内存 这些变量在函数内部声明，并且在函数被调用时才能创建。它们的作用域局限于函数内部，而且在函数被调用才创建。它们的作用域局限于函数内部，热切声明周期限制在函数的执行时间内。 动态内存 内存分派在堆上，可以根据需要存放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。","categories":[],"tags":[]},{"title":"PHP常见的经典面试题","slug":"如何看待面试这回事","date":"2017-10-20T16:00:00.000Z","updated":"2017-10-22T04:14:20.000Z","comments":true,"path":"2017/10/21/2/","link":"","permalink":"http://www.maksim.website/2017/10/21/2/","excerpt":"","text":"常见经典面试题 什么是引用变量？在 PHP 当中用什么符号定义引用变量？ 要求写出JQuery 中，可以处理AJAX的几种方法。 写出尽可能多的Linux 命令 写出三种以上 MySQL数据存储引擎的名字 编写在线留言本，实现用户的在线留言功能 谈谈你对 MVC 的认识，介绍几中目前比较流行的MVC 框架 请写出常见的排序算法 PHP 如何解决网站大流量与高并发 1.什么是引用变量？在 PHP 当中用什么符号定义引用变量。 考官考点： PHP 的引用变量的概念以及定义方式 延伸：PHP 引用变量的原理 概念： 在 PHP 中引用意味着用不同的名字访问同一个变量内容。 定义方式 ： 使用&amp;符号","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.maksim.website/tags/面试/"}]},{"title":"PHP 控制反转、依赖注入、依赖查找服务容器？","slug":"PHP-依赖注入和服务容器","date":"2017-10-18T16:00:00.000Z","updated":"2017-10-22T04:09:53.000Z","comments":true,"path":"2017/10/19/cjek1zh550022x9rd57ob3bnr/","link":"","permalink":"http://www.maksim.website/2017/10/19/cjek1zh550022x9rd57ob3bnr/","excerpt":"","text":"控制反转（Inversion of Control，英文缩写为IoC）是框架的重要特征，并非面向对象编程的专用术语。它与依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）并没有关系。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"服务容器","slug":"服务容器","permalink":"http://www.maksim.website/tags/服务容器/"}]},{"title":"《PHP internals Book》 一本深入PHP 扩展开发的书籍","slug":"《PHP-internals-Book》-介绍","date":"2017-10-17T16:00:00.000Z","updated":"2018-01-07T10:45:32.198Z","comments":true,"path":"2017/10/18/10/","link":"","permalink":"http://www.maksim.website/2017/10/18/10/","excerpt":"","text":"今天给大家介绍一本 PHP 扩展开发相关的书籍《PHP internals Book》，这本书是几个PHP开发人员之间的协作努力，可以更好地记录和描述PHP内部的工作原理。 《PHP internals Book》 有三个主要目标： 记录和描述PHP内部工作原理。 记录并描述如何使用扩展扩展语言。 记录并描述如何与社区进行交互以开发PHP本身。 《PHP internals Book》 主要面向具有C编程语言经验的开发人员。然而，尽管如此，我们将尝试提炼信息并对其进行总结，以便不了解C的开发人员仍然能够理解内容。 但是，让我们坚持。如果您不知道C语言，您将无法实现高效，稳定（任何平台下的崩溃），性能和实用性。以下是有关C语言本身，生态系统和构建工具以及操作系统API的一些非常好的在线资源： http://www.tenouk.com/ https://en.wikibooks.org/wiki/C_Programming http://c-faq.com/ https://www.gnu.org/software/libc/ http://www.faqs.org/docs/Linux-HOWTO/Program-Library-HOWTO.html http://www.iecc.com/linker/linker10.html","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"PHP基础解惑： =与==、===的区别","slug":"PHP基础解惑：-=与==、===的区别","date":"2017-10-17T16:00:00.000Z","updated":"2017-10-18T13:19:23.000Z","comments":true,"path":"2017/10/18/1/","link":"","permalink":"http://www.maksim.website/2017/10/18/1/","excerpt":"","text":"首先等于号（=）在大多数语言中都是赋值操作； ==和===都是比较运算符，用来比较两个变量间的关系，他们两个都有“等于”的含义，不过===是恒等计算符。两侧数据类型不一致时会返回 false，在官方文档中给出如下： ==如果两侧的变量类型不同时，会转化类型后在进行比较。 例子 名称 结果 $a == $b 等于 TRUE，如果类型转换后 $a 等于 $b。 $a === $b 全等 TRUE，如果 $a 等于 $b，并且它们的类型也相同。 上表摘自 PHP 手册。下面来看一个例子： 123456&lt;?php $age = 18; var_dump($age == 18)l //bool(true) var_dump($age === 18); //bool(true) var_dump($age == '18'); //bool(true) var_dump($age === '18'); //bool(false)","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP基础","slug":"PHP基础","permalink":"http://www.maksim.website/tags/PHP基础/"}]},{"title":"PHP页面静态化","slug":"PHP静态化页面","date":"2017-10-16T11:17:47.000Z","updated":"2017-10-16T11:30:35.000Z","comments":true,"path":"2017/10/16/cjek1zh5l002wx9rdne5wgp86/","link":"","permalink":"http://www.maksim.website/2017/10/16/cjek1zh5l002wx9rdne5wgp86/","excerpt":"","text":"关于页面要了解静态化页面，首先我们就要知道什么是页面？ 一、静态web页面： 1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。 2、为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。 3、静态web无法连接数据库； 4、静态web资源开发技术：HTML； 5、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。 二、动态web页面： 动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。 如果客户端请求的是静态资源(.htm或者是.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。 如果客户端请求的是动态资源（.jsp、.asp/.aspx、.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。 #静态化 PHP静态化分为：纯静态化 和 伪静态化；纯静态化又分为：局部静态化 和 完全静态化 纯静态化：是把PHP生成的动态页面保存成静态的html文件，用户访问该静态页面，而不是用户每一次访问都重新生成一张相同的网页，优点就是减小服务器开销， 局部静态化：是生成的静态文件中，有局部的数据还是通过ajax技术动态获取的； 完全静态化：即不存在动态获取数据的情况，所以内容都来自静态的html页面 伪静态化：其实还是动态访问，其实质是动态生成数据，你访问的网址类似于”http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化 伪静态的优点：美观；便于搜索引擎收录 buffer 概括 buffer 其实就是缓冲区，一个内存地址空间，主要是用于存储数据的区域。","categories":[],"tags":[]},{"title":"PHP基础手札之emtpy、isset、is_null的区别","slug":"PHP基础手札之emtpy、isset、is_null的区别","date":"2017-10-15T16:00:00.000Z","updated":"2017-10-16T01:55:22.000Z","comments":true,"path":"2017/10/16/2/","link":"","permalink":"http://www.maksim.website/2017/10/16/2/","excerpt":"","text":"PHP提供了3个用于测试变量值的函数，分别是isset()、empty()、is_null（从这里就可以看出PHP系统函数变量名命名的混乱，这也是一直被人诟病的地方）.这几个函数均返回布尔值，有时使用不当会造成意想不到的结果。 比如，用isset()和empty()返回的结果是相反的，但却并非一直如此。 isset()用来检测一个变量是否已声明且值不为null。只能在变量不是null时返回真。 empty()用来检测一个变量是否为空，也就是说有如下情况时返回真值：变量是一个空字符串，false，空数组,null,’’,以及被unset删除后的变量。 在PHP5.5之后，empty()函数可以接受任意类型的表达式 is_null()函数用来判断变量内容是否是null，即返回真值的条件仅为变量值是null，值得一提的是，is_null() 是 isset() 的反函数，区别是isset()函数可以应用到未知变量，但is_null()只能针对以声明的变量。 对比项 变量值($var) isset($var) empty($var) is_null($var) “”（空字符串） bool(true) bool(true) bool(false) “ “(空格) bool(true) bool(false) bool(false) false bool(true) bool(true) bool(false) true bool(true) bool(false) bool(false)","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"PHP基础解惑：省略结束标签","slug":"PHP基础手札之省略结束标签","date":"2017-10-15T16:00:00.000Z","updated":"2018-03-09T13:13:44.475Z","comments":true,"path":"2017/10/16/1/","link":"","permalink":"http://www.maksim.website/2017/10/16/1/","excerpt":"","text":"对于PHP编译器来说，脚本的结束标签?&gt;是可选的，在写程序时你可以忽略它。你或许碰见过：在使用include()、require()或输入输出缓冲函数时，页面顶部有时会多空行或者出现“header had send”之类的错误信息，这类问题与结束标签有关。 省略结束标签适合纯PHP文件。如果是PHP与HTML混合开发，则不可省略。 忽略结束标签不仅能少些两个字符，而且可以使得我们开发的过程更加顺利。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP基础","slug":"PHP基础","permalink":"http://www.maksim.website/tags/PHP基础/"}]},{"title":"","slug":"MySQL常用存储引擎之Innodb","date":"2017-10-15T11:24:45.000Z","updated":"2017-10-15T11:52:43.000Z","comments":true,"path":"2017/10/15/cjek1zh4b0013x9rdm6furr8r/","link":"","permalink":"http://www.maksim.website/2017/10/15/cjek1zh4b0013x9rdm6furr8r/","excerpt":"","text":"MySQL常用存储引擎之InnodbMysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。 和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。 特点： 灾难恢复性好 支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的 使用行级锁 对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的 实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引 支持外键 支持热备份 Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由innodb_file_per_table这个参数决定。 如果值为 ON,会为每个 innodb 表建立一个tablename.ibd的系统文件，如果该参数为OFF时会把数据存储到系统的表空间ibdataX 引用 《打造扛得住的 MySQL》 慕课网 《高性能 MySQL》 《My》","categories":[],"tags":[]},{"title":"","slug":"MySQL服务器参数介绍","date":"2017-10-13T08:56:28.000Z","updated":"2018-02-27T13:04:29.467Z","comments":true,"path":"2017/10/13/cjek1zh48000yx9rd33kitjv1/","link":"","permalink":"http://www.maksim.website/2017/10/13/cjek1zh48000yx9rd33kitjv1/","excerpt":"","text":"title:MySQL服务器参数介绍categories:MySQLdate:2017-10-18 id:1人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。 MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。 从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。 ## MySQl获取配置信息路径 命令行参数 mysqld_safe --datadir=/data/sql_data 配置文件 mysqld --help --verbose | grep -A 1 &#39;Default options&#39; MySQL会先从/etc/my.cnf文件下读取配置信息，然后是/etc/mysql/my.cnf。 MySQL配置参数的作用域 全局参数 set global 参数名 = 参数值; set @@global。参数名:=参数值; 会话参数 set [session] 参数名=参数值; set @@session.参数名:=参数值; 会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。 在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。 内存配置相关参数MySQL对于内存的使用我们可以分为两个类来看。 无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存 可以通过参数配置控制的，各类的缓冲池所需要的内存。 对内存参数配置之前，我们需要进行考虑： 确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。 确定MySQL的每个连接使用的内存，例如排序缓冲和临时表 把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。 sort_buffer_size join_buufer_szie read_buffer_size read_rnd_buffer_size 确定需要为操作系统保留多少内存给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。 数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。 另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。 如何为缓冲池分配内存Innodb_buffer_pool_size，Innodb缓冲区 总内存-（每个线程所需要的内存*连接数）- 系统保留内存 手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。 key_buffer_size设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而 1select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos; I/O相关配置参数Innodb I/O相关配置 安全相关配置参数expire_logs_days 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。","categories":[],"tags":[]},{"title":"","slug":"业务评估","date":"2017-10-13T05:41:58.000Z","updated":"2017-10-13T05:41:58.000Z","comments":true,"path":"2017/10/13/cjek1zh680040x9rdc6vovma2/","link":"","permalink":"http://www.maksim.website/2017/10/13/cjek1zh680040x9rdc6vovma2/","excerpt":"","text":"业务评估业务需求 响应时间（request time） 数据总量 每秒请求量 读写比 重要程度 响应时间是与整个数据库的状态有关，不仅与CPU、数据总量、每秒请求量、读写比以及各种场景都是有关系的。所以说相应时间是一个综合指标。 对于DBA来说最关心的就是业务的相应时间能不能够满足，在满足的情况下再去优化以下的这些点，才是有意义的。 数据总量往往需要业务方提供一个一到两年的数据总量，这是因为如果没有数据总量，前期是没有办法规划我们的数据库实例的。当然也有很多的不确定因素，比如互联网行业，比如有的业务会爆发性的增长，这些规划可能是不合理的，但是在我们也要有一个大概的评估，因为这是前期资源申请和资源分配的策略。 每秒请求量","categories":[],"tags":[]},{"title":"MySQL体系结构","slug":"MySQL体系结构","date":"2017-10-12T16:00:00.000Z","updated":"2017-10-13T11:35:40.000Z","comments":true,"path":"2017/10/13/1/","link":"","permalink":"http://www.maksim.website/2017/10/13/1/","excerpt":"","text":"数据库产品的架构一般可以分为应用层、逻辑层、物理层，对于MySQL，同样可以理解为如下3个层次。 其中Connectors可以理解为各种客户端、 应用服务； Connection Pool可以理解为应用层，负责和客户端、用户进行交互，需要和不同的客户端（PHP,Java,C API,.Net以及ODBC,JDBC等等）和中间服务器进行交互，这一层主要完成的是链接处理，授权认证，和安全等一些功能，连接到MySQL的客户端在其进程中，都会有一个独立的线程，连接的查询只会在这个登录线程中进行查询。 Management Services&amp;Utilities、SQL Interface、 Parser、 Optimizer、 Caches&amp;Buffers、 Pluggable Storage Engines可以理解为数据库的大脑——逻辑层。 负责具体的查询处理、事务处理、存储管理、恢复管理，以及其他附加功能。查询处理器负责查询的解析、执行。当接收到客户端的查询时，数据库会分配一个县城来处理它。先友查询处理器（优化器）生成执行计划，然后交由计划执行器来执行，执行器有时需要访问更底层的事务管理器、存储管理器来操作数据，事务管理器、存储管理器主要负责事务控制、并发控制、存储管理。在其中，将由事务管理来保证“ACID”特性，通过锁管理器来控制并发，由日志管理器来确保数据持久化，存储故那里器一般还包括一个缓冲管理器，有它来确定磁盘和缓存之间的数据传输。 根据上面的架构图，我们可以看到在逻辑层中Pluggable Storage Engines 这是MySQL服务逻辑架构中的第三层，是MySQL的存储引擎，MySQL提供出了存储引擎接口，第三方可以根据自己的业务逻辑需求开发自己的存储引擎，Innodb起初就是由Innobase Oy公司所开发，2006年5月被甲骨文公司并购。 服务器通过API与存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作，但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层和服务的请求。 注意：存储引擎是针对于表的而不是针对于库的，不同的表可以使用不同的引擎； 最下方的Files&amp;Logs可以理解为物理层，实际物理磁盘（存储）上的数据库文件，比如数据文件、日志文件等等。 引用： 《MySQL DBA修炼之道》 作者陈晓勇 出版社：华章图书 《打造扛得住的MySQL》 电子工业出版社","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"MySQL常用存储引擎之MyISAM","slug":"MyISAM","date":"2017-10-12T16:00:00.000Z","updated":"2017-10-18T13:54:04.000Z","comments":true,"path":"2017/10/13/2/","link":"","permalink":"http://www.maksim.website/2017/10/13/2/","excerpt":"","text":"MyISAM存储引擎是MySQL5.5之前版本默认的存储引擎，由于这个原因，现在还有大量的数据库在使用MyISAM的表。 同时它也是MySQL大部分系统表和临时表使用的而存储引擎，这个临时表并非是我们使用CREATE TEMPORARY TABLE所建立的临时表。 使用CREATE TEMPORARY TABLE语句创建的临时表，我们可以使用MySQL各种存储引擎的，这里所说的临时表指的是在排序、分组等操作中，当当数量超过一定大小后，由查询优化器所建立的磁盘临时表。 MyISAM存储引擎表由MYD和MYI组成。 在这里，我们建立一个myIsam的表，并且存储引擎使用了MyISAM。 1234CREATE TABLE `myIsam` ( `id` int(11) DEFAULT NULL, `c1` varchar(10) DEFAULT NULL)ENGINE= MyISAM DEFAULT CHARSET=utf8 下图为MyISAM在文件系统上的存储方式： 以frm为扩展名存储的文件并非是MyISAM存储引擎独有，它是用于记录表的结构。MyISAM表可以存储的记录数，一般首选治愈可用磁盘空间，或者是操作系统单个文件最大尺寸的限制。 作为MySQL最早的存储引擎之一，MyISAM有一些已经开发出来很多年的特性，可以满足用户的实际需求。 加锁与并发 MyISAM使用的是表级锁，进行读取操作时会对需要读到的所有表加共享锁，写入时则会对表加排他锁。但是在表有读取查询的同时，可以往表中插入新的记录，这也被称之为并发插入，CONCURRENT INSERT 修复 对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作，但是此处的修复和事务恢复以及崩溃恢复并不是一个概念，执行表的修复可能导致数据的丢失，而且修复操作时非常慢的。可以通过CHECK TABLE table检查表的错误，如果存在错误可以通过REPAIR TABLE table进行修复。在MySQL服务器处于关闭状态时，可以通过myisamcheck命令工具进行检查和恢复，切记是处于关闭状态。 索引 对于MyISAM表，即使是BLOG和TEXT等长字段，也可以基于前500个字符创建索引，而且MyISAM也支持全文索引。 延迟更新索引（Delayed Key Write）创建MyISAM表的时候，如果制定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃的时候会造成索引损坏，需要执行修复操作。此属性可以再全局设置，也可以为单个表设置。 压缩 如果表在创建并导入数据以后，不会再进行修改操作，可以使用myisampa对表进行压缩（打包）。压缩表不能进行修改，除非解除压缩，压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升性能，压缩表支持索引，但索引也是只读的。 压缩时表中的记录是独立压缩的，所以读取单行的时候不需要去解压整个表。 限制 版本&lt;MySYQL5.0时默认表大小为4G，如存储大表则需要修改MAX_Rows和AVG_ROW_LENGTH这两个参数，调整后表会进行重建，这需要很长的时间。 版本 &gt; 5.0时默认支持256TB 适用场景： 非事务性应用 只读类应用 空间类应用（在5.7之前，MyISAM是唯一支持空间函数的存储引擎）","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"服务器系统对MySQL性能带来的影响","slug":"服务器操作系统对MYSQL性能带来的影响","date":"2017-10-09T16:00:00.000Z","updated":"2017-10-13T11:39:54.000Z","comments":true,"path":"2017/10/10/2/","link":"","permalink":"http://www.maksim.website/2017/10/10/2/","excerpt":"","text":"影响数据库性能的主要因素有很多，主要包括以下几点： 服务器硬件 服务器系统 数据库存储引擎的选择 数据库参数配置 数据库结构设计和SQL语句 服务器系统MySQL本身支持很多操作系统： Windows FreeBSD Solaris Linux 很多人都习惯将开发环境的数据库部署在Windows上，将生产环境的数据库部署在Linux上，这就会导致一个问题，MySQL 的schema存储方式在文件系统上实际是一个目录，在Windows平台上，大小写是不敏感的，而在Linux上大小写是敏感的，所以这就会导致，数据库和表的名字在Windows是可以运行的，但是当移植到Linux下就会找不到相关数据库和表的错误。 CentOS系统参数优化内核相关参数（/etc/sysctl.conf） 12345678910111213141516171819202122232425262728293031# net.core.somaxconn = 65535net.core.netdev_max_backlog = 65535net.ipv4.tcp_max_syn_backlog = 65535# TCP连接回收net.ipv4.tcp_fin_timeout = 10net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.core.wmen_default = 87380net.core.wmen_max = 16777216net.core.rmem_default = 87380net.core_rmem_max = 1677216net.ipv4.tcp_keeplive_time = 120net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 3kernel.shmmax = 4294967295# Linux内核参数最重要的参数之一，用于定义单个共享内存段的最大值# 1. 这个参数应该设置的足够大，以便能在一个共享内存段下容纳下整个Innodb缓冲池的大小# 这个值的大小对于64位Linux系统，可取的最大值为物理内存值-1byte,建议设置为物理内存的一半，一半取决于Innodb缓冲池的大小即可，可以取物理内存-1bytevm.swappiness = 0 # 这个参数当内存不足时会对性能产生较明显的影响# Linux系统内存交换区。# 禁用交换分区所带来的风险：# 1. 降低操作系统的性能# 2。 容易造成内存溢出，崩溃，或者被操作系统kill掉# 在MySQL服务器上保留叫分区还是有必要的额，但是要控制何时使用交换分区，vm.swappiness = 0 ，就是告诉内核除非虚拟内存完全满了，否则就不会使用交换分区 增加资源限制（/etc/security/limit.conf），这个文件实际上是Linux PAM也就是插入式认证模块的配置文件。 123456789* soft nofile 65535* hard nofile 65535# * 表示对所有用户有效# soft 指的是当前系统生效的设置# hard 表明系统中所设定的最大值# nofile 表示所限制的资源是打开文件的额最大数目# 65535 就是限制的数量# 把可打开的文件数量增加到65535个，以保证可以打开足够多的文件句柄，这个文件的修改需要重启系统后生效 磁盘调度策略(/sys/block/devname/queue/scheduler) 12cat /sys/block/devname/queue/schedulernoop anticipatory deadline [cfq] noop（电梯式调度策略）NOOP实现了一个FIFO队列，它像电梯的工作方式一样对I/O请求进行组织，当有一个新的请求到来时，它将请求合并到最近的请求之后，以此来保证请求同一个介质。NOOP倾向于饿死读而利于写，因此NOOP对于闪存设备，RAM以及嵌入式是最好的选择。 deadline（介质时间调度策略）Deadline确保了在一个截至时间内服务请求，这个截至时间是可调整的，而默认读期限短于写期限。这样就防止了写操作因为不能被读取而饿死的现象。Deadline对数据库类应用是最好的选择。 anticipatory（预料I/O调度策略）本质上与Deadline一样，但在最后一次读操作后，要等待6ms，才能继续进行对其他I/O请求进行调度。它会在每个6ms中插入新的I/O操作，而会将一些小写入流合并成一个大写入流，用写入延时换取最大的写入吞吐量。AS适合于写入较多的环境，比如文件服务器，AS对数据库环境表现很差。 通过下面方法修改磁盘策略： 1echo deadline &gt; /sys/block/devname/queue/scheduler 文件系统在Windows环境下，仅有FAT和NTFS两种文件系统，但其实现在只使用NTFS。 在Linux环境下就不同了，目前主流的文件系统有EXT3、EXT4、XFS。这三种文件系统都带有日志，安全性可以得到保证，江湖传闻XFS新更能更好。 EXT3/4系统的挂在参数(/etc/fstab) 1234# 日志写入data = writeback | ordered | jouranlnoatime, nodiratime/dev/sda1/ext4 noatime,nodiratime,data=writeback 1 1","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"服务器硬件对MYSQL性能的影响","slug":"服务器硬件对MYSQL性能的影响","date":"2017-10-09T16:00:00.000Z","updated":"2017-10-15T11:12:06.000Z","comments":true,"path":"2017/10/10/1/","link":"","permalink":"http://www.maksim.website/2017/10/10/1/","excerpt":"","text":"影响数据库性能的主要因素有很多，主要包括以下几点： 服务器硬件 服务器系统 数据库存储引擎的选择 数据库参数配置 数据库结构设计和SQL语句 服务器硬件：每当大促或者一些活动的时候，我们监控系统时会发现，CPU和可用内存的资源都是很紧张的，特别对于一些计算密集型的应用，CPU的资源可能会变成系统的瓶颈。 当我们工作所需要的热数据的大小大于可用内存大小的时候，IO系统就会变成我们的瓶颈。 网络也算是一种IO，它对于性能的影响往往发生在大量的数据被查询时，特别是使用MemCache这类缓存系统时，当缓存大量失效时，就会造成大量的网络传输从而影响服务性能。 当发生这类问题的时候，我们可以升级I/O子系统，来增加大量的内存。 如何选择CPU？我们是选择更多的CPU，还是更快的CPU？Intel Xeon E7-8890 v2 主频2.5GHz 核心数量：18核36线程 正常情况下，这两点我们都想要，但是现实是残酷的，44499RMB的价格，并不是所有公司都能够接受的。 首先，我们需要考虑几个问题。 ####我们的应用是CPU密集型的应用吗？ 如果是CPU密集型的应用要加快SQL的处理速度，显然我们需要的是更快的CPU而不是核心较多的CPU。 值得注意的是，MySQL目前还不支持多CPU对同一SQL并发处理。 也就是说，一条SQL只能使用一颗CPU来进行处理，多颗CPU对于一条SQL的处理效率是没有帮助的。 我们系统的并发量如何？ 虽然单个SQL无法利用到多个CPU资源，如果要提高系统的吞吐量和并发处理量呢？ 这时我们就需要CPU越多越好。 在Web应用中，CPU的数量就要比频率要重要一些。 我们所使用的MySQL版本也会决定如何选择CPU，老版本的MySQL对于多核CPU的支持并不好，5.0之前的版本限制是非常严重的，5.6、5.7对多核CPU的支持已经有了很好的改善。 选择32位还是64位的CPU？这个问题已经是多余的了，目前64位已经是默认配置了，而且MySQL对于64位CPU的支持已经很好了。 不过值得注意的是，在64位CPU上使用32位操作系统，意味着我们不能使用大的内存，任何一个单独的进程都不能寻址到4G以上的内存，MySQL是一个单线程的服务，这样就会对MySQL的性能造成极大的影响。 内存、更大更快？内存的大小直接影响数据库的性能，目前内存的IO效率要远远高于磁盘，所以把数据缓存到内存中可以大大提高数据库性能。 MyISAM会把索引缓存到内存中，数据放到系统上进行缓存。 InnoDB会在内存上同时缓存索引和数据，所以可以提高运行效率 内存的确是越多越好，可是数据库的性能影响也是有限的，并不能无限增加性能，数据库可以利用的内存是有限的。 当所有的数据都被缓存到内后，再增加内存大小就变成没有意义的了。 如果我们的数据的大小是100G，内存是64G，我们可以通过扩展内存到128G来扩大数据库的缓冲区来提高数据库性能。 可是如果此时内存以经256G了，并且数据库的缓存池大小已经达到了196G的情况下，就不能指望增加内存来提高数据库心梗了。 多余的内存可以增加操作系统等其他服务的性能。 缓存虽然不能避免磁盘的写操作，但是可以起到延缓作用，把多次写入变成一次写入。 ### 内存的选择？ 内存的频率越高读取也就越快，应该选择主板所支持的最高主频，组成购买升级，每个通道的内存最高相同品牌、颗粒、频率、电压、校验技术和型号。单条容量要尽可能的大。 根据数据库大小选择内存，例如现在热数据有100G，那么我们就可以选择128G的内存。但是还有一个问题，那就是数据的增长率，为了避免短时间内多次升级硬件，可以选择更大一些的内存。 ##I/O子系统（磁盘的配置和选择） 虽然内存对数据库的性能影响很重要，通过增加内存大小可以解决大部分性能问题，但是并不能忽视I/O子系统对性能影响。 有时我们需要以牺牲内存为代价提高I/O子系统的性能，因为无论如何最终，数据都要通过磁盘来进行持久化的存储。 目前主流的四种磁盘配置： 使用传统机器磁盘 使用RAID增强传统机器磁盘 使用固态存储SSD和PCIe卡 使用网络存储NAS和SAN 传统机器硬盘传统机器磁盘是目前最常见的选择，使用最多，这类磁盘价格低，存储空间大，但是读、写速度较慢，传统机器硬盘的读、写效率取决于它的存储机制。 传统机器硬盘读取数据的过程： 移动磁头到磁盘表面的正确位置 等待磁盘旋转，使所需的数据在磁头之下 等待磁盘旋转过去，所有所需的数据都被磁头读取 磁盘执行这些操作有多快，也就决定了磁盘的读取速度，第1,2步骤被称之为访问时间，第3步称之为传输速度。 如何选择传统机器硬盘 存储容量 传输速度 访问时间 主轴转速 物理尺寸 RAID增强机器硬盘的性能首先我们要知道什么是RAID，RAID是磁盘冗余队列的简称（Redundant Arrays of independent Disks）简单来说RAID的作用就是可以把多个容量较小的磁盘组成一组容量更大的磁盘，并提供数据冗余保证数据完整性的技术。 数据库中使用的RAID 0级别：RAID 0是最早出现的RAID模式，也称之为数据条带，是组建磁盘阵列中最简单的一种形式，只需要两块以上的硬盘即可，成本低，可以提高整个磁盘的性能和吞吐量。RAID 0没有提供冗余或错误修复能力，但是实现成本是最低的。 RAID 0 就是多个独立的磁盘串联到一起，比如有三块300G的磁盘组合到一起，就可以组成一块900G的磁盘，在写入时可以并发同时对三块磁盘进行写入，理论上写入效率就是普通磁盘的三倍。 RAID 0可能是性价比最高的解决方案，但是如果考虑到数据的恢复、可靠性因素，RAID 0就变成了一种成本最高的一种解决方案。 因为在RAID 0 中数据没有冗余，数据损坏的几率要比单块磁盘的几率还要高，因为RAID 0中任意一块磁盘损坏了，都会造成数据丢失。 所以RAID 0比较适合于不担心数据丢失的情况，比如可以随时从其他数据库克隆的备存，或者是一次性使用的数据。 数据库中使用的RAID 1级别RAID 1又称磁盘镜像，原理是把一块磁盘的数据镜像到另一个磁盘上，也就是说数据写入一块磁盘的同事，会在另一块限制的磁盘上生成镜像文件，在不影响性能的情况下最大限度的保证系统的可靠性和可修复性。 RAID 1当一块硬盘失效时，系统会忽略该硬盘，转而使用剩余的镜像盘来读取数据，拥有很好的冗余能力，虽然这样对数据的安全性而言是绝对安全的，但是却似的成本增加，磁盘的利用率仅有百分之五十，以4块300G的硬盘而言，能够利用的空间仅有600G，出现故障后的RAID系统也不在可靠了，应当及时更换损坏的硬盘，否则其他的镜像盘也出现问题了，会导致系统的崩溃。 更换硬盘后需要很长的时间同步镜像，虽然对数据的访问不会受到影响，但是对整个系统的性能是会有所下降的。 RAID 1在读的速度上要比RAID 0快。 ####数据库中使用的RAID 5级别 RAID 5又称之为分布式奇偶校验磁盘阵列，通过分布式奇偶校验块把数据分散到多个磁盘上，这样如果任何一个盘数据失效，都可以从奇偶校验块中重建。但是如果两块磁盘失效，则整个卷的数据都无法恢复。 在RAID 5上随机比较慢，因为每次写都需要两次读和两次写，以计算校验位的数值，比较适合以读为主的数据库业务。 最大的性能问题，发生在磁盘失效的时候，因为数据需要重新分布到其他磁盘上，这样会严重影响数据库性能，如果要使用RAID 5的话，最好使用在从服务器上。 数据库中使用的RAID 10级别RAID 10又称分片的镜像，她是对磁盘先做RAID 1之后对两组RAID 1的磁盘再做RAID 0，所以对读写都有良好的性能，相对于RAID 5重建起来更简单，速度也更快。 RAID级别的选择 等级 特点 是否冗余 盘数 读 写 RAID 0 便宜，快速，危险 无 N 快 快 RAID 1 高速读，简单，安全 有 2 快 慢 RAID 5 安全，成本这种 有 N+1 快 取决于最慢的盘 RAID 10 贵，告诉，安全 有 2N 快 快 固态存储 拥有更好的随机读写性能。 能够更好的支持并发 更容易损坏 在数据库存储中，我们常用的固态存储设备是SSD和PCI-E SSD。 SSD 使用SATA接口，可以替换传统磁盘而无需任何改变 SATA接口的SSD同样支持RAID技术 PCI-E SSD 无法使用SATA接口，需要独特的驱动和配置 价格相比SSD要贵，但是性能比SSD更好 PCI-E会占用服务器的内存。 固态存储的使用场景 适用于存在大量随机I/O的场景 使用于解决单线程负载的I/O场景 如果只有一块固态存储设备我们更应该将其放在从服务器上，因为从服务器是单线程的，而主DB是多线程的写入，为了产生更少的延迟，我们应该增加从服务器的I/O性能，而且由于固态设备易损耗，在主服务器上使用存在一定的安全隐患。 网络存储SAN和NASSAN(Storage Area Network)和NAS(Network-Attached Storage)是两种外部文件存储设备加载到服务器上的方法 SAN设备通过光纤连接到服务器，设备通过块接口访问，服务器可以将其当做硬盘使用。 NAS设备使用网络连接，通过基于文件的协议如NFS或SMB来访问。 网络存储适用的场景网络存储在随机I/O比较差，并不适合MySQL数据库存储数据，有一些人认为可以使用网络存储实现服务的高可用性，比如两台服务器挂在同一网络环境下的磁盘，当主服务器可以由主备服务器来接管磁盘来提供服务，提高系统的可用性。 虽然能够在一定条件下能够提高系统的可用性，可是却是以牺牲性能为代价，而且，一旦网络存储设备出现问题，则需要更多的时间进行恢复。 不过，我们可以利用网络存储设备来存储数据库的备份文件，当一台独立服务器出现故障，短时间内无法恢复的情况下，可以利用网络存储设备上存储的备份文件恢复是实例。 网络接口设备对数据库性能的影响 网络带宽对性能的影响 网络质量对性能的影响 建议 采用高性能和高贷款的网络设备和交换机 对多个网卡进行绑定，增强可用性和带宽 尽可能的进行网络隔离 总结：CPU 64位的CPU一定要工作在64位的系统下 对于并发比较高的场景CPU的数量比频率更重要 对于CPU密集性场景和复杂SQL则频率越高越好 内存 选择主板所能使用的最高频率的内存 内存的大小对性能很重要，所以尽可能的大 I/O子系统 PCie -&gt; SSD -&gt; Raid10 &gt; 磁盘 -&gt; SAN","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"大表会对数据库带来的那些问题！","slug":"什么样的表才可以被称之为大表","date":"2017-09-17T16:00:00.000Z","updated":"2017-10-18T12:45:30.000Z","comments":true,"path":"2017/09/18/1/","link":"","permalink":"http://www.maksim.website/2017/09/18/1/","excerpt":"","text":"什么样的表才可以被称之为大表?所谓的大表都是相对而言的，对不同的存储引擎都有不同的限制，Innodb并没有定义每张表的最大行数，只要物理磁盘允许，我们就可以将数据存入数据库中。 在实际使用过程中，当数据量超过千万行之后，就会对数据库的性能造成影响。 记录行数巨大，单表超过前往行 表数据文件巨大，表数据文件超过10G 当然这也是相对的，也要跟我们的业务场景，磁盘 IO情况而定，如果这个表只是用来记录日志的，只有INSERT、SELECT 操作，而几乎没有 UPDATE 和 DELETE的操作，就算是超过了千万行，对我们的业务操作也没有太大的影响。 但是也有例外的情况，如果我们要对超过10G 的日志表追加列，如果这个时候，这个表被同步到N台服务器上后，就会变成一场灾难。 大表对查询的影响慢查询：很难在一定的时间内过滤出所需要的重要数据。 大表对 DDL 操作的影响：建立索引需要很长的时间。 风险： MYSQL 版本 &lt; 5.5 建立索引会锁表 MYSQL 版本 &gt;= 5.5 虽然不会锁表但会引起长时间的主从延迟 修改表结构需要长时间锁表风险： 会造成长时间的主从延迟，由于主从复制的机制都是现在主库上完成操作，再传输到从库上，在执行相同操作，如果在主库上需要使用480s 的时间来完成 DDL 操作，在从服务器上至少也需要480s。 影响正常数据库操作。进行 DDL 时会被锁表，这样一来就会造成堵塞，在这一个阶段，数据库连接数会被激增，一旦数据库连接数被沾满，前台就会出现500错误。 如何处理数据库中的大表分库分表把一张大表分成多个小表难点： 1.分表主键的选择。 这个往往根据业务的不同，有多种分表的方式，比如对于订单表来说，可以根据订单号分表，也可以根据供应商和地区域来进行分表，选择合适的分区键对于后期的分表是十分重要的。 2.分表后跨分区数据的查询和统计 不要认为选择了好的分区键后就不需要跨分区进行查询了，好的分区键只能尽量避免跨分区查询。 大表的历史数据归档使用这种方法，可以减少对前后端业务的影响，因为表结构并没有发生变化，一切的程序都可以正常的使用，对于历史订单可以开放一个接口。 而且归档表可以跟正在使用的表放在不同的服务器上，一方面减少了热数据所在服务器的表容量，同时也减少了服务器的查询压力，对于后端业务而言，应该是已经完成相关操作和统计的历史数据。 难点： 归档时间点的选择。 如何进行归档操作，对于大表的增删改查都要十分的小心，既然我们要归档，就要把要归档的数据从数据库中移除，从一个上亿行的数据表中移出上百万行的时候，就要注意方式了，轻则会产生主从延迟，严重会产生大量的阻塞。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"利用 INSERT 命令将表中字段导入到新表中","slug":"insert","date":"2017-09-17T16:00:00.000Z","updated":"2017-09-18T09:04:49.000Z","comments":true,"path":"2017/09/18/1/","link":"","permalink":"http://www.maksim.website/2017/09/18/1/","excerpt":"","text":"最近为公司内部系统写了一个爬虫，爬了一个问答社区的三万多条数据，由于一开始的设计不够合理，将所有记录都放入了一个表中，由于是问答系统，合理的数据库设计，应该是将问题和答案分离开来，这样的结构更加合理，也易于未来的扩展。 我刚开始做iOS 的，转到 PHP 有一年多了，大学时有自学PHP，东学学西搞搞，结果就变成了啥都快记不住了，什么也都懂一些。 到了现在MYSQL 的基础也忘了许多，你让我扯一扯大规模，主从，分表，优化，我倒是能说上一堆，但是实际操作起来，啧啧。 这么一个简单的功能一时之间竟然都没有想起来，搜索引擎的确是个好东西（当然不拿医疗盈利的话）。 现在 iOS 也快忘得差不多了，感叹 ing，Swift 4都出了··· 1INSERT INTO `new_table_name` VALUE (`c1`,`c2`) SELECT `c1`,`c2` FROM `old_table_name` 简单的一命令即可将数据导出。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"INSERT","slug":"INSERT","permalink":"http://www.maksim.website/tags/INSERT/"}]},{"title":"大事务对MySQL性能带来的影响","slug":"大事务对MySQL性能带来的影响","date":"2017-09-15T16:00:00.000Z","updated":"2017-10-10T12:26:56.000Z","comments":true,"path":"2017/09/16/1/","link":"","permalink":"http://www.maksim.website/2017/09/16/1/","excerpt":"","text":"引言在我们的日常开发过程当中，为了保持数据的一致性，多多少少都会用到事务。 当面对大量数据时，使用事务一定要谨小慎微，因为一旦编写的事务中设计的数据量过大，就会严重的影响系统性能，如果操作的数据量特别巨大，则会造成服务器的阻塞，导致业务逻辑无法访问。 什么是事务？在了解大事务对 MySQL 性能带来的影响之前，我们首先要了解什么是事务，事务又起到了什么样的作用： 事务是关系型数据库系统区分于其他一切文件系统的重要特性，举例说明，对于文件系统来说，为了保证两个文件的一致，在我们修改完一个文件后，系统突然崩溃，这样文件系统在恢复后就很难保持系统的一致了，而数据库系统中，由于使用了事务，在数据库崩溃后，我们可以恢复数据库中的数据，使其保证数据的一致性。 事务是一组具有原子性的SQL语句，或是一个单独的工作单元，事务处理中只有两种可能性，事务处理成功，事务处理失败，一旦失败，数据库就会回滚到原始状态。 事务要符合：原子性、一致性、隔离性、持久性 事务的原子性（ATOMICITY）定义：一个事务必须被诗作为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交完成，要么全部失败，对于一个事物来说，不可能只执行其中的一部分操作。 举个例子（银行），我们有两个账户，一个是理财账户，另外一个是活期存款账户，现在需要从理财账户中转出2000RMB到活期存款账户中，我们需要经过以下步骤。 检查理财账户中的余额是否高于2000RMB 从理财账户的余额中减去2000RMB 在活期存款账户中增加2000RM 以上步骤必须作为一个整体一起完成，如果运行到第二步骤时系统崩溃，如果没有事务原子性这一特性，用户将损失两千元，这是无法接受的一件事情。 在事务中执行到第二步崩溃时，在系统恢复后，在日志中有没有完成提交的事务，系统就会回滚，避免了用户的损失。 整个事务中所有操作要么全部提交成功，要么全部失败回滚。 事务的一致性（CONSISTENCY）定义：一致性是指事务将数据库从一种一致性状态转换到另外一种一致性状态，在事务开始之前和事务结束后数据库中数据的完整性没有被破坏。 事务的隔离性（ISOLATION）定义： 隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其他事务是不可见的。 SQL标准中定义的四种隔离级别 未提交读（READ UNCOMMITED） 已提交读（READ COMMITED） 可重复读（REPEATABLE READ） 可串行化（SERIALIZABLE） 事务的持久性（DURABILITY）定义：一旦事务提交，则其所做的修改就会永久 的保存到数据库中，即使此时系统崩溃，已经提交的修改数据也不会丢失。 什么是大事务定义：运行时间比较长，操作数据比较多的事务。 余额宝这样的理财产品，每天都会计算前一天的理财收入所得，如果在一个事务中对所有的用户的理财收入都进行计算，并更新到用户余额中，这样数以亿计的用户余额的更新就要数个小时，而且一旦中间出现问题就会回滚，时间会更长。 这时一旦出现问题，数据库就会加锁，造成用户无法使用余额的问题。 风险： 锁定太多的数据，造成大量的阻塞和锁超时，对于innodb为了保证数据的一致性，虽然是行级锁，但是也会把所有相关的记录都加上锁。 回滚所需要的时间比较长，回滚时数据仍然会被锁定。 执行时间长，容易造成主从延迟。 如何处理大事务 避免一次处理太多数据,当面临成百上千万的数据量时，我们最好分批进行处理，例如每一个事务处理一万条数据。 移出不必要在事务中的SELECT操作。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"使用Object.defineProperty()模拟双向数据绑定","slug":"使用Object.defineProperty()模拟双向数据绑定","date":"2017-09-06T14:28:57.000Z","updated":"2017-09-06T15:10:50.000Z","comments":true,"path":"2017/09/06/cjek1zh6e004dx9rds9dbuhiv/","link":"","permalink":"http://www.maksim.website/2017/09/06/cjek1zh6e004dx9rds9dbuhiv/","excerpt":"","text":"对象是由多键值对组成的无序集合，对象中的每个属性对应任意类型的值。定义对象可以使用构造函数或字面量的形式。 123var obj = new Object(); //obj = &#123;&#125;obj.name = 'Maksim'; //添加属性obj.say = function ()&#123;&#125;; //添加方法 为对象添加属性我们还可以使用 Object.defineProperty 定义和修改属性。 语法：Object.defineProperty(obj, prop, descriptor)","categories":[],"tags":[]},{"title":"法律结构条、款、项、目","slug":"法律结构条、款、项、目","date":"2017-09-04T16:00:00.000Z","updated":"2017-10-19T08:55:04.000Z","comments":true,"path":"2017/09/05/1/","link":"","permalink":"http://www.maksim.website/2017/09/05/1/","excerpt":"","text":"公司的新项目上线了，我们要为律师团队开发一套内部系统，其中包括爬虫抓来的问答、法律条款的检索。 而法律条文不能直接以文章的形式存储，因为后期可能会涉及到法律条文的引用，例如： 《烟草专卖法》第二条第二款 一般来讲，一件(部)法律由章、节、条、款、项、目组成，个别重要的法典还分编。 编、章、节是对法条的归类，所以，在适用法律时只需引用到条、款、项、目即可，无需指出该条所在的编、章、节。因此，弄懂法律规范中条、款、项、目的含义，在执法活动中正确适用法律规范的条、款、项、目，对于规范执法行为，提高执法质量是大有益处的。 一、“条”1. 条的概念法律规范的“条”，又称“法条”，是组成法律规范的基本单位。一部法律，都是由若干法条组成的。如《烟草专卖法》由46个法条组成，《烟草专卖法实施条例》由70个法条组成。 法律规范的“条”，是法律规范对某一个具体法律问题的完整规定，如： 《烟草专卖法》第三十条 违反本规定擅自收购烟叶的，由烟草专卖行政主管部门处以罚款，并按照国家规定的价格收购违法收购的烟叶；数量巨大的，没收违法收购的烟叶和违法所得。 这一条就是对擅自收购烟叶法律责任的完整规定。 ### 2. 条的书写 ​ 一般来讲，条的数目的书写应使用中文，如《烟草专卖法》第三十条。但也有使用阿拉伯数字的，如《烟草专卖法》第30条。 ​ 执法活动中，对一个涉法问题作出决定时，可能要适用多个法条。如对无证运输的人进行处罚时，应同时适用《烟草专卖法》第三十一条第一款、《条例》第五十五条第一项和第六十九条的规定。 二、“款”1. 款的概念。 “款”是“条”的组成部分。在一般情况下，每一款都是一个独立的内容或是对其前一款内容的补充表述。如： 《烟草专卖法》第二条 本法所称烟草专卖品是指卷烟、雪茄烟、烟丝、复烤烟叶、烟叶、卷烟纸、滤嘴棒、烟用丝束、烟草专用机械。 卷烟、雪茄烟、烟丝复烤烟叶统称烟草制品。 《烟草专卖法》第二条有二款。其中第一款界定了烟草专卖品的范围，第二款进一步界定了烟草制品的范围。 2. 款的表现形式。“款”的表现形式为条中的自然段，每个自然段为一款。 “款”前不冠以数字以排列其顺序。如《烟草专卖法》第二条的两款，款前均无数字。有数字排列的不称为款。如： 《条例》第七条取得烟草专卖生产企业许可证，应当具备下列条件： (一)有与生产烟草专卖品相适应的资金； (二)有生产烟草专卖品所需要的技术、设备条件； (三)符合国家烟草行业的产业政策要求； (四)国务院烟草专卖行政主管部门规定的其他条件。 上条第一段冒号下为：(一) 有与生产烟草专卖品相适应的资金。该段文字虽然是另起一行，但因为上段结束符号是冒号，本段开始前有(一)，因此，该段文字不视为是一个自然段，也不能认为其是一款。 3. 关于款的数目的书写。款的数目的书写一般应当使用中文，不用阿拉伯数字。如《烟草专卖法》第二条第二款，不写作《烟草专卖法》第二条第2款。 4. 款的适用 款一般可以独立适用，如《烟草专卖法》第二条第二款，但也有例外的，但与烟草专卖有关的法律法规中少见。 一个法条有两款或者两款以上的，应当适用到款。一个法条只有一款的，应当直接适用该法条，不应称作该条第一款，如： 《条例》第三条烟草专卖品中的烟丝是指用烟叶、复烤烟叶、烟草薄片为原料加工制成的丝、末、粒状商品。 在引用时，就应该写作“根据《实施条例》第三条”，而不是“根据《实施条例》第三条第一款”。 参照最高人民法院《关于引用法律、法令等所列条、款、项,目顺序的通知》，如果某一条下面没有分款而直接分列几项的，就不要加“第一款”，例如《条例》第七条只有（一）（二）（三）三项，就不要写“第七条第一款第一项”，而直接写“第七条第一项”。 三、“项”1. 项的概念 一般来讲，“项”是以列举的形式对前段文字的说明。如： 《条例》第四十九条烟草专卖行政主管部门查处违反《烟草专卖法》和本条例的案件时，可以行使下列职权： (一)询问违法案件的当事人、嫌疑人和证人； (二)检查违法案件当事人的经营场所，依法对违法生产或者经营的烟草专卖品进行处理； (三)查阅、复制与违法活动有关的合同、发票、账册、单据、记录、文件、业务函电和其他资料。 ​ 该条的三个项是对前段文字中“下列职权”的列举式说明。 2. 项的表现形式含有项的法条，其前段文字中一般都有“下列”二字或相应的文字表述。“项”前冠以数字以对列举的内容进行排列。如《条例》四十九条，各项前都冠以(一)、(二)、(三)等数字，而且这些数字只能以中文数字加括号的形式出现。 3. 项的数目的书写项的数目的书写一般应当使用中文加括号，不用阿拉伯数字。如《条例》第四十九条第（三）项，不写作《条例》第四十九条第3项。 4. 项的适用对含有项的法条，适用时应当适用到项；如对无证运输的处罚，应当适用《条例》第五十五条第(一)项。适用到项，是对被处罚的无证运输行为性质和情节的一种界定。如果不适用到项，该无证运输的行为就不知是四种行为之中的哪一种行为，有适用法律不准确之嫌。 根据立法技术的不同需要，“项”可以依附于条，也可以依附于款。即条中可以有项，款中也可以有项。 四、“目”1. 目的概念 “目”隶属于项，是法律规范中最小的单位。“目”的特性与作用与“项”相似，不同的是项对条或款的列举式说明，而“目”是对项的列举式说明。如《条例》第五十五条第(二)项： (二)有下列情形之一的，没收违法运输的烟草专卖品和违法所得： 非法运输的烟草专卖品价值超过5万元或者运输卷烟数量超过100件（每1万支为1件）的； 被烟草专卖行政主管部门处罚两次以上的； 抗拒烟草专卖行政主管部门的监督检查人员依法实施检查的； 非法运输走私烟草专卖品的； 运输无烟草专卖生产企业许可证的企业生产的烟草专卖品的； 利用伪装非法运输烟草专卖品的； 利用特种车辆运输烟草专卖品逃避检查的； 其他非法运输行为，情节严重的。 ​ 这八种情形，就是该项的八个目，列举没收违法运输的烟草专卖品和违法所得的八种情况。 2. 目的表现形式​ 目的前面冠以阿拉伯数字，并在阿拉伯数字后加点(在具体引用法条的目时，只注明阿拉伯数字，无须加点)，例如《条例》第五十五条第(二)项第7目。 3. 目的适用如果某个法条或款的内容有“项”，而“项”下还有“目”的，在适用法律时就应当适用到“目”。如烟草专卖局在对非法运输走私烟草专卖品的行为进行处罚时，就应当适用《条例》第五十五条第(二)项第4目。当然，如果既非法运输走私烟草专卖品又利用特种车辆运输逃避检查，在作出处罚决定时就应同时适用相应的两个目。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/categories/随笔/"}],"tags":[]},{"title":"Invert a Binary Tree","slug":"Invert-a-Binary-Tree","date":"2017-08-13T05:01:00.000Z","updated":"2017-08-13T07:36:25.000Z","comments":true,"path":"2017/08/13/2/","link":"","permalink":"http://www.maksim.website/2017/08/13/2/","excerpt":"","text":"12345 4 4 / \\ / \\ 2 7 to 7 2 / \\ / \\ / \\ / \\1 3 6 9 9 6 3 1 解答： 1234567891011121314151617181920/** * Definition for a binary tree node. * strcut TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode (index x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125; */class Solution &#123; public: TreeNode *invertTree(TreeNode* root) &#123; if (root == NULL) return NULL; TreeNoe * tmpNode = root-&gt;left; root-&gt;left = invertTree(root-&gt;right); root-&gt;right = invertTree(tmpNode); return root; &#125;&#125;; 利用的递归这个概念，短短几行就完成了一个翻转二叉树，只是在翻转二叉树的左右子数。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.maksim.website/categories/C-C/"}],"tags":[{"name":"C/C++,算法","slug":"C-C-算法","permalink":"http://www.maksim.website/tags/C-C-算法/"}]},{"title":"算法笔试入门题目Memmove","slug":"memove","date":"2017-08-13T04:02:10.000Z","updated":"2017-08-13T07:24:58.000Z","comments":true,"path":"2017/08/13/1/","link":"","permalink":"http://www.maksim.website/2017/08/13/1/","excerpt":"","text":"1234void *memmove (void *dest, const void *src, size_t n)&#123; //implementation here&#125; 这是 C 语言中的一个库函数，他的功能是吧内存中一块内容从src拷贝到dest，固定的长度是n。 这是笔试中的一个入门体 12345678910void *memmove (void *dest, const void *scr, size_t n)&#123; char *p1 = dest; char *p2 = src; while (*p2 != \\0) *p1++ = *p2++; return p1;&#125; 上面的这份代码，可以完成要求，可是却存在一些问题，我们先来看一下，C语言中的一些让人进场不会注意到的陷阱。 内存重叠的处理，从一个指针，它指向的内存地址，拷贝到另外一个地址，那么有没有可能是完全重合，或者有一部分是重合的。 临时变量太多 或者没有安全释放 没有测试内存越界，size 是否小于零，指针是否为空？ 指针操作熟悉 内存是否重叠？ ) 正确的写法 123456789101112131415161718void *memmove (void *dest, const void *scr, size_t n)&#123; char *p1 = dest; const char *p2 = src; //o用常量表示src //判断src 和 dest 的位置关系 if (p2 &lt; p1) &#123; p2 += n; p1 += n; while (n-- != 0) *--p1 = *--p2; &#125; else &#123; while (n-- != 0) &#123; *p1++ = *p2++; &#125; &#125; return p1;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.maksim.website/categories/C-C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.maksim.website/tags/算法/"}]},{"title":"Array&String算法","slug":"Array&String 算法","date":"2017-08-11T16:00:00.000Z","updated":"2017-10-10T11:34:06.000Z","comments":true,"path":"2017/08/12/1/","link":"","permalink":"http://www.maksim.website/2017/08/12/1/","excerpt":"","text":"12345//Returns the position of the first occurrence of string target in string source or -1 if target is not part of source.int strStr (String source, String target) &#123; &#125; 希望在 string 里面寻找target，如果找到一个完全匹配的话，就返回他所在的位置，如果不存在就返回-1; 字符串匹配两种比较容易实现的字符串比较算法。 假设在长度为 n的沐川中匹配长度为 m的子串。 Brute-Force 算法： 顺序遍历母串，将每个字符作为匹配的起始字符，判断是否匹配子串。时间复杂度 O(m*n) Brute-Force 123456789101112131415char* StrStr(const char *str, const char *target) &#123; if(!*target) return str; char *p1 = (char *)str; while(*p1) &#123; char *p1Begin = p1, *p2 = (char*)target; while(*p1 &amp;&amp; *p2 &amp;&amp; *p1 == *p2) &#123; p1++; p2++; &#125; if (!*p2) //发现p2走到了末尾，就意味着有匹配到的字符串，那么直接返回p1Begin;所记录的位置 return p1Begin; p1 = p1Begin + 1; &#125; return NULL;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.maksim.website/categories/C-C/"}],"tags":[]},{"title":"Linux 和 GNU 工程","slug":"GNU&Linux","date":"2017-08-10T12:01:00.000Z","updated":"2017-08-10T12:52:58.000Z","comments":true,"path":"2017/08/10/3/","link":"","permalink":"http://www.maksim.website/2017/08/10/3/","excerpt":"","text":"每天都有许多计算机用户使用一个被改动过的GNU 系统 (18k 字节)，但是他们并没有意识到它。 经过一系列的事件，现在被广泛使用的 GNU 版本则经常被称作“Linux”，可是许多用户并不了解与之相关的 GNU 工程。 Linux 确实存在；它是一个内核，许多人都在使用它。但是你不能仅使用内核本身。内核只有作为整个系统的一个部分才有用处。Linux 是和 GNU 操作系统结合在一起使用：系统本身是 GNU，与 Linux 作为内核一起工作。 许多用户没有并不完全了解 Linux 内核和被称作“Linux”的整个系统的区别。而不加区别地使用这个名字并不能对理解有帮助。 程序员一般都知道 Linux 是一个内核。但是因为他们也听到整个系统被称作“Linux”，他们会根据名字去想象历史。比如，很多人认为当 Linus Torvalds 完成了内核后，他的朋友四处寻找其他的自由软件，而且所有的可以被组装成一个类似 Unix 系统的程序都是现成的。 他们的发现不是巧合 – 这就是 GNU 系统。 可用的自由软件加在一起就组成了一个完整的系统，这是由于自 1984 年就开始的 GNU 工程一直在为此努力。GNU 宣言(31k 字节) 早已设立了开发一个类似 Unix 的自由系统的目标，称作 GNU。GNU 工程的最初公告 也勾画了 GNU 系统的原始提纲。在 Linux 被编写时，这个系统几乎已经完成。 大多数自由软件的工程都是为了特定的工作开发特定的程序。比方说，Linus Torvalds 编写类似 Unix 的内核(Linux); Donald Knuth 编写一个文本格式化工具(TeX); Bob Scheifler 开发一个窗口系统(X Window System)。对于这项工程编写的程序都作出了贡献，对这些贡献进行评估是很自然的。 如果以这种方法来衡量对 GNU 工程的贡献，我们会得出什么结论？一个 CD-ROM的提供商发现在他们的“Linux 发行版”中，GNU 软件 占最大的比重，大约占全部源代码的 28% ，而且这还包括一些关键的部件，没有这些部件，系统就无法工作。Linux 本身占大约 3%。所以如果你要根据程序的作者来选择一个名字的话，最合适的选择是“GNU”。 但是我们不认为这是一个解决问题的适当方法。GNU 工程以前不是，现在也不是一个开发某个软件包的工程。它不是一个 开发 C 编译器的工程, 尽管我们做了。它也不是一个开发一个文本编辑器的工程，尽管我们也做了。GNU 工程的目标是开发一个完全自由的类似 Unix 的系统: GNU。 许多人已经为系统中的自由软件作出了重大贡献，他们都应该获得荣誉。但 GNU 是一个系统而不是一些实用程序的组合的原因是，GNU 工程的最初目标就是做一个完整系统。我们曾经为完成一个完整的系统做了一个所需程序清单，而且我们有系统地寻找，编写这些程序，并且寻找别人编写清单上的每一个程序。我们编写了关键的但是十分枯燥的主要部件，比如汇编语言和连接器，因为这是系统所必需的。除了编程工具，一个完整的系统还需要更多的东西， Bourne Again SHell 程序, PostScript 解释器 Ghostscript, 和 GNU C 库 同样是很重要的。 到了 90 年代初期，我们曾经把除了内核以外的东西放到一起组成了一个系统（我们同时也在做内核的工作）称为 GNU Hurd, 运行在 Mach 上)。开发这个内核比我们想象的要难得多，我们现在仍然在 为此工作。 庆幸的是，你不必再等了，因为 Linux 开发成功。当 Linus Torvalds 写成了 Linux，他填补了一个重要的空白。人们可以将 Linux 和 GNU 系统组成一个完整的自由系统：基于 Linux 的 GNU 系统（或简称为 GNU/Linux 系统）。 把它们组合到一起听起来很容易，但是这并不是一个简单的工作。 GNU C 库 (简称 glibc) 需要作大量的修改。集成到一个完整的发行系统中也是一项很大的工作。它需要对如何安装和启动系统进行定位 – 这个问题直到现在还在完善，因为我们还没有抓住要点。那些开发了不同的发行系统的人们作出了巨大贡献。 除了 GNU，还有一个独立进行的工程开发了一个自由的类似 Unix 的操作系统。这个系统被称为 BSD，它是由 UC Berkeley 开发的。 在 GNU 工程的鼓舞下，BSD 的开发者开始进行他们自己的自由软件的开发工作，并时常受到 GNU 人士的鼓励，但是他们的实际工作与 GNU 差别不大。今天 BSD 系统采用一些 GNU 软件，就象不同版本的 GNU 系统也采用 BSD 的软件一样。总的说来，它们是两套独立开发的不同的系统。今天一个免费的操作系统几乎都是采用 GNU 或 BSD 系统的一个派生版本。 GNU 工程支持 GNU/Linux 系统，就象支持 GNU 系统一样 – 包括资金的支持。我们为重写与 Linux 相关的 GNU C 库提供资金，以至于它们现在可以很好地集成在一起，直到最新版本的 GNU/Linux 仍在使用这个库而无需修改。我们也为早期 Debian GNU/Linux 的开发提供资金。 今天我们的绝大多数的工作都在基于 Linux 的 GNU 系统上完成，我们希望你也如此。但是请不要含糊地使用 Linux 而使公众迷惑。Linux 是内核，系统的关键部件之一。系统或多或少实际上都应该是 GNU 系统，再加上 Linux。当你在讨论到这个组合系统时，请使用 “GNU/Linux”。 如果要为 GNU/Linux 作链接，本页和 http://www.gnu.org/gnu/the-gnu-project.html 都是很好的选择。如果你想为 Linux（内核）作链接，http://www.kernel.org/是一个很好 URL。 本文摘 https://www.gnu.org/gnu/linux-and-gnu.html Copyright 1997, 1998 Richard Stallman 中文翻译：白若玉翻译校正：刘昭宏 全文在保证完整性的前提下可以在任意媒体转载 - 须保留此标注。 Updated: 30 Nov 2000 paulv","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[{"name":"Linux,GNU","slug":"Linux-GNU","permalink":"http://www.maksim.website/tags/Linux-GNU/"}]},{"title":"Virtualbox下安装 CentOS  minimal 后设置上网","slug":"Virtualbox下安装 CentOS  minimal 后设置上网","date":"2017-08-10T08:04:12.000Z","updated":"2017-08-10T11:53:40.000Z","comments":true,"path":"2017/08/10/2/","link":"","permalink":"http://www.maksim.website/2017/08/10/2/","excerpt":"","text":"在虚拟机中以minimal安装 CentOS 后无法上网，因为CentOS的默认网卡未激活。 可以设置 文件 /etc/sysconfig/network-scripts/ifcfg-enp0s3 将 ONBOOT=no 改为 ONBOOT=yes 保存后重启网卡： service network restart 这样就可以上网了，我用的是桥接模式。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[{"name":"Linux,Centos","slug":"Linux-Centos","permalink":"http://www.maksim.website/tags/Linux-Centos/"}]},{"title":"CentOS中Live、netinstall、minimal、DVD 等版本的区别","slug":"CentOS版本区别","date":"2017-08-10T07:04:12.000Z","updated":"2017-08-10T07:46:27.000Z","comments":true,"path":"2017/08/10/1/","link":"","permalink":"http://www.maksim.website/2017/08/10/1/","excerpt":"","text":"LiveCD 和LiveDVD 是可以直接光盘运行的胸痛，但不能安装，两者差别在于容量大小，DVD 包含的软件要多一些。 netinstall 用于网络安装和系统救援的镜像文件。 minimal 这个镜像文件用于安装一个非常基本的 CentOS系统,包含了一些基本所需的最小安装包。 DVD 镜像包含了完整的发布版，可以用于安装完整的 CentOS 系统。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[{"name":"Linux,Centos","slug":"Linux-Centos","permalink":"http://www.maksim.website/tags/Linux-Centos/"}]},{"title":"","slug":"Mysql-索引","date":"2017-08-06T11:33:07.000Z","updated":"2018-03-09T14:27:52.318Z","comments":true,"path":"2017/08/06/cjek1zh4a0011x9rdqqm53y2x/","link":"","permalink":"http://www.maksim.website/2017/08/06/cjek1zh4a0011x9rdqqm53y2x/","excerpt":"","text":"title:MySQL索引categories:MySQL date:2017-8-6数据库索引，是数据库管理系统中一个排序的数据结构，用于协助快速查询、更新数据库表中的数据。它类似于书本上的索引，通过索引可以更便捷地找到书里面的内容而不需要查阅整本书。对于海量数据的检索，索引往往是最有效的。 目前MySQL主要支持的几种索引有:B树索引(B-tree)、散列索引(hash)、空间索引(R-tree)和全文索引(full-text)。如果没有特别指明，本书指的就是B-Tree索引。由于索引是在存储引擎层实现的，所以不同的存储引擎的索引实现会有一些差异。以下所述的是一些较通用的索引知识。 逻辑上又可以分为:单列索引、复合索引(多列索引)、唯一(Unique)索引和非唯一(Non Unique)索引。 如果索引键值的逻辑顺序与索引所服务的表中相应行的物理顺序相同，那么该索引被称为簇索引(cluster index)，也称为聚集索引、聚簇索引，也就是说数据和索引(B+树)在一起，记录被真实地保存在索引的叶子中，簇索引也称为索引组织表，反之为非聚集索引。我们常用的InnoDB表其实使用的就是聚集索引。 簇索引是一个很重要的概念，InnoDB作为最常使用的引擎，只有在熟悉了它的数据存储方式之后，才可能有针对性地对它进行调优。 簇索引的一些优点如下。 将相关的的数据保持在一起，叶子节点内可保存相邻近的记录。·因为索引和数据存储在一起，所以查找数据通常比非簇索引更快。由于主键是有序的，很显然，对于InnoDB表，最高效的存取方式是按主键存取唯一记录或进行小范围的主键扫描。 如果充分利用簇索引，它可以极大地提升性能，但簇索引也有许多不足之处。 簇索引对I/O密集型的负荷性能提升最佳，但如果数据是在内存中(访问次序不怎么重要)，那么簇索引并没有明显益处。 插入操作很依赖于插入的顺序，按primary key的顺序插入是最快的。 更新簇索引列的成本比较高，因为InnoDB不得不将更新的行移动到新的位置。 全表扫描的性能不佳，尤其是数据存储得不那么紧密时，或者因为页分裂(page split)而导致物理存储不连续。 二级索引的叶节点中存储了主键索引的值，如果主键采用的是较长的字符，那么索引可能会很大，且通过二级索引查找数据也需要进行两次索引查找。","categories":[],"tags":[]},{"title":"在Mac上编译安装线程安全的PHP7.2","slug":"在-Mac上编译安装线程安全的-PHP7.2","date":"2017-08-05T04:04:12.000Z","updated":"2017-08-05T03:17:24.000Z","comments":true,"path":"2017/08/05/1/","link":"","permalink":"http://www.maksim.website/2017/08/05/1/","excerpt":"","text":"因为项目需求后期可能会需要使用到进程守护和消息队列，于是上网查了一下，看到Netkiller PHP 手札中有介绍到PHP使用 Pthread实现优雅守护进程的方法。 可是由于我本地的 PHP 是使用brew进行安装的，在 Linux 下使用 yum或者 apt进行安装的 PHP 同样不支持线程安全。 于是开始折腾起来，将 PHP 卸载掉后使用编译进行重新安装，开启--enable-maintainer-zts 后在编译过程中遇到了 Clang 报错，经过了一番 Google、百度过后，原来是编译器在作怪。Mac 由于 Xcode 的原因，默认使用的编译器是 Clang，在编译到 pthread 的时候，就会报错。 解决方法也很简单，在./configure 命令的最后加上 CC=gcc ，告诉make 我要使用 GCC 编译器进行编译即可。 其实在日常的开发中PHP开发者，很少会接触到多线程这一块。甚至有的PHP 开发者都搞不清楚什么是线程、进程和协程。 那是因为在 Web 开发中根本使用不了多线程，因为 PHP 本身并不提供多线程API，其多线程的支持是由 Pthread 扩展提供的，而 Pthread 扩展的文档中有说明： Warning 不可以在 web 服务器环境中使用 pthreads 扩展，PHP 多线程开发仅限于命令行模式的应用。 Windows版的PHP从版本5.2.1开始有Thread Safe(线程安全)和None Thread Safe(NTS，非线程安全)之分，这两者不同在于何处？到底应该用哪种？ 从2000年 10月20日发布的第一个Windows版的PHP3.0.17开始的都是线程安全的版本，这是由于与Linux/Unix系统是采用多进程的工作方式不同的导致的。 Windows系统是采用多线程的工作方式。如果在IIS下以CGI方式运行PHP会非常慢，这是由于CGI模式是建立在多进程的基础之上的，而非多线程。一般我们会把PHP配置成以ISAPI的方式来运行，ISAPI是多线程的方式，这样就快多了。 但存在一个问题，很多常用的PHP扩展是以 Linux/Unix的多进程思想来开发的，这些扩展在ISAPI的方式运行时就会出错搞垮IIS。因此在IIS下CGI模式才是PHP运行的最安全方式，但CGI模式对于每个HTTP请求都需要重新加载和卸载整个PHP环境，其消耗是巨大的。 为了兼顾IIS下PHP的效率和安全，微软 给出了FastCGI的解决方案。FastCGI可以让PHP的进程重复利用而不是每一个新的请求就重开一个进程。同时FastCGI也可以允许几个进程同时执行。这样既解决了CGI进程模式消耗太大的问题，又利用上了CGI进程模式不存在线程安全问题的优势。 因此，如果是使用ISAPI 的方式来运行PHP就必须用Thread Safe(线程安全)的版本；而用FastCGI模式运行PHP的话就没有必要用线程安全检查了，用None Thread Safe(NTS，非线程安全)的版本能够更好的提高效率。 从上面这段描述我们可以清楚的知道，如果不是使用 ISAPI 的话，不使用多线程特性，那么基本上就用不Thread Safe。 查看自己的 PHP版本是否是线程安全你的只需要在命令行中输入 PHP -v查看 PHP 的版本即可，如下： 引用： PHP线程安全和非线程安全有什么区别 http://www.cnblogs.com/T8881/p/6397264.html PHP Internals Book（《PHP内部书》PHP 内核开发者合著) http://www.phpinternalsbook.com/index.html PHP运行模式 http://www.cnblogs.com/xia520pi/p/3914964.html Netkiller PHP 手札 http://netkiller.github.io/php/index.html","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"多线程,PHP7.2,编译安装,GCC","slug":"多线程-PHP7-2-编译安装-GCC","permalink":"http://www.maksim.website/tags/多线程-PHP7-2-编译安装-GCC/"}]},{"title":"在SQL中使用变量","slug":"在SQL中使用变量","date":"2017-08-05T00:04:12.000Z","updated":"2017-08-05T01:31:44.000Z","comments":true,"path":"2017/08/05/602/","link":"","permalink":"http://www.maksim.website/2017/08/05/602/","excerpt":"","text":"MySQL 李的变量可分为用户变量和系统变量 1. 用户变量 MySQL允许用户在语句中自定义变量，对于用户变量的值，可以先保存在用户变量中，然后在引用它；这样就可以将值从一个语句传到另外一个语句。 用户变量与连接有关。一个客户端定义的变量不能被其他客户端看到货使用。当客户端退出时，该客户端连接的所有变量将自动释放。这点不同于在函数或存储过程中通过 DECLAER 药监局声明的局部变量，局部变量的生存周期在它被声明的“BEGIN...END”块内。 用户变量的表现形式为：@var_name 设置用户变量的一个途径是执行 SET 语句，语法如下： 1SET @var_name= expr[, @var_name= expr] ... 对于SET，可以使用“=”或“:=”作为分配符。分配给每个变量的expr可以为整数、实数、字符串或NULL值。如: 1mysql&gt; SET @t1=0, @t2=0, @t3=0; 或 1SET @minMid=(select min(id) FROM table_name) ; 2.系统变量 MySQL服务器维护着两种系统变量: 全局变量影响MySQL服务的整体运行方式 会话变量影响具体客户端连接的操作 当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中对指定的选项进行更改。服务器启动后，通过连接服务器并执行SET GLOBAL var_name语句，可以动态更改这些全局变量。要想更改全局变量，必须具有SUPER权限。 服务器还为每个连接的客户端维护一系列的会话变量。在连接时使用相应全局变量的当前值对客户端的会话变量进行初始化。对于动态会话变量，客户端可以通过SET SESSION var_name语句更改它们。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其他客户端的会话变量。 访问全局变量的任何客户端都可以看见对全局变量所做的更改。然而，它只影响更改后连接的客户的相应会话变量，而不会影响目前已经连接的客户端的会话变量(即使客户端执行SET GLOBAL语句也不影响)。 也就是说，如果你的连接是短连接，那么修改全局变量后，客户端有重连的操作，就会立刻影响到客户端。而对于长连接、连接池来说，连接可能一直在MySQL里没有被销毁，也就不会有重连的操作，所以这种情况下对全局变量的修改一般不会影响到客户端。 可以使用如下几种语法形式来设置或检索全局变量或会话变量(下面的例子使用sort_buffer_size作为示例变量名)。 要想设置一个GLOBAL变量的值，可使用下面的语法。 12mysql&gt; SET GLOBAL sort_buffer_size=value; mysql&gt; SET @@global.sort_buffer_size=value; 要想设置一个SESSION变量的值，可使用下面的语法。 123mysql&gt; SET SESSION sort_buffer_size=value; mysql&gt; SET @@session.sort_buffer_size=value; mysql&gt; SET sort_buffer_size=value; 如果设置变量时不指定GLOBAL、SESSION或LOCAL，则默认使用SESSION。 要想检索一个GLOBAL变量的值，可使用下面的语法。 12mysql&gt; SELECT @@global.sort_buffer_size;mysql&gt; SHOW GLOBAL VARIABLES LIKE 'sort_buffer_size'; 要想检索一个SESSION变量的值，可使用下面的语法。 12mysql&gt; SELECT @@sort_buffer_size;mysql&gt; SELECT @@session.sort_buffer_size; mysql&gt; SHOW VARIABLES LIKE 'sort_buffer_size'; 当用SELECT@@var_name搜索一个变量时(也就是说，不指定GLOBAL、SESSION)，MySQL会返回SESSION值(如果存在SESSION变量的话)，否则返回GLOBAL值。 对于SHOW VARIABLES，如果不指定GLOBAL、SESSION的话，MySQL会返回SESSION值。 引用 《MySQLDBA 修炼之道》 作者：陈晓勇 MySQL 官方文档 9.4 User-Defined Variables","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"基础很重要，你真的知道什么是数据库吗？","slug":"读书笔记之什么是数据库？","date":"2017-08-04T13:04:12.000Z","updated":"2017-08-04T13:12:48.000Z","comments":true,"path":"2017/08/04/601/","link":"","permalink":"http://www.maksim.website/2017/08/04/601/","excerpt":"","text":"“数据库基础”可不是一件小事。问题是，有时人们认为他们知道的很多。 例如，这个问题:什么是数据库? 我敢说大多数的人相信他们知道这个问题的答案。但其中一部分人(或者很多)都会答错。SQL Server 不是数据库，它只是一种 DBMS(数据库管理系统)。你可以使用 SQL Server 来创建数据库，但 SQL Server 本身不是一种数据库。 那么，什么是数据库?数据库是一种有组织的数据存储，其中的数据可以通过指定的数据元素(比如，字段、记录和文件)来访问(详见图 1-1)。 数据库是一种有组织的数据存储，其中的数据可以通过指定的数据元素来访问。 DBMS 是一种使终端用户或程序员能够共享数据的软件。它提供了一套操作数据库的系 统性方法:创建、更新、检索和存储信息。DBMS 通常还负责数据完整性、数据安全性、数据访问控制和优化、自动回退、重起和恢复。 对外行人来说，你可以把数据库想象成一个文件夹，把 DBMS 想象成文件柜，且所容纳的所有文件都贴有标签。DBMS 管理着数据库，通过 DBMS 来实现和访问数据库实例。所以说，DB2、Oracle 和 SQL Server 都是数据库管理系统。工资单应用使用工资单的数据库，该数据库可以使用 DB2、Oracle 或者 SQL Server 来实现。 摘自DBA 《修炼之道：数据库管理员的第一本书》","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"利用 MySQL 权限机制设置用户权限","slug":"Mysql权限控制","date":"2017-08-04T05:01:00.000Z","updated":"2017-08-08T00:38:00.000Z","comments":true,"path":"2017/08/04/600/","link":"","permalink":"http://www.maksim.website/2017/08/04/600/","excerpt":"","text":"MySQL 权限控制包含如下两个阶段。 阶段1： 服务器检测是否允许你链接。 阶段2： 假定你能连接，服务器将检测你发出的每一个请求，查看你是否有足够的权限实施它。例如你从数据库表中选择（SELECT）行或从数据库中删除表，那么服务器要确定你是否对表有SELECT权限或对数据库有DROP权限。 MySQL是通过用户名、密码、IP(主机名)3个要素来验证用户的。当你想要访问MySQL服务器时，MySQL客户端程序一 般会要求你指定如下参数。 MySQL服务器的IP(主机名)， 端口 用户名 密码 以下是连接MySQL服务器的一个示例，你需要以实际的IP、端口、用户名、密码代替相应的内容。 1mysql -h host_ip_address -u user_name -pyour_password -P server_port 一般在生产环境下，程序账号有增加、删除、查询、修改这4项功能即可。 如下命令用于赋予查询、插入、修改、删除权限，并进行密码设置。 1grant select,insert,update,delete on db_name.* to user_name@ '10.%' identified by 'password'; 如下命令用于回收上面所赋予的权限。 1revoke select,insert,update,delete on db_name.* from user_name@ '10.%';","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"PHP7 微信支付不能回调，让我们的团队损失1.00CNY。","slug":"PHP7微信支付","date":"2017-07-14T06:15:20.000Z","updated":"2017-07-14T11:39:10.000Z","comments":true,"path":"2017/07/14/cjek1zh4w001mx9rd0bcvqmkh/","link":"","permalink":"http://www.maksim.website/2017/07/14/cjek1zh4w001mx9rd0bcvqmkh/","excerpt":"","text":"公司目前正在使用一套基于 TP5的开源商城，在线上测试过程中碰到了一个问题，微信支付完成后无法进行回调更新订单状态，简单点说就是钱没了，啥也没得到。 What？这可是一个无法容忍的错误。 原本以为是微信支付配置环节出了问题，于是便去查看微信官网给出的帮助手册，又顺着流程走了一边，信心满满的又测试了一边，结果尴尬了，又损失了0.01人民币。 反复确认流程后，确认并不是配置的问题，于是便开始了百度，原来这一切都是在微信官网给出的SDK中的一段代码惹的祸，就这么一段代码让我们团队损失了接近1人民币。 12//获取通知的数据$xml = $GLOBALS['HTTP_RAW_POST_DATA']; // WxPay.Api.php 414 line 这段代码如果放在PHP7之前的版本是不会有任何问题的，但是在 PHP7版本中却已经废除了 HTTP\\_RAW\\_POST\\_DATA 。 在官方文档中给了说明： Warning This feature was DEPRECATED in PHP 5.6.0, and REMOVED as of PHP 7.0.0. 在PHP5.6.0发布的时候，就已经不推荐只用这种方法，于是在PHP 社区在开发 PHP7.0的时候直接就将其废弃掉了。 而官方也给出了替代的方案，那就是php://input php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP\\_RAW\\_POST\\_DATA，因为它不依赖于特定的php.ini指令。 而且，这样的情况下 $HTTP\\_RAW\\_POST\\_DATA 默认没有填充， 比激活 always\\_populate\\_raw\\_post\\_data潜在需要更少的内存。 enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的。 Note: 在 PHP 5.6 之前 php://input 打开的数据流只能读取一次； 数据流不支持 seek 操作。 不过，依赖于 SAPI 的实现，请求体数据被保存的时候， 它可以打开另一个 php://input 数据流并重新读取。 通常情况下，这种情况只是针对 POST 请求，而不是其他请求方式，比如 PUT 或者 PROPFIND。 于是我将这段代码改为了： 12//获取通知的数据$xml = file_get_contents(\"php://input\"); // WxPay.Api.php 414 line 最后我又以0.01人民币的代价确认修复了这个 BUG。 PHP7:&quot;怪我喽，让你经常看文档，哼！&quot;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"wechat pay, php, php7, php://input","slug":"wechat-pay-php-php7-php-input","permalink":"http://www.maksim.website/tags/wechat-pay-php-php7-php-input/"}]},{"title":"提高 MySQL 的性能，从数据库设计规范开始","slug":"数据库设计规范实例","date":"2017-06-22T16:00:00.000Z","updated":"2017-08-04T04:41:58.000Z","comments":true,"path":"2017/06/23/2/","link":"","permalink":"http://www.maksim.website/2017/06/23/2/","excerpt":"","text":"这几日一直都在看慕课网的一篇有关于数据库设计的实战教程，在其中讲述了关于数据库设计的一些相关规范，可以说是受益匪浅，于是便将学习所得记录下来，如果有想要看视频版的同学可以到慕课网查看。 点我跳转到慕课网观看视频 数据库名称规范1.所有数据库对象名称必须使用小写字母并使用下划线分割由于 MySQL数据库的对象名称默认情况下是大小写敏感的，特别是在 Linux 系统下，MySQL 的数据库和表实际上的存储方式就是 Linux 下的一个文件，由于 Linux 系统是对大小写敏感的，所以 MySQL 也就对大小写敏感，这就意味着 DbName dbname 是完全不同的两个数据库。 如果在开发过程中使用大小写混用的情况下，就会对未来的开发工作造成很多不必要的麻烦，要时刻注意数据库对象的大小写。 2.所有的数据库对象名称禁止使用 MySQL 的保留字段1select id,username from ,age from tb_user; 在上述SQL 语句中存在两个 from，由于 MySQL 并不知道这两个 from 有什么区别，若是执行这条 SQL 语句肯定会报错，但是在建表的时候却不会报错。 若是已经使用了关键字做了字段名，那就需要在字段名前后加上反引号，示例如下： 1select id,username `from` ,age from tb_user; 反引号是为了区分MySQL关键字和保留字与普通字符而引入的符号，保留字的列表请点击此网页查看 https://dev.mysql.com/doc/refman/5.7/en/keywords.html 3. 数据库对象的命名要做到见名识义，而且最好不要超过32个字符MySQL 的限制长度是64个字符，但是表名和列名一旦过长，在使用过程中将会很不方便，而且还会增加网络传输的开销。 例如： 12用户数据库： ex_userdb用户账户表： user_account 4. 所有的临时表必须以 tmp为前缀并以日期为后缀在我们的日常工作中，会在数据库中建立一些临时表或者中间表，往往无法第一时间将其清理掉，时间一长便无法分清，哪些是临时表或者是持久化表，这样一来就会造成很多的垃圾数据。 5.备份表必须以bak为前缀并以日期为后缀在日常工作中，我们会对数据库进行备份，在备份的时候，以 bak 开头可以清晰的表示出这是一个备份表，并且以时间结尾标注了这个表是在什么时间进行的备份，这样一来能够设计出更加整洁的数据库，并且结构清晰。 6.所有存储相同数据的列明和列类型必须一致。通着这这种字段都是以关联字段进行使用的，如果两个表的关联字段的数据类型不一致，在关联时MySQL 会进行隐式类型转换，造成字段索引失效，影响数据库的运行性能，导致不必要的开销。 数据库基本设计规范1. 在没有特殊要求的情况下，所有表必须使用 Innodb 存储引擎比如列存储、在5.7版本之前存储空间数据，如果还在使用MyISAM 引擎如果在升级到5.6之后应该尽快将存储引擎升级到 Innodb，因为在5.6之后的默认引擎就是 Innodb，Innodb 支持事务，行级锁，更好的恢复性，高并发下性能更好。 2.数据库和表的字符集使用 UTF8统一的字符集可以避免由于字符集转换禅城的乱码，MySQL 中 UTF8字符集汉字站3个字节，ASCII 码占用1个字节，若我们定了一个 varchar(255)的列，并且存储中文的话，255个中文字符将会占用725个字节。 3.所有的表和字段都需要添加注释使用 comment 从句添加表和列的备注，从一开始就进行数据字典维护。 4.尽量控制单表数据量的大小，建议控制在500万行以内500万并不是 MySQL数据库的限制，MySQL 的存储数据量取决于存储设置和文件系统，修改表结构，备份，恢复都会有很大问题。 可以使用历史数据归档，分库分表等手段来控制数据量的大小，历史数据归档常用语系统日志，分库分表主要应用在业务表上。 5.谨慎的使用 MySQL 分区表。分区表在物理上表现为多个文件，在逻辑上表现为一个表。谨慎的选择分区键，跨分区查询效率可能更低。 建议采用物理分表的方式管理大数据。 6.尽量做到冷热数据分离，减小表单的宽度MySQL 限制最多存储4096列，并且每一行的大小是不能超过65535个字节的。最好将经常用到的列放到一个表中，这样一来可以减少磁盘 IO，保证热数据的内存缓存命中率。利用更有效的利用缓存，避免读入无用的冷数据。 7.禁止在表中建立预留字段预留字段的命名很难做到见名识义，预留字段无法确认存储的数据类型，所以无法选择合适的类型。对预留字段类型的修改，会对表进行锁定，修改一个字段类型的成本远高于新建一个字段。 8.禁止在数据库中存储图片，文件等二进制数据这类文件都会很大，会在短时间内造成数据量的疯涨，在数据库读取的时会产生大量的 IO 操作，非常好事，影响数据库性能，常规的做法是将图片保存在对应的文件服务器上，然后在数据库中保存地址信息就可以了。 9.禁止在线上做数据库压力测试如果使用生产环境进行压力测试一方面会对正常的业务访问造成影响，另一方面也会对数据库造成影响，产生大量的垃圾数据。 8.禁止从开发环境，测试环境直接连生产环境数据库会对生产环境的数据的完整性进行破坏。 数据库索引设计规范1.限制每张表上的索引数量，建议单标索引不超过5个索引数量是和列的数量是成正比的，通常列的数量越多索引的数量也会越多，索引并不是越多越好，索引可以提高效率单同样也可以鉴定效率，索引可以增加查询效率，单同样也会降低插入和更新的效率。 由于 MySQL 优化器在选择优化查询时，会根据统计信息对每一个可以用到的索引进行评估，以生成出一个最好的执行计划，如果同时有很多索引都可以用于查询，就会增加 MySQL优化器生成优化器的时间，同样机会降低 SQL 查询的性能。 禁止给表中的每一个列都建立单独的索引。 2.每一个 Innodb表都必须有一个主键Innodb 是一种索引组织表，数据存储的逻辑顺序与索引的顺序是相同的，每一个表上上都会有很多索引，但是存储顺序只有一种，Innodb是按照主键索引进行组织表的。 如果没有主键，那么 Innodb 会优先以第一非空，唯一索引当做主键，在没有非空唯一所以的情况下，MySQL 会生成一个站位6个字节的主键，这个自动生成的主键性能并不是最好的。 在表的设计中不要使用更新频繁的列作为主键，不使用多列主键（联合索引），因为 Innodb是一个索引组织表的缘故，如果主键频繁被更新，那么久意味着，数据存储的顺序就会频繁的变动，必然会带来大量的 IO 操作。 不要使用 UUID，MD5，HASH，字符串列作为主键。因为这类数据无法保证数据的顺序增长，如果后面插入的值比已经存在的值还要小，则为了保证索引的顺序，则会把新的数据插入到前面，这样就会造成所有大于这个值的数据要想后移带来大量的 IO 操作。 建议使用自增 ID 作为主键。 3.常见索引列建议1.SELECT、UPDATE、DELETE语句的WHERE 从句中的列出现的字段中添加索引2.包含在 ORDER BY、GROUP BY、DISTINCT 中的字段3.多表JOIN的关联列 4.如何选择索引列的顺序在联合索引中索引的使用顺序是由从左到右的顺序来使用的。所以我们需要将区分度最高的列放在联合索引的最左侧，尽量把字段长度小的列房子啊联合索引的最左侧，私用最频繁的列放在联合索引的左侧。 ###避免建立冗余索引和重复索引 重复索引：1primary key(id)、index(id)、unique index(id) 冗余索引：1index(a,b,c) 、index(a,b)、index(a) 5.对于频繁的查询优先考虑使用覆盖索引覆盖索引：就是包含了所有查询字段的索引 避免 Innodb 表进行索引的二次查找， 数据库字段设计规范1.优先选择符合存储需要的最小的数据类型 将字符串转换为数字类型存储 INET_ATON(‘255.255.255.255’) = 4294967295 INET_NTOA(4294967295) = ‘255.255.255.255’ 对于非负型的数据来说，要有限选用无符号整型来存储，无符号相对于有符号可以多出一倍的存储空间 VARCHAR（N）中的 N 代表的是字符数，而不是字节数 使用 UTF8存储汉字 VARCHAR(255)=765个字节 过大的长度会消耗更多的内存，因为当数据被载入到内存时为了提高效率是按照所定义的类型长度来申请内存的。 2.避免使用 Text、BLOG 的数据类型Text列分为四种 TinyText、Text、MidumText、LongText，Text 类型可以存储下64K的数据，备注或者说明很少会使用到64K 这么庞大的数据，使用 Varchar 类型就可以了。另外由于MySQL 内存表是不支持 Text 和 Blog 的，因此我们在对这种大数据类型进行排序的时候无法使用内存表，而必须使用磁盘内置表，这类数据MySQL 在读取数据时会进行二次查询，所以会使得 SQL 的性能变的很差。 建议把 BLOG 或是 TEXT列分离到单独的扩展表中 ，并且在查询时一定不要使用 select * 的方式，而是取出必要的列，在使用 BOLOG 或者 TEXT 类型的时候就不要查询该列。 TEXT或 BLOG 类型只能使用前缀索引，并且 TEXT 的列上是不能有默认值的。 3.避免使用 ENUM 数据类型枚举类型是一个很特别的类型，在其他关系型数据库中并不存在这一类型，枚举本身是一个字符串类型，但是其本身却是以整数类型，所以能够存储65535种不同的枚举值，前面提到要将字符串类型转换成整数进行存储，从这一点看枚举是一种很好的数据类型，有助于我们很好的进行优化。 但是枚举类型也存在着很大的缺陷，修改 ENUM 值需要使用 ALTER 语句，频繁的对表结构进行修改很容易造成失误，在修改元数据的时候会生成元数据锁，在大量数据访问的时候会造成数据库系统的阻塞，对枚举数据进行操作的时候是存在一定的操作风险的。 ENUM 类型的 ORDER BY 操作效率低，需额外操作，由于是按照整型进行存储的，所以在查询的时候会对其进行字符串转化然后在进行排序，这种装换是无法使用索引的，所以枚举值排序性能比较差。 禁止使用数值作为 ENUM 的枚举值，因为枚举本身是索引顺序存储的，如果枚举值也是用整型进行存储，很容易会造成逻辑上的一种混淆，一般情况下枚举值是整型，通常建议使用整型代替。 4.尽量可能把所有列定义为 NOT NULL索引 NULL 列需要额外的空间来保存，所以需要占用更多的空间，索引空间占用的越低越好。 进行比较和计算时候对 NULL 值做特别的处理，所以可能会造成索引失效。 5.使用 TIMESTAMP 或DATETIME 类型存储时间字符串存储日期型的数据（不正确的做法） 缺点1：无法用日期函数进行计算和比较。缺点2：用字符串存储日期要占用更多的空间 TIMESTAMP 1970-01-01 00：00：01 ~ 2038-01-19 03：14：07 其实 TIMESTAMP 是以 INT 类型存储的，但是以日期格式显示，TIMESTAMP占用4字节和 INT 相同，单比 INT 可读性高， 当超出 TIMESTAMP 类型的存储范围时我们需要使用 DATETIME 类型来进行存储。 6.同财务相关的金额类数据，必须使用 decimal 类型Decimal 类型为精准浮点数，在计算时不会丢失精度，占用空间油定义的宽度决定，可用于存储比 bigint 更大的整数数据。 数据库 SQL 开发规范1.建议使用预编译语句进行数据库 只传参数，比传递 SQL 语句更高效 相同语句可以一次解析，多次使用，提高处理效率 防范 SQL 注入的风险 2.避免数据类型的隐式转换隐式转换一般发生在 Where 从句中，当列类型和参数类型不一致时就会出现隐式转换。， 隐式转换会导致索引失效 3.充分利用表上已经存在的索引尽量避免用%号的查询 例如 a like ‘%123%’ 一个 SQL 只能利用到符合索引中的一列进行范围查询 使用 left join 活 not exists 来优化 not in 操作。 4.程序链接不同的数据库使用不同的账号，禁止跨库查询。 为了数据库迁移和分库分表留出余地 降低业务耦合度 避免由于权限过大产生的安全风险 5.禁止使用 SELECT *必须使用 SELECT&lt;字段列表&gt;查询 消耗更多的 CPU 和 IO 以及网络带宽资源 无法使用覆盖索引 可减少表结构变更带来的影响 6.禁止使用不含字段列表的 insert 语句 12insert into t values (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); //不包含字段列表的 insertinsert into t(c1,c2,c3) values(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); //正确的写 可以减少表结构变更带来的影响 7.避免使用子查询，可以把子查询优化为join 并不是所有的子查询都可以使用 join进行优化，一般情况下只有子查询在 IN 子句中，并且子查询是一个简单的 SQL ，例如其中不包含 order by之类的复杂查询，才可以进行转换。 子查询的结果集无法使用索引 子查询会产生临时表操作，如果子查询数据量大则严重影响性能 临时表会消耗过多 CPU 以及 IO 资源 8.避免使用 JOIN 关联太多的表 每Join 一个表会占用一部分内存（join buffer size） 会产生临时表操作，影响查询效率 MySQL 最多允许关联61个表，建议不超过五个 9.减少同数据库的交互次数 数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率 10.使用 in 代替or in 的值不要超过500个 in 操作可以有效的利用索引 11.禁止使用 order by rand(）进行随机排序 会把表中所有符合条件的数据装载到内存中进行排序 会消耗大量的 CUP 和 IO 以及内存支援 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式 12.WHERE 从句中禁止对列进行函数转换和计算 对列进行函数转换或计算会导致无法使用索引 12wehre date(createtime) = &apos;20160901&apos;where createtime &gt;= &apos;20160901&apos; and createtime&lt; &apos;20160902&apos; 13.有明显不会重复值时使用 UNION ALL 而不是UNION UNION 会把所有数据放到临时表中然后进行去重操作 UNION ALL 不会对结果集进行去重操作 14.拆分复杂的大 SQL 为多个小 SQL MySQL 一个 SQL 只能使用一个 CPU进行计算 SQL 拆分后可以进行并行执行来提高处理效率 数据库操作行为规范1.超100万行的批量写操作，需分批多次进行操作 大批量操作可能会造成严重的主从延迟 binlog 日志为row 格式时会产生大量的日志 避免产生大事务操作 2.对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。对于大表使用 pt-online-schema-change 修改表结构，可以避免主从延时、表锁的问题。 3.禁止为程序使用的账户赋予 super 权限 当达到最大连接数贤之士，MySQL 允许1个有 super 权限的用户连接 super 权限只能留给 DBA 处理问题的账户使用 4.对于程序链接数据库账户，遵循权限最小原则 程序使用数据库账号只能在一个 DB下使用，不准夸库 程序使用账号原则上不准有 drop权限","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL 设计规范","slug":"MySQL-设计规范","permalink":"http://www.maksim.website/tags/MySQL-设计规范/"}]},{"title":"利用规约设计模式（Specification）开发整洁的规格校验（PHP 语言描述）","slug":"理解Specification设计模式","date":"2017-05-31T16:00:00.000Z","updated":"2017-10-18T13:12:45.000Z","comments":true,"path":"2017/06/01/1/","link":"","permalink":"http://www.maksim.website/2017/06/01/1/","excerpt":"","text":"规格校验是使我们在日常的开发过程中中比较常见的一种业务需求，最直观的使用是我们在开发电商类网站时我们会对商品的一些规格进行限定，例如重量大小不能超过 N（kg） 。 如果是一个刚刚加入业界的程序员，很有可能会编写出大量的if语句来进行解决此类的业务逻辑，这样编码可行吗？ 答案是可以，因为顺利的完成了业务逻辑代码的编写任务，但是却违反了类设计中的开闭原则，而且一看就是没有经过正规的训练，没有对于 OOP 编程有更深的了解。 那么有没有一种设计模式可以让我们设计出优雅而又整洁的逻辑代码呢，答案是显而易见的，要不然也就不会出现这篇文章，它就是——规模设计模式。 我们可以利用规约模式来解决这一实际问题，开发出优雅而又健全的业务逻辑代码。 规约设计模式的主要设计目的就是为了生成业务规则的明确规范，通过isSatisfiedBy方法来检测对象是否符合规范。 下图是规约模式 UML 类图（不懂的同学推荐去看由谭云杰所编写的《大象：Thinking in UML》） 即使看不懂 UML 类图也没有关系，编码能力的提高是要根据不断的实践才能有所增长的。当你顺着我的思路打完代码，你就已经可以明白规约设计模式的设计理念以及作用。 当然我还是要解释一下这个类图所代表的含义。 既然是规格校验，那么一个规格校验到底包括什么呢？ 一般而言主要有：区间、大于、小于、不等于，这几样，那么我们是不是可以将其抽象成一个类呢？ 这就是上面那张 UML 的简单含义，其中主要是用于描述其类的关系，UML 就是帮助我们对类进行抽象的一个工具。 下面让我们撸起袖子打代码。首先我们应该新建了 Goods类用于表示被规约的产品，其中包含一个 Price 价格属性，然后在建立对 Price 属性的规约，用来检验最新实例化的 Goods 是否满足约定。 123456789101112131415161718192021&lt;?php//商品类namespace DesignPatterns\\Behavioral\\Specification;class Goods&#123; /** * @var float */ private $price; public function __construct(float $price) &#123; $this-&gt;price = $price; &#125; public function getPrice(): float &#123; return $this-&gt;price; &#125;&#125; 在建立规约之前，我们需要建立一个接口，这个接口中定了了一个方法isSatisfiedBy,也就是上文提到的那个检测对象是否满足规约条件的那个方法。 12345678&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;interface SpecificationInterface&#123; public function isSatisfiedBy(Goods $goods): bool;&#125; Ok，在我们编写其余代码之前，我们需要来做一个思考，在程序语言当中，判断条件中的操作符是不是有或、与、非这三个判断条件，对应着 ||、&amp;&amp;、！。 那么我们是否可以将其抽象成一个又一个的类呢？ OrSpecification规约用来表示 Or 的关系，与我们的逻辑判断一样，表示在两个规约之间只要满足一条便返回 true。 123456789101112131415161718192021222324252627282930namespace DesignPatterns\\Behavioral\\Specification;class OrSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface[] */ private $specifications; /** * @param SpecificationInterface[] ...$specifications */ public function __construct(SpecificationInterface ...$specifications) &#123; $this-&gt;specifications = $specifications; &#125; /** * if at least one specification is true, return true, else return false */ public function isSatisfiedBy(Item $item): bool &#123; foreach ($this-&gt;specifications as $specification) &#123; if ($specification-&gt;isSatisfiedBy($item)) &#123; return true; &#125; &#125; return false; &#125;&#125; AndSpecification 用于表示 And 关系，两条以上规约时，必须都满足条件才会返回 true否则返回false. 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class AndSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface[] */ private $specifications; /** * @param SpecificationInterface[] ...$specifications */ public function __construct(SpecificationInterface ...$specifications) &#123; $this-&gt;specifications = $specifications; &#125; /** * if at least one specification is false, return false, else return true. */ public function isSatisfiedBy(Item $item): bool &#123; foreach ($this-&gt;specifications as $specification) &#123; if (!$specification-&gt;isSatisfiedBy($item)) &#123; return false; &#125; &#125; return true; &#125;&#125; NotSpecification.php 用于表示Not。 123456789101112131415161718192021&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class NotSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface */ private $specification; public function __construct(SpecificationInterface $specification) &#123; $this-&gt;specification = $specification; &#125; public function isSatisfiedBy(Item $item): bool &#123; return !$this-&gt;specification-&gt;isSatisfiedBy($item); &#125;&#125; 逻辑判断抽编码好了之后，我们就要开始真正的规约了，我们建立一个 Price 规约，其中主要设定了 Price 的范围，构造函数中包含最大值与最小值，并且实现isSatisfiedBy用来判断输入的值是否符合范围。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class PriceSpecification implements SpecificationInterface&#123; /** * @var float|null */ private $maxPrice; /** * @var float|null */ private $minPrice; /** * @param float $minPrice * @param float $maxPrice */ public function __construct($minPrice, $maxPrice) &#123; $this-&gt;minPrice = $minPrice; $this-&gt;maxPrice = $maxPrice; &#125; public function isSatisfiedBy(Item $item): bool &#123; if ($this-&gt;maxPrice !== null &amp;&amp; $item-&gt;getPrice() &gt; $this-&gt;maxPrice) &#123; return false; &#125; if ($this-&gt;minPrice !== null &amp;&amp; $item-&gt;getPrice() &lt; $this-&gt;minPrice) &#123; return false; &#125; return true; &#125;&#125; 下面我们进行单元测试，如果不懂单元测试的朋友，也可以直接使用上面的代码进行测试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification\\Tests;use DesignPatterns\\Behavioral\\Specification\\Item;use DesignPatterns\\Behavioral\\Specification\\NotSpecification;use DesignPatterns\\Behavioral\\Specification\\OrSpecification;use DesignPatterns\\Behavioral\\Specification\\AndSpecification;use DesignPatterns\\Behavioral\\Specification\\PriceSpecification;use PHPUnit\\Framework\\TestCase;class SpecificationTest extends TestCase&#123; public function testCanOr() &#123; $spec1 = new PriceSpecification(50, 99); $spec2 = new PriceSpecification(101, 200); $orSpec = new OrSpecification($spec1, $spec2); $this-&gt;assertFalse($orSpec-&gt;isSatisfiedBy(new Item(100))); $this-&gt;assertTrue($orSpec-&gt;isSatisfiedBy(new Item(51))); $this-&gt;assertTrue($orSpec-&gt;isSatisfiedBy(new Item(150))); &#125; public function testCanAnd() &#123; $spec1 = new PriceSpecification(50, 100); $spec2 = new PriceSpecification(80, 200); $andSpec = new AndSpecification($spec1, $spec2); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(150))); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(1))); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(51))); $this-&gt;assertTrue($andSpec-&gt;isSatisfiedBy(new Item(100))); &#125; public function testCanNot() &#123; $spec1 = new PriceSpecification(50, 100); $notSpec = new NotSpecification($spec1); $this-&gt;assertTrue($notSpec-&gt;isSatisfiedBy(new Item(150))); $this-&gt;assertFalse($notSpec-&gt;isSatisfiedBy(new Item(50))); &#125;&#125; 这样一来，我们就设计出了优雅而又健壮的代码。 说明： 本文章代码，来自于 Github 开源项目，点击链接进入查看http://designpatternsphp.readthedocs.io/","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maksim.website/tags/设计模式/"}]},{"title":"","slug":"单例模式 - Singleton","date":"2017-03-16T15:28:53.000Z","updated":"2017-03-16T15:28:53.000Z","comments":true,"path":"2017/03/16/cjek1zh6g004fx9rdfvl7sf1e/","link":"","permalink":"http://www.maksim.website/2017/03/16/cjek1zh6g004fx9rdfvl7sf1e/","excerpt":"","text":"单例模式 - Singleton单例模式确保每一个指定的类只存在一个实例对象，并且可以全局访问那个实例。一般情况下会用延时加载的策略，指在第一次需要使用的时候初始化。 设计模式并不局限于某一个语言，他是一种编程思维 在 iOS 开发中单例模式h很常见，NSUserDefaults.standardUserDefaults()等等。 如果多于一个实例又会怎么样呢？代码和内存还没精贵到这个地步吧？ 某些场景下，保持实例对象仅有一份是很有意义的。举个例子，你的应用实例 (UIApplication)，应该只有一个吧，显然是指你的当前应用。还有一个例子：设备的屏幕 (UIScreen) 实例也是这样，所以对于这些类的情况，你只想要一个实例对象。 单例模式的应用还有另一种情况：你需要一个全局类来处理配置文件。我们很容易通过单例模式实现线程安全的实例访问，而如果有多个类可以同时访问配置文件，那可就复杂多了。 使用单例模式 这是一个日志类，有一个属性（是以单例对象）和两个方法（sharedInstance()和 init()）。 第一吊用 sharedInstance()的时候，instance 属性还没有初始化，所以我们必须创建一个新的实例并且返回。 下一次再调用 sharedInstance()的时候，instance 已经完成了初始化，直接返回即可，这个逻辑就确保了只有一个实例对象。 接下来我们继续完善单例模式，通过这个类来管理专辑数据。 注意到在我们前面的截图里，分组中有个 API 分组，这里可以放那些提供后台服务的类。在这个分组中创建一个新的文件 LibraryAPI.swift ，继承自 NSObject 类。 在 LibraryAPI 里添加下面这段代码：","categories":[],"tags":[]},{"title":"","slug":"图层树","date":"2017-03-16T02:36:21.000Z","updated":"2018-02-27T14:15:44.077Z","comments":true,"path":"2017/03/16/cjek1zh6n004px9rd0b924tam/","link":"","permalink":"http://www.maksim.website/2017/03/16/cjek1zh6n004px9rd0b924tam/","excerpt":"","text":"title:iOS图层树categories:iOSdate:2015-12-21 id:1图层树Core Animation 是一个符合引擎，塔的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分分解成独立的图层，存储在一个叫做图层数的体系中，于是这个树形成了 UIKit 以及在 iOS 10应用程序当中你所看能在屏幕上看见的一切的基础。 图层与视图如果你曾经在 iOS 10或MacOS 平台上面写过应用程序，你可能能会对视图的概念比较熟悉。一个视图就是在屏幕上显示一个矩形块（比如图片，文字或者视频），它能拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系。 图1.1一种典型的 iOS 屏幕（左边）和型城市图的层级关系（右边） 在 iOS 中，所有的视图都从一个叫做 UIview 的基类派生而来，UIView 可以处理触摸事件，可以支持基于 Core Graphics 绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。 CALayerCALayer类在概念上和 UIView 类似，同样也是一些被层级关系树管理的矩形块，同样可以包含一些内容（像图片，文本或者背景色），管理子视图的位置。它们有一些方法和尚需经用来做动画和变换。 和 UIview 最大的不同是 CALayer 不处理用户的交互。 CALayer 兵不清楚具体的响应链（iOS通过视图层级关系用来传递触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触电在图层的范围之内。 平行的层级关系每一个 UIView 都有一个 CALayer 实例的图层属性，也就是所谓的 Backing layer,视图的职责就是创建并管理这个图层，以确保子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应是在层级关系树当中有相同的操作（见图1.2） 图1.2 图层的树状结构（左边）以及对应的视图层级（右边） 实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView 仅仅是对它的一个封装，提供了一些 iOS 类似于处理触摸事件的具体功能，以及 Core Animation 底层方法的高级借口。 但是为什么 iOS 要基于 UIview 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这也是能避免很多重复代码。在 iOS 和 Mac OS两个平台上，时间和用户交互有很多地方不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么 iOS有 UIKit 和 UIView，但是 MacOS 有 APPKit 和 NSView 的元婴。他们功能上很类似，但是在实现上有着显著的区别。 绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。+ 实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，","categories":[],"tags":[]},{"title":"PHP Closures","slug":"PHP 的闭包","date":"2017-03-15T14:15:16.000Z","updated":"2017-08-11T06:22:38.000Z","comments":true,"path":"2017/03/15/1/","link":"","permalink":"http://www.maksim.website/2017/03/15/1/","excerpt":"","text":"闭包函数（closures）也就做匿名函数（Anonymous functions），是指在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。 理论上，闭包和匿名函数是不同的概念，不过 PHP 将其视作相同的概念，所以闭包与匿名函数相等。 匿名函数其实就是没有名字的函数。匿名函数可以赋值给变量，还能像其他任何 PHP 对象那样传递。不过匿名函数仍然是函数，因此可以调用，还可以传入参数。匿名函数特别适合作为函数或方法的回调。 创建闭包12345$closure = function ($name) &#123; return sprintf('Hello %s', $name);&#125;;echo $closure('Maksim');//输出 Hello Maksim 创建一个闭包对象，然后将其复制给$closure 变量。闭包和普通的 PHP 函数很想：使用语句相同，也接受参数，而且能返回值。不过，匿名函数没有名称。 我们通常把 PHP 闭包当做函数和方法的回调使用。很多 PHP 函数都会用到回调函数，例如 array_map()和 preg_replace_callback()。这是使用 PHP 匿名函数的最佳时机！ 记住，闭包和其他值一样，可以作为参数传入其他 PHP 函数，我们把一个闭包对象当做回调参数，传给 array_map()函数。 12345$numbersPlusOne = array_map(function ($number)&#123; return $number + 1;&#125;,[1,2,3]);print_r($numbersPlusOne);//([0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4) 在闭包出现之前，PHP 开发者只能单独创建普通函数，然后使用名称引用那个函数，这么做，代码执行的稍微慢一点，而且把回调场景和使用场景分割开了，如下： 123456$numbersPlusOne = array_map('incrementNumber',[1,2,3]);function incrementNumber($number)&#123; return $number + 1;&#125;print_r($numbersPlusOne);//([0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4) 这样的代码虽然可用，但是没有使用闭包来的间接。如果只需要使用一次回调，没有必要单独定义具名函数。把闭包当做回调使用，写出的代码更加简洁、清晰。 使用附加状态前面演示了如何把匿名函数当做回调使用，下面探讨如何为 PHP 闭包附加兵封装状态。JavaScript 开发者可能对 PHP 的闭包感到奇怪，因为 PHP 闭包不会像真正的 JavaScript 闭包那样自动封装应用状态。在 PHP 中，必须手动调用闭包对象的 bindTo()方法或者使用 use 关键字，把状态附加到 PHP 闭包上。 使用 use 关键字附加闭包状态常见得多，因此我们先看这种方式。使用 use 关键字把变量附加到闭包上时，附加的变量会记住附加时赋给它的值。 123456789101112function enclosePerson($name) &#123; return function ($doCommand) use ($name) &#123; return sprintf('%s, %s', $name, $doCommand); &#125;;&#125;//把字符串“Maksim”封装在闭包中$clay = enclosePerson('Clay');//掺入参数，调用闭包echo $clay('get sweet tea');// Clay, get sweet tea 使用 use 关键字可以把多个参数传入闭包，此时要像 PHP 函数或者方法的参数一样，使用逗号分割多个参数 PHP 闭包是对象。与其他 PHP 对象类似，每个闭包实例都可以使用$this 关键字获取闭包的内部状态。闭包对象的默认状态没什么用，不过有一个__invoke()魔术方法和 bindTo()方法，仅此而已。 但是，bindTo()方法为闭包增加了一些有趣的潜力。我们可以把使用这个方法把 Closure 对象的内部状态绑定到其他对象上。bindTo()方法的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的 PHP 类。因此闭包可以访问绑定闭包的对象中受保护和私有的成员变量。 你会发现，PHP 框架经常使用 bindTo()方法把路由 URL 映射到匿名回调函数上。框架会把匿名函数绑定到应用对象上，这么做可以把这个匿名函数中使用$this 关键字引用重要的应用对象。 12345678910111213141516171819202122232425&lt;?phpclass App&#123; protected $routes = array(); protected $responseStatus = '200 Ok'; protected $responseContentType = 'text/html'; protected $responseBody = 'Hello world'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this,__CLASS__); &#125; public function dispatch($currentPath) &#123; foreach ($this-&gt;routes as $routePath =&gt; $callback) &#123; if ($currentPath === $currentPath) &#123; $callback(); &#125; &#125; header('HTTP/1.1 '. $this-&gt;responseStatus); header('Content-type: ' . $this-&gt;responseContentType); header('Content-length: ' . mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; &#125;&#125; 我们要特别注意 addRoute（）方法。这个方法的参数分别是一个路由路径（例如/users/josh）和一个路由回调。dispatch()方法的参数是当前 HTTP 请求的路径，它调用匹配的路由回调。第10行是重点所在，我们把路由回调绑定到了当前 APP 实例上。这么做能够在回调函数中处理 APP 实例的状态。 1234567$app = new App();$app-&gt;addRoute('/users/josh', function ()&#123; $this-&gt;responseContentType = 'application/json;charset=utf8'; $this-&gt;responseBody = '&#123;\"name\":\"json\"&#125;';&#125;);$app-&gt;dispatch('/users/josh'); 参考 现代 PHP 官方手册","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"Closures","slug":"Closures","permalink":"http://www.maksim.website/tags/Closures/"}]},{"title":"","slug":"RESTFul 是什么？","date":"2017-03-14T06:30:03.000Z","updated":"2017-07-17T05:46:24.000Z","comments":true,"path":"2017/03/14/cjek1zh5f002ix9rduxxttgtd/","link":"","permalink":"http://www.maksim.website/2017/03/14/cjek1zh5f002ix9rduxxttgtd/","excerpt":"","text":"RESTFul 是什么？RESTful的本质是一种软件架构风格，核心是面向资源，主要用来解决降低开发的复杂性，提高系统的可伸缩性。随着互联网的发展，各种终端层出不穷，手机浏览器，手机 APP 为了节约成本，我们可以使用 RESTful 架构，只需要封装好一套完善的API就可以为多套终端提供服务。 设计概念和准则 网络上所有事物都可以被抽象为资源 每一个资源都有唯一的标识符，对资源的操作不会改变这些标识 所有的操作都是无状态的 所谓的资源就是网络上的一个实体，或者说是网络上一个具体的信息。 HTTP 协议 - URL HTTP 是一个属于应用层的协议，特点是简捷、快速 1schema://host[:port]/path[?query-string][#anchor] schema 指定底层使用的协议（如：http,https） host 服务器的 IP 地址或者域名 port 服务器端口 path 访问资源的路径 query-string 发送给 http 服务器的数据 anchor 锚 HTTP","categories":[],"tags":[]},{"title":"","slug":"光源色、物体色、固有色","date":"2017-03-14T06:20:11.000Z","updated":"2017-03-14T06:20:11.000Z","comments":true,"path":"2017/03/14/cjek1zh6h004ix9rdruevabn6/","link":"","permalink":"http://www.maksim.website/2017/03/14/cjek1zh6h004ix9rdruevabn6/","excerpt":"","text":"光源色、物体色、固有色什么是光源色光源色指的是发光体所发出光线的颜色。例如，阳光、月光、火光和各种灯光等的光色。光源色的不同会引起物体的固有颜色的变化。例如，一块红布在白天看起来和在晚上灯光下看起来颜色是有所不同的。许多女同志都懂得这一点，她们避免晚上去商店购买衣料，因为晚上灯光下看到的黄色，和白天看到的是有些不一样的。就是同样的眼光来说，在早晨、正午和傍晚其光色也是不相同的，会引起同一景物的色调的显著变化。 物体在不同颜色的光照下会呈现出跟光颜色比较接近的色彩，这些都是收到光源色彩的影响。 什么是物体色物体色是指光源色经过物体有选择的吸收和反射，反映到人的视觉中的光色感觉。物体本身并不会发光，但都具有对各种波长的光有所选择性的吸收、反射或者投射的特性，因此形成千变万化的不相同的物体色彩。 物体可以分为透明物体和不透明物体，不透明物体呈现的色彩是由它反射的光色决定的，而透明物体呈现的色彩则是由它透过的色彩决定的。 如绿色树叶吸收太阳光除绿色光的其他色光，所以我们看到的是绿色，而蓝色玻璃只透过蓝色光吸收其他光所以看起来呈现的是蓝色。 什么是固有色固有色指的是一个物体在通常情况下给人的色彩印象（概念）例如，红旗是红色的，草地是绿色的，中国人的皮肤是黄色的等等。 从色彩的光学原理知道物体并不存在固定不变的固有颜色，物体的颜色是与光密切相关的，是在一定的条件下变化的，是具体的，而不是一种概念。讲中国人皮肤是黄色的，其实不可能指出是哪一种具体的光色。然而，物体的颜色景观是变化的、复杂的，单扔给我们一定的色彩印象。所以我们既不要受固有色概念的束缚，又不能完全故事固有色。","categories":[],"tags":[]},{"title":"色彩基础","slug":"色彩的基本构成和使用方法","date":"2017-03-11T12:40:00.000Z","updated":"2017-03-11T12:40:58.000Z","comments":true,"path":"2017/03/11/cjek1zh7o0069x9rdq20uaaxf/","link":"","permalink":"http://www.maksim.website/2017/03/11/cjek1zh7o0069x9rdq20uaaxf/","excerpt":"","text":"色彩的基本构成和使用方法 色彩的定义是什么 色彩的种类 色彩3大特点 色彩的定义是什么我们平时看到的所有东西都会有自己的色彩，有难以感觉到的灰暗，也有鲜艳耀眼的成色等，其实色彩是依赖于光存在的，没有光就不会有色彩，色彩是物体对光谱的反射给人眼传达的一种视觉信息。 我们可以把颜色通过可见光的波长来划分，这有点跟 PS 软件上面的取色板上的色彩排列相似（如下图）。 光其实也是电磁波的一种，我们知道电磁波的传播速度是一样的，而决定我们看到颜色光的色彩的就是电磁波的波长，我们可以从图中看到不同颜色对应的波长范围，如红色光的波长在760纳米之间，蓝色光的波长范围在380纳米之间，所以可见光的范围在380-760之间（如下图）。 色彩种类划分我们可以看到的可见光的范围是380-760纳米波长之间的光谱，通过三棱镜折射出太阳光我们可以看到红橙光绿青蓝紫7中颜色，而实际上我们可以把颜色归类成红黄蓝三追踪原色，这3种颜色可以通过组合搭配调配处其他任意颜色。 色光三颜色 ： 红黄蓝 RGB（PS 案例）物体三颜色： 红蓝黄（水彩绘画） 色彩的三要素 色相 明度 纯度（饱和度） 色相色相其实就是指色彩，物体所呈现的颜色状态叫做色相，如红旗的颜色就是红色，天空的颜色是蓝色，荷叶的颜色是绿色，我们可以很简单的识别一种物体的色相。 在 RGB 色彩模式中，色彩用红，绿，蓝三种色彩来合成表现的，每种色彩分成255个阶，通过不同的比例调配出千变万化的色彩。 明度明度是指色彩的明暗程度，也称深浅度，是表现颜色层次感的基础。 我们知道色彩的表现是以光反射的形式表现的，比如同一个橙子的颜色是橙色的，但是在明度上的变化让我们可以看出这个橙子的立体感(如下图)。 在无彩色系中，白色明度最高，黑色明度最低，在黑白之间存在一系列灰色，靠近白色的部分称之为名灰色，靠近黑色的部分称之为暗灰色。在有色系中，黄色明度最高，紫色明度最低。任何一个有色彩，当它掺入白色时，明度提高，当掺入黑色时，明度降低。同时其混度也响应降低。 在 RGB 色彩模式中，RGB 色彩3个数值相加越大就代表色彩明度越高，我们可以简单理解为月亮的颜色明度越高，就比如R：255是红色，那么 R255，G：50，B：50就是加了亮度的红色，会显得亮而且轻(如图)。 纯度（饱和度）纯度通常是指色彩的鲜艳程度。从科学的角度看，一种颜色的鲜艳度取决于这一色相发射光的单一程度，也就是指原色在色彩中所占的百分比。人眼能识别的有单色光特征的颜色，都具有一定的鲜艳度。不同色相不仅明度不同，纯度也不相同。 通常纯色的纯度最高，也就是不加入黑白灰的颜色，同一色相的色彩，不掺杂白色或者黑色，则被称为纯色。在纯色中加入不同明度的无彩色，会出现不同的纯度。以蓝色为例，向纯蓝色中加入一点白色，纯度下降而明度上升，变为淡蓝色。继续加入白色的量，颜色会越来越淡，纯度下降，而明度持续上升。反之，加入黑色或灰色，则相应的纯度和明度同时下降。","categories":[{"name":"设计","slug":"设计","permalink":"http://www.maksim.website/categories/设计/"}],"tags":[{"name":"色彩","slug":"色彩","permalink":"http://www.maksim.website/tags/色彩/"}]},{"title":"使用 Vagrant 统一公司内开发环境","slug":"使用 Vagrant 搭建开发环境","date":"2016-12-13T01:10:23.000Z","updated":"2018-01-03T15:35:20.470Z","comments":true,"path":"2016/12/13/cjek1zh6b0046x9rd0usxieqr/","link":"","permalink":"http://www.maksim.website/2016/12/13/cjek1zh6b0046x9rd0usxieqr/","excerpt":"","text":"Vagrant 是什么? 简单地说，Vagrant让我们可以通过代码的方式快速地、可重复地创建针对不同虚拟环境的虚拟机，包括Virtualbox、AWS、Docker等。它使得我们可以一次性地、自动创建多个环境相同的虚拟机，对于软件开发和测试尤其有用。本文我们将以Virtualbox为例，看看Vagrant的基本使用。 Vagrantd的作用? 统一开发环境。一次配置打包，统一分发给团队成员，统一团队开发环境，解决诸如“编码问题”，“缺少模块”，“配置文件不同”带来的问题； 避免重复搭建开发环境。新员工加入，不用浪费时间搭建开发环境，快速加入开发，减少时间成本的浪费； 多个相互隔离开发环境。可以在不用box里跑不同的语言，或者编译安装同一语言不同版本，搭建多个相互隔离的开发环境，卸载清除时也很快捷轻松。 Vagrant 适用范围 开发环境 项目配置比较复杂 官网：https://www.vagrantup.com/ vagrant与 VirtualBox的版本需要注意匹配，在官网有详细介绍，如果版本不匹配会出现一些错误。 常用命令 vagrant box list 查看目前已有的box vagrant box add 新增加一个box vagrant box remove 删除指定box vagrant init 初始化 vagrant up 启动虚拟机 vagrant ssh SSH 登陆虚拟机 vagrant suspend 挂起虚拟机 vagrant reload 重启虚拟机 vagrant halt 关闭虚拟机 vagrant status 查看虚拟机运行状态 vagrant destroy 销毁当前虚拟机","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://www.maksim.website/tags/工具/"}]},{"title":"使用策略模式敲开设计模式的大门(PHP语言描述)","slug":"PHP设计模式系列之入门","date":"2016-09-23T14:15:16.000Z","updated":"2017-10-18T13:12:08.000Z","comments":true,"path":"2016/09/23/108/","link":"","permalink":"http://www.maksim.website/2016/09/23/108/","excerpt":"","text":"设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 前言 本系列文章不会直接上代码直接进行解释，我一直认为带着问题来学习是效率最高的学习方式。 本系列文章不会有演示截图，你为什么不敲一遍加深印象呢，另外说不定我的代码有错。 我所写的文章只是我对于编程的理解，如果有错误希望能够得到指正以免误人子弟。 怎么样才可以进行设计模式的学习步子迈大了容易扯到蛋，如果在没有熟悉 OOP 编程思想前就开始学习设计模式，我感觉会有两种可能，不是“扯蛋”，就是“拉跨”。 当然上面的话是一句玩笑话，学习设计模式可以有效的提高我们的代码质量与深入的理解 OOP 编程理念，如但是果在没有扎实的功底（至少要要理解了抽象、接口、多态）前就开始学习设计模式会越学越难，脑子越来越浑，那就真变成了从入门到放弃了，因为你的思维还没有真正的走进 OOP(单身狗表示完全无法面向对象^_^)。 对于设计模式的不理解我感觉主要分为两种，一种是不知道怎么实现的，原因就是如上所述，另外一种是不知道为什么要这么用的，其实没有必要纠结于为什么这么用，这么用了有啥作用，设计模式不过是与算法一样只是为了实现某个特定环境下可以使用的一种更好的选择。 更好一点的例子就是当我们对一些数据进行排序的时候，我们首先想到就是那几个排序算法一样，当我们打着打着代码突然灵光一闪，好像这个地方用这个设计模式写起来会轻松一点。 当碰到不懂得地方，思考一下，想不通，就出去走走，把这个东西放下来，反正就算看到第二天凌晨也也是无用的，当真正遇到问题的时候，灵光一闪这个东西可以这么写，然后去实践，这就是我的学习之道。还有就是尽量去学实例，而不是去死扣概念，当你真正用起来了，你也就差不多懂了，算法与数据结构亦是如此。 本系列文章尽量以推导的形式来进行书写，而不是以现成的代码来进行讲解，让读者知道设计模式是怎么来的也就是如何演化出来的，希望各位能够喜欢。另外本系列的文章并不会提供运行界面的截图，如果想看看结果是否正确，为什么不自己试试呢？ 设计模式尝鲜（策略模式）开头引用的话来自于百度百科，我相信很多刚刚开始接触编程的人都会犯晕，因为所有人都不喜欢被学术化的文字，我们以设计模式中较为常用的策略模式来进行演示，当我们编写一个广告模块的时候，公司给的要求是根据访问者的性别来进行显示广告以提高转化率，那我们应该怎么写呢？ 首先我们想到的是在每一个广告位上面都使用 if 判断来判断访客的性别，这样就能够解决这样的需求，那么我们的每一个广告代码的代码块可能是这个样子的： 12345判断 男 or 女&#123; 如果是男的就是男人的广告&#125;else&#123; 显示女人的广告&#125; 既然伪代码想好了，那么我们就可以着手进行开发了，然后我们在 if 代码块中添加各自的家在广告代码，于是就变成了下面的样子： 12345if ($_GET['sex'] == 'man') &#123; echo '外星人大减价现在购买立即送电竞瑞文皮肤';&#125;else&#123; echo '卡西欧美颜相机不要钱免费送！';&#125; 但是这是属于一种硬编码的编程方式，一旦我们增加了某种需求，要求其年龄大于23岁显示什么样的广告，那么我们就不得不在每一个 if 判断处再加上新的判断条件，这样的设计就是不合理的，为了提高可读性与可维护性，我们会考虑建立两个不同的类来对两个广告类来对其进行管理。于是代码变成了下面的样子。 12345678910111213141516171819202122232425//index.phpinclude 'GenderAD.php';include 'ManAD.php';if ($_GET['sex'] == 'man') &#123; $ad = new ManAD();&#125;else&#123; $ad = new GenderAD();&#125;$ad-&gt;show();//GenderAD.phpclass GenderAD&#123; public algorithm()&#123; echo '卡西欧美颜相机不要钱免费送！'; &#125;&#125;//ManAD.phpclass ManAD&#123; public algorithm()&#123; echo '外星人大减价现在购买立即送电竞瑞文皮肤'; &#125;&#125; algorithm 英[ˈælgərɪðəm] 美[ˈælɡəˌrɪðəm] n. 演算法; 运算法则; 计算程序; 其实到了这一步就已经算是一个简单的策略模式了，因为他已经具有策略的特质了，只不过还不够完善，如果说这不算什么的话我也没有办法，因为所有的设计模式其实都是思维模式与表现形式罢了，就像上面的引用中提到的一样，设计模式只不过是为了能够让代码可以重用，更容易他让人理解，因为你的代码并不是你一个人在维护，那么问题来了，只是简单的对其进行封装真的就提高代码的可维护性了么，其实并没有，我们还没有将 OOP 的设计概念发挥到极致。 经过分析我们发现其实 ManAD类和 GenderAD最终都要进行显示，他们的方法的显示方法都是 show，如果是你一个人在开发那么没有什么问题，可是若是两个人开发呢，你们可以直接可以对话的方式进行沟通，协定好都是 show方法来显示，可是为什么不用更工程化的方式来实现呢？ 我们可以使用接口来实现这一目的，如果对接口还不了解，可以去查阅一下资料，很快你就能够明白，在本文结束后我会在下方标注出参考范例。 我们可以新建一个接口来对这些策略进行控制。 12345678910111213141516interface ADinterface&#123; public function algorithm();&#125;class ManAD implements ADInterface&#123; public function algorithm()&#123; echo '外星人大减价现在购买立即送电竞瑞文皮肤'; &#125;&#125;class GenderAD implements ADInterface&#123; public function algorithm()&#123; echo '卡西欧美颜相机不要钱免费送！'; &#125;&#125; 这样一来广告策略必须遵循这个接口进行开发，就保证了所有策略类都需要实现 show 方法。 到目前为止，策略模式已经相对的完善了，但是还是不够完美，因为代码依旧并不是很 OOP，我们其实还可以更进一步，让他更 OOP，我们可以对那些策略外面套一个壳子，给外面一个选择器。 123456789101112131415class StrategySelect &#123; //具体策略对象 private $strategyInstance; //构造函数 public function __construct($instance) &#123; $this-&gt;strategyInstance = $instance; &#125; public function algorithm($strategy) &#123; return $this-&gt;strategyInstance-&gt;algorithm(); &#125;&#125; 我们通过构造函数接收到具体的执行策略，然后使用algorithm()执行相对应的策略。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpinterface ADinterface&#123; public function algorithm();&#125;class StrategySelect &#123; //具体策略对象 private $strategyInstance; //构造函数 public function __construct($instance) &#123; $this-&gt;strategyInstance = $instance; &#125; public function algorithm() &#123; return $this-&gt;strategyInstance-&gt;algorithm(); &#125;&#125;class ManAD implements ADInterface&#123; public function algorithm()&#123; echo '外星人大减价现在购买立即送电竞瑞文皮肤'; &#125;&#125;class GenderAD implements ADInterface&#123; public function algorithm()&#123; echo '卡西欧相机免费赠送啦'; &#125;&#125;header(\"Content-type:text/html;charset=utf-8\");if ($_GET['sex'] == 'man') &#123; $stratey = new StrategySelect(new ManAD()); $stratey-&gt;algorithm();&#125;else&#123; $stratey = new StrategySelect(new GenderAD()); $stratey-&gt;algorithm();&#125; Strategy其实算是一个策略选择器，当满足一定条件的时候，我们通过这个策略选测器来进行选择相对应的策略。这样一来更符合逻辑。是不是很 OOP？ 如果有什么不懂得可以在评论区进行留言，有时间我会一一答复，如果发现本文中有什么错误请指出，我也害怕误人子弟，特别是概念上的东西，在最后StrategySelect类的讲解上我依旧感觉写的很模糊，有些差强人意。 参考 《Leaning PHP Design Patterns》 William Sanders 著 苏金国 王宇飞等译 《PHP之道》 《PHP大话设计模式》 Rango(韩天峰) 录制者 慕课网视频教程","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maksim.website/tags/设计模式/"}]},{"title":"AV Foundation那些事系列（一）AVFunction入门了解","slug":"文字转语音","date":"2016-07-30T12:38:29.000Z","updated":"2016-07-30T13:36:40.000Z","comments":true,"path":"2016/07/30/194/","link":"","permalink":"http://www.maksim.website/2016/07/30/194/","excerpt":"","text":"前言Hello，大家好，先做一个简短的自我介绍，我是AirCrayon，目前就职于齐齐哈尔的一家创业型公司，从今天开始，每周末我都将为大家带来一篇博文，今天为大家带阿里的是 AVFunction 的那些事系列博文的第一章——AV Foundation入门。 苹果公司一直以来都是一家擅长引领潮流的一家公司，不论是产品设计开始技术革新，1991年苹果公司推出了QuickTime首次将数字音频和数字视频展现在用户面前。 QuickTime不仅仅是一个媒体播放器，而且是一个完整的多媒体架构，可以用来进行多种媒体的创建、生产和分发，并为这一过程提供端到端的支持：包括媒体的实时捕捉，以编程的方式合成媒体，导入和导出现有的媒体，还有编辑和制作、压缩、分发，以及用户回放等多个环节。 在2001年苹果公司推出了iTunes和iPod，从根本上改变了用户收听音乐的方式，iTunes store的出现彻底改变了国外的传统音乐行业（多么牛的一家公司）。 AV Foundation 的含义AV Foundation是MacOS（目前还叫 OS X ，但最新版本的名字将叫做 MacOS）和 iOS 系统中用于处理基于时间的媒体数据的高级Objective-C框架。通过开发所需要的工具提供了大量的功能集，让开发者能够基于 Apple 平台创建媒体应用程序。AV Foundation 的构建考虑到了目前的硬件环境和应用程序，其设计过程高度依赖于多线程机制。充分利用了多和设备的有时并且使用了大量的 block 和 GCD 机制将复杂的计算放在后台线程中会自动提供硬件加速操作，确保在大部分设备上应用程序以最佳的性能运行。AV Foundation 的设计也充分考虑了电量效率来满足注入 iPhone 和 iPad 这类的移动设备，此外从一开始该框架就是针对于64位处理器设计，可以发挥64为处理器的所有优势。 在iOS7下的AVFoundation下增加了一个类用于文字转成语音,需要注意的是其转换的语音与你的手机语言环境有关,如果手机是英文环境,则无法读取中文字符串,但是中文环境下可以读取英文. 12AVSpeechSynthesizer *xx = [[AVSpeechSynthesizer alloc]init]; //开始播放[xx speakUtterance:[AVSpeechUtterance speechUtteranceWithString:@&quot;语音转换&quot;]];","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"对于未来的规划","slug":"plan","date":"2016-07-20T04:45:16.000Z","updated":"2016-07-20T05:10:54.000Z","comments":true,"path":"2016/07/20/cjek1zh61003qx9rdiw4d8hvj/","link":"","permalink":"http://www.maksim.website/2016/07/20/cjek1zh61003qx9rdiw4d8hvj/","excerpt":"","text":"我现在在做什么很久没有写博客了，其实是不知道写什么了，目前在做一个 PHP的项目，这也算是大学没有白白浪费，至少还学了一门语言，虽然并没有一上来就做 iOS 心里有点小遗憾。我并没有回北京而是选择留在了齐齐哈尔，这是一座很美的城市，其中也有很多回忆，留下来的一个原因就是这里的回忆实在是太多了，等回忆被齐齐哈尔的大风吹散也就该是离开这里的时候了。 对于未来的规划规划这种东西规划的太久也没有用，谁都不可能预料到以后会发生什么，只能说是大致心里有一个方向，最近打算在看 swfit 的同时也看一下安卓。本身我就会 PHP，说不定在齐齐哈尔的这段时间里我会成为一个全栈工程师。 毕业了，虽然闲散的时间少了，但是这个时候我可以去做一些我喜欢做的事情，因为可以自己赚钱了，昨天在网上买了一个瑜伽垫准备开始健身，健康的身体才是未来的保障，我还买了一套美术教程，其实我还想买一个尤克里里，但是想了想还是算了，可能是在我出生的时候身上的音乐细胞就全都被消灭掉了。 我目前每天11点半睡觉，早晨五点钟起床，从五点到六点半的这个时间段我分配出了半个小时锻炼，一个小时的晨读，读的并不是技术类的书籍而是一些读物，目前正在读《百年孤独》，这样做只是希望自己能够得到精神上的满足还有活跃一下脑子，害怕有一天变成了代码脑袋。 以下是我这一年要读的书： 《百年孤独》 《摆渡人》 在齐齐哈尔这段时间要掌握的技能： 安卓开发 跨平台开发 自己的爱好： 可以画简单的插画 新书收藏超过500 这样今年简单的计划就算是完成了","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/tags/随笔/"}]},{"title":"Objective-C Runtime：Class","slug":"Runtime:Class","date":"2016-05-30T16:27:31.000Z","updated":"2017-07-17T05:53:32.000Z","comments":true,"path":"2016/05/31/2/","link":"","permalink":"http://www.maksim.website/2016/05/31/2/","excerpt":"","text":"Objective-C具有相当多的动态特性，表现在三个方面动态类型（Dynamic typeing）、动态绑定（ggDynamic binding）、动态加载（Dynamic loading），之所以被叫做动态，是因为必须到运行时（Runtime）才会做这些事情。 动态类型：即运行时在决定对象的类型。这类动态特性在日常生活中非常常见，简单说就是id类型。实际上静态类因为固定性与可与执行而使用得更加广泛，静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。 动态绑定：基于冬天类型，在某个实例对象呗确定后，其类型便被确定了，该对象对应的水泥管和响应的消息也将会被完全确定。 动态加载：根据需求加载所需要的资源，最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的图通屏幕设备上加载原图。 这一切的特性都是由于objective-c的Runtime。 Runtime库主要做了下面的几件事 封装：在这个库中对象可以用C语言的结构体表示，而方法可以用C函数来实现，另外再加上一些额外的特性。这些结构体和函数被runtime封装后，我们就可以在程序运行时创建、检查，修改类、对象和它们的方法了。 找出方法的最终执行代码：当程序执行[object doSometing]时，会想消息接受者（object）发送一条消息，runtime会根据消息接受者是否响应该消息而做出不同的反应。 而在我们在了解Runtime之前，我们需要清楚Runtime的数据类型 如果想要进一步的了解，我们可以到苹果开源上下载Runtime的源码来进行学习。 Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下: 1typedef struct objc_class *Class; 1234567891011121314151617struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ isa:需要注意的是在Objective-C中，所有类的自身也是一个对象这个对象的Class里面有一个isa指针，它指向metaClass（元类），下一章进行详细介绍。 super_class：指向该类的父类，如果该类已经是最顶层的根类，则它的值为NULL。 name：类的名称 info:在运行时使用的一些标识 version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。针对cache，我们用下面例子来说明其执行过程： instance_size 该类实例变量的大小 ivars 该类中所有成员变量的数组 methodLists 该类中自定义方法的数组 cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。 protocls 该类遵守协议的数组 1NSArray *array = [[NSArray alloc] init]; 其流程是： [NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。 检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。 接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。 在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。 ##参考资料 Objective-C Runtime 运行时之一：类与对象 Objective-C Runtime的数据类型 Objective-C objc_class 介绍","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[]},{"title":"使用 Feedly RSS阅读器订阅技术大牛的博客","slug":"Rss","date":"2016-05-08T03:06:05.000Z","updated":"2016-05-08T03:06:30.000Z","comments":true,"path":"2016/05/08/cjek1zh5c002fx9rdo14lxqwd/","link":"","permalink":"http://www.maksim.website/2016/05/08/cjek1zh5c002fx9rdo14lxqwd/","excerpt":"这几天一直都在自己看书，可是书上面的东西都比较落后一点，而且没有大牛博文上的东西讲的深入，可是来回跳转各位大牛的博客又非常的麻烦，有一些公众账号虽然也会推荐一些知识内容，可是你应该有过看到多个公众号发一篇博文的经历吧。 这个时候我想起了一个叫做 RSS 订阅的一个功能，可是国产的RSS 订阅器的 UI 是一个很大的槽点，而且功能相对于臃肿，很多功能都用不到，最终选择了 Feedly 这款 APP，UI 清爽，功能简单，完全符合我的需要，而且还支持 OPML 导入。 AirCrayon 是一名 iOS 程序员，所以我订阅的大多都是 iOS 的技术大牛，大牛唐巧一直在维护一个中文博文列表的项目地：https://github.com/tangqiaoboy/iOSBlogCN","text":"这几天一直都在自己看书，可是书上面的东西都比较落后一点，而且没有大牛博文上的东西讲的深入，可是来回跳转各位大牛的博客又非常的麻烦，有一些公众账号虽然也会推荐一些知识内容，可是你应该有过看到多个公众号发一篇博文的经历吧。 这个时候我想起了一个叫做 RSS 订阅的一个功能，可是国产的RSS 订阅器的 UI 是一个很大的槽点，而且功能相对于臃肿，很多功能都用不到，最终选择了 Feedly 这款 APP，UI 清爽，功能简单，完全符合我的需要，而且还支持 OPML 导入。 AirCrayon 是一名 iOS 程序员，所以我订阅的大多都是 iOS 的技术大牛，大牛唐巧一直在维护一个中文博文列表的项目地：https://github.com/tangqiaoboy/iOSBlogCN 在其中为广大 iOS 程序员提供了一个OPML 文件，将其文件下载来进入Feedly 的官网。 没有账户的同学请先注册账户，虽然是英文的但是一般都应该能看的懂，也就不做注册介绍了。 第一步,登录后点击 AddContent 第二步，右侧栏拉倒底部点击 Import OPML 第三步，上传 OPML 文件 这样一来就已经大功告成了，进入 AppStore 或者安卓市场下载一个 Feedly 后登陆自己的账户后便可以使用手机直接查看技术大牛的最新博文了。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"内存管理 Form《Objectivce-C编程全解》&《Objectivce-C编程》","slug":"基于引用计数的内存管理","date":"2016-05-06T04:31:00.000Z","updated":"2017-07-14T08:44:52.000Z","comments":true,"path":"2016/05/06/cjek1zh6s004yx9rdkx9bpedw/","link":"","permalink":"http://www.maksim.website/2016/05/06/cjek1zh6s004yx9rdkx9bpedw/","excerpt":"","text":"Xcode4.2之后可以使用自动引用计数（ARC,Automatic Reference Counting）的管理方式进行说明，ARC 是 Mac OS X 10.7和 iOS5引入的新特性，也是苹果公司推荐使用的内存管理方式。弃用 ARC 后，编译器会在适当的地方自动加入 retaion、release、autorelease 等语句，来简化 Objective-C 编程在内存管理方面的工作量 动态内存管理内存管理的必要性C 语言中需要手动利用 malloc()和 free()对内存进行管理。当程序运行结束时，操作系统会释放掉为其分配的内存。如果是很小、运行时间短的程序，就算是内存没有释放也没有问题，程序结束时操作系统会进行自动释放。而对于长时间运行的程序，则需要程序员释放不再使用的内存，否则程序就会崩溃。 如果程序没能妥善管理内存，运行过程中就不但不能释放不再使用的内存，而且还会不停的分配内容村，这样所占用的内存就会越来越多，程序速度也会越来越慢，最后甚至会出现内存耗尽而崩溃。 就好像滴水一样，程序未能释放已不使用的内存叫做内存泄漏(memory leak)。C 语言中要特别注意内存的动态分配和释放，以防内存泄漏。有效地管理内存，会提高程序的执行效率。 如果访问了以被释放的内存，则会造成数据错误，严重时甚至会导致程序异常终止。在指针指向已被释放或回收的情况下，该指针就称之为悬垂指针（danling pointer）或野指针。继续使用这种指针会造成程序崩溃。 Objective—C 会通过向对象发送 alloc 消息来生成实例对象，alloc 的作用就是分配内存。alloc 方法的返回值是 id 类型，我们之前介绍过 id 其实就是指针类型，而其指向的就是为实例对象分配的内存。生成的实例对象用完之后如果不被释放的话，就会发生内存泄漏。另一方面，如果给已经被释放了的实例对象发送消息，运气好的话会得到警告，告诉你已被释放的对象发送了消息，运气不好的话则会程序错误甚至异常终止，所以 Objective-C 的程序一定要注意内存管理。 在面向对象的语言中，对象是程序的核心。而对象也有生命周期，既有从头到尾一直存在的对象，也有声明起短暂的临时对象。对象之间也可能相互引用，构成结构复杂的数据结构。同面向过程的语言相比，面向对象语言的内存管理更复杂一些。 引用计数器、自动引用计数和自动垃圾回收Coca 环境的 Objective-C 提供了一种动态内存管理方式，称之为引用计数（reference counter）。这种方式会跟踪每一个对象被引用的次数，当对象的引用次数为0的时候，系统会释放掉这个对象所占用的内存。这种内存管理方式也被称之为基于引用计数器的内存管理。 比引用计数内存管理更高级一点的就是自动引用计数（Automatic Reference Counting，简写 ARC）的内存管理。自动引用计数使开发人员不需要考虑何时使用 retain、release、autorelease 来管理内存，它提供了自动评估对象生存期的工恩给你，在编译期间会自动加入何时的内存管理方法，为了同自动引用计数器进行区分，将引用计数内存管理方式称之为手动引用技术内存管理。 除了 ARC 外，Objective-C2.0还引入了另外一种自动内存管理机制——垃圾回收，使用垃圾回收时，就不需要通过引用计数来刮泥创建的对象，系统会自动识别那些对象仍在使用，那些对象可以回收。 程序员可以从手动引用计数管理、ARC 和垃圾回收中选择任意一种内存管理方式来进行开发，不过还是推荐大家使用 ARC 的方式来进行内存管理。 内存管理方式 难易度 Mac iOS 备注 手动引用计数 较难 支持 支持 自动引用计数 容易 支持 支持 现在已经默认使用此方式 垃圾回收 容易 支持 不支持 兼容方法在ARC的程序中,有一些类使用MRC实现的. 如果希望某些指定的类还是使用MRC. 那么这个时候可以在 在targets的build phases选项下Compile Sources下选择要不使用arc编译的文件，双击它，输入 -fno-objc-arc 即可 MRC工程中也可以使用ARC的类。方法如下： 在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可 手动引用计数内存管理本节将说明如何基于引用计数器来管理内存。手中引用计数是内存引用计数的基础，就算程序使用自动引用计数的内存管理，也需要了解手动引用计数的原理。 引用计数Cocoa 环境的 Objective-C 使用了一种叫做引用计数的计数来管理对象所占的内存。每个对象都有一个与之相关的整数——引用计数，当某段代码需要使用一个对象时，就将该对象的引用计数值加1。当这段代码不再使用这个对象的时候，则将对象的引用计数器减1.换而言之，引用计数就是指程序中到底有多少个地方需要访问这个对象。 使用 alloc 和初始化方法创建一个对象的时候，该对象的引用计数初始值为1.假设有一个类 A 在进行某些处理的过程中需要使用到实例 B，为了防止实例化 B被别的对象随意释放，类 A 会实现给实例 B 发送一个 retain 消息。这样，没执行一次 retain，实例 B 的引用计数就会加1。 反之，不需要某个对象时，可以发送 release 消息，使对象的引用计数减1。 实际上，释放内存的并不是 release，而是 dealloc 方法。同 alloc 不同，dealloc 不是类方法而是一个实例方法。没收到一个 release 消息，对象的引用计数器就会减一。当对象的引用计数器达到0的时候，系统就知道这个对象不需要了。这时，Objectivce—C 会自动向对象发送一条 delloc 消息来释放内存。通常允许在程序内直接调用 dealloc。 retain、release和 dealloc 的定义如下所示。retain 的返回值是接收消息的对象。 123-(void)retain;-(oneway void)release;-(void)dealloc; retain 是“保持”的意思，给一个对象发送 retain 消息，就意味着“保持”这个对象。生成对象或通过给对象发送 retain 消息来保持对象这种状态，都可以说是拥有这个对象的所有权（ownership）拥有实例所有权的对象叫做所有者（owner）。 这里需要注意的是，所有权是一个虚拟的概念。既无法通过语法标记，也无法通过这个对象的某个属性表示出来。程序在运行时没发确认某个对象的所有者是谁。所有权仅仅是人们分析阅读程序时，为了说明对象之间的关系而加上去的一个属性。 通过引用计数能够表现出一个对象有几个所有者。只要某个对象的引用计数器大于0就表示这个对象有所有者。引用计数变为0的时候，说明这个对象没有所有者，会被释放。 图1 没有使用引用计数器的例子 让我们通过例子来说明一下基于应用技术的内存管理。首先，假设图（1）中对象 A 的方法把一个新生成的一个实例对象复制给了 A 的实例变量。这个时候新生成的对象的引用计数为1，他的所有者是对象 A，然后，图（2）中把这个对象的指针付给了对象 B 的某个实例变量。因为对象鼻没有发送 retain 消息，所以并不是这个对象的所有者，这个独享的引用计数器还是1.最后图（3）中对象 A 不再使用这个对象的时候发送了一个 release 消息，于是，虽然对象 B 还在使用这个对象，但该对象也被释放了。而此时如果对象 B 给已经释放的消息在发送消息，就会发生运行错误，程序将会异常终止！ 为了防止这样的情况发生，一定要给动态生成的对象发送 retain 消息来增加它的引用计数。只要对对象的引用次数大于零，系统就不会释放它。 测试引用计数让我们通过一个例子来看引用计数到底是如何工作的。 retain 和 release 方法是类 NSObject 的实例方法，方法 retainCount 可以获得对象的引用计数的当前值。retainCount 方法并没有太大的使用价值，一般在调试程序的时候使用。 代码清单的程序显示了对象生成后收到 retain、release 消息时引用计数器的变化。retainCount 的返回值是 NSUInteger 类型，使用 printf 输出返回值的时候需要进行类型转换。 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; id obj = [[NSObject alloc]init]; NSLog(@\"init:%d\",(int)[obj retainCount]); [obj retain]; NSLog(@\"retain:%d\",(int)[obj retainCount]); [obj retain]; NSLog(@\"retain:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); return 0;&#125; 程序的输出如下所示。我们可以看出，对象刚生成的时候引用计数器的值为1，没收到一次 retain 消息，引用计数器的值就会加1；而收到 release 消息，引用计数器的值就减少1 12345672016-05-06 13:19:16.761 引用计数器学习[6574:600738] init:12016-05-06 13:19:16.762 引用计数器学习[6574:600738] retain:22016-05-06 13:19:16.762 引用计数器学习[6574:600738] retain:32016-05-06 13:19:16.762 引用计数器学习[6574:600738] release:22016-05-06 13:19:16.763 引用计数器学习[6574:600738] release:12016-05-06 13:19:16.763 引用计数器学习[6574:600738] release:1Program ended with exit code: 0 释放对象的方法在自定义类的时候，如果累的实例变量是一个对象类型，那么，在销毁类的对象的时候，也要给类的实例变量发送 release 消息。 通过给对象发送 release 消息可以放弃对这个对象的所有权，但如前所述，真正释放对象占用的内存方法是 dealloc方法。 释放一个类的实例对象时，为了彻底释放该实例对象的所有对象的所有权，需要为该类重写 dealloc 方法，在其中释放已经分配的资源，放弃实例变量的所有权。 123456- (void)dealloc&#123; //重写的是 dealloc 方法而不是 release 方法 /* 这里通过 release 方法放弃子类中所有实例变量的所有权 其他用于释放前的善后操作也都卸载这里 */&#125; 在重写 dealloc 犯法中，在释放自身之前，首先做好“善后工作”（释放所有需要释放的资源）。一般情况下，“善后工作”包括通过使用 release 放弃自身的实例变量的所有权。销毁对象的时候，不允许直接使用 dealloc，而是使用 release。release 会让引用计数减少1，只有当引用计数等于0的时候系统才会自动调用 dealloc 真正的销毁这个对象。 子类“善后工作”完成后，调用父类的 dealloc 方法来释放父类中定义的实例变量，这样，内存的释放会从子类一直向上知道 NSObject，最终这个对象就会被彻底释放掉。下面的分数计算器的例子中展示了如何重写 dealloc。 Retain计数原则当使用Objective-C编写程序时，如果没有使用 ARC，就必须遵守特定的内存管理约定，否则可以由 ARC 来自动完成相关任务。 下面为 retain 计数总结若干规则，规则中的“你”代表“当前正在使用的某个类实例”。这是一种很有用的带入形式：请读者将自己想象成是在正在编写的那个对象。例如，“如果你保留了某个 NSString 对象，那么该实例就不会被释放掉”的真是意思是“如果读者正在使用的实例保留了某个 NSString 实例，那么该实例就不会被释放。” 下面列出规则（袁阔闹中的是实现细节） 如果用来创建对象的方法，其方法名是以 alloc 或new 开头的，或者包含 copy，那么你已经得到了该对象的所有权（即可以假设新对象的 retain计数是1，而且该对象不再 NSAutoreleasePool 对象中）。你要负责不再需要使用该对象的时候释放掉他。以下是部分常见的、会“传输”所有权的方法：alloc（后面总会跟一个 init 方法）、copy 和 mutableCopy 通过任何其他途径创建的对象（例如通过便捷方法），你是没有所有权的（即可以假设新对象的 retain 计数是1，而且该对象已经在 NSAutoreleasePool 对象中。如果没有保留该对象，那么当NSAutoreleasePool被“排干”时，这个对象会被释放）。 如果你不拥有某个对象，但是要确保该对象能继续存在，那么可以通过响起发送 retain 消息来获得所有权。 当你拥有某个对象并且不再需要使用该对象的时候，可以向其方发送 release 消息或者 autorelease 消息 只要对象还有只要一个拥有方，该对象就会继续存在下去。 ##参考文献： ① Objectivce-C编程全解（第三版） [日]荻原刚志 著 唐璐 翟俊杰 译 ② Objectivce-C编程 [美]Aaron Hillegass 著 夏伟频 译","categories":[{"name":"ios","slug":"ios","permalink":"http://www.maksim.website/categories/ios/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"http://www.maksim.website/tags/内存管理/"}]},{"title":"读书总结之NSObject","slug":"NSObject","date":"2016-05-06T03:03:16.000Z","updated":"2016-05-06T13:29:50.000Z","comments":true,"path":"2016/05/06/cjek1zh4k001ax9rddq5rkeg9/","link":"","permalink":"http://www.maksim.website/2016/05/06/cjek1zh4k001ax9rddq5rkeg9/","excerpt":"使用 Objectvice-C 进行全面对象编程时，除了需要知道语言本身的语法和面向对象的知识外，还需要了解Objectvice-C的根类 NSObject 的信息。 NSObject根类的作用作为一门动态编程语言，Objectstvice-C有很多动态的特性，因此，Objectvice-C不进需要编译环境，同时还需要一个运行时系统（runtime system）来执行编译好的代码。运行时系统扮演的角色类似于Objectvice-C的操作系统，他负责完成对象生成、释放时的内存管理、发来的消息查找对应的处理方法等工作。 通常情况下，程序无法直接使用运行时系统提供的功能。根类方法提供了运行时系统的基本工恩给你。继承了 NSObject 的所有类都可以自由的使用运行时系统的功能，也就是说，根类就想到于系统的一个借口。 根类通过哪些方式提供了哪些功能对系统有很大的影响。因此，根类不同的系统之间是无法开发出通用的程序的。 Cocoa 是以OPENSTEPDE的核心 API 为基础发展起来的。OPENSTEP的前身为 NeXTstep。在 NeXTstep 时代，根类是累 Object,而在 OPENSTEP 时代，根类则变为了 NSObject，同时类的设计也得到了大幅度的改进。","text":"使用 Objectvice-C 进行全面对象编程时，除了需要知道语言本身的语法和面向对象的知识外，还需要了解Objectvice-C的根类 NSObject 的信息。 NSObject根类的作用作为一门动态编程语言，Objectstvice-C有很多动态的特性，因此，Objectvice-C不进需要编译环境，同时还需要一个运行时系统（runtime system）来执行编译好的代码。运行时系统扮演的角色类似于Objectvice-C的操作系统，他负责完成对象生成、释放时的内存管理、发来的消息查找对应的处理方法等工作。 通常情况下，程序无法直接使用运行时系统提供的功能。根类方法提供了运行时系统的基本工恩给你。继承了 NSObject 的所有类都可以自由的使用运行时系统的功能，也就是说，根类就想到于系统的一个借口。 根类通过哪些方式提供了哪些功能对系统有很大的影响。因此，根类不同的系统之间是无法开发出通用的程序的。 Cocoa 是以OPENSTEPDE的核心 API 为基础发展起来的。OPENSTEP的前身为 NeXTstep。在 NeXTstep 时代，根类是累 Object,而在 OPENSTEP 时代，根类则变为了 NSObject，同时类的设计也得到了大幅度的改进。 NSArray,NSString 等等NS前缀类、函数归属于cocoa Fundation基础类库,其”NS”的由来据说是这样的：乔布斯被苹果开除后,创立了NeSt公司,而cocoa Fundation基础类库就是出自于NeST公司,NeST中的”NS”被作为Fundation中所有成员的前缀 类和实例NSObject 只是一个实例变量，就是 Class 类型的变量 isa。isa 用于表示实例对象属于哪个类对象。因为 isa 决定着实例变量和类的关系，非常重要，所以子类不可以修改 isa 的值。另外，也不能通过直接访问 isa 来查询实例变量到底属于哪个类，而是要通过实例方法 class 来完成查询。 在运行时的代码中我们可以查看到objc_class的定义如下： 1234567/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; 下面对类和实例变量的相关方法进行说明。NSObject 的方法与其说是为自己定义的，不如说是为了其子类和所有实例对象而定义的。 123456789101112131415161718192021222324- (class) class 返回消息接收者所属类的类对象+ (class) class 返回类型对 虽然可以使用类名作为消息的接受者来调用类方法，但类对象是其他消息的参数，或者将类对象赋值给变量的时候，需要通过这个方法来获取类的参数- (id) self 返回接受者自身。是一个无任何实际动作但很有用的方法。-(BOOL) isMemberOfClass: (Class) aClass 判断消息接受者是不是参数 aClass 类的对象 -(BOOL) isKindOfClass: (Class) aClass 判断消息接受者是否是参数 aClass 类或者 aClass 的子类的实例。这个函数和 isMemberOfClass:的区别在于当消息的接受者是 aClass 的子类的实例时也返回 YES。 - (BOOL) isSubclassOfClass: (Class) aClass 判断消息接受者是不是参数 aClass 的子类或自身，如果是则返回 YES - (Class) superclass 返回消息接受者所在类的父类的类对象。 + (Class) superclass 返回消息接收类的父类和类对象 实例对象的生成和释放1234567891011121314151617181920+ (id) alloc 生成消息接收类的实例对象。通常和 init 或者 init 开头的方法连用，生成实例化对象的同事需要对其进行初始化。子类中不润徐重写 alloc 方法+ (void) dealloc 释放实例对象。dealloc 被称之为 release 的结果调用。除了在子类中重写 dealloc 的情况之外，程序不润徐直接调用 dealloc- (oneway void)release 将消息接受者的引用计数减1.引用计数变为0时，dealloc 方法被调用，消息接受者被释放- (id)retain 为消息接收者的引用计数加1，同事返回消息接收者- (id)autorelease 把消息的接受者加入到自动释放池中，同事返回消息接受者 - (NSUinteger) retainCount 返回消息接受者的引用计数，可在调试时使用这个方法。NSUInteger 是无符号证书类型- (void)finalize 垃圾收集器在释放接受者对象之前会执行该 finalize 方法。 上面从 dealloc 到 retainCount 都是手动引用计数管理内存时使用的方法，使用 ARC 时不可用。finalize 仅供垃圾回收有效时使用。 初始化123456789- (id) init init 可对 alloc 生成的实例对象进行初始化。子类中可以重写 init 或者自定义的心的以 init 开头的初始化函数。+ (void)initialize 被用于类的初始化，也就是对类中共同使用的变量进行初始化设定等。这个方法会在类收到第一个消息之前被自动执行，不需手动调用 + (id) new new 是 alloc 和 init 的组合。new 方法返回的实例对象的所有者就是调用 new 方法的对象。但是把 alloc 和 init 组合定义为 new 没有什么优点，并不建议使用。 根据类的实现不同，new 方法并不会每次都返回一个全新的实例对象。有时new 方法会返回对象池中预先生成的对象，也有可能每次都返回同一个对象。 对象的比较12345-(BOOL) isEqual: (id) anObject 消息的接受者如果和参数 anObject 相等则返回 YES - (NSUInteger) hash 把对象放入容器的时候，返回系统内部用的散列表 原则上来讲，具有相同 id 值也就是同一个指针指向的对象被认为是相等的。而子类在这个基础上进行了扩展，把拥有相同值认为是相等。我们可以根据需求对“想通知”激进型定义，但一般都会让具备“相同值”的对象返回相同的散列表，因此就需要对散列表方法进行重新定义。而反之则并不成立，也就是说，散列值相等的两个对象不一定相等。 另外，有的累中还自定义了 compare:或者isEqualTo 之类的方法。至于到底是哪个方法或者自定义类的时候是否需要定义比较的方法，都需要根据目的和类的内容做具体分析。 对象的内容描述12345+ (NSString*) description 返回一个 NSString 类型的字符串，表示消息接受者所属类的内容。通常是这个类的名称。- (NSString*)description 返回一个 NSString 类型的字符串，表示消息接受者的实例对象的内容。通常是类名家 id 值。子类中可以重新定义 description 的返回值。例如 NSString的实例会返回字符串的内容，NSArray 的实例会对数组中的每一个元素调用 description，然后将调用结果用句号进行分割，并且一起返回。 消息发送机制选择器和 SEL 类型至今为止我们把选择器（方法名）和消息关键字放在一起进行说明。程序中的方法名（选择器）在便有被一个内部标识符所代替，这个内部标识符所对应的数据类型就是 SEL 类型。 Objective-C为了能够在程序中操作编译后的选择器，定义了@selector()指令。通过使用@selector()指令，就可以直接饮用编译后的选择器。使用方法如下： 123@selector(mutableCopy)@selector(compare:)@selector(replaceObjectAtIndex:withObject:) 也可以声明 SEL 类型的变量 选择器不同的情况下，编译器转换后生成的 SEL 类型的值也一定不同，相同的算择期对应的 SEL 类型的值一定相同。Objective-C的程序员不需要知道选择器对应的 SEL 类型的值到底是什么，具体的值是和处理器相关的。但是如果 SEL 类型的便利功能无效的话，可设其为 NULL，或者也可以使用(SEL)0这种常见的表达方式 可以使用 SEL 类型的变量来发送消息，为此，NSObject 中准备了如下方法 123456-(id)performSelector: (SEL) aSelector 向消息的接收者发送 aSelector代表的消息，返回这个消息的执行结果 -(id)performSelector: (SEL) aSelector withObject: (id) anObject 与上面的方法一直，不过可以传递参数 例如下面两个消息表达式进行的处理是相同的 12[target description][targ performSelector: @selector(description)]; 下面的例子展示了如何根据条件动态决定执行那个方法 123SEL method = (void1) ? @selector(activate:) : @selector(hide:);id obj = (cond2) ? MyDocument : defaultDocument;[target performSelector:method withObject:obj] 这种调用方式很想 C 语言中函数指针的用法，使用函数指针可以实现和上面的程序同样的功能。 函数指针是函数在内存中的地址。指针对应的函数是在编译的时候决定的，不能够执行指定之外的函数。SEL 类型就相当于方法名，根据消息接受者的不同（上例子中 target 的赋值），来动态执行不同的方法。 通过 SEL 类型来指定要中子星的方法，这就是 Objectivce-C消息发送的方式。也正是通过这种方法才实现了 Objectivce-C的动态性 消息搜索对象收到一个消息后执行哪个方法是动态决定的。 所有的实例变量都存在一个 Class 类型的 isa 变量，它就是类对象。当收到消息后，运行时系统会检查类内是否有和这个消息选择器相同的方法，如果有就执行对应的方法，如果没有就通过类对象中指向父类的指针来查找父类中是否有对应的方法。如果一直找到根类都没有找到对应的方法，就会提示执行时错误。 如果每次收到消息都需要查找对应的方法的话，消息发送过程的开销就会很大，是针对这种情况，运行时内部会缓存一个散列表，表中记录着某个类拥有和什么样的选择器相对应的方法、方法被定义在何处等信息。这样一来，当下次在收到同样的消息时，直接利用上次缓存好的信息即可。 NSObject 中定义了可以动态检查一个对象是否能够响应某个选择器的方法。 12345- (BOOL) respondsToSelector: (SEL) aSelector 查询消息的接收者中是否能够响应 aSelector 的方法，包括从父类继承来的方法，如果存在的话则返回 YES- (BOOL) instancesRespondToSelector: (SEL) aSelector 查询消息的接收者所属的类中是否能够响应 aSelector 的实例方法，如果存在的话则返回 YES 一函数的形式来调用方法类中定义的方法通常是以函数的形式来实现的，但通常在编程的时候并不会直接操作方法所对应的函数。 但如果想尽可能第让程序更快一点，或者需要按照 C 语言的管理传递函数指针的时候，可以直接调用方法对应的函数，以节省发送消息的开销。另外执行时动态加载方法的定义等时，也可以将方法作为函数调用。但是需要注意的是，如果以函数的形式来调用方法的话，将无法利用面向对象的动态绑定等功能。虽然消息发送同函数调用相比确实慢一点，但却有面向对象的动态绑定、多态等优点。同这些优点相比，速度上略微的损失是不值得一提的。而其实消息发送的速度也非常的快。 通过使用下面的方法，可以获得某个对象持有的方法的函数指针，这些方法都被定义在 NSObject 中。 1234- (IMP) methodForSelector: (SEL) aSelector 搜索和执行选择器对应的方法，并返回指向该方法实现的函数指针。实例对象和类对象都可以使用这个方法。对实例对象使用时，会返回实例方法对应的函数，对类对象使用时，会返回类对象对应的函数+ (IMP) instanceMethodForSelector: (SEL)aSelector; 搜索和制定选择器相对应的实例方法，并返回该指向实例方法实现的函数指针 IMP 是“implemention”的缩写，它是一个函数指针，指向了方法实现代码的入口 IMP 的定义为： 12345#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id (*IMP)(id, SEL, ...); #endif 这个被指向的函数包括 id(self 指针)、调用的 SEL（方法名），以及其他参数 例如： 1- (id)setBox:(id)obj1 title:(id)obj2; foo 是这个方法所属类的一个实例变量。获取指向 setBox 的函数指针，并且通过该指针进行函数调用的过程如下： 123IMP funcp;funcp = [foo methodForSelector:@selector[setBox:title]];xyz = (*funcp)(foo,@selector[setBox:title:],param1,param2) 类对象和跟对象因为累对象也是一个对象，所以累对象可以作为根类 NSObject 的某个子类的对象来使用。下面这句话看上去好像比较奇怪，但是实际上他是正确的，会返回 YES 1[NSString class] isKindOfClass:[NSObject class]] 这就说明了相当于类对象的类的对象是存在的。而类对象的类就被叫做元类(metaclass)。实例对象(instance object)所属的类是 class，类对象(class object)所属的类是 metaclass。 Objective-C 中的很多概念都来源于 Smalltalk，元类的概念就是其中之一。但现在的 Objective-C中已经不存在元类的概念了，程序中不能操作元类。用于表示对象的 id 类型和表示类的 Class 类实际上都是指向结构体的指针。被详细定义在/usr/include/objc 下面的 objc.h 头文件中。通过查看 objc.h 中 id和 Class 的定义，就会发现类和元类的关系如图所示。Objective-C2.0更新了基本的数据结构，但是没有改变类和元类的关系。 类 A 是 NSObject 的子类，类 B是 A 的子类。类对象和实例对象都存在一个成员变量 isa，它是一个 objc_class 类型的指针 图中带有 isa 的实现表明了 isa 指向的对象，带有 super_class 的虚线则表明了父类的关系。 类对象中保存的是实例方法，元对象中保存的是累方法。通过这样的定义能够统一实现实例方法和类方法的调用机制。 因为编程时不可以直接操作元类，所以并不需要完全了解图中的细节。大家只需要记住任何一个类对象都是继承了根类的元对象的一个实例即可。也就是说，类对象可以执行根类对象的实例方法。 例如，类对象可以执行 NSObject 的实例方法 performSelector:和 respondsToSelector:。当然提前是没有将这些方法作为类方法再次定义。 下面让我们总结一下。其中（1）和（2）我们已经介绍过了。（3）比较不容易理解， 所有类的实例对象都可以执行根类的实例方法 如果在派生类中重新定义了实例方法，新定义的方法会被执行 所有类的类对象都可以执行根类的类方法 如果在派生类中重新定义了类方法，新定义的方法会被执行 所有类的类对象都可以执行根类的实例方法 即使在派生类中重新定义了实例方法，根类中的方法也会被执行 如果在派生类中将实例方法作为类方法重新定义了的话，新定义的方法会被执行 参考文献① Objectivce-C编程全解（第三版） [日]荻原刚志 著 唐璐 翟俊杰 译","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"UITableView 系统 API实现滑动删除Cell","slug":"delete_cell","date":"2016-04-23T08:05:19.000Z","updated":"2016-07-29T08:24:31.000Z","comments":true,"path":"2016/04/23/cjek1zh5p0033x9rd0kzikmw4/","link":"","permalink":"http://www.maksim.website/2016/04/23/cjek1zh5p0033x9rd0kzikmw4/","excerpt":"","text":"#UITableView 系统 API实现滑动删除Cell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import UIKitclass ViewController: UIViewController &#123; private lazy var tableview:UITableView = &#123; let tb = UITableView(frame: CGRectZero,style: UITableViewStyle.Plain) tb.dataSource = self tb.delegate = self tb.registerClass(UITableViewCell.self, forCellReuseIdentifier: &quot;Cell&quot;) return tb &#125;() private var dataArray = [&quot;lazy&quot;,&quot;make&quot;,&quot;help&quot;,&quot;papa&quot;] override func viewDidLoad() &#123; super.viewDidLoad() view = tableview &#125;&#125;extension ViewController:UITableViewDataSource&#123; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return dataArray.count; &#125; func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableview.dequeueReusableCellWithIdentifier(&quot;Cell&quot;, forIndexPath: indexPath) cell.textLabel?.text = dataArray[indexPath.row] return cell &#125;&#125;extension ViewController:UITableViewDelegate&#123; //1.设置Cell 可编辑 func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool &#123; return true &#125; //2.进入编辑模式，滑动初选删除按钮 func tableView(tableView: UITableView, titleForDeleteConfirmationButtonForRowAtIndexPath indexPath: NSIndexPath) -&gt; String? &#123; return &quot;删除&quot; &#125; //3.响应删除按钮事件 func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) &#123; tableview.setEditing(false, animated: true) print(&quot;删除\\(dataArray[indexPath.row])&quot;) dataArray.removeAtIndex(indexPath.row) tableview.reloadData() &#125;&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"一个新的开始","slug":"一个新的开始","date":"2016-03-27T15:28:11.000Z","updated":"2016-05-06T13:31:46.000Z","comments":true,"path":"2016/03/27/cjek1zh690043x9rd26hvj062/","link":"","permalink":"http://www.maksim.website/2016/03/27/cjek1zh690043x9rd26hvj062/","excerpt":"人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。","text":"人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。 于是在不甘，与短暂的刺激后，我又开始了写作，其实也是想试一试，自己到底能不能够成功，我所谓的成功其实就是写一个完整的故事，记得小时候抓周，我抓的就是个笔，奶奶曾经说我以后是个笔杆子，可惜现在虽然现在也是在写东西，不过写的是代码，而不是小说。 记得那是还在上初中的时候，我接触到了网络文学，我记得我看的第一本网络小说应该是木子心写的《现代修罗》，可惜最后太监了，那个时候我对太监这件事当真是有些厌恶，可是没想到到最后，我也踏入了后宫那洪流之中，成为了诸多太监中的一份子。我朋友曾经对我说过一句话，要是能在我生儿子之前能看到你一本完本的小说就行了。 其实这段时间一直在思考我要不要继续写东西，我能否坚持下去，最终还是决定试一试，思前想后决定写一篇科幻类的小说，希望能够做到不落俗套，写出自己心目中的网络文学。 以后每个月我都会更新一篇关于网络文学的文章，主要是去分析曾经红极一时或者是现在当红的网络小说的写作手法。看一看那些大神是如何进行网络文学创作的，同时也是去提升自己的能力。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/tags/随笔/"}]},{"title":"我的碎片化时间都在做什么?","slug":"mytime","date":"2016-03-26T03:03:16.000Z","updated":"2017-07-17T05:45:46.000Z","comments":true,"path":"2016/03/26/cjek1zh5y003lx9rd0rvriybp/","link":"","permalink":"http://www.maksim.website/2016/03/26/cjek1zh5y003lx9rd0rvriybp/","excerpt":"一直都没太仔细的时间管理,基本上就是想要去做什么就去做,但就算如此有的时候回想一下自己这一天都在做什么了,却发现一天过得有些苍白,可能是精神上还是没有获得太多的满足,日记现在还在坚持写,不过一般都是有什么事情发生了才会去写上那么一笔. 最近一直在想自己的时间去了哪里,现在正在处于学习状态,满脑子都是成片的代码,倒是没有更多的碎片化时间. 那么我平时大部分碎片化时间都在干什么呢.","text":"一直都没太仔细的时间管理,基本上就是想要去做什么就去做,但就算如此有的时候回想一下自己这一天都在做什么了,却发现一天过得有些苍白,可能是精神上还是没有获得太多的满足,日记现在还在坚持写,不过一般都是有什么事情发生了才会去写上那么一笔. 最近一直在想自己的时间去了哪里,现在正在处于学习状态,满脑子都是成片的代码,倒是没有更多的碎片化时间. 那么我平时大部分碎片化时间都在干什么呢. 微信朋友圈 刷微博 QQ空间 网络小说 百度各种稀奇古怪的东西 这么算下来,我的碎片化时间并没有被合理的利用起来,仔细分析一下,以上种种对我来说,除了看网络小说以外,对自己的进步没有任何实质性的帮助,当然,我看网络小说并非是只是为了爽,主要是去分析一本网络小说的具体写作手法,以及伏笔,高潮等如何去写,以提高自己网络小说写作的水平. 那么其他的几项呢,基本上对自己没有任何帮助,除了可以获得短暂的心情愉悦,可是却并有得到任何的营养,精神上只是短暂的得到了满足,但这份满足却在短暂的愉悦过后变得苍白无力,因为自己并没有因此得到知识以及改变. 那么我该如何安排自己的碎片化时间呢? ①时间：物质存在的可用钟表来量度的属性。某一过程的发生、发展、终止，既反映了过程的持续性也反映了顺序性。过程的持续性表现为时间间隔，顺序性表现为日期和时刻。 ②碎片时间：所谓的碎片时间，即指日常工作、学习之余闲散的，零碎的时间，这些时间不是很长，如等车、排队、等人等情况所用的时间，这些时间不适宜做比较有深度的事情，一般用来手机阅读，玩游戏等。来源在线 新华词典 对于碎片化的时间的定义中说道这些时间不是以做比较深度的事情,那么什么叫做比较深度的事情,我对于这句话的理解就是需要耗时非常多的事情,例如看代码,读有深度的技术文章,因为这不是短暂的时间就可以完成的. 但是却可以用这一段时间去读一些比较短效精干的文章,在互联网如此发达的年代,倒是很好可以解决这样的需求,自媒体,微信公众号等都可以进行实现.这时候还真是要感谢网络的快速发展,使得只是的传播变得廉价. 分析了这些之后,简单的做了一些事情 删除低质量的微信公众账号 取消关注了娱乐圈的大V们 关闭了微信朋友圈功能 重新梳理了一遍亚马逊电子书城 删除了手机中并不算火的网络小说 删除了无用的社交软件 并且将我的书单进行了调整,将自己兴趣的书籍进行了筛选最终选出了要读的三本书. 中国通史 塔木德 李鸿章传 经过简单的梳理过后,倒是有了一些明确的目标,也知道接下来要怎么做了.","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/tags/随笔/"}]},{"title":"iOS多线程","slug":"多线程-nsoperation","date":"2016-03-22T08:05:19.000Z","updated":"2017-07-17T05:55:20.000Z","comments":true,"path":"2016/03/22/cjek1zh6o004rx9rdst11kf6z/","link":"","permalink":"http://www.maksim.website/2016/03/22/cjek1zh6o004rx9rdst11kf6z/","excerpt":"","text":"简介多线程是所有程序员都应该知道的一个概念，因为当一个程序开始运行，进程就已经开启了！ 多线程基本概念进程(process)和文件(files)是UNIX/Linux操作系统最基本的抽象。进程是处于执行期的程序和它所包含的资源的综合，也就是说一个进程就是处于执行期的程序。一个线程（thread）就是运行在一个程序上下文中的一个逻辑刘，不难看出，线程是进程中最基本的活动对象。 在软件工程中，上下文是一种属性的有序序列，它们为主流在环境内的对象定义环境，在对象的激活过程中创建上下文，对象呗配置为要求某些自动服务，如同步、事务、实时激活、安全性等等。又比如计算机技术中，对象鱼进程而言，上下文就是进程执行时候的环境，具体来就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。 在传统系统中，一个进程只包含一个线程。但是在现代系统中，润徐一个进程里面可以同时运行多个县城，这类程序被称之为多线程程序。所有的程序都有一个主线程（main thread，在iOS开发中，主线程主要用于UI呈现，要将耗时操作放到其他线程之中，否则UI界面会被卡死），主直选成是进程的控制流或者执行线程在多线程程序中，主线可以创建一个活多个对等线程（peer thread），从这个时间点开始，这些线程就开始兵法执行，主线程和对等线程的区别仅在于主线程总是进程中第一个运行的线程。从某种程度上看，线程可以看做是轻量级的进程（lightweight process）。 每个程序都拥有独立的线程上下文（thread context），线程ID（Thread ID，TID），程序计数器（PC），线程栈（stack），一组寄存器（register）和条件码，其中内核正式通过线程ID（TID）来识别线程，进行线程调度的。 上面的内容是否晦涩难懂，那么我们看一看百度百科是如何解释多线程的： 在百度百科中，多线程是指软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多余一个线程，今儿提高整体处理性能。就这样的一句话就解释了什么是线程和线程的作用，就是为了提高程序的执行效率，能够在同一时间段执行多个任务。 这样一来是否就容易理解了，其实每一个软件都是一个进程，每个进程中包含一个到多个的线程，我们在window有的时候程序卡死，我们使用任务管理器结束程序的时候就是杀死那个进程。进程也可能是整个程序或者是部分程序的动态执行，线程是一组指令的集合，或者是程序的特殊段，它可以在程序里面单独执行，也可以把它理解成为代码运行的上下文，所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。 线程是程序中一个单一的顺序控制流程，在单个程序中同时运行多个线程完成不同的工作，成为多线程。 线程和进程的主要区别在于子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其知心上下文，多线程主要是为了节省CPU时间，发挥利用，根据具体情况而定。线程的运行需要使用计算机的内存资源和CPU。 到了这里你应该已经知道了什么是多线程了，首先让我们来整理一下然后再进行进行学习。 进程:就是指在系统中运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间中 线程:一个进程要执行任务，必须得有线程（每一个进程只要有一条线程），一个进程的所有任务都是放在线程中完成的 线程的串行：一个线程中执行的任务是串行的，如果在一个线程中赤星多个任务，只能一个一个的按照顺序执行 多线程：一个进程中可以开启多条线程，每条线程可以并行（同时），执行不同的任务。 多线程的优缺点多线程的优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 多线程的缺点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 多线程在iOS开发中的应用主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”主线程的主要作用显示、刷新UI界面处理UI事件（比如点击事件、滚动事件、拖拽事件等）主线程的使用注意:别将比较耗时的操作放到主线程中。耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验 PthreadPOSIX线程（POSIX threads）简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一套API，在类Unix系统中，都是用Pthreads作为系统的线程。在这里只讲一下其基本使用，因为在日常的开发之中并不是很常用这种方式进行多线程的开发。 Pthread的基本使用由于Pthreads是使用C语言进行开发的，所以其使用都是C语法。 语法规则1pthread_create(pthread_t *thread,pthread_attr_t * attr,void*(*start_routine)(void*),void*arg); 创建线程thread:返回创建的线程ID attr:线程属性，调度策略、优先级等都在这里设置，如果为NULL则标识默认属性 start_rountine:线程入口函数，可以返回一个void*类型的返回值，该返回值可由pthread_join()捕获arg:传给start_rountine的参数，可以为NULL 设置线程属性线程属性通过attr进行设置设置与查询attr结构为pthread_attr_get()与pthread_attr_set()两个系列函数，也可以在创建时通过pthread_create参数参数，有些必须在线程创建时进行设置比如跳读策略。 调度策略POSIX定义一种优先级调度模型，此模型确定任何两个线程相对于对方的重要程度。当两个线程同时准备就绪的时候，系统就会自动选择具有最高优先级的线程。 SCHED_OTHER：非实时、正常SCHED_RR：实时、轮询法SCHED_FIFO：实时、先入先出，与vxworks的调度机制一致 例程： 123pthread_attr_t attr;pthread_attr_init(&amp;attr);pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);//sched_policy NSThread简介NSThread 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切,通过NSThread这个API我们可以实现简单的多线程编程,但需要管理线程的声明周期、同步、加锁等问题，这样会导致一定的性能开销，当我们进行多线程开发的时候，并不推荐此方法。 NSThread的初始化动态方法1- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 12345678910// 初始化线程NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];// 设置线程的优先级(0.0 - 1.0，1.0最高级)thread.threadPriority = 1;// 开启线程[thread start];参数解析：selector ：线程执行的方法，这个selector最多只能接收一个参数target ：selector消息发送的对象argument : 传给selector的唯一参数，也可以是nil 静态方法1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 12[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];// 调用完毕后，会马上创建并开启新线程 隐式创建线程的方法1[self performSelectorInBackground:@selector(run) withObject:nil]; 获取当前线程1NSThread *current = [NSThread currentThread]; 获取主线程1NSThread *main = [NSThread mainThread]; 暂停当前线程123456// 暂停2s[NSThread sleepForTimeInterval:2];// 或者NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];[NSThread sleepUntilDate:date]; 线程间的通信123456781.在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES];2.在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];3.在当前线程执行操作[self performSelector:@selector(run) withObject:nil]; 优缺点1.优点：NSThread比其他两种多线程方案较轻量级，更直观地控制线程对象2.缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销 NSOperationNSOperation的作用 配合使用NSOperation和NSOperationQueue实现多线程编程 NSOperation和NSOperationQueue实现多线程的具体步骤 先将需要执行的操作封装到一个NSOperation对象中 然后将NSOperation对象添加到NSOperationQueue中 系统会自动的将NSOperationQueue中的NSOperation中取出来 将取出的NSOperation封装的操作放到一条线程中执行 NSOperation的子类NSOperation是一个抽象的类,它并不具备封装操作的能力,当我们进行多线程编程的时候,必须使用它的子类. NSInvocationOperation NSBlockOperation 自定义子类继承NSOperation,实现内部相对应的方法 NSInvocationOperation创建NSInvocationOperation对象 1-(id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg; 调用start方法开启线程 1-(void)start; 一旦执行操作，就会调用target的sel方法默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 NSBlockOperation创建NSBlockOperation对象 1+(id)blockOperationWithBlock:(void (^)(void))block; 通过addExecutionBlock:方法添加更多的操作 1-(void)addExecutionBlock:(void (^)(void))block; 只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 NSOperationQueueNSOperationQueue可以调用start放啊来进行执行任务,但是默认是同步执行的 如果将NSOperationQueue添加到NSOperationQueue操作队列中,系统会自动异步执行. 添加操作: 12-(void)addOperation:(NSOperation *)op;-(void)addOperationWithBlock:(void (^)(void))bloc 最大并发数什么是并发数 同时执行的任务数比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 12-(NSInteger)maxConcurrentOperationCount;-(void)setMaxConcurrentOperationCount:(NSInteger)cnt; 队列的取消,暂停,回复取消队列的所有操作 1-(void)cancelAllOperations; 提示：也可以调用NSOperation的 -(void)cancel方法取消单个操作 暂停和恢复队列 12-(void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列-(BOOL)isSuspended; 操作依赖NSOperation之间可以设置依赖来保证执行顺序比如一定要让操作A执行完后，才能执行操作B，可以这么写 1[operationB addDependency:operationA]; // 操作B依赖于操作A 可以在不同queue的NSOperation之间创建依赖关系 操作监听可以监听一个操作的执行完毕 12-(void (^)(void))completionBlock;-(void)setCompletionBlock:(void (^)(void))block; 自定义NSOperation自定义NSOperation的步骤 重写-(void)main方法，在里面实现想执行的任务 重写-(void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 GCD简介GCD 是 libdispatch 的市场名称，而 libdispatch 作为 Apple 的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点： GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。 GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。 GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力 （未完待续） 参考文献： [1] fireaxe - Pthread编程基础","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"将博客迁移到了github","slug":"wordpress to hexo","date":"2016-03-08T15:00:00.000Z","updated":"2017-07-17T05:42:21.000Z","comments":true,"path":"2016/03/08/cjek1zh64003ux9rdsb8a3qyr/","link":"","permalink":"http://www.maksim.website/2016/03/08/cjek1zh64003ux9rdsb8a3qyr/","excerpt":"","text":"折腾了一天终于将博客迁移到了github上,以前一直用的都是WordPress,这几天看一些大牛的微博发现有很多人用的都是hexo于是在好奇心的驱使下搜了一下,发现很有逼格,身为一个不折腾就会死的人我便开始了迁移之路,这篇博文并不会讲如何迁移,因为今天没有时间了,等过两天进行一下总结,熟悉一下hexo. 在用WordPress的时候,有的博文中有html标签,hexo用的markdown很多标签不兼容,这样就导致了,导入WordPress文章的时候会出现错误,要删除其中的标签,头晕了一个晚上,一激动把一些博文删掉了. 之前的博文有很多人转载的东西,我也全都删除了,就留下了一些比较有用的东西,以后的博文也我要尽量的去试着原创,毕竟那也是一种不错的挑战.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/tags/随笔/"}]},{"title":"移动info.plist后无法运行","slug":"移动info.plist后无法运行","date":"2016-03-04T14:29:03.000Z","updated":"2016-05-08T03:22:43.000Z","comments":true,"path":"2016/03/04/cjek1zh7e005vx9rdaxft6t6w/","link":"","permalink":"http://www.maksim.website/2016/03/04/cjek1zh7e005vx9rdaxft6t6w/","excerpt":"今天做项目的时候,不小心将info.plist移动了,再移动回项目中的时候直接报错,查了一下百度找到了解决办法. 只需要在bulid Phases中的Copy Bundle Resources重新加入info.plist即可","text":"今天做项目的时候,不小心将info.plist移动了,再移动回项目中的时候直接报错,查了一下百度找到了解决办法. 只需要在bulid Phases中的Copy Bundle Resources重新加入info.plist即可","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"统一设置tabBarItem字体样式","slug":"统一设置tabBarItem字体样式","date":"2016-03-04T12:14:36.000Z","updated":"2017-07-17T05:46:12.000Z","comments":true,"path":"2016/03/04/cjek1zh7m0064x9rdp0rxkg79/","link":"","permalink":"http://www.maksim.website/2016/03/04/cjek1zh7m0064x9rdp0rxkg79/","excerpt":"","text":"一般我们在使用tabBar的时候都需要进行自定义,统一设置其字体样式的方法如下. 在iOS开发中有两个方法:load与initialize. load是在类加载的时候会自动调用,iOS工程在运行的时候,会自动将工程内的类加载到内存之中,这个时候就是load执行的时候. initialize是在第一次使用或者调用子类的时候回自动执行,具有初始化类的功能,我们可以通过这两个方式的执行特性来对tabBarItem的样式进行设置. tabBarItem其实是一个模型(Item是苹果对模型的一种命名规范),我们并不能够对模型直接格式操作,但是我们可以对控件的格式进行设置,这样也就是使用到了文本属性(富文本)来进行设置. 代码如下: 12345678910+(void)initialize&#123; //获取所有的tabBarItem 获取所有的外观 UITabBarItem *item = [UITabBarItem appearance]; NSMutableDictionary *att = [[NSMutableDictionary alloc]init]; [att setObject:[UIColor grayColor] forKey:NSForegroundColorAttributeName]; NSMutableDictionary *selectedAtt = [[NSMutableDictionary alloc]init]; [selectedAtt setObject:[UIColor orangeColor] forKey:NSForegroundColorAttributeName]; [item setTitleTextAttributes:att forState:UIControlStateNormal]; [item setTitleTextAttributes:selectedAtt forState:UIControlStateSelected]; &#125; 这样一来我们就完成了样式的设置,appearance在英语中的意思是外观,在iOS中算是一个标记,通过这个标记,我们可以取得UITabBarItem中所有Item的外观.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"使用iOS本地通知","slug":"IOS推送通知","date":"2016-03-03T07:06:05.000Z","updated":"2017-07-17T05:49:19.000Z","comments":true,"path":"2016/03/03/244/","link":"","permalink":"http://www.maksim.website/2016/03/03/244/","excerpt":"","text":"在 iOS 开发中推送通知被分为两种，本地通知与推送通知， 本地通知是应用在后台运行时，把一些消息提示给用户，一个很好的例子就是基于定位的应用，这类应用在后台运行，到他发现到达某个特殊地点是给予用户提醒，本地通知只能使用在 iOS 设备中，他可以立即发出通知也可以在计划时间后发出。 本地通知只是应用所在设备上给用户通知，而推送通知是远程通知，它是由远程服务器推送过来的。无论是哪一种，通知的形式都是一样的。 12345678910111213141516171819202122232425262728//本地推送,主要用于一些常规类的提醒 /** * 1.健康类 定时几点运动 * 2.社交类 几点约会 * 3.游戏类 到时见领取奖励 * 4.新闻类 每日早间提醒阅读 * 5.医药类 你该吃药了,药别停 */ //在iOS8下需要注册一下本地推送 [[UIApplication sharedApplication] registerUserNotificationSettings: [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge|UIUserNotificationTypeAlert|UIUserNotificationTypeSound categories:nil]]; //初始创建本地推送 UILocalNotification *local = [[UILocalNotification alloc]init]; //设置推送时间 local.fireDate = [NSDate dateWithTimeIntervalSinceNow:5]; //设置推送的内容 local.alertBody = @&quot;你该吃药了!&quot;; //设置时区 根据当前手机时区设置的 local.timeZone = [NSTimeZone defaultTimeZone]; //设置重复的间隔 local.repeatInterval = kCFCalendarUnitDay; //设置推送声音(本地需要有相对应的声音,该声音需要少于三十秒) //local.soundName = UILocalNotificationDefaultSoundName; local.soundName = @&quot;音效.caf&quot;; local.userInfo = @&#123;@&quot;name&quot;:@&quot;王花花&quot;&#125;; local.applicationIconBadgeNumber = 9999; //加入到系统级推送 [[UIApplication sharedApplication] scheduleLocalNotification:local]; 清除本地推送 1234567891011//如何取消推送//获取目前已经加入本地消息推送的有几个.NSArray *array = [[UIApplication sharedApplication]scheduledLocalNotifications];//遍历推送内容for (UILocalNotification *notification in array) &#123; NSLog(@&quot;%@&quot;,notification.userInfo); //如果遇到我们想要取消的本地推送 [[UIApplication sharedApplication] cancelLocalNotification:notification];&#125;//如果全部取消//[[UIApplication sharedApplication]cancelAllLocalNotifications];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"iOS推送通知","slug":"检查设备是否支持后台处理","date":"2016-03-03T07:06:05.000Z","updated":"2016-05-08T03:03:35.000Z","comments":true,"path":"2016/03/03/244/","link":"","permalink":"http://www.maksim.website/2016/03/03/244/","excerpt":"","text":"iOS 于2008年问世时，只能有一个第三方应用处于活动状态（位于前台）。这意味着应用需要执行的任务都必须在应用位于前台时完成，佛泽任务将暂停并在应用下次启动时接着执行。iOS4退出后，向第三方应用提供了后台功能。鉴于 iOS 设备的系统资源有限，且节省电量至关重要，对后台处理有些限制，那就是不能干扰前台引用，也不能消耗太多电量。通过妥善的利用后台功能，引用能做很多事情。 iOS 支持两种后台任务处理方式 第一种方式是在后台完成耗时操作。这种方式适合用于完成大量数据下载或更新等任务，他们需要的时间超过了用户与应用交互的时间。 第二种方式是执行 iOS 润徐的后台活动，如播放音乐、蓝牙交互、监视 GPS 数据以及获取位置变化、维持永久网络连接让 VoIP应用能够正常运行。 检查设备是否支持后台处理能够运行 iOS6或者 iOS5的设备都支持在后台执行活动，这在 Apple 文档中称之为多任务，如果应用需要支持 iOS4就需要注意了，因为有些设备不支持多任务。编写使用多任务功能的代码，需要检测设备是否支持多任务。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"iOS多线程.01 简介","slug":"简介","date":"2016-03-01T04:11:20.000Z","updated":"2017-07-17T05:55:56.000Z","comments":true,"path":"2016/03/01/cjek1zh7h0060x9rd5t1ezh32/","link":"","permalink":"http://www.maksim.website/2016/03/01/cjek1zh7h0060x9rd5t1ezh32/","excerpt":"","text":"简介我们为何需要多线程呢？多线程其实是为了实现并发执行，而且线程是并发执行多个代码路径的多种技术之中比较轻量级的一种（对应较重的实现是多进程）。 在单核 CPU 时代，支持多线程的操作系统会通过分配 CPU 计算时间，来实现软件层面的多线程。创建线程，线程间切换都是有成本开销的。但由于多线程可以避免阻塞所造成的 CPU 计算时间浪费，所以多线程所带来的开销成本总体看来是值得的。任务一般都可以被拆分成多个子任务，如果一个子任务发生了阻塞，计算时间就可以分配给其他子任务。这样就提高了 CPU 的利用率。 在多核 CPU 时代，就更好理解了。由于硬件上就支持多线程技术，就可以让多个线程真正同时地运行。如果任务能够被拆分，各个子任务就能并行地在 CPU 上运行，这就能显著加快运行速度。 总结说来，多线程的目的是，通过并发执行提高 CPU 的使用效率，进而提供程序运行效率。 OS X 和 iOS 是多线程操作系统，它们追随 UNIX 系统使用了 POSIX 线程模型。OS X 和 iOS 都提供了一套底层的 C 语言 POSIX 线程 API 来创建和管理线程。但实际应用开发中，除非需要跨平台，我们并不常直接使用 POSIX 线程 API，而是使用系统或语言提供的其他一些更为简单的方案。 多线程基本概念在了解多线程之前，我们应该先搞懂几个概念，首先了解几个基本概念 进程 线程 多线程 主线程 进程进程（process），是计算机中已运行程序的实体。在面向线程设计的系统中，进程是线程的容器。程序本身只是指令、数据以及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，而且每个进程皆可以同步或者异步的方法独立运行。现代计算机系统刻在统一时间内以进程的形式将多个程序加载到存储器中，并且借由时间共享（分时复用），在一个处理器上表选出同时运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上） 线程线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程（软件多线程）多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个执行绪，进而提升整体处理性能。 软件多线程。即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。 主线程在一个 iOS 程序运行后，默认会开启1条线程。称之为主线程或者是 UI 线程。 主线程是进程的控制流或者执行线程在多线程程序中，主线可以创建一个或多个对等线程（peer thread），从这个时间点开始，这些线程就开始兵法执行，主线程和对等线程的区别仅在于主线程总是进程中第一个运行的线程。从某种程度上看，线程可以看做是轻量级的进程（lightweight process）。 每个程序都拥有独立的线程上下文（thread context），线程ID（Thread ID，TID），程序计数器（PC），线程栈（stack），一组寄存器（register）和条件码，其中内核正式通过线程ID（TID）来识别线程，进行线程调度的。 我们要知道，一条线程只能处理一个任务，如果将大规模运算放到主线程之中，就会造成 UI 界面卡顿的现象。 线程进程的主要区别线程和进程的主要区别在于子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其知心上下文，多线程主要是为了节省CPU时间，发挥利用，根据具体情况而定。线程的运行需要使用计算机的内存资源和CPU。​ 多线程的优缺点多线程的优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 多线程的缺点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 参考资料[1] 维基百科 [3] OS X 和 iOS 中的多线程技术 infoq [2] fireaxe - Pthread编程基础","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"Objective-C Block的基本使用","slug":"Block学习","date":"2016-02-17T08:05:19.000Z","updated":"2017-07-17T05:44:15.000Z","comments":true,"path":"2016/02/17/231/","link":"","permalink":"http://www.maksim.website/2016/02/17/231/","excerpt":"","text":"一、Block 的定义定义和使用Block， 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; //（1）定义无参无返回值的Block void (^printBlock)() = ^()&#123; printf(&quot;no number&quot;); &#125;; printBlock(); printBlock(9); int mutiplier = 7; //（3）定义名为myBlock的代码块，返回值类型为int int (^myBlock)(int) = ^(int num)&#123; return num*mutiplier; &#125; //使用定义的myBlock int newMutiplier = myBlock(3); printf(&quot;newMutiplier is %d&quot;,myBlock(3)); &#125; //定义在-viewDidLoad方法外部 //（2）定义一个有参数，没有返回值的Block void (^printNumBlock)(int) = ^(int num)&#123; printf(&quot;int number is %d&quot;,num); &#125;; 定义Block变量，就相当于定义了一个函数。但是区别也很明显，因为函数肯定是在-viewDidLoad方法外面定义，而Block变量定义在了viewDidLoad方法内部。当然，我们也可以把Block定义在-viewDidLoad方法外部，例如上面的代码块printNumBlock的定义，就在-viewDidLoad外面。 再来看看上面代码运行的顺序问题，以第（3）个myBlock距离来说，在定义的地方，并不会执行Block{}内部的代码，而在myBlock(3)调用之后才会执行其中的代码，这跟函数的理解其实差不多，就是只要在调用Block（函数）的时候才会执行Block体内（函数体内）的代码。所以上面的简单代码示例，我可以作出如下的结论， 在类中，定义一个Block变量，就像定义一个函数； Block可以定义在方法内部，也可以定义在方法外部； 只有调用Block时候，才会执行其{}体内的代码； （PS：关于第（2）条，定义在方法外部的Block，其实就是文件级别的全局变量） 那么在类中定义一个Block，特别是在-viewDidLoad方法体内定义一个Block到底有什么意义呢？我表示这时候只把它当做私有函数就可以了。我之前说过，Block其实就相当于代理，那么这时候我该怎样将其与代理类比以了解呢。这时候我可以这样说：本类中的Block就相当于类自己服从某个协议，然后让自己代理自己去做某个事情。很拗口吧？看看下面的代码， 12345678//定义一个协议@protocol ViewControllerDelegate- (void)selfDelegateMethod;@end//本类实现这个协议ViewControllerDelegate@interface ViewController ()@property (nonatomic, assign) id delegate;@end 接着在-viewDidLoad中的代码如下， 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view from its nib. self.delegate = self; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(selfDelegateMethod)] &#123; [self.delegate selfDelegateMethod]; &#125;&#125; #pragma mark - ViewControllerDelegate method//实现协议中的方法- (void)selfDelegateMethod&#123; NSLog(@&quot;自己委托自己实现的方法&quot;);&#125; 看出这种写法的奇葩地方了吗？自己委托自己去实现某个方法，而不是委托别的类去实现某个方法。本类中定义的一个Block其实就是闲的蛋疼，委托自己去字做某件事情，实际的意义不大，所以你很少看见别人的代码直接在类中定义Block然后使用的，Block很多的用处是跨越两个类来使用的，比如作为property属性或者作为方法的参数，这样就能跨越两个类了。 二、__block关键字的使用在Block的{}体内，是不可以对外面的变量进行更改的，比如下面的语句， 123456789- (void)viewDidLoad &#123; //将Block定义在方法内部 int x = 100; void (^sumXAndYBlock)(int) = ^(int y)&#123; x = x+y; printf(&quot;new x value is %d&quot;,x); &#125;; sumXAndYBlock(50);&#125; 这段代码有什么问题呢，Xcode会提示x变量错误信息：Variable is not assigning (missing__block type)，这时候给int x = 100;语句前面加上__block关键字即可，如下， 1__block int x = 100; 这样在Block的{}体内，就可以修改外部变量了。 三、Block作为Property属性实现页面之间传值需求：在ViewController中，点击Button，push到下一个页面NextViewController，在NextViewController的输入框TextField中输入一串字符，返回的时候，在ViewController的Label上面显示文字内容， （1）第一种方法：首先看看通过“协议/代理”是怎么实现两个页面之间传值的吧， 12345678910//NextViewController是push进入的第二个页面//NextViewController.h 文件//定义一个协议，前一个页面ViewController要服从该协议，并且实现协议中的方法@protocol NextViewControllerDelegate - (void)passTextValue:(NSString *)tfText;@end @interface NextViewController : UIViewController @property (nonatomic, assign) id delegate;@end //NextViewController.m 文件//点击Button返回前一个ViewController页面 1234567- (IBAction)popBtnClicked:(id)sender &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(passTextValue:)]) &#123; //self.inputTF是该页面中的TextField输入框 [self.delegate passTextValue:self.inputTF.text]; &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 接下来我们在看看ViewController文件中的内容， 123456789101112131415161718//ViewController.m 文件@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *nextVCInfoLabel;@end//点击Button进入下一个NextViewController页面- (IBAction)btnClicked:(id)sender&#123;NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil];nextVC.delegate = self;//设置代理[self.navigationController pushViewController:nextVC animated:YES];&#125;//实现协议NextViewControllerDelegate中的方法#pragma mark - NextViewControllerDelegate method- (void)passTextValue:(NSString *)tfText&#123;//self.nextVCInfoLabel是显示NextViewController传递过来的字符串Label对象self.nextVCInfoLabel.text = tfText;&#125; 这是通过“协议/代理”来实现的两个页面之间传值的方式。（2）第二种方法：使用Block作为property，实现两个页面之间传值，先看看NextViewController文件中的内容， 1234567891011//NextViewController.h 文件@interface NextViewController : UIViewController @property (nonatomic, copy) void (^NextViewControllerBlock)(NSString *tfText);@end//NextViewContorller.m 文件- (IBAction)popBtnClicked:(id)sender &#123; if (self.NextViewControllerBlock) &#123; self.NextViewControllerBlock(self.inputTF.text); &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 再来看看ViewController文件中的内容， 1234567891011- (IBAction)btnClicked:(id)sender&#123; NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil]; nextVC.NextViewControllerBlock = ^(NSString *tfText)&#123; [self resetLabel:tfText];&#125;; [self.navigationController pushViewController:nextVC animated:YES];&#125;#pragma mark - NextViewControllerBlock method- (void)resetLabel:(NSString *)textStr &#123; self.nextVCInfoLabel.text = textStr;&#125; 好了就这么多代码，可以使用Block来实现两个页面之间传值的目的，实际上就是取代了Delegate的功能。 另外，博客中的代码Sample Code可以再Github下载，如果因为Github被墙了，可以在终端使用git clone + 完整链接，即可克隆项目到本地。 Github中的代码，可以开启两种调试模式，你需要在项目的配置文件BlockSamp-Prefix.pch中注释或者解注释下面的代码. 1#define Debug_BlcokPassValueEnable 即可开启两种调试的方式，如果注释了上面的语句就是使用Delegate进行调试；否则使用Block进行调试。","categories":[{"name":"ios","slug":"ios","permalink":"http://www.maksim.website/categories/ios/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"CGFloat、CGPoint、CGSize和CGRect","slug":" CGFloat、CGPoint、CGSize和CGRect","date":"2016-01-30T16:27:31.000Z","updated":"2017-10-18T12:21:22.000Z","comments":true,"path":"2016/01/31/2/","link":"","permalink":"http://www.maksim.website/2016/01/31/2/","excerpt":"","text":"CGFloat、CGPoint、CGSize和CGRect主要是用来描述UI控件的几何属性的基本类型。 CGFloat: 浮点值的基本类型 CGPoint: 表示一个二维坐标系中的点 CGSize: 表示一个矩形的宽度和高度 CGRect: 表示一个矩形的位置和大小 CGFloatCGFloat是这四种类型中最基本的类型，这是一个浮点型的数据，他就是一个数值，下面三种类型都需要使用该数值来进行赋值，当我们使用CMD键进入CGBase.h文件后，可以清楚的看到关于CGFloat的定义，映入眼帘的是一个别名定义： 1typedef CGFLOAT_TYPE CGFloat; 当我们CMD点击CGFLOAT_TYPE的时候，我们可以跳转到宏定义的代码区域，其实就在其上面 1234567891011#if defined(__LP64__) &amp;amp;&amp;amp; __LP64__# define CGFLOAT_TYPE double# define CGFLOAT_IS_DOUBLE 1# define CGFLOAT_MIN DBL_MIN# define CGFLOAT_MAX DBL_MAX#else# define CGFLOAT_TYPE float# define CGFLOAT_IS_DOUBLE 0# define CGFLOAT_MIN FLT_MIN# define CGFLOAT_MAX FLT_MAX#endif 我们可以清晰的看到这就是一段宏定义，#if defined(LP64) &amp;&amp; LP64这一段代码主要使用来判断操作系统是64位还是32位，如果是64位那么CGFloat就是double类型，如果不是那边是32位操作系统，则会被系统定义为float类型,接下来的三种类型都是基于CGFloat的结构体。 CGPointCGPoint用于表示二维坐标系中的某一个点，在IOS中以左上角（0，0）为起始坐标。CMD进入CGGeometry.h中便可以直接查看其类型的定义如下（CGSize、CGRect都在此文件中）： 12345struct CGPoint &#123; CGFloat x; CGFloat y;&#125;;typedef struct CGPoint CGPoint; CGSizeCGSize主要用于描述UI控件的宽与高 12345struct CGSize &#123; CGFloat width; CGFloat height;&#125;;typedef struct CGSize CGSize; CGRectCGRect同样也是一个结构体，通过上面的了解，我们知道了原来CGRect是由CGSize和CGPoint组成，这样一来便可以确定一个UI空间的大小与位置。 12345struct CGRect &#123; CGPoint origin; CGSize size;&#125;;typedef struct CGRect CGRect;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"懒加载与模型转换","slug":"懒加载与模型转换","date":"2016-01-30T15:48:32.000Z","updated":"2016-03-09T01:06:54.000Z","comments":true,"path":"2016/01/30/219/","link":"","permalink":"http://www.maksim.website/2016/01/30/219/","excerpt":"","text":"所谓的懒加载其实就是重写getter方法，以实现实例化类的同时自动加载数据，简化代码的一个作用,代码如下 12345678//这是一个实例-(NSArray*)question&#123;if (!_question) &#123;//判断是否为空_question = [GZModelName questionList];&#125;return _question;&#125; 接下来便是模型转化,因为使用点语法写起来的方法也非常简单，只需要重新定义构造方法即可,其中用到的plist文件如下图： .h文件 123456789@interface GZQuestion : NSObject@property (nonatomic,copy) NSString *answer;@property (nonatomic,copy) NSString *icon;@property (nonatomic,copy) NSString *title;@property (nonatomic,strong) NSArray *options;-(instancetype)initWithDic:(NSDictionary *)dic;+(instancetype)questionWithDic:(NSDictionary *)dic;+(NSArray*)questionList;@end .m文件 12345678910111213141516171819202122-(instancetype)initWithDic:(NSDictionary *)dic&#123;if (self = [super init]) &#123;//KVC 直接从字典中读取对应的值，需要注意的是，定义的属性名称，要与字典的key值相对应，否则会崩溃[self setValuesForKeysWithDictionary:dic];&#125;return self;&#125;+(instancetype)questionWithDic:(NSDictionary *)dic&#123;return [[self alloc]initWithDic:dic];&#125;+(NSArray *)questionList&#123;//加载plistNSString *path = [[NSBundle mainBundle] pathForResource:@&quot;questions&quot; ofType:@&quot;plist&quot;];NSArray *dicArray = [NSArray arrayWithContentsOfFile:path];//字典转模型NSMutableArray *tempArray = [NSMutableArray array];for (NSDictionary *dic in dicArray) &#123;GZQuestion *question = [GZQuestion questionWithDic:dic];[tempArray addObject:question];&#125;return tempArray;&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"Objective-C 简单的数组排序","slug":"OC简单数组排序","date":"2016-01-05T07:53:07.000Z","updated":"2017-08-13T07:08:54.000Z","comments":true,"path":"2016/01/05/3/","link":"","permalink":"http://www.maksim.website/2016/01/05/3/","excerpt":"","text":"12345678910NSMutableArray *array = [NSMutableArray arrayWithObjects:@\"8123\",@\"456\",@\"378\", nil];NSComparator cmp = ^(id obj,id obj1)&#123; return [obj compare:obj1];&#125;;[array sortUsingComparator:cmp];NSLog(@\"%@\",array);&lt;/pre&gt;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"iOS多线程","slug":"iOS 多线程","date":"2015-12-10T08:04:12.000Z","updated":"2018-02-27T14:23:15.961Z","comments":true,"path":"2015/12/10/1/","link":"","permalink":"http://www.maksim.website/2015/12/10/1/","excerpt":"","text":"NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在制定的线程中、或者立即、延迟执行某个方法调用个。这个方法给用户实现多线程编程最简单的方法。 在当前线程中执行方法： 123- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay: (NSTimeInterval)delay inModes:(NSArray *)modes 在指定线程中执行方法： 12345- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array 在主线程中执行方法： 12345- (void)performSelectorOnMainThread: (SEL)selector withObject:(id)argument waitUntilDone:(BOOL)wait- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array 在后台线程中执行方法： 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg 这一系列方法简单易用，但只提供了有限的几个选择：指定执行的方法（但传入方法的参数数量有限制）；指定是在当前线程，还是在主线程，还是在后台线程执行；指定是否需要阻塞当前线程等待结果。 例如，以下代码使得方法 foo: 在一个新的后台线程执行，并传入了 object 参数： 12SEL selector ＝ @selector(foo:);[self performSelectorInBackground:selector withObject:object]; 以下代码使得 updateUI 方法在主线程内得到执行，并且当前线程会被阻塞，直到主线程执行完该函数： 1[self performSelectorOnMainThread:@selector(updateUI) withObject:nil waitUntilDone:YES];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"Objc,多线程","slug":"Objc-多线程","permalink":"http://www.maksim.website/tags/Objc-多线程/"}]},{"title":"域名即将到期了，也不打算续费了。","slug":"吐槽","date":"2015-08-27T17:03:16.000Z","updated":"2016-03-09T01:04:50.000Z","comments":true,"path":"2015/08/28/108/","link":"","permalink":"http://www.maksim.website/2015/08/28/108/","excerpt":"","text":"额，以前一直没有注意，就这样的一个pw结尾的域名竟然都会被劫持，我也真是醉了。 以前DNSPOD提示我有异常登陆，我也没在意，结果今天site了一下域名，结果尴尬的发现被泛解析了，我也真是醉了，全都是博彩网站。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/tags/随笔/"}]},{"title":"DATA URI image封装类","slug":"data-uri-image","date":"2015-08-17T12:12:44.000Z","updated":"2017-03-12T05:41:51.000Z","comments":true,"path":"2015/08/17/94/","link":"","permalink":"http://www.maksim.website/2015/08/17/94/","excerpt":"","text":"Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。 1234567891011121314151617181920class DataBase64&#123; public $file = &apos;&apos;; public function __construct($file)&#123; $this-&gt;file = $file; &#125; public function getBase64()&#123; $type = getimagesize($this-&gt;file); $fp = fopen($this-&gt;file, &apos;r&apos;) or die(&quot;Can&apos;t open file&quot;); $file_content= chunk_split(base64_encode(fread($fp, filesize($this-&gt;file)))) ; switch($type[2])&#123;//判读图片类型 case 1:$img_type=&quot;gif&quot;;break; case 2:$img_type=&quot;jpg&quot;;break; case 3:$img_type=&quot;png&quot;;break; &#125; return $img=&apos;data:image/&apos;.$img_type.&apos;;base64,&apos;.$file_content; &#125; &#125; $data = new DataBase64(&apos;image/1.jpg&apos;); $img = $data-&gt;getBase64();","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/tags/PHP/"}]},{"title":"目录常量：PATH_SEPARATOR和DIRECTORY_SEPARATOR","slug":"PATH_SEPARATOR-and-DIRECTORY_SEPARATOR","date":"2015-07-30T00:22:04.000Z","updated":"2017-07-17T05:47:43.000Z","comments":true,"path":"2015/07/30/46/","link":"","permalink":"http://www.maksim.website/2015/07/30/46/","excerpt":"","text":"DIRECTORY_SEPARATOR（string） 目录分隔符，这是PHP内置的一个常量，代表着”/“或“” 因为系统原因，目录的分隔符被分为两种，在windows中目录的分割符号可以使用‘/’或者‘’，但是在linux中目录分隔符只能使用’/‘; PATH_SEPARATOR 路径分隔符，同样是PHP内置的一个常量，在windows系统中，如果使用include包含多个路径可以使用分号（;）来进行分割，可是在linux系统中却要使用冒号（：）。 这两个常量主要就是用来解决linux与windows的兼容问题，避免因为系统差异出现的错误，可以增强移植性。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"deepin下安装 php的扩展","slug":"deepin-install-PHP","date":"2015-05-26T01:56:08.000Z","updated":"2016-03-09T01:05:44.000Z","comments":true,"path":"2015/05/26/36/","link":"","permalink":"http://www.maksim.website/2015/05/26/36/","excerpt":"","text":"一直没用过linux开发PHP，昨天试了一下，却发现deepin下安装的php默认是不开其扩展的，可是PHP.INI中却没有开启扩展的选项，无奈之下百度了一番，却发现文章很少，但是却找到了ubuntu的命令，型号deepin的命令跟ubuntu一样，到是解决了PHP扩展的一些问题，原来只需要将所需要的扩展下载下来，重启服务器便可。 代码如下： 123sudo apt-get install php5-你所需要的扩展。sudo service apache2 restart 这样用来扩展就可以使用了。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/tags/PHP/"}]},{"title":"Smarty3封装类","slug":"Smarty封装","date":"2015-05-21T14:10:59.000Z","updated":"2017-07-17T05:44:54.000Z","comments":true,"path":"2015/05/21/200/","link":"","permalink":"http://www.maksim.website/2015/05/21/200/","excerpt":"","text":"12345678910111213141516171819// load Smarty library require('Smarty.class.php'); // The setup.php file is a good place to load // required application library files, and you // can do that right here. An example: require('guestbook/guestbook.lib.php'); class Smarty_GuestBook extends Smarty &#123; function __construct() &#123; // Class Constructor. // These automatically get set with each new instance. parent::__construct(); $this-&gt;setTemplateDir('/web/www.example.com/guestbook/templates/'); $this-&gt;setCompileDir('/web/www.example.com/guestbook/templates_c/'); $this-&gt;setConfigDir('/web/www.example.com/guestbook/configs/'); $this-&gt;setCacheDir('/web/www.example.com/guestbook/cache/'); $this-&gt;caching = Smarty::CACHING_LIFETIME_CURRENT; $this-&gt;assign('app_name', 'Guest Book'); &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/tags/PHP/"}]},{"title":"PHP框架编写（二）单入口路由","slug":"PHP框架编写（二）单入口路由","date":"2015-04-30T08:05:19.000Z","updated":"2017-07-17T05:47:10.000Z","comments":true,"path":"2015/04/30/cjek1zh580028x9rdc3pqq75b/","link":"","permalink":"http://www.maksim.website/2015/04/30/cjek1zh580028x9rdc3pqq75b/","excerpt":"","text":"PHP框架编写（二）单入口路由基本思路是浏览器端通过URL字符串提供控制器类的名字和方法的名字，PHP据此找到对应的类和方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/******************************************************* * * URL 路由原理展示代码 * * 浏览器访问地址: http://server/index.php?C=Controler1&amp;M=Method1 * 根据C找到控制器类，再根据M找到方法，然后执行这个方法 * * ****************************************************/ $C = isset($_GET['C']) ? $_GET['C']: null; $M = isset($_GET['M']) ? $_GET['M']: null; if($C != NULL &amp;&amp; $M != NULL &amp;&amp; class_exists($C) &amp;&amp; method_exists($C, $M)) &#123; $cObj = new $C(); $cObj-&gt;$M(); &#125;else&#123; echo '找不到控制器或方法'; exit; &#125; // 控制器1 class Controler1 &#123; public function Method1() &#123; echo 'Controler1, Method1'; &#125; public function Method2() &#123; echo 'Controler1, Method2'; &#125; &#125; // 控制器2 class Controler2 &#123; public function Method1() &#123; echo 'Controler2, Method1'; &#125; public function Method2() &#123; echo 'Controler2, Method2'; &#125; &#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"http://www.maksim.website/tags/php/"}]},{"title":"PHP框架编写（一）：框架运行流程","slug":"PHP框架开发(一)MVC","date":"2015-04-29T14:02:49.000Z","updated":"2016-03-09T01:05:50.000Z","comments":true,"path":"2015/04/29/6/","link":"","permalink":"http://www.maksim.website/2015/04/29/6/","excerpt":"","text":"首先欢迎各位进入我的博客，我感觉非常荣幸，我并不是什么高手，现在的我不过是个在校的大学生，写这篇系列的博文只不过是为了加深自己对PHP的理解，以及对之前的学习做一个总结，同时也希望各位能够给我提一些意见。 PHP框架总给人以高大上的感觉，很多人学框架都学的头晕脑胀，百思不得其解，看完这篇博文后应该可以让还处于迷茫中的学习者找到一个入门的道路。 PHP框架到底是什么，框架不过是其他程序员提供的一个快速开发的一个代码而已，他帮助PHP开发者能够快速的开发，免去一些代码而已，PHP框架目前的核心就是MVC和数据库操作，更加大白话一点其实就是编程中最基础的增删改查，不过就是将他变的更加漂亮而已。 那么什么是MVC呢，M模型,V显示,C控制器。 这基本上是所有教程和书中都会提及的概念，也就不再多进行赘述模糊不清的概念了。 M是啥，字面上理解太费劲了，其实M模型我感觉表面上就是对数据库的操作，以及业务逻辑的梳理，这便是M模型，主要进行逻辑分析，将分析的结果传递给C也就是控制器，M就是一个深藏功与名的人，他默默就默默地站在幕后，干着最累的工作。 V就是显示，也就是其中最好面子的人，他们两个人忙活半天，其实都是在给我忙活，所有东西都处理完了，拿到他这里来显示。 C控制器，这个字面上就好理解了，那就是起到控制的作用，他控制着全局，属于M和C的一个中间层。（如果说错了，还请高手指正） 现在市面上的PHP框架基本上都是单一入口的文件。下面就是一个PHP框架的运行的简单流程图。 对PHP框架有了一定的了解之后，我们下一篇就开始讲PHP框架的目录结构了。 仅以此文先给刚刚入门的菜鸟，和正在努力奋斗的程序员们，祝各位早日成为攻城狮！出任CTO，赢取白富美，走向人生巅峰。 （如有转载，请注明出处，小弟感激不尽。）","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/tags/PHP/"}]}]}