{"meta":{"title":"Maksim's Website","subtitle":null,"description":"Maksim's Website，分享成长的点点滴滴，关注PHP、JavaScript、Linux、C/C++、Go、SQL、MySQL、Redis、iOS、安卓开发，努力做一个值得收藏的博客。","author":"Maksim","url":"http://www.maksim.website"},"pages":[{"title":"","date":"2018-04-10T11:30:05.996Z","updated":"2018-04-10T11:30:05.996Z","comments":true,"path":"404.html","permalink":"http://www.maksim.website/404.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2018-04-10T11:50:51.594Z","comments":false,"path":"tags/index.html","permalink":"http://www.maksim.website/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-04-10T11:49:17.000Z","updated":"2018-04-10T11:49:17.535Z","comments":true,"path":"tags/index-1.html","permalink":"http://www.maksim.website/tags/index-1.html","excerpt":"","text":""},{"title":"Search","date":"2018-03-09T13:45:59.000Z","updated":"2018-03-09T13:45:59.772Z","comments":true,"path":"Search/index.html","permalink":"http://www.maksim.website/Search/index.html","excerpt":"","text":""},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2018-04-10T11:51:43.093Z","comments":true,"path":"categories/index.html","permalink":"http://www.maksim.website/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-08-04T02:46:46.834Z","updated":"2018-08-04T02:46:46.826Z","comments":true,"path":"about/index.html","permalink":"http://www.maksim.website/about/index.html","excerpt":"","text":"知识与勇气两者是不朽的，故也能成你于不朽。 ——《智慧书》"}],"posts":[{"title":"如何分析学习 PHP 开源项目","slug":"2018-08-19 如何分析学习 PHP 开源项目","date":"2018-08-18T16:00:00.000Z","updated":"2018-09-08T04:58:32.057Z","comments":true,"path":"2018/08/19/2/","link":"","permalink":"http://www.maksim.website/2018/08/19/2/","excerpt":"","text":"在我们开发项目的过程中，不可避免的会使用一些开软程序，因为使用开源程序可以缩短我们的开发周期，降低研发成本。 但是在使用过程中，难免会碰到各种坑，这个时候，就要求程序员拥有分析开源项目的能力，因为并非是所有开源项目都会拥有一个稳定的维护团队和健全的文档（毕竟开源项目很少有盈利的）。 在进行 PHP 研发过程中，我们可以使用以下5中方式来进行代码分析： 看文档 Xdebug做调试 自带函数（debug_backtrace, debug_print_backtrace, var_export, var_dump, get_inclued_files） SocketLog（不能var_dump的地方ajax、api，var_dump了也看不见的地方，cron 脚本，队列） 思维整理 （UML、思维导图） 为什么要把看文档排在第一位？ 当我们第一次拿到开源程序的代码时，很多人会第一反应去看它的源代码，但是如果说我们要了解它的编程思想，就看编程思想而言是看文档，还是看代码要容易呢？ 如果在不了解开源代码的功能就去了解代码的话，其实很难能够弄懂他的编程思想。 有时候开源程序没有提供文档，我们可以使用 PHPDocumentor 将注释提取成文档。 PHPDocumentor: http://www.phpdoc.org/ 使用 Xdebug 调试代码 我们可以使用 Xdebug 联合 IDE 通过断点调试放慢代码执行流程，当程序执行到用户指定的断点后，可以到该位置停顿，然后输出在该变量中的值，可以一步一步的分析代码，如果碰到难懂的代码就可以通过这种形式来进行调试代码。 Xdebug: https://xdebug.org PHP自带函数 打出调用栈： 12debug_backtrace();debug_print_backtrace(); 如果我们自己去看执行流程，就要跟着函数一步一步的走，可是如果使用调用栈，就可以清晰明了的看清。 1234567891011&lt;?phpnamespace app\\index\\controller;class Index&#123; public function index() &#123; dump(debug_backtrace());exit; &#125;&#125; 我们可以通过这两个函数查看 ThinkPHP 是如何调用控制器的,在这里，我使用的 ThinkPHP5.0，在这里我们需要从下往上看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389array(7) &#123; [0] =&gt; array(5) &#123; [\"function\"] =&gt; string(5) \"index\" [\"class\"] =&gt; string(26) \"app\\index\\controller\\Index\" [\"object\"] =&gt; object(app\\index\\controller\\Index)#3 (0) &#123; &#125; [\"type\"] =&gt; string(2) \"-&gt;\" [\"args\"] =&gt; array(0) &#123; &#125; &#125; [1] =&gt; array(7) &#123; [\"file\"] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/App.php\" [\"line\"] =&gt; int(343) [\"function\"] =&gt; string(10) \"invokeArgs\" [\"class\"] =&gt; string(16) \"ReflectionMethod\" [\"object\"] =&gt; object(ReflectionMethod)#4 (2) &#123; [\"name\"] =&gt; string(5) \"index\" [\"class\"] =&gt; string(26) \"app\\index\\controller\\Index\" &#125; [\"type\"] =&gt; string(2) \"-&gt;\" [\"args\"] =&gt; array(2) &#123; [0] =&gt; object(app\\index\\controller\\Index)#3 (0) &#123; &#125; [1] =&gt; array(0) &#123; &#125; &#125; &#125; [2] =&gt; array(6) &#123; [\"file\"] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/App.php\" [\"line\"] =&gt; int(606) [\"function\"] =&gt; string(12) \"invokeMethod\" [\"class\"] =&gt; string(9) \"think\\App\" [\"type\"] =&gt; string(2) \"::\" [\"args\"] =&gt; array(2) &#123; [0] =&gt; array(2) &#123; [0] =&gt; object(app\\index\\controller\\Index)#3 (0) &#123; &#125; [1] =&gt; string(5) \"index\" &#125; [1] =&gt; array(0) &#123; &#125; &#125; &#125; [3] =&gt; array(6) &#123; [\"file\"] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/App.php\" [\"line\"] =&gt; int(456) [\"function\"] =&gt; string(6) \"module\" [\"class\"] =&gt; string(9) \"think\\App\" [\"type\"] =&gt; string(2) \"::\" [\"args\"] =&gt; array(3) &#123; [0] =&gt; array(3) &#123; [0] =&gt; string(0) \"\" [1] =&gt; NULL [2] =&gt; NULL &#125; [1] =&gt; array(66) &#123; [\"app_host\"] =&gt; string(0) \"\" [\"app_debug\"] =&gt; bool(false) [\"app_trace\"] =&gt; bool(false) [\"app_status\"] =&gt; string(0) \"\" [\"app_multi_module\"] =&gt; bool(true) [\"auto_bind_module\"] =&gt; bool(false) [\"root_namespace\"] =&gt; array(0) &#123; &#125; [\"extra_file_list\"] =&gt; array(1) &#123; [0] =&gt; string(59) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/helper.php\" &#125; [\"default_return_type\"] =&gt; string(4) \"html\" [\"default_ajax_return\"] =&gt; string(4) \"json\" [\"default_jsonp_handler\"] =&gt; string(11) \"jsonpReturn\" [\"var_jsonp_handler\"] =&gt; string(8) \"callback\" [\"default_timezone\"] =&gt; string(3) \"PRC\" [\"lang_switch_on\"] =&gt; bool(false) [\"default_filter\"] =&gt; string(0) \"\" [\"default_lang\"] =&gt; string(5) \"zh-cn\" [\"class_suffix\"] =&gt; bool(false) [\"controller_suffix\"] =&gt; bool(false) [\"default_module\"] =&gt; string(5) \"index\" [\"deny_module_list\"] =&gt; array(1) &#123; [0] =&gt; string(6) \"common\" &#125; [\"default_controller\"] =&gt; string(5) \"Index\" [\"default_action\"] =&gt; string(5) \"index\" [\"default_validate\"] =&gt; string(0) \"\" [\"empty_controller\"] =&gt; string(5) \"Error\" [\"use_action_prefix\"] =&gt; bool(false) [\"action_suffix\"] =&gt; string(0) \"\" [\"controller_auto_search\"] =&gt; bool(false) [\"var_pathinfo\"] =&gt; string(1) \"s\" [\"pathinfo_fetch\"] =&gt; array(3) &#123; [0] =&gt; string(14) \"ORIG_PATH_INFO\" [1] =&gt; string(18) \"REDIRECT_PATH_INFO\" [2] =&gt; string(12) \"REDIRECT_URL\" &#125; [\"pathinfo_depr\"] =&gt; string(1) \"/\" [\"https_agent_name\"] =&gt; string(0) \"\" [\"url_html_suffix\"] =&gt; string(4) \"html\" [\"url_common_param\"] =&gt; bool(false) [\"url_param_type\"] =&gt; int(0) [\"url_route_on\"] =&gt; bool(true) [\"route_config_file\"] =&gt; array(1) &#123; [0] =&gt; string(5) \"route\" &#125; [\"route_complete_match\"] =&gt; bool(false) [\"url_route_must\"] =&gt; bool(false) [\"url_domain_deploy\"] =&gt; bool(false) [\"url_domain_root\"] =&gt; string(0) \"\" [\"url_convert\"] =&gt; bool(true) [\"url_controller_layer\"] =&gt; string(10) \"controller\" [\"var_method\"] =&gt; string(7) \"_method\" [\"var_ajax\"] =&gt; string(5) \"_ajax\" [\"var_pjax\"] =&gt; string(5) \"_pjax\" [\"request_cache\"] =&gt; bool(false) [\"request_cache_expire\"] =&gt; NULL [\"request_cache_except\"] =&gt; array(0) &#123; &#125; [\"template\"] =&gt; array(8) &#123; [\"type\"] =&gt; string(5) \"Think\" [\"view_path\"] =&gt; string(0) \"\" [\"view_suffix\"] =&gt; string(4) \"html\" [\"view_depr\"] =&gt; string(1) \"/\" [\"tpl_begin\"] =&gt; string(1) \"&#123;\" [\"tpl_end\"] =&gt; string(1) \"&#125;\" [\"taglib_begin\"] =&gt; string(1) \"&#123;\" [\"taglib_end\"] =&gt; string(1) \"&#125;\" &#125; [\"view_replace_str\"] =&gt; array(0) &#123; &#125; [\"dispatch_success_tmpl\"] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/tpl/dispatch_jump.tpl\" [\"dispatch_error_tmpl\"] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/tpl/dispatch_jump.tpl\" [\"exception_tmpl\"] =&gt; string(72) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/tpl/think_exception.tpl\" [\"error_message\"] =&gt; string(33) \"页面错误！请稍后再试～\" [\"show_error_msg\"] =&gt; bool(false) [\"exception_handle\"] =&gt; string(0) \"\" [\"record_trace\"] =&gt; bool(false) [\"log\"] =&gt; array(3) &#123; [\"type\"] =&gt; string(4) \"File\" [\"path\"] =&gt; string(52) \"/Users/maksim/Downloads/thinkphp_5.0.20/runtime/log/\" [\"level\"] =&gt; array(0) &#123; &#125; &#125; [\"trace\"] =&gt; array(1) &#123; [\"type\"] =&gt; string(4) \"Html\" &#125; [\"cache\"] =&gt; array(4) &#123; [\"type\"] =&gt; string(4) \"File\" [\"path\"] =&gt; string(54) \"/Users/maksim/Downloads/thinkphp_5.0.20/runtime/cache/\" [\"prefix\"] =&gt; string(0) \"\" [\"expire\"] =&gt; int(0) &#125; [\"session\"] =&gt; array(5) &#123; [\"id\"] =&gt; string(0) \"\" [\"var_session_id\"] =&gt; string(0) \"\" [\"prefix\"] =&gt; string(5) \"think\" [\"type\"] =&gt; string(0) \"\" [\"auto_start\"] =&gt; bool(true) &#125; [\"cookie\"] =&gt; array(7) &#123; [\"prefix\"] =&gt; string(0) \"\" [\"expire\"] =&gt; int(0) [\"path\"] =&gt; string(1) \"/\" [\"domain\"] =&gt; string(0) \"\" [\"secure\"] =&gt; bool(false) [\"httponly\"] =&gt; string(0) \"\" [\"setcookie\"] =&gt; bool(true) &#125; [\"database\"] =&gt; array(20) &#123; [\"type\"] =&gt; string(5) \"mysql\" [\"dsn\"] =&gt; string(0) \"\" [\"hostname\"] =&gt; string(9) \"127.0.0.1\" [\"database\"] =&gt; string(0) \"\" [\"username\"] =&gt; string(4) \"root\" [\"password\"] =&gt; string(0) \"\" [\"hostport\"] =&gt; string(0) \"\" [\"params\"] =&gt; array(0) &#123; &#125; [\"charset\"] =&gt; string(4) \"utf8\" [\"prefix\"] =&gt; string(0) \"\" [\"debug\"] =&gt; bool(true) [\"deploy\"] =&gt; int(0) [\"rw_separate\"] =&gt; bool(false) [\"master_num\"] =&gt; int(1) [\"slave_no\"] =&gt; string(0) \"\" [\"fields_strict\"] =&gt; bool(true) [\"resultset_type\"] =&gt; string(5) \"array\" [\"auto_timestamp\"] =&gt; bool(false) [\"datetime_format\"] =&gt; string(11) \"Y-m-d H:i:s\" [\"sql_explain\"] =&gt; bool(false) &#125; [\"paginate\"] =&gt; array(3) &#123; [\"type\"] =&gt; string(9) \"bootstrap\" [\"var_page\"] =&gt; string(4) \"page\" [\"list_rows\"] =&gt; int(15) &#125; [\"console\"] =&gt; array(3) &#123; [\"name\"] =&gt; string(13) \"Think Console\" [\"version\"] =&gt; string(3) \"0.1\" [\"user\"] =&gt; NULL &#125; [\"queue\"] =&gt; array(1) &#123; [\"connector\"] =&gt; string(4) \"Sync\" &#125; &#125; [2] =&gt; bool(true) &#125; &#125; [4] =&gt; array(6) &#123; [\"file\"] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/App.php\" [\"line\"] =&gt; int(139) [\"function\"] =&gt; string(4) \"exec\" [\"class\"] =&gt; string(9) \"think\\App\" [\"type\"] =&gt; string(2) \"::\" [\"args\"] =&gt; array(2) &#123; [0] =&gt; array(2) &#123; [\"type\"] =&gt; string(6) \"module\" [\"module\"] =&gt; array(3) &#123; [0] =&gt; string(0) \"\" [1] =&gt; NULL [2] =&gt; NULL &#125; &#125; [1] =&gt; array(66) &#123; [\"app_host\"] =&gt; string(0) \"\" [\"app_debug\"] =&gt; bool(false) [\"app_trace\"] =&gt; bool(false) [\"app_status\"] =&gt; string(0) \"\" [\"app_multi_module\"] =&gt; bool(true) [\"auto_bind_module\"] =&gt; bool(false) [\"root_namespace\"] =&gt; array(0) &#123; &#125; [\"extra_file_list\"] =&gt; array(1) &#123; [0] =&gt; string(59) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/helper.php\" &#125; [\"default_return_type\"] =&gt; string(4) \"html\" [\"default_ajax_return\"] =&gt; string(4) \"json\" [\"default_jsonp_handler\"] =&gt; string(11) \"jsonpReturn\" [\"var_jsonp_handler\"] =&gt; string(8) \"callback\" [\"default_timezone\"] =&gt; string(3) \"PRC\" [\"lang_switch_on\"] =&gt; bool(false) [\"default_filter\"] =&gt; string(0) \"\" [\"default_lang\"] =&gt; string(5) \"zh-cn\" [\"class_suffix\"] =&gt; bool(false) [\"controller_suffix\"] =&gt; bool(false) [\"default_module\"] =&gt; string(5) \"index\" [\"deny_module_list\"] =&gt; array(1) &#123; [0] =&gt; string(6) \"common\" &#125; [\"default_controller\"] =&gt; string(5) \"Index\" [\"default_action\"] =&gt; string(5) \"index\" [\"default_validate\"] =&gt; string(0) \"\" [\"empty_controller\"] =&gt; string(5) \"Error\" [\"use_action_prefix\"] =&gt; bool(false) [\"action_suffix\"] =&gt; string(0) \"\" [\"controller_auto_search\"] =&gt; bool(false) [\"var_pathinfo\"] =&gt; string(1) \"s\" [\"pathinfo_fetch\"] =&gt; array(3) &#123; [0] =&gt; string(14) \"ORIG_PATH_INFO\" [1] =&gt; string(18) \"REDIRECT_PATH_INFO\" [2] =&gt; string(12) \"REDIRECT_URL\" &#125; [\"pathinfo_depr\"] =&gt; string(1) \"/\" [\"https_agent_name\"] =&gt; string(0) \"\" [\"url_html_suffix\"] =&gt; string(4) \"html\" [\"url_common_param\"] =&gt; bool(false) [\"url_param_type\"] =&gt; int(0) [\"url_route_on\"] =&gt; bool(true) [\"route_config_file\"] =&gt; array(1) &#123; [0] =&gt; string(5) \"route\" &#125; [\"route_complete_match\"] =&gt; bool(false) [\"url_route_must\"] =&gt; bool(false) [\"url_domain_deploy\"] =&gt; bool(false) [\"url_domain_root\"] =&gt; string(0) \"\" [\"url_convert\"] =&gt; bool(true) [\"url_controller_layer\"] =&gt; string(10) \"controller\" [\"var_method\"] =&gt; string(7) \"_method\" [\"var_ajax\"] =&gt; string(5) \"_ajax\" [\"var_pjax\"] =&gt; string(5) \"_pjax\" [\"request_cache\"] =&gt; bool(false) [\"request_cache_expire\"] =&gt; NULL [\"request_cache_except\"] =&gt; array(0) &#123; &#125; [\"template\"] =&gt; array(8) &#123; [\"type\"] =&gt; string(5) \"Think\" [\"view_path\"] =&gt; string(0) \"\" [\"view_suffix\"] =&gt; string(4) \"html\" [\"view_depr\"] =&gt; string(1) \"/\" [\"tpl_begin\"] =&gt; string(1) \"&#123;\" [\"tpl_end\"] =&gt; string(1) \"&#125;\" [\"taglib_begin\"] =&gt; string(1) \"&#123;\" [\"taglib_end\"] =&gt; string(1) \"&#125;\" &#125; [\"view_replace_str\"] =&gt; array(0) &#123; &#125; [\"dispatch_success_tmpl\"] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/tpl/dispatch_jump.tpl\" [\"dispatch_error_tmpl\"] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/tpl/dispatch_jump.tpl\" [\"exception_tmpl\"] =&gt; string(72) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/tpl/think_exception.tpl\" [\"error_message\"] =&gt; string(33) \"页面错误！请稍后再试～\" [\"show_error_msg\"] =&gt; bool(false) [\"exception_handle\"] =&gt; string(0) \"\" [\"record_trace\"] =&gt; bool(false) [\"log\"] =&gt; array(3) &#123; [\"type\"] =&gt; string(4) \"File\" [\"path\"] =&gt; string(52) \"/Users/maksim/Downloads/thinkphp_5.0.20/runtime/log/\" [\"level\"] =&gt; array(0) &#123; &#125; &#125; [\"trace\"] =&gt; array(1) &#123; [\"type\"] =&gt; string(4) \"Html\" &#125; [\"cache\"] =&gt; array(4) &#123; [\"type\"] =&gt; string(4) \"File\" [\"path\"] =&gt; string(54) \"/Users/maksim/Downloads/thinkphp_5.0.20/runtime/cache/\" [\"prefix\"] =&gt; string(0) \"\" [\"expire\"] =&gt; int(0) &#125; [\"session\"] =&gt; array(5) &#123; [\"id\"] =&gt; string(0) \"\" [\"var_session_id\"] =&gt; string(0) \"\" [\"prefix\"] =&gt; string(5) \"think\" [\"type\"] =&gt; string(0) \"\" [\"auto_start\"] =&gt; bool(true) &#125; [\"cookie\"] =&gt; array(7) &#123; [\"prefix\"] =&gt; string(0) \"\" [\"expire\"] =&gt; int(0) [\"path\"] =&gt; string(1) \"/\" [\"domain\"] =&gt; string(0) \"\" [\"secure\"] =&gt; bool(false) [\"httponly\"] =&gt; string(0) \"\" [\"setcookie\"] =&gt; bool(true) &#125; [\"database\"] =&gt; array(20) &#123; [\"type\"] =&gt; string(5) \"mysql\" [\"dsn\"] =&gt; string(0) \"\" [\"hostname\"] =&gt; string(9) \"127.0.0.1\" [\"database\"] =&gt; string(0) \"\" [\"username\"] =&gt; string(4) \"root\" [\"password\"] =&gt; string(0) \"\" [\"hostport\"] =&gt; string(0) \"\" [\"params\"] =&gt; array(0) &#123; &#125; [\"charset\"] =&gt; string(4) \"utf8\" [\"prefix\"] =&gt; string(0) \"\" [\"debug\"] =&gt; bool(true) [\"deploy\"] =&gt; int(0) [\"rw_separate\"] =&gt; bool(false) [\"master_num\"] =&gt; int(1) [\"slave_no\"] =&gt; string(0) \"\" [\"fields_strict\"] =&gt; bool(true) [\"resultset_type\"] =&gt; string(5) \"array\" [\"auto_timestamp\"] =&gt; bool(false) [\"datetime_format\"] =&gt; string(11) \"Y-m-d H:i:s\" [\"sql_explain\"] =&gt; bool(false) &#125; [\"paginate\"] =&gt; array(3) &#123; [\"type\"] =&gt; string(9) \"bootstrap\" [\"var_page\"] =&gt; string(4) \"page\" [\"list_rows\"] =&gt; int(15) &#125; [\"console\"] =&gt; array(3) &#123; [\"name\"] =&gt; string(13) \"Think Console\" [\"version\"] =&gt; string(3) \"0.1\" [\"user\"] =&gt; NULL &#125; [\"queue\"] =&gt; array(1) &#123; [\"connector\"] =&gt; string(4) \"Sync\" &#125; &#125; &#125; &#125; [5] =&gt; array(6) &#123; [\"file\"] =&gt; string(58) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/start.php\" [\"line\"] =&gt; int(19) [\"function\"] =&gt; string(3) \"run\" [\"class\"] =&gt; string(9) \"think\\App\" [\"type\"] =&gt; string(2) \"::\" [\"args\"] =&gt; array(0) &#123; &#125; &#125; [6] =&gt; array(4) &#123; [\"file\"] =&gt; string(56) \"/Users/maksim/Downloads/thinkphp_5.0.20/public/index.php\" [\"line\"] =&gt; int(17) [\"args\"] =&gt; array(1) &#123; [0] =&gt; string(58) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/start.php\" &#125; [\"function\"] =&gt; string(7) \"require\" &#125;&#125; 我们可以来分析一下 ThinkPHP5.0的调用步骤： 在入口文件的第17行调用加载了 start.php 在 start.php 的第19行执行了 think\\App::start()方法 然后在 APP.php 中执行了 exec()方法….. debug_backtrace 显示的是详细信息，如果想要简单的查看调用，可以使用debug_print_backtrace函数直接打印输出堆栈的调用信息。 这样我们就可以分析出，ThinkPHP 的执行流程，也就四五分钟的时间。 当我们需要输出变量的时候，我们应该使用 var_dump()，因为var_dump 可以直观的看出数组的结构。 当我们在在向日志文件输出数组的时候，我们可以使用 var_export()进行输出。 123456789101112131415&lt;?php$a = array (1, 2, array (\"a\", \"b\", \"c\"));var_export ($a);/* 输出：array ( 0 =&gt; 1, 1 =&gt; 2, 2 =&gt; array ( 0 =&gt; 'a', 1 =&gt; 'b', 2 =&gt; 'c', ),)*/ 另外我们可以通过 get_included_files来获取当前脚本文件都加载了哪些文件。 12345678910111213141516171819202122232425array(23) &#123; [0] =&gt; string(56) \"/Users/maksim/Downloads/thinkphp_5.0.20/public/index.php\" [1] =&gt; string(58) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/start.php\" [2] =&gt; string(57) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/base.php\" [3] =&gt; string(73) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/Loader.php\" [4] =&gt; string(75) \"/Users/maksim/Downloads/thinkphp_5.0.20/vendor/composer/autoload_static.php\" [5] =&gt; string(72) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/Error.php\" [6] =&gt; string(73) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/Config.php\" [7] =&gt; string(63) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/convention.php\" [8] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/App.php\" [9] =&gt; string(74) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/Request.php\" [10] =&gt; string(62) \"/Users/maksim/Downloads/thinkphp_5.0.20/application/config.php\" [11] =&gt; string(64) \"/Users/maksim/Downloads/thinkphp_5.0.20/application/database.php\" [12] =&gt; string(67) \"/Users/maksim/Downloads/thinkphp_5.0.20/application/extra/queue.php\" [13] =&gt; string(71) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/Hook.php\" [14] =&gt; string(60) \"/Users/maksim/Downloads/thinkphp_5.0.20/application/tags.php\" [15] =&gt; string(62) \"/Users/maksim/Downloads/thinkphp_5.0.20/application/common.php\" [16] =&gt; string(70) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/Env.php\" [17] =&gt; string(59) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/helper.php\" [18] =&gt; string(71) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/Lang.php\" [19] =&gt; string(63) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/lang/zh-cn.php\" [20] =&gt; string(61) \"/Users/maksim/Downloads/thinkphp_5.0.20/application/route.php\" [21] =&gt; string(72) \"/Users/maksim/Downloads/thinkphp_5.0.20/thinkphp/library/think/Route.php\" [22] =&gt; string(78) \"/Users/maksim/Downloads/thinkphp_5.0.20/application/index/controller/Index.php\"&#125; 上面都是用PHP 自带的函数来做代码分析，下面来讲解一下利用 SocketLog 来分析源代码。 SocketLog 可以把我们的一些日志打到浏览器的调试工具上面。 比如说 SQL 语句，点开后可以查看调用栈，通过这些信息，我们就可以快速定位我们想要修改的代码。其实 SocketLog 还可以做微信调试。 详细的使用方法可以通过 github 进行查看： https://github.com/luofei614/SocketLog 我们可以通过一些思维导图的工具来帮助我们分析业务逻辑。 我们还可以通过 UML 图形来整理类之间的关系，我们可以看 《大象UML 》来了解 UML 建模。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"添加报警程序提高对线上错误的感知能力","slug":"2018-08-19 添加报警程序提高对线上错误的感知能力","date":"2018-08-18T16:00:00.000Z","updated":"2018-09-10T14:36:53.673Z","comments":true,"path":"2018/08/19/1/","link":"","permalink":"http://www.maksim.website/2018/08/19/1/","excerpt":"","text":"Why?在我们项目的研发过程中，如果有 BUG 没有被测试出来就部署到生产环境，会造成很大的影响，其实很少会有用户去做 BUG 反馈，一旦发现 bug，可能用户掉头就会离开（用户没有义务帮助我们收集 bug），这样的情况并不是我们想要看到的，所以我们需要对我们的代码做一些处理，增强对 BUG 的感知能力。 像是在移动端开发中就有腾讯团队开发的 Bugle 这样的工具对用户端的 Bug 进行手机的工具，既然移动端可以实现，那么 PHP 自然也可以。 How？其实处理的方式也很简单，PHP 为我们提供了register_shutdown_function 和 set_error_handler这两个函数，通过这两个函数我们就可以实现对线上错误的收集。 register_shutdown_function 这个函数会在 PHP 程序终止或者exit()后被调用 set_error_handler 设置用户自定义的错误处理函数，我们可以在其中注册一些操作。 123456789101112131415161718register_shutdown_function('fatal_error');set_error_handler('error_handler');function fatal_error() &#123; if ($e = error_get_last()) &#123; switch($e['type']) &#123; case E_ERROR: case E_PARSE: case E_CORE_ERROR: case E_COMPILE_ERROR: case E_USER_ERROR: error_handler($e['type'], $e['message'], $e['file'], $e['line']); &#125; &#125;&#125;function error_handler($errno, $errstr, $errfile, $errline) &#123; //实现业务逻辑发送短信 || 邮箱等操作。&#125;; 另外我们可以不光在警告中添加报警，也可以在业务逻辑中添加，因为对于代码而言，不要过于自信，要考虑到为空，或者是判断条件 ture 和 false，会不会有其他的情况。 1234$user = db_find('seeker', '`uid`, `realname`, `email`, `token`', \"`uid` ='\" .s($uid), \"'\" );if (empty($user)) &#123; log(\"id 为\". intval($uid).\"的 recommend_user 表记录查询不到\", 'recommend_weixinlogin', true, true);&#125; 又或者是消息队列超过了当前队列数量是否过大。 1234$emails = get_data(\"SELECT * FROM subscribe WHERE `email_status` = 1 AND `unsubscribe` = 0\");if (count($emails) &gt; 5000) &#123; log('##订阅邮箱大于5000了，队列数过大，需要考虑分批加入队列', 'subscribe_big', true, true);&#125; 通常我们都会将报警发送到短信或者邮箱里，其实我们也可以换一种解决方案——slack。 slack 是国外的一款软件，我们可以将其当做消息中心，可以建立各种各样的消息类型。slack 有手机 app 也有pc端的软件，同时我们也可以利用这款软件对用户的操作进行监控，如果出现问题可以手动干预。 在这些解决方案中我还是比较推荐大家使用邮箱或者 slack，因为短信存在着天然缺陷——字符长度限制，如果使用邮件或者 slack 就不会存在这样的问题，我们可以直接将调用栈直接发送到我们的邮箱或者 slacK消息中，这样一来也就能够更加迅速的定位 Bug，实现的方法也很简单，可以看我的之前写的另外一篇博文《如何分析学习 PHP 开源项目》","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"Supervisor 一个进程控制系统","slug":"2018-08-01 Supervisor 进程守护","date":"2018-08-01T13:08:02.442Z","updated":"2018-09-03T14:43:40.172Z","comments":true,"path":"2018/08/01/cjlz9prb3008oabrdj781lxot/","link":"","permalink":"http://www.maksim.website/2018/08/01/cjlz9prb3008oabrdj781lxot/","excerpt":"","text":"在日常开发或者是架设环境的时候，我们需要保证我们编写的应用能够稳定运行在系统中，如果系统管理员误操作将该进程杀死，这样将会对整个系统带来巨大的灾难，在 PHP 开发中如果只是在编写 Web 应用的话可能很少会碰到这类问题，但是一旦编写网络服务，或者是处理消息队列的任务脚本时，就必须要掌握进程守护的技巧。 但是对于大环境下，能够了解服务端编程的 PHP 程序员很少，甚至有的连线程、进程都说不清楚，这样更别提写守护进程了，可能有的同学连守护进程是什么都不了解，不过不要担心，我这就来介绍一下。 想要理解守护进程很简单，我们在编写 PHP CLI 程序时候，当我们使用 PHP 执行脚本时，系统就会自动创建一个进程，我们为了确保这个进程能够在被干掉后，能够让他自行再次启动，保证服务的可靠性，这就是守护进程做的事情。 而 Supervisor 就是为了解决这个问题而出现的。 Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。 Beanstalkd+Supervisor构建消息队列我们可以使用 Python 提供的 easy_intall 来进行安装，如果没有我们可以通过 Linux 的包管理工具进行安装，当然也有其他安装方式，在这里我使用的系统是 CentOS。 123456yum install python-toolseasy_install supervisormkdir /etc/supervisorecho_supervisord_conf &gt; /etc/supervisor/supervisord.confvim /etc/supervisor/supervisord.confmkdir /etc/supervisor/conf.d 1234567891011121314151617181920212223242526272829303132333435363738394041424344[unix_http_server]file=/tmp/supervisor.sock ;UNIX socket 文件，supervisorctl 会使用;chmod=0700 ;socket文件的mode，默认是0700;chown=nobody:nogroup ;socket文件的owner，格式：uid:gid;[inet_http_server] ;HTTP服务器，提供web管理界面;port=127.0.0.1:9001 ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性;username=user ;登录管理后台的用户名;password=123 ;登录管理后台的密码[supervisord]logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.loglogfile_maxbytes=50MB ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小logfile_backups=10 ;日志文件保留备份数量默认10，设为0表示不备份loglevel=info ;日志级别，默认info，其它: debug,warn,tracepidfile=/tmp/supervisord.pid ;pid 文件nodaemon=false ;是否在前台启动，默认是false，即以 daemon 的方式启动minfds=1024 ;可以打开的文件描述符的最小值，默认 1024minprocs=200 ;可以打开的进程数的最小值，默认 200[supervisorctl]serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord; [program:xx]是被管理的进程配置参数，xx是进程的名称[program:xx]command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run ; 程序启动命令autostart=true ; 在supervisord启动的时候也自动启动startsecs=10 ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒autorestart=true ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启startretries=3 ; 启动失败自动重试次数，默认是3user=tomcat ; 用哪个用户启动进程，默认是rootpriority=999 ; 进程启动优先级，默认999，值小的优先启动redirect_stderr=true ; 把stderr重定向到stdout，默认falsestdout_logfile_maxbytes=20MB ; stdout 日志文件大小，默认50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数，默认是10; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.outstopasgroup=false ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程killasgroup=false ;默认为false，向进程组发送kill信号，包括子进程;包含其它配置文件[include]files = /etc/supervisor/conf.d/*.conf ;可以指定一个或多个以.ini结束的配置文件 这样我们就安装并配置好了 Supervisor，接下来，我们在/etc/supervisor/conf.d/建立一个新的配置文件. 1vim /etc/supervisor/conf.d/beanstalkd.conf 12 （未完待续…..）","categories":[],"tags":[]},{"title":"SVN 的圆舞曲（00）：起步","slug":"2018-07-25 SVN 的圆舞曲（01）：安装","date":"2018-07-24T16:00:00.000Z","updated":"2018-09-10T14:25:19.532Z","comments":true,"path":"2018/07/25/1/","link":"","permalink":"http://www.maksim.website/2018/07/25/1/","excerpt":"","text":"接下来，我们学习如何在Linux 环境下进行 SVN 的安装。 由于目前的 Linux 发行版本实在是太多了，而且每个版本的安装方式也都不一样，所以在这里我们只列举 CentOS 和 Ubunut 的安装方式。 CentOS: 1yum install subversion Ubunut: 1apt-get install subversion Subversion 软件包已经内置了服务端和客户端两个部分，无论是在本地搭建服务器还是访问远程版本库，只要安装了 Subversion 软件包就可以了。 服务端命令与客户端命令Subversion 的命令主要分为两个部分——服务端、客户端。 服务端的命令主要包括: svnserver - 控制 SVN 系统服务的启动等 svnadmin - 版本库的创建/导出/导入/删除等 svnlook - 查看版本库的信息 客户端命令 svn - 版本控制的检出/更新/提交/重定向等 在这里提到的术语可能有的人并不清楚，不要担心，在后面的文章中我会逐渐进行讲解，现在贴出这些命令的主要原因是希望大家不要去死记硬背这些命令，凡是运行这些命令的时候，想一下，当前是以一种什么身份去运行。 版本库的创建与删除创建版本库的命令很简单： 1svnadmin create /path/repos","categories":[{"name":"SVN","slug":"SVN","permalink":"http://www.maksim.website/categories/SVN/"}],"tags":[]},{"title":"SVN 的圆舞曲（00）：简述版本控制器","slug":"2018-07-25 SVN 的圆舞曲（00）：起步","date":"2018-07-24T16:00:00.000Z","updated":"2018-09-08T05:31:29.465Z","comments":true,"path":"2018/07/25/1/","link":"","permalink":"http://www.maksim.website/2018/07/25/1/","excerpt":"","text":"什么是版本控制如果公司不是只有你一个开发的话，那么你肯定会接触过版本管理，目前主流的版本控制器是 GIT，但是仍然有一些公司在使用 SVN，就比如说我目前的公司。 如果对版本控制器不熟悉的同学也没有关系，这篇文章会带领大家由浅入深的了解 SVN。 那么什么是 版本控制？ 版本控制是维护工程蓝图的标准做法，能追踪工程蓝图从诞生到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发中，确保由不同人所编辑的同一代码文件都能得到同步。 上面这段话是不是很高大上，这来自维基百科。其实我们只需要理解他的后半句就可以了。 首先我们知道绝大多数的软件开发，都是由很多个程序员共同完成，项目越大，所需要的程序员也就越多，一个项目里面有很多代码文件，虽然每个程序员都有自己的分工。 比如说张三开发模块 A，李四开发模块 B，这样分配下去，但是会不可避免的出现，某个代码文件多个程序员共同开发的情况，比如说某个程序中包含了公共函数库这个文件，可能前前后后会有很多个程序员往这里面添加函数。 如果没有版本控制器，最开始函数库文件分发到每个程序员手上的时候是版本1，有一天张三向这个公共函数库中添加了个函数保存成了版本2，这个时候问题就来了，其他的程序员所有的代码依旧是版本1，跟张三的版本是不一样的，这个时候公共函数库已经发生了变化，很可能发生一些不可预料的情况。 为了避免出现问题，张三把自己的改动告诉给项目组的所有人，然后发送给其他开发人员，大家再各自把张三添加的函数也添加自己手中的公共函数库文件中，这样代码才能够保持同步。 有的同学可能会说，这种问题大家一起克服一下，不是什么大问题，没错，人少的时候的确可以，但如果是非常庞大的团队呢？ 一个文件改动一两次可能还好，但是如果改动上千个文件，每个文件改动十次，你还受得了吗？ 这样一来根本就不可能打代码了，每天沟通这些事情就已经能消耗掉所有人的精力了。 版本控制器软件，就是为了解决这样的问题而诞生的。有了版本控制器，无论是哪一个程序员改动了程序中的哪一行，都能够保证同一个项目组中的其他程序员得到项目的相同版本，从而避免发生团队开发发生前面提到的问题。 版本控制可不仅仅只有这点作用，版本控制软件能够让任意文件，恢复到任意版本，而且还能追溯任意一行代码在什么时间被什么人修改过。 如果是个人开发是不是版本控制就没有什么用了呢？ 其实不然，假设你现在开发到某一个阶段，发现该来该去，发现还是上周或者上个月的某个版本比较好，想要恢复回去，你就不需要去从新敲一遍，当然也有人会按照一定的时间段来手动保存代码，但是明明有软件能够帮你更好的完成这项工作，为何还要费力不讨好的自己为难自己？ 各种版本控制器的比较对于刚刚入行的同学而言，应该会听说到一些关于版本控制，比如说SVN，GIT，还有 GITHub，可能对这些术语的理解并不是很透彻，并且在业内长期存在着一些误解，比如说有人认为 GIT 比 SVN更吊，还有人分不清 GIT 和 GIThub 的关系，甚至有人认为 GIThub 就是 GIT。 下面我们来捋一捋这之间的关系。其实版本控制已经有很多年的历史了，历史上出现过很多版本控制解决方案比如说 VSS、RCS、CVS、GIT、SVN、StarTeam、ClearCase。由于技术的发展，有些由于安全性差，无法支持跨平台等各种原因退出了历史舞台，目前只剩下了 CVS、GIT 和 SVN。 其中 CVS目前使用量是比较小的，很多公司都已经过渡到了 SVN 或者是 GIT,后两种属于一个类型，但是各有优势。 既然有这么多的版本控制解决方案，他们之间有什么区别呢，我们又该如何选择？ 我们通过使用比较频繁的方面来进行比较： 特性 CVS SVN GIT 并发修改 支持 支持 支持 并发提交 不支持 支持 支持 历史轨迹 不支持更名 支持更名 支持更名 分布式 不支持 不支持 支持 首先是并发修改，同时多个开发人员，对同一个文件进行修改，以上三者都是支持，这是非常重要的，也是使用最频繁的一个特性，前面有提到过一个 RCS的版本控制，它就不支持，这其中涉及到一个概念叫做锁定，在 RCS 中如果有人正在修改某一个文件，这个文件就会被锁定，直到修改完毕，其他开发人员才可以对该文件进行修改操作，而 CVS 是从 RCS 发展而来的，所以说 CVS 是对 RCS 是有一些改进的。 其次是并发提交，这里首先要知道，版本控制中的版本记录，是需要开发人员的提交操作来触发的，也就是说你要执行触发操作，它才会记录版本号，否则是不会记录版本号的，如果你修改了多个文件或提交，那么 CVS会一个个的提交，每个文件被修改后都会记录一个不同的版本号，而 SVN 和 GIT 可以同时提交多个文件的修改，修改了多个文件，记录同一个版本号。 这两种方式各有优缺点，CVS 每个文件都会记录一个版本号，那么占用的磁盘空间比较大，用久了就会显得很臃肿，但是如果出现 Bug 之后，由于 CVS 是一个一个的提交，定位 BUG 的时候，只要定位到版本号，就可以对应到某一个文件，找 BUG 就会比较快了，GIT 和 SVN 就需要从批量提交的多个文件中一个一个文件的进行查找，看看到底是这次提交中的哪个文件引发的 BUG。 然后就是历史轨迹，如果说一个文件被修改了，CVS 他就无法去追踪到修改文件名之前的历史版本，而 GIT 和 SVN即使文件名被修改了，它依然能够追踪到这个文件之前的所有历史版本，这一点 SVN 和 GIT 显得更加优秀一点。 分布式值得是是否需要一台专门的服务器来运行版本控制系统，CVS和 SVN 是一种集中式的版本控制，他需要一台专门的服务器来运行版本控制，而 GIT 是分布式的，它不需要一台专门的服务器来运行版本控制，每一个开发人员的电脑组成的网络就可以运行，特别适合源代码的发布和交流，所以很多开源项目会使用 GIT。 比如说我们前面提到过的 GITHUB站点，它就是一个使用了 GIT 系统的一个网站，用来服务千千万万个开源你项目，这个开发模式并不是说谁更强的问题，而是应用场景不同的问题。 在一些超大型的项目中往往会在 GIT之上，再加一层 SVN 来实现更复杂的版本控制需求。 简单的了解过后，我们就可以根据自己的实际需要，来选择适合自己的版本控制解决方案。 SVN 的安装下面，我们来介绍如何在 Linux 安装 SVN，现在市面上使用的 Linux 版本实在是太多了，而且不同的操作系统安装软件的方法也不太一样，我们没有办把所有系统的安装方法都列举出来，下面直接上两种安装方式： 12$ apt-get install subversion #Ubunut$ yum install subversion #CentOS （未完待续…..）","categories":[{"name":"SVN","slug":"SVN","permalink":"http://www.maksim.website/categories/SVN/"}],"tags":[]},{"title":"Redis 的持久化方案","slug":"2018-07-18 Reids 运维开发（02）：的持久化方案","date":"2018-07-18T14:21:03.590Z","updated":"2018-09-03T14:44:51.138Z","comments":true,"path":"2018/07/18/cjlz9praq008eabrdll7b5p2g/","link":"","permalink":"http://www.maksim.website/2018/07/18/cjlz9praq008eabrdll7b5p2g/","excerpt":"","text":"持久化这个词对于开发人员来说应该不会陌生，如果不了解也没有关系，因为这是一个非常简单的概念。 简单的说就是把内存中的数据保存到硬盘中！ Redis 是一款内存数据库，所有的数据都会被放置到内存当中，如果在运行时发生了宕机，那么保存在内存中的数据就会全部丢失，这并不是我们想要看到的，为此，Redis 提供了持久化机制，对数据的更新异步的保存到磁盘当中。 Redis 支持 RDB 和 AOF 两种持久化机制，持久化功能有效地避免因为进程退出造成数据丢失的问题，当下次重启时利用之前持久化的文件即可实现数据恢复。 RDBRDB 可以指定时间间隔保存数据快照，这有些类似于数据库表快照性质的，也就是说他隔一段时间就会把数据拍个照片然后保存下来，这也是数据库常用的备份方式，在某一个时间点执行备份 sql 或者是备份目录之类的，出发 RDB 持久化过程分为手动出发和自动触发。 触发机制手动出发分别对应 save 和 bgsave 命令： save 命令：阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间堵塞，线上环境不建议使用。运行 save 命令对应的 Redis 如下： 1DB saved on disk bgsave 命令：Redis 执行 fork 进程操作创建子进程，RDB 持久化过程由紫禁城负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。运行 bgsave 命令对应的 Redis 日志如下： 1234Backgroud saving stated by pid 3151DB saved on diskRDB: 0 MB of memory used by copy-on-writeBackground saving terminated with success 显然bgsave 命令是针对 save 阻塞问题做的优化，因此Redis 内部所有涉及 RDB 的操作都采用 bgsave 的方式，而 save 命令已经被废弃了。 除了手动触发，之外，Redis 内部还存在自动触发 RDB 的持久化机制： 使用 save 相关配置，如“save m n”表示 m 秒内数据集存在n 此修改时，自动触发bgsave。 如果从节点执行全量赋值操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点 执行 debug reload 命令重新加载 Redis 时，也会自动触发 save 操作。 默认情况下执行 shotdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave 执行流程 执行 bgsave 命令，Redis 父进程判断当前是否存在正在执行的子进程，如 RDB/AOF 子进程，如果存在 bgsave 命令则直接返回。 父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞，通过 info stats 命令查看 latest_fork_usec 选项，可以获取最近一个 fork 操作的耗时，单位为微秒。 父进程 fork 完成后，bgsave 命令返回“Background saveing started”信息并不再阻塞父进程，可以继续响应其他命令。 子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行 lastsave 命令可以获取最后一次生成 RDB 的时间，对应 info 统计的 rdb_last_save_time 选项。 进程发送信号告诉父进程表示完成，父进程更新统计信息，具体见 info Persistence 下的 rdb_*相关选项。 RDB 文件保存在 dir 配置指定的目录下，文件通过dbfilename 配置指定。可以公国执行 config set dir {newDir}和 config set dbfilename {newFilename} 运行期间动态执行，当下次运行 RDB 文件会保存到新目录上。 优缺点RDB 模式的优点 适用于进行备份 fork 出子进程进行备份，主进程没有任何 IO 操作 恢复大数据集时的速度快 RDB 模式的优点： 特定条件下进行一次持久化，易丢失数据 庞大数据时，保存时会出现性能问题 相比之下，RDB 模式将时间设置的相对密集了，频繁的备份就会占用较多的资源，但是如果把时间拉的比较远了，万一出问题，就会恢复到上一个时间点，很可能会丢失数据。 AOFAOF 以独立日志的方式保存所有历史操作命令，当需要回复的时候，会按照之前输入的命令挨个都执行一次，主要作用是解决了数据持久化的实时性，目前已经是 Redis 持久化的主流方式。 配置方式； redis.confg: appendonly yes AOF 默认不开启，AOF 文件名通过 appendfilename 进行培植，默认文件名是 appendonly.aof，保存路径与 RDB 一样，需要通过 dir 配置指定。 AOF 工作流程：命令写入（append）、文件同步（sync）、文件重写（Write）、重启加载（load） 在命令写入命令时候，Redis 会将命令追加到 aof_buf(缓冲区中)，然后再根据对应的策略向硬盘做同步操作，随着AOF 文件越来越大，需要定期对 AOF 文件进行重写达到压缩的目的。 当 Redis 重启时候，可以加载 AOF 文件进行恢复。 AOF 命令的写入的内容直接是文本协议格式，例如 set hello world 这套命令，在 AOF 缓冲区会追加如下文本： 1*3\\r\\n$3\\rnset\\r\\n$5\\r]nhello\\r\\n$5\\r\\nworld\\r\\n 这样有一个好处，文本协议具有可读性，方便直接修改和处理，而且直接采用协议格式，可以避免了二次处理的开销。 缓冲区同步文件策略： 可配置值 说明 always 命令写入 aof_buf 后调用系统 fsync 操作同步到 AOF 文件，fsync 完成后线程返回 everysec 命令写入 aof_buf 后调用系统 Write 操作，Write 操作完成后县城返回。fsync 同步文件操作由专门线程每秒调用一次。 no 命令写入 aof_buf 后调用系统 Write 操作，不对 AOF 文件做 fsync 同步，同步硬盘操作系统由操作系统负责，通常同步周期最长30秒 系统调用 Write 和 fsync 说明： Write 操作会触发延迟写机制，Linux 在内核提供页缓冲区来提高硬盘 IO 性能。Write 操操作在写入系统缓冲区后直接返回，同步硬盘操作依赖于系统调度机制不过同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。 fsync 针对单个文件操作，做强制硬盘同步，fsyn 将阻塞直接写到硬盘完成后返回，保证了数据持久化。 重写机制随着命令不断写入 AOF，文件越来越大，为了解决这个问题，Redis 引入 AOF 重写机制压缩文件体积。AOF 文件重写是把 Redis 进程内的数据转化为写命令同步到新的 AOF 文件的过程。 重写后的 AOF 文件会变小的主要原因是： 进程内已超时的数据不会写入文件 旧的 AOF 文件含有无效命令，如del key1、 hdel key2、srem keys、set alll、set a222等。重写使用进程内数据直接生成，这样新的 AOF 文件只保留最终数据的写入命令 多条写命令可以合并成为一个如：lpush list a、lpush list b、lpush list c 可以转化为 lpush list a b c。为了防止但命令过大造成数据段缓冲区溢出，对于 list、set、hash、zset 等类型操作，以64个元素为界拆分多条。 AOF 重写降低了文件占用空间，除此之外，另外一个目的是更小的 AOF 文件可以更快地被 Redis 加载。 AOF 重写过程可以手动触发和被动触发： 手动触发：直接调用bgrewriteaof 被动触发：根据 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 参数确定自动触发的时机。 优缺点AOF模式的优点 数据非常完整，故障恢复丢失数据少 可对历史记录进行处理 AOF模式的缺点 把整个操作都记录下来，这也就导致了文件体积较大 速度低于 RDB 且故障恢复速度慢，如果几十万次或者上百万条记录，要比 RDB 慢上很多。 这两种模式可以同时开启，但是会优先加载 AOF。但是需要注意，如果想要同时开启，尤其 AOF 模式最好 Redis 比较干净的时候就开启，刚开始的时候，我们用的 RDB 模式进行的备份，而 AOF 模式会从 AOF 的那个时间点开始计算，如果在之前有数据，恢复的时候就会出问题了。 RDB 和 AOF 的抉择首先，我们队 RDB 和 AOF 做一个对比 命令 RDB AOF 启动优先级 低 高 体积 小 大 数据安全性 丢数据 根据策略决定 轻重 重 轻 假如说 RDB 和 AOF 同时开启， 也就是说在工作目录下既有 RDB 文件也有 AOF 文件，如果此时突然宕机，Redis 重启之后会优先加载 AOF，因为AOF的数据级别是比较高的，大部分情况下它会比 RDB 保存更新的数据。 RDB 使用类似二进制的形式进行存储，并且进行了压缩，所以他的体积非常小，恢复速度也就会更快，AOF 类似日志的形式也有重写机制，但是他的体积还是较大的，加载速度也就更慢。 根据上文中所提到过，RDB 的数据安全性要较低一些，会丢失一些数据，AOF 是根据策略决定的。 RDB 是一个很重的操作，因为他要将全部的 Redis 数据存储到硬盘当中，首先是要将内存中的数据移动到硬盘当中，这个操作本身就涉及很多方面，首先硬盘写入量就很大，本身也是一个计算密集型的操作，它还会执行个 fork 产生一些内存开销。 AOF 不讨论重写的话，本身就是一个很轻的追加日志操作。 RDB 的最佳策略 建议‘关’掉 RDB 集中管理 主从，从开 AOF的最佳操作 建议开启，但是如果只是用来做缓存的话可以关闭掉 AOF 重写集中管理 everysec 最佳策略 最小分片 缓存或者存储 监控（硬盘、内存、负载、网络） 足够的内存","categories":[],"tags":[]},{"title":"利用 tail 命令监控文件变化","slug":"2018-07-17 利用 Tail 命令监控文件变化","date":"2018-07-16T16:00:00.000Z","updated":"2018-07-22T08:02:11.304Z","comments":true,"path":"2018/07/17/1/","link":"","permalink":"http://www.maksim.website/2018/07/17/1/","excerpt":"","text":"tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 命令格式1tail(选项)(参数) 选项 1234567891011--retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；-c&lt;N&gt;或——bytes=&lt;N&gt;：输出文件尾部的N（N为整数）个字节内容；-f&lt;name/descriptor&gt;或；--follow&lt;nameldescript&gt;：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；-F：与选项“-follow=name”和“--retry&quot;连用时功能相同；-n&lt;N&gt;或——line=&lt;N&gt;：输出文件的尾部N（N位数字）行内容。--pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；-q或——quiet或——silent：当有多个文件参数时，不输出各个文件名；-s&lt;秒数&gt;或——sleep-interal=&lt;秒数&gt;：与“-f”选项连用，指定监视文件变化时间隔的秒数；-v或——verbose：当有多个文件参数时，总是输出各个文件名；--help：显示指令的帮助信息；--version：显示指令的版本信息。 2．**命令功能：** 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 3．**命令参数：** -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c&lt;数目&gt; 显示的字节数 -n&lt;行数&gt; 显示行数 –pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. -q, –quiet, –silent 从不输出给出文件名的首部 -s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 4．**使用实例：** 实例1：显示文件末尾内容 命令： tail -n 5 log2014.log 输出： [root@localhost test]# tail -n 5 log2014.log 2014-09 2014-10 2014-11 2014-12 ==============================[root@localhost test]# 说明： 显示文件最后5行内容 实例2：循环查看文件内容 命令： tail -f test.log 输出： [root@localhost ~]# ping 192.168.120.204 &gt; test.log &amp; [1] 11891[root@localhost ~]# tail -f test.log PING 192.168.120.204 (192.168.120.204) 56(84) bytes of data. 64 bytes from 192.168.120.204: icmp_seq=1 ttl=64 time=0.038 ms 64 bytes from 192.168.120.204: icmp_seq=2 ttl=64 time=0.036 ms 64 bytes from 192.168.120.204: icmp_seq=3 ttl=64 time=0.033 ms 64 bytes from 192.168.120.204: icmp_seq=4 ttl=64 time=0.027 ms 64 bytes from 192.168.120.204: icmp_seq=5 ttl=64 time=0.032 ms 64 bytes from 192.168.120.204: icmp_seq=6 ttl=64 time=0.026 ms 64 bytes from 192.168.120.204: icmp_seq=7 ttl=64 time=0.030 ms 64 bytes from 192.168.120.204: icmp_seq=8 ttl=64 time=0.029 ms 64 bytes from 192.168.120.204: icmp_seq=9 ttl=64 time=0.044 ms 64 bytes from 192.168.120.204: icmp_seq=10 ttl=64 time=0.033 ms 64 bytes from 192.168.120.204: icmp_seq=11 ttl=64 time=0.027 ms [root@localhost ~]# 说明： ping 192.168.120.204 &gt; test.log &amp; //在后台ping远程主机。并输出文件到test.log；这种做法也使用于一个以上的档案监视。用Ctrl＋c来终止。 实例3：从第5行开始显示文件 命令： tail -n +5 log2014.log 输出： [root@localhost test]# cat log2014.log 2014-01 2014-02 2014-03 2014-04 2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 ============================== [root@localhost test]# tail -n +5 log2014.log 2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 ==============================","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[]},{"title":"从简单的示例中入门 Redis 五种常用数据结构","slug":"2018-07-17 Reids 运维开发（01）：从简单的示例中入门 Redis 五种常用数据结构","date":"2018-07-16T16:00:00.000Z","updated":"2018-07-22T08:02:15.979Z","comments":true,"path":"2018/07/17/2/","link":"","permalink":"http://www.maksim.website/2018/07/17/2/","excerpt":"","text":"概述Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 简单的 key-value 存储，性能极高 Redis 拥有更多的数据结构和支持更丰富的数据操作 Redis 支持数据持久化和数据恢复 Redis 的所有操作都是原子性的 服务器支持 AUTH 密码验证 Redis 和 PHP 组件的依赖关系 在 Redis 的安装时，有一个配置文件，可以在安装的时候进行详细的配置，安装之后会带一个 cli 命令行的工具，相对而言 Memcached 并没与这样的工具，我们在使用memcached需要使用 telnet，所以 Redis 的命令行要比 Memcache 要好用很多。 连接方式： 1redis-cli -h host -p port -a password PHP 如果想要连接 Redis 就必须安装 Redis 扩展。 在这里就不赘述如何进行安装了，我们可以使用包管理工具或者是编译安装。 123redis-serverredis-cliset user_1 maksim 1234&lt;?php$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379);echo $redis-&gt;get('user_1').PHP_EOL; 安装完成后，我们可以测试一下，看看能否正常取到值。 Redis 常用命令 命令 说明 示例 DEL 删除 key DEL KEY_NAME EXISTS 检查给定 Key 是否存在 EXISTS KEY_NAME KEYS 查找所有符合给定模式 pattren 的 key KEYS PATTERN TYPE 返回 key 所春初的值的类型 TYPE KEY_NAME EXPIRE 设置 key 的过期时间 EXPIRE KEY_NAME TIME_IN_SECONDS TTL 返回 Key 的剩余过期时间 TTL KEY_NAME SAVE RDB 持久化 SAVE INFO Reids 服务器的各种信息和统计数值 INFO [section] SHUTDOWN 保存并停止所有客户端 SHUTDOWN [NOSAVE \\ SAVE] Redis 常用字段类型 String 字符串 Hash 散列表 List 列表 Set 无序集合 Zset 可排序结合 String最常见的数据类型，可以是任何类型的字符串比如 JSON、XML、数字、甚至是二进制，最大容量是512M。 典型的使用场景包括：缓存功能、计数器、共享 Session、限速 常用命令 命令 说明 Cli 命令 PHP SET 赋值 SET key value $redis-&gt;set(‘key’, ‘value’); SETEX 赋值并添加过期时间 SETEX key expire value $redis-&gt;setex(‘key’, ‘expire’, ‘value’); GET 取值 GET key $redis-&gt;get(‘key’); INCR 递增数字 INCR key $redis-&gt;incr(‘int_key’); INCRBY 增加指定的数字 INCRBY key increment $redis-&gt;incrBy(‘int_key’, number); DECR 递减数字 DECR key $redis-&gt;decr(‘key1’); DECRBY 减少指定的数字 DECRBY key decrement $redis-&gt;decrBy(‘key1’, number); INCRBYFLOAT 增加指定浮点型数 INCRBYFLOAT key increment $redis-&gt;incrByFloat(‘key1’, 1.5); APPEND 向稳步追加值 APPEND key value $redis-&gt;append(‘key’, ‘value2’); STRLEN 获取字符串长度 STRLEN key value $redis-&gt;strlen(‘key’); MSET 同时设置多个 key 的值 MSET key1 [key2 value2 …] $redis-&gt;mSet([‘key0’=&gt;’value0’]); MGET 同时获取多个 key 的值 MGET key1 [key2 …] $redis-&gt;mGet([‘key1’,’key2’]); 示例：使用 String 记录用户登录次数有关于文章篇幅有限，所以只是简单实现，首先我们在 redis 中设置一个 user和他的点击次数 12set username_1 maksimset views_1 0 我们可以通过业务名加上 id 的形式来对 key 进行命名。 然后编写模拟登录 login.php 123&lt;?phpsession_start();$_SESSION['uid'] = 1; 再然后进行显示 1234567891011121314151617181920&lt;?php$session = session_start();$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379);$data = [ 'uid' =&gt; $_SESSION['uid'], 'views' =&gt; 0, 'username' =&gt; '游客',];if (!empty($data['uid'])) &#123; $data['username'] = $redis-&gt;get('username_'.$data['uid']); $data['views'] = $redis-&gt;get('views_'.$data['uid']);&#125;$message = '你当前的用户为：'. $data['username'].' 这是你第'.$data['views'].'浏览该内容';$redis-&gt;incr('views_'.$data['uid']);echo $message;?&gt; Hash 类型Hash 类型与 PHP 的数组类似，可以保存多个 key-value 对，每个k-v 都是字符串类型，最多2^32-1字段。 该类型适用于一个属性之中具有多个子属性，比如我们的用户信息。 命令 说明 Cli 命令示例 PHP 写法 HSET 赋值 HSET key field value $redis-&gt;hSet(key, field, value); HMSET 赋值多个字段 HMSET key filed1 value1 [field2 values] $redis-&gt;hMset(key, [‘filed1’=&gt; ‘value1’]); HGET 取值 HGET key field $redis-&gt;hGET(KEY, [‘filed’,’filed2’]) HMGET 获取多个字段的值 HMGET key field1 [field2] $redis-&gt;hmGet(key,[‘filed’,’filed2’]) HGETALL 获取所有的字段的值 HGETALL key $redis-&gt;hGetAll(key); HLEN 获取字段的数量 HLEN key $redis-&gt;hLen(key); 示例： 存储用户信息在 redis 中存入用户信息： 1hmset userinfo_1 real_name 张三 email 1401588099@qq.com 继续在index.php 中编写代码 123$realName = $redis-&gt;hGet('userinfo_'.$data['uid'],'real_name');$email = $redis-&gt;hGet('userinfo_'.$data['uid'],'email');$message .= '&lt;br&gt;'. '真实姓名：'.$realName.'&lt;br&gt;'.'邮箱：'.$email; List 类型Redis 的 List 类型实现其实就是一个双向链表用于存储一个有序的字符串列表，从队列两端添加和弹出元素，拥有开发经验的同学听到双向列表就应该知道 List 的作用了，他可是当做消息队列来使用，这也是最常见的应用。 使用场景：消息队列，文章列表 命令 说明 cli 命令 PHP LPUSH 向列表左端添加元素 LPUSH key value $redis-&gt;lPush(key, value); RPUSH 向列表右端添加元素 RPUSH key value $redis-&gt;rPush(key, value); LPOP 从列表左端弹出元素 LOPO key $redis-&gt;lPop(key); RPOP 从队列右端弹出元素 RPOP key $redis-&gt;rPop(value); LLEN 获取列表中元素个数 LLEN key $redis-&gt;lSize(key); LRANGE 获取列表中某一片段的元素 LRANGE key start stop $redis-&gt;lRange(key, start, end); LREM 删除列表中指定的值 LREM key count value $redis-&gt;lRem(key, value, count)l LINDEX 获取指定索引的元素值 LINDEX key index $redis-&gt;lGet(key, index); LSET 设置指定索引的元素值 LSET key index value $redis-&gt;lSet(key, index, value); LTRIM 只保留列表指定的片段 LTRIM key start stop $redis-&gt;lTrim(key, start, end); LINSERT 向列表中插入元素 LINSERT key BEFORE/AFTER existing_value value $redis-&gt;linsert(key, Redis::BEFORE, existing_value, value) 示例：秒杀123456789101112131415161718192021222324252627282930313233&lt;?php//ms_status_3 0 结束 1已经//在redis-cli 中输入 set cache_ms_status 1//ms_list 秒杀队列$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379);if (!isset($_GET['uid'])) &#123; echo '参数不合法';exit;&#125;$uid = $_GET['uid'];if (!$uid) &#123; echo '参数不合法'; exit;&#125;$limit = 2; //设置秒杀数if ($redis-&gt;lSize('cache_ms_uids') &gt;= $limit) &#123; $redis-&gt;set('cache_ms_status', 0); echo '已经被抢光了，下次再来！'; exit;&#125;if ($redis-&gt;get('cache_ms_status') == 0) &#123; echo '已经结束了'; exit;&#125;$redis-&gt;lPush('cache_ms_uids', $uid);echo '秒杀成功'; 安装上面的代码，我们就建立了一个简单的秒杀队列，其业务逻辑基础就是如此，不过请不要将其代码用于实际项目中，因为中间还缺少很多操作，最典型的就是防止黄牛等等一系列业务逻辑。 Set 类型Set 类型类似于集合，其中可以存储不同的类型元素，需要注意的是，Set 集合是禁止重复的，所以一般都用来实现去重，元素最多为2^32 -1 ，其中元素没有顺序， 常用命令 命令 说明 cli 命令示例 PHP SADD 添加元素 SADD key value [value1 value2 …] $redis-&gt;sAdd(‘key’, ‘set’); SREM 删除元素 SREM key value [value1 value3 …] $redis-&gt;sRem(‘key’, ‘set’); SMEMBERS 获取集合中所有元素 SMEMBERS key $redis-&gt;sMembers(‘key’); SISMEMBER 判断元素是否在集合中 SISMEMBER key value $redis-&gt;slsMember(‘key’, ‘value’); SDIFF 对集合做差集运算 SDIFF key1 key2 [key3 …] $redis-&gt;sDiff(‘key1’, ‘key2’, ‘key3’); SINTER 对集合做交集运算 SINTER key1 key2 [key3 …] $redis-&gt;sInter(‘key1’, ‘key2’, ‘key3’); SUNION 对集合做并集运算 SUNION key1 key2 [key3 …] $redis-&gt;sUnion(‘key1’, ‘key2’, ‘key3’); SCARD 获得集合中元素的个数 SCARD key $redis-&gt;sCard(‘key1’); SDIFFSTORE 对集合做差集运算并将结果存储 SDIFFSTORE destination key1 key2 [key3] $redis-&gt;sDiffStore(‘output’, ‘key1’, ‘key2’); SINTERSTORE 对集合做交集运算并将结果存储 SINTERSTORE destination key1 key2 [key3] $redis-&gt;sInterStore(‘output’, ‘key1’, ‘key2’); SUNIONSTORE 对集合做并集运算并将结果存储 SUNIONSTORE destination key1 key2 [key3] $redis-&gt;sUnionStore(‘output’, ‘key1’, ‘key2’); SRANDMEMBER 随机获取集合中的元素 SRANDMEMBER key [count] $redis-&gt;sRandMember(‘key1’, 2); SPOP 随机弹出一个元素 SPOP key $redis-&gt;sPop(‘key1’); 示例：查并集在 Redis 中添加南北方拥有的商品，然后在 PHP 中进行显示 12SADD cache_bei apple peach pearSADD cache_nan apple banana avocado 1234567891011121314151617181920&lt;?php$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379);$bei = $redis-&gt;sMembers('cache_bei');$nan = $redis-&gt;sMembers('cache_nan');echo '北方有的商品：&lt;br&gt;';print_r($bei);echo '&lt;br&gt;';echo '南方有的商品：&lt;br&gt;';print_r($nan);echo '&lt;br&gt;';echo '两个地方都有的商品：&lt;br&gt;';print_r($redis-&gt;sInter('cache_bei', 'cache_nan'));echo '&lt;br&gt;';echo '两个地域所有的商品：&lt;br&gt;';print_r($redis-&gt;sUnion('cache_bei', 'cache_nan')); Zset有序集合看名字我们就会知道和上面的集合用法是类似的，不过它是有序的，有序也就意味着每一个元素在插入的时候系统都会给他指定一个分数，然后根据分数高低进行排序，跟集合一样，它也是禁止重复的，分数是可以相同的，有序集合是使用散列表和跳跃表来进行实现的，这也就意味着，如果要去读写中间的数据时非常快的， 常用命令 命令 说明 cli 命令示例 PHP ZADD 添加元素 ZADD key score value[ score2 value2 …] $redis-&gt;zAdd(‘key’,1,’val1’); ZSCORE 设置元素的分数 ZSCORE key value $redis-&gt;zScore(‘key’, val2); ZRANGE 获取正序排名在某范围的元素 ZRANGE key start stop [WITHSCORE] $redis-&gt;zRange(‘key1’, 0, -1); ZREVRANGE 获取倒序排名在某范围的元素 ZREVRANGE key start stop [WITHSCORE] $redis-&gt;zRevRange(‘key’, 0, -1); ZRANGEBYSCORE 获取指定分数范围内的元素 ZRANGEBYSCORE key min max $redis-&gt;zRangeByScore(key, start,end, [withscores, limit]); ZINCRBY 增加某个元素的分数 ZINCRBY key increment value $redis-&gt;zIncrBy(‘key’, increment, ‘member’); ZCARD 获取集合中元素的个数 ZCARD key $redis-&gt;zSize(‘key’); ZCOUNT 获取指定分数范围内的元素个数 ZCOUNT key min max $redis-&gt;zCount(key, start ,end); ZREM 删除一个或多个元素 ZREM key value1 [value2] $redis-&gt;zDelete(‘key’, ‘val’); ZREMRANGEBYRANK 按照排名范围删除元素 ZREMRANGEBYRANK key start stop $redis-&gt;zRemRangeByRank(‘key’, 0, 1); ZREMRANGEBYSCORE 按照分数范围删除元素 ZREMRANGEBYSCORE key start stop $redis-&gt;zRemRangeByScore(‘key’, 0, 3); ZRANK 获取正序排序的元素的排名 ZRANK key value $redis-&gt;zRank(key, val); ZREVRANK 获取逆序排序的元素的排名 ZREVRANK key value $redis-&gt;zRevRank(key, val); 案例：按照评分给小说排名首先还是模拟评分直接在 cli 中添加数据： 123456ZADD book_rank 1 冰火魔厨ZADD book_rank 2 琴魔ZADD book_rank 3 酒神ZADD book_rank 3 天火大道ZADD book_rank 5 斗罗大陆ZADD book_rank 5 惟我独仙 然后在 PHP 中使用倒序排列输出排名为前五的小说 1234567891011&lt;?php$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379);$books = $redis-&gt;zRevRange('book_rank', 0 ,4, true);$count = $redis-&gt;zSize('book_rank');echo '当前一共有'.$count.'本书，显示排名前五的书籍&lt;br&gt;';foreach ($books as $key =&gt; $value) &#123; echo '《'.$key.'》的评分为:'.$value.'星&lt;br&gt;';&#125; 合理的使用 Redis 防止内存站满： 设置超时时间，如果把 redis 定位成一个缓存使用，键值一定要设置一个超时时间，如果不设置的话 key 会一直占着内存，造成非常大的浪费，而且随着时间的推移，内存的占用率越来越大，如果有一天达到内存上限，Redis 就会不断的进行持久化，另外一个 key 的时长进行综合评估，也不是越长越好，太长了其实跟没有超时时间没有太大区别。 不存方过大文件，一般来说 Redis 每一个键在存储数据的时候不要超过500字节，要是超过的话一定要想办法先压缩一下然后在进行储存，Redis 是将数据放到内存中的，如果把太大的东西丢进 Redis 里面肯定会浪费一定的内存的。还有就是数据是需要来回传递的，当访问量非常高的时候，你里面还带了一个非常大的文件，来回的传输，很有可能就把带宽占用满了，其他的服务就不可用。 不存不常用数据，Redis 比较适合存放一些热数据，所以我们要把冷热数据进行分离，冷数据比较适合放在 Mysql 之中，在 Redis 应该存一些比较高频的数据，把一些不长用的数据放在 Redis 中就太有点浪费资源了。Redis 存储数据量小的时候，速度肯定要快一些。不同的业务数据最好分开存储，不要把一些不相关的业务数据都放到一个 Redis 实例里面。 提高使用效率 合理使用不同的数据类型：Redis 支持的类型非常的多，根据不同业务的业务场景，来使用不同的数据结构，不同的字段类型适用场景是不一样的。 慎用正则处理或批量操作 Hash、Set 等：这是一个非常恐怖的操作，Hash 和 Set 本身就是一个很大的数据，然后在批量操作的话很要命的，因为 Redis 是单线程的，如果线上 Key 非常多的时候，如果再进行正则匹配效率会非常的低，效率一旦低下来，就会堵塞其他命令的运行。如果在批量操作 Hash 的时候，是需要把 feild 也进行一次操作的， 所以说不要以为 Redis 是万能的，最终他还是要消耗 CPU 的。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"","slug":"2017-10-19 PHP 基础面试圈覆盖（09）：会话控制","date":"2018-07-02T13:52:36.919Z","updated":"2018-07-02T13:52:36.919Z","comments":true,"path":"2018/07/02/cjlz9pqvk0002abrdvng0god9/","link":"","permalink":"http://www.maksim.website/2018/07/02/cjlz9pqvk0002abrdvng0god9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"排序算法图解","slug":"2018-06-30 排序算法图解","date":"2018-06-29T16:00:00.000Z","updated":"2018-09-03T14:45:38.654Z","comments":true,"path":"2018/06/30/1/","link":"","permalink":"http://www.maksim.website/2018/06/30/1/","excerpt":"","text":"这篇博文是来自 https://www.awaimai.com/1980.html，但是都是基于面向过程的代码编写，我用面向对象的方式重新实现了一边，并且按照自己的写作习惯进行了重新编辑。 在 PHP 日常开发过程中，接触算法的机会并不多，大多数PHP 程序员都是在进行 CURD 的操作，甚至连数据结构的接触也很局限，并且大多数培训班很少回去讲解数据结构与算法，这也导致了 PHP 程序员的水平参差不齐，但是无论是进阶，还是跳槽到 BAT 这样的大公司算法都是一道绕不过去的坎，光是在算法上躺下的程序员就不在少数。 这也是一道程序员的分水岭之一，掌握算法能够利于我们开发出更加高效的软件，毕竟程序=数据结构+算法。这是每一个科班出身的人第一天上数据结构与算法这门课要学习的第一句话，排序算法是程序员必须掌握的基础内容。 （未完成，编写工作还在进行） 1 快速排序快速排序是由东尼·霍尔发展的一种排序算法。 在平均状况下，排序n个项目要Ο(nlog n)次比较。 在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。 事实上，快速排序通常明显比其他Ο(nlog n)算法更快，因为它的内部循环可以在大部分的架构上，很有效率地被实现出来。 快速排序采用分治法实现排序，具体步骤： 从数列中挑出一个数作为基准元素。通常选择第一个或最后一个元素。 扫描数列，以基准元素为比较对象，把数列分成两个区。规则是：小的移动到基准元素前面，大的移到后面，相等的前后都可以。分区完成之后，基准元素就处于数列的中间位置。 然后再用同样的方法，递归地排序划分的两部分。 递归的结束条件是数列的大小是0或1，也就是永远都已经被排序好了。 PHP代码实现： 1234567891011121314151617181920212223242526272829303132function quickSort($arr) &#123; // 先设定结束条件，判断是否需要继续进行 if(count($arr) &lt;= 1) &#123; return $arr; &#125; // 选择第一个元素作为基准元素 $baseValue = $arr[0]; // 初始化小于基准元素的左数组 $leftArray = array(); // 初始化大于基准元素的右数组 $rightArray = array(); // 遍历除基准元素外的所有元素，按照大小关系放入左右数组内 array_shift($arr); foreach ($arr as $value) &#123; if ($value &lt; $baseValue) &#123; $leftArray[] = $value; &#125; else &#123; $rightArray[] = $value; &#125; &#125; // 再分别对左右数组进行相同的排序 $leftArray = quickSort($leftArray); $rightArray = quickSort($rightArray); // 合并基准元素和左右数组 return array_merge($leftArray, array($baseValue), $rightArray);&#125; 2 冒泡排序冒泡排序是一种简单的排序算法。 算法重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 走访数列的工作重复地进行，直到没有再需要交换，也就是说该数列已经排序完成。 因为排序过程让较大的数往下沉，较小的往上冒，故而叫冒泡法。 算法步骤： 从第一个元素开始，比较相邻的元素，如果第一个比第二个大，就交换他们两个。 从开始第一对到结尾的最后一对，对每一对相邻元素作同样的工作。比较结束后，最后的元素应该会是最大的数。 对所有的元素重复以上的步骤，除了最后一个。 重复上面的步骤，每次比较的对数会越来越少，直到没有任何一对数字需要比较。 PHP代码实现： 12345678910111213141516function bubbleSort($arr)&#123; $len = count($arr); for($i = 1; $i &lt; $len; $i++) &#123; for($k = 0; $k &lt; $len - $i; $k++) &#123; if($arr[$k] &gt; $arr[$k + 1]) &#123; $tmp = $arr[$k + 1]; $arr[$k + 1] = $arr[$k]; $arr[$k] = $tmp; &#125; &#125; &#125; return $arr;&#125; 3 插入排序插入排序是一种简单直观的排序算法。 插入排序的工作原理是：将需要排序的数，与前面已经排好序的数据从后往前进行比较，使其插入到相应的位置。 插入排序在实现上，通常采用in-place排序，即只需用到O(1)的额外空间的排序。 因而，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 算法步骤： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果以排序的元素大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置中； 重复步骤2。 PHP代码实现： 12345678910111213141516171819202122&lt;?phpclass InsertionSort&#123; public static function sort(array &amp;$arr) &#123; $count = count($arr); if ($arr == null || $count &lt; 2) &#123; return; &#125; for ($i = 1; $i &lt; $count ; $i++) &#123; for ($j = $i - 1; $j &gt;= 0 &amp;&amp; $arr[$j] &gt; $arr[$j + 1]; $j--) &#123; self::swap($arr, $j, $j + 1); &#125; &#125; &#125; public static function swap(array &amp;$arr, $i, $j) &#123; $arr[$i] = $arr[$i] ^ $arr[$j]; $arr[$j] = $arr[$i] ^ $arr[$j]; $arr[$i] = $arr[$i] ^ $arr[$j]; &#125;&#125; 4 选择排序选择排序是一种简单直观的排序算法。 算法步骤： 首先，在序列中找到最小元素，存放到排序序列的起始位置； 接着，从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 PHP代码实现： 1234567891011121314151617181920function selectSort($arr)&#123; $len = count($arr); for ($i = 0; $i &lt; $len; $i++) &#123; $p = $i; for ($j = $i + 1; $j &lt; $len; $j++) &#123; if ($arr[$p] &gt; $arr[$j]) &#123; $p = $j; &#125; &#125; $tmp = $arr[$p]; $arr[$p] = $arr[$i]; $arr[$i] = $tmp; &#125; return $arr;&#125; 5 归并排序归并排序是建立在归并操作上的一种有效的排序算法。 归并排序将待排序的序列分成若干组，保证每组都有序，然后再进行合并排序，最终使整个序列有序。 该算法是采用分治法的一个非常典型的应用。 算法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 排序效果： PHP实现代码： 1234567891011121314151617181920212223242526272829303132333435/** * 归并排序 * * @param array $lists * @return array */function merge_sort(array $lists)&#123; $n = count($lists); if ($n &lt;= 1) &#123; return $lists; &#125; $left = merge_sort(array_slice($lists, 0, floor($n / 2))); $right = merge_sort(array_slice($lists, floor($n / 2))); $lists = merge($left, $right); return $lists;&#125;function merge(array $left, array $right)&#123; $lists = []; $i = $j = 0; while ($i &lt; count($left) &amp;&amp; $j &lt; count($right)) &#123; if ($left[$i] &lt; $right[$j]) &#123; $lists[] = $left[$i]; $i++; &#125; else &#123; $lists[] = $right[$j]; $j++; &#125; &#125; $lists = array_merge($lists, array_slice($left, $i)); $lists = array_merge($lists, array_slice($right, $j)); return $lists;&#125; 6 堆排序堆排序是指利用堆这种数据结构所设计的一种排序算法。 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆排序的平均时间复杂度为Ο(nlogn) 。 算法步骤： 创建一个堆H[0..n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小1，并调用shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤2，直到堆的尺寸为1。 PHP实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 堆排序 * * @param array $lists * @return array */function heap_sort(array $lists)&#123; $n = count($lists); build_heap($lists); while (--$n) &#123; $val = $lists[0]; $lists[0] = $lists[$n]; $lists[$n] = $val; heap_adjust($lists, 0, $n); //echo \"sort: \" . $n . \"\\t\" . implode(', ', $lists) . PHP_EOL; &#125; return $lists;&#125;function build_heap(array &amp;$lists)&#123; $n = count($lists) - 1; for ($i = floor(($n - 1) / 2); $i &gt;= 0; $i--) &#123; heap_adjust($lists, $i, $n + 1); //echo \"build: \" . $i . \"\\t\" . implode(', ', $lists) . PHP_EOL; &#125; //echo \"build ok: \" . implode(', ', $lists) . PHP_EOL;&#125;function heap_adjust(array &amp;$lists, $i, $num)&#123; if ($i &gt; $num / 2) &#123; return; &#125; $key = $i; $leftChild = $i * 2 + 1; $rightChild = $i * 2 + 2; if ($leftChild &lt; $num &amp;&amp; $lists[$leftChild] &gt; $lists[$key]) &#123; $key = $leftChild; &#125; if ($rightChild &lt; $num &amp;&amp; $lists[$rightChild] &gt; $lists[$key]) &#123; $key = $rightChild; &#125; if ($key != $i) &#123; $val = $lists[$i]; $lists[$i] = $lists[$key]; $lists[$key] = $val; heap_adjust($lists, $key, $num); &#125;&#125; 7 希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。 但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 算法步骤： 先将整个待排序的记录序列分割成为若干子序列，分别进行直接插入排序 待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 PHP实现代码： 12345678910111213141516171819202122232425/** * 希尔排序 标准 * * @param array $lists * @return array */function shell_sort(array $lists)&#123; $n = count($lists); $step = 2; $gap = intval($n / $step); while ($gap &gt; 0) &#123; for ($gi = 0; $gi &lt; $gap; $gi++) &#123; for ($i = $gi; $i &lt; $n; $i += $gap) &#123; $key = $lists[$i]; for ($j = $i - $gap; $j &gt;= 0 &amp;&amp; $lists[$j] &gt; $key; $j -= $gap) &#123; $lists[$j + $gap] = $lists[$j]; $lists[$j] = $key; &#125; &#125; &#125; $gap = intval($gap / $step); &#125; return $lists;&#125; 8 基数排序基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 说基数排序之前，我们简单介绍桶排序： 桶排序是将阵列分到有限数量的桶子里。 每个桶子再个别排序，有可能再使用别的排序算法，或是以递回方式继续使用桶排序进行排序。 桶排序是鸽巢排序的一种归纳结果。 当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间O(n)。 但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。 简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。 例如，要对大小为[1..1000]范围内的n个整数A[1..n]排序 首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储 (10..20]的整数，……集合B[i]存储( (i-1)10, i10]的整数，i = 1,2,..100。总共有 100个桶。 然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。 再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任 何排序法都可以。 最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这 样就得到所有数字排好序的一个序列了。 假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。 如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是 O(n + m n/mlog(n/m)) = O(n + nlogn – nlogm) 从上式看出，当m接近n的时候，桶排序复杂度接近O(n) 当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的 ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。 前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是： 1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。 2）其次待排序的元素都要在一定的范围内等等。 123456789101112131415161718192021222324252627/** * 基数排序 * * @param array $lists * @return array */function radix_sort(array $lists)&#123; $radix = 10; $max = max($lists); $k = ceil(log($max, $radix)); if ($max == pow($radix, $k)) &#123; $k++; &#125; for ($i = 1; $i &lt;= $k; $i++) &#123; $newLists = array_fill(0, $radix, []); for ($j = 0; $j &lt; count($lists); $j++) &#123; $key = $lists[$j] / pow($radix, $i - 1) % $radix; $newLists[$key][] = $lists[$j]; &#125; $lists = []; for ($j = 0; $j &lt; $radix; $j++) &#123; $lists = array_merge($lists, $newLists[$j]); &#125; &#125; return $lists;&#125; 9 总结各种排序的稳定性，时间复杂度、空间复杂度、稳定性总结如下图： 关于时间复杂度： (1)平方阶(O(n2))排序 各类简单排序:直接插入、直接选择和冒泡排序； (2)线性对数阶(O(nlog2n))排序 快速排序、堆排序和归并排序； (3)O(n1+§))排序,§是介于0和1之间的常数。 希尔排序 (4)线性阶(O(n))排序 基数排序，此外还有桶、箱排序。 关于稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"PHP基础教程：Memcache","slug":"2018-06-29 PHP基础教程：memcache","date":"2018-06-28T16:00:00.000Z","updated":"2018-09-03T14:45:49.156Z","comments":true,"path":"2018/06/29/1/","link":"","permalink":"http://www.maksim.website/2018/06/29/1/","excerpt":"","text":"什么是MemcacheMemcache是一个自由、源码开放、高性能、分布式的分布式内存对象缓存系统 ，用于动态Web应用以减轻数据库的负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高了网站访问的速度。Memcache是一个存储键值对的HashMap，在内存中对任意的数据（比如字符串、对象等）所使用的key-value存储，数据可以来自数据库调用、API调用，或者页面渲染的结果。MemCache设计理念就是小而强大，它简单的设计促进了快速部署、易于开发并解决面对大规模的数据缓存的许多难题，而所开放的API使得MemCache能用于Java、C/C++/C#、Perl、Python、PHP、Ruby等大部分流行的程序语言。 MemCache 和 MemCached： MemCache是这个项目的名称，而MemCached是服务器端的主程序名称。 Memcache使用场景通常，我们会在访问量高的Web网站和应用中使用Memcache，用来缓解数据库的压力，并且提升网站和应用的响应速度。 在应用程序中，我们通常在以下节点来使用MemCached： 访问频繁的数据库数据（身份token、首页动态） 访问频繁的查询条件和结果 作为Session的存储方式（提升Session存取性能） 页面缓存 更新频繁的非重要数据（访客量、点击次数） 大量的hot数据 安装Memcache我们在Linux上安装软件一般会采取两种方案，一种是编译安装，另外一种是使用Linux系统为我们提供的包管理工具。 在安装Memcache之前，我们需要提前安装Libevent，因为Memcache的实现依赖于这个库。 编译安装的好处是我们可以自定义一些设置，比如说安装到指定的目录下，相对而言假如你在编译时发生一些错误，而你对Linux又不是特别了解的话，可能处理错误时比较困难。 1yum install -y memcached 启动memcache 1memcached -d -l 127.0.0.1 -p 11211 -m 150 -u root -d 守护进程 -l IP地址 -p 端口号 -m 分配内存 -u 以什么用户进行运行（在线上不建议使用 root） 客户端的安装过程安装PHP的memcahed扩展需要» libmemcached客户端库（版本大于等于 1.0.0）。链接 memcached 服务器时使用SASL认证，需要libmemcached 必须开启SASL选项。 Memcached从0.2.0开始，要求PHP版本大于等于5.2.0。 如果libmemcached被安装在一个非标准路径，使用–with-libmemcached-dir=DIR 来指定路径，DIR就是libmemcached安装时的prefix参数。这个路径需要包含文件include/libmemcached/memcached.h。 如果要支持压缩就需要zlib。对于非标准安装的zlib库，使用–with-zlib-dir=DIR 来指定zlib安装路径，DIR就是zib安装时的prefix参数。 session处理器的支持默认是开启的。如果要关闭它，使用选项–disable-memcached-session 。 （未完待续….）","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"数据结构入门（04）： 链表","slug":"2018-05-05 数据结构入门（05）：链表","date":"2018-05-04T16:00:00.000Z","updated":"2018-08-04T02:46:56.325Z","comments":true,"path":"2018/05/05/1/","link":"","permalink":"http://www.maksim.website/2018/05/05/1/","excerpt":"","text":"这篇文章依旧是介绍线性数据结构——链表。 在前面的几篇文章中，我们也介绍了其他的线性结构：动态数组、栈、队列。这三种数据结构，底层依托的都是静态数组，靠resize 解决固定容量问题。 而链表则是真正的动态数据结构，对于链表来说，他是数据结构学习科目中的一个重点，也是一个难点，首先他是最简单的动态数据结构，在接下来，我们还会接触更多的动态数据结构，最典型的二分搜索树，都是动态数据结构，如果有更好的链表基础的话，对于后面的学习将会变的容易很多。 对于链表而言，涉及到计算机领域非常重要的概念，也就是引用或者是指针这个概念和内存相关，在 Java 或者 PHP 中我们并不需要手动的管理内存，但是对于链表这种数据结构更深入的了解，能够帮助大家对引用和指针，甚至是计算机系统中和内存管理相关管理话题有更深的认识。 很多人会忽视的一点，链表本身也是有它非常清晰的递归结构的，只不过由于链表是一种线性结构所以我们依然可以使用循环的方式来进行操作，但是链表本身天生就是具有递归结构的性质的所以他也是一个帮助同学们了解递归机制的相应的数据结构，当我们学习更加复杂的树形结构的时候，递归这种逻辑机制深入的理解是必不可缺的，对于本文章后面所涉及的递归问题也会进行介绍。 链表这种数据结构本身也具有功能性，他可以用来组织更加复杂的数据结构，比如说图结构，Hash 表等，栈和队列也可以用链表进行实现。 链表 Linked List 的数据结构数据存储在“节点”(Node) 中 1234class Node &#123; T value; Node next;&#125; 在 Value 中存储着我们所需要使用的真正数据，而 next 是一个 Node 类型的对象，next 本身又是一个节点，看单词的字面意思就知道，他指向的是这个节点的下一个节点。 对于链表来说就像是一个火车一样，每一个节点就像是一个车厢一样，在车厢中存储着我们需要使用的东西，而车厢和车厢之间，需要存在一个连接，以使得数据时整个在一起的，用户可以方便的在这个链表上进行查询或者其他的操作。 数据和数据之间的链接就是由 next 完成的。 链表当然不会是无穷无尽的，链表的最后一个节点存储就是一个 NULL，如果一个节点为空了，那么就是最后一个节点，通过上面的这些内容，希望大家能够理解，什么真正的动态，这样我们就不需要处理固定容量的问题。 对于链表来说，你需要存储个多少个数据，只要创建多少个节点，然后连接起来，当然链表也并不是没有缺点，对比数组而言，它丧失了随机访问的能力，也就是说不能给一个索引就能直接取出索引下对应的数据。链表由于是靠 next 一层一层链接的，我们必须靠 next 逐层寻找。 所以链表自然也就不适合索引有语意的情况。 链表的实现对于链表而言，他是由内部类组成的，所以我们需要在类中声明一个内部类。也就是说只有在 LinkedList 类中才可以放到 Node 这个类，可能有一些教材或者教科书，会将 Node 设计成一个外部共用的类，这是一个设计上的问题，个人倾向于设计成一个私有的内部类。 对于用户而言，没有必要清楚链表是怎样实现的，根本不需要知道链表内部有个 node，他只需要知道是链表是一个线性结构，可以增加、删除数据就可以了。 我们要对用户屏蔽内部实现的细节。 123456789101112131415161718192021222324252627package Linked;public class LinkedList &lt;T&gt; &#123; class Node &#123; public T value; public Node next; public Node() &#123; this(null, null); &#125; public Node (T value) &#123; this(value, null); &#125; public Node (T value, Node next) &#123; this.value = value; this.next = next; &#125; @Override public String toString() &#123; return value.toString(); &#125; &#125; &#125; 这样就设计好了节点。 对于链表来说，我们要向访问链表中所有的节点，相应的我们必须把链表的头存储起来 head，也就是说在 LinkedList应该有一个Node 型的变量叫做 head 指向链表中的第一个节点。 1234567891011121314151617//记录拥有多少个节点private int size;//存放头节点private Node head;public LinkedList() &#123; head = null; size = 0;&#125;public int getSize() &#123; return size;&#125; public boolean isEmpty() &#123; return size == 0;&#125; 为数组尾添加元素是非常方便的，但是对于链表而言情况恰好相反，我们在链表头添加元素是非常方便的，对于数组而言，因为有 size 在跟踪数组的尾巴，我们直接向其中插入数据就可以了，但是对于链表来说，我们设计了一个 head跟踪链表的头，但是我们没有变量跟踪链表的尾巴。 我们在链表头添加元素会很方便，只需要将新来的 Node 中的 next 指向 head，然后将 head 变量指向新来的 Node 就可以了。 12node.next = headhead = node 下面实现在链表头添加新的元素 1234567public void addFirst(T value) &#123; Node node = new Node(value); node.next = head; head = node; //也可以将上面的三行代码替换成 head = new Node(e, head);可以自己想一想是为什么！ size++;&#125; 现在想要在‘索引’为2的地方添加一个新的元素，我们首先要创建 node，如果想要将节点插入到正确的位置，我们首先就是要找到","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.maksim.website/categories/数据结构与算法/"}],"tags":[]},{"title":"数据结构入门（03）： 队列","slug":"2018-05-04 数据结构入门（04）：队列","date":"2018-05-03T16:00:00.000Z","updated":"2018-07-21T06:29:08.188Z","comments":true,"path":"2018/05/04/1/","link":"","permalink":"http://www.maksim.website/2018/05/04/1/","excerpt":"","text":"队列 Queue 本身也是一种线性结构，依然是排成一排，相比数组，队列对应的操作也是数组的子集，不过和栈不同，我们只能从一端（队尾）添加元素，只能从另一端（队首）取出元素。我们可以将其想象成我们现实生活中的排队，第一个来的，要第一个出去。也就是说队列是一种先进先出（First In First Out[FIFO]）的数据结构。 队列的实现队列我们只要要实现以下方法 Queue\\ void enqueue(E) E dequeue() E getFornt() int getSize() boolean isEmpty() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package Array;public class ArrayQueue&lt;T&gt; &#123; private Array&lt;T&gt; array; public ArrayQueue(int capacity) &#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayQueue() &#123; array = new Array&lt;&gt;(); &#125; public int getSize() &#123; return array.getSize(); &#125; public boolean isEmpty() &#123; return array.isEmpty(); &#125; public int getCapacity() &#123; return array.getCapacity(); &#125; public void enqueue(T e) &#123; array.addLast(e); &#125; public T dequeue() &#123; return array.removeFirst(); &#125; public T getFront() &#123; return array.getFirst(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(String.format(\"Queue: \")); res.append(\"front [\"); for (int i = 0; i &lt; array.getSize(); i++) &#123; res.append(array.get(i)); if (i != array.getSize() -1) &#123; res.append(\",\"); &#125; &#125; res.append(']'); return res.toString(); &#125;&#125; 12345678910111213Queue: front [0] tailQueue: front [0,1] tailQueue: front [0,1,2] tailQueue: front [1,2] tailQueue: front [1,2,3] tailQueue: front [1,2,3,4] tailQueue: front [1,2,3,4,5] tailQueue: front [2,3,4,5] tailQueue: front [2,3,4,5,6] tailQueue: front [2,3,4,5,6,7] tailQueue: front [2,3,4,5,6,7,8] tailQueue: front [3,4,5,6,7,8] tailQueue: front [3,4,5,6,7,8,9] tail 循环队列数组队列是有局限性的，主要是在于出队这个操作，他的时间复杂度是 O(N) ，当我们删除队首时候，后面的元素都要向前移动一位，这是数组实现队列删除元素走的这样的一个过程，所以他的时间复杂度是O(N)。 如果我们删除首位后，其他位置不向前移动，因为这样后面的元素，还是保持着队列的样子，所以可以在数组中记录队首是谁 (front)，如果删除了队首[0]，那么就将队首的位置设置成[1]。 这种数据结构也就是循环队列。 当队列中一个内容都没有的时候，front(队首)和 tail 队尾指向是在一起的。 也就是说，当front == tail 的时候，就说明队列为空，只要数组内容不为空，tail 和 front 就不可能相等，当有内容入队了，我们只需要维护 tail 将其指向下一个元素要入队时的位置就可以了，也就是 tail++。 如果此时队列中已经拥有五个元素了，当我们要进行出队时，只需要将front 指向的元素出队，并且维护 front 向后移动一位。 我们可以看出循环队列不再要求所有的元素进行移动了，只需要维护 front 的指向改变就可以了。 现在结构相对简单，但是并不能体现出循环，当入队的元素达到了容量的上限时，tail 就不能再向后移动了。 从上图我们可以看到，由于队首的元素移出数组之后余下的空间，没有被后面的数据占用，所以前面也许还有可以利用的空间，这就是循环队列的来由。 其实我们就是把我们的数组看成一个环，现在的数组一共可以容纳8个元素，索引是0到7，7之后的索引其实是0，而此时我们就可以判断数组空间已经被沾满了， 上面我们说过维护 tail 就是 ++ 运算，但是如果是循环队列就不准确了，应该是： 1（当前索引 + 1） % 数组的长度 从7计算到0，就是 (7 + 1) % 8 = 0。0这位置还能放心的元素，如果再次加入元素，新的元素就会被放置到0这个位置上。 \\ 现在到了这种情况，1这个位置是空的，那么是否还能在向其中插入元素呢？ 需要注意的是，我们之前提到过 front == tail 队列为空，如果再有一个新的元素入队了，放到[1]这个位置上，我们的 tail 就会与 front 相等，这个时候，我们的队列其实并不为空，如果还让新的元素可以进来的话，front == tail 既可以表示队列为空，又可以便是队列为满了，这并不是我们希望看到的条件。 队列满我们应该用 （tail + 1） % capacity == 0。 当我们在进行入队操作时，发现队列以满之后就可以扩容了，也就是说这样会被浪费掉一个空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class LoopQueue&lt;T&gt; &#123; private T[] data; private int front, tail; private int size; public LoopQueue(int capactiy) &#123; //因为循环队列会浪费一个空间，所以应该是传递的容积+1。 data = (T[])new Object[capactiy+1]; front = 0; tail = 0; size = 0; &#125; public LoopQueue() &#123; //因为循环队列会浪费一个空间，所以应该是传递的容积+1。 this(10); &#125; public int getCapactiy() &#123; return data.length - 1; &#125; public boolean isEmpty() &#123; return front == tail; &#125; public int getSize() &#123; return size; &#125; public void enqueue(T e) &#123; if ((tail + 1) % data.length == front) &#123; resize(getCapactiy() * 2); &#125; data[tail] = e; tail = (tail + 1) % data.length; size++; &#125; public T dequeue() &#123; if (isEmpty()) &#123; throw new IllegalArgumentException(\"Cannot dequeue from an empty queue!\"); &#125; T ret = data[front]; data[front] = null; front = (front + 1) % data.length; size--; //如果限制的空间达到了当前容积的1/4进行缩容，节省空间 if (size == getCapactiy() / 4 &amp;&amp; getCapactiy() / 2 != 0) &#123; resize(getCapactiy() / 2); &#125; return ret; &#125; private void resize(int newCapacity) &#123; T[] newData = (T[])new Object[newCapacity + 1]; for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[(i + front) % data.length]; &#125; data = newData; front = 0; tail = size; &#125; public T getFront() &#123; if (isEmpty()) &#123; throw new IllegalArgumentException(\"Queue is empty!\"); &#125; return data[front]; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(String.format(\"Queue: size = %d, capacity = %d \\n\", size, getCapactiy())); res.append(\"front [\"); for (int i = front; i != tail; i = (i + 1) % data.length) &#123; res.append(data[i]); if ((i + 1 ) % data.length != tail) &#123; res.append(\",\"); &#125; &#125; res.append(\"] tail\"); return res.toString(); &#125; public static void main(String[] args) &#123; LoopQueue&lt;Integer&gt; queue = new LoopQueue&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; queue.enqueue(i); System.out.println(queue); if ( i % 3 == 2) &#123; queue.dequeue(); System.out.println(queue); &#125; &#125; &#125; &#125; 数组队列和循环队列的比较我们可以从代码上直观的就可以看到，循环队列要比数组队列复杂很多，但是这种从代码上增加复杂度的方式是值得的，因为数组队列在每一次出队操作的时候，需要循环将后面的数据向前移动一位，这样一来时间复杂度是 O（N），而循环队列的出队复杂度则是 O(1)。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.maksim.website/categories/数据结构与算法/"}],"tags":[]},{"title":"数据结构入门（03）：栈","slug":"2018-05-03 数据结构入门（03）：栈","date":"2018-05-02T16:00:00.000Z","updated":"2018-07-03T14:22:57.638Z","comments":true,"path":"2018/05/03/1/","link":"","permalink":"http://www.maksim.website/2018/05/03/1/","excerpt":"","text":"栈的应用今天给大家讲解一个全新的线性结构分别是栈和队列，在这一篇文章的前半部分我会首先讲解栈。 栈也是一种线性结构，比起数组，栈对应的操作是数组的子集。 栈只能从一端添加元素，也只能从一端取出元素，这一端也被称为栈顶。 向栈添加数据我们将其称之为入栈，如下图： 当我们想要取出数据时候，我们只能从栈顶取出数据，也就是说，我们首先取出的是3，然后才是2，1这样的一个顺序。 按照这个顺序执行，所以栈被称之为后进先出（Last In First Out [LIFO]）的数据结构。3其实是最后一个被放到栈中的数据，却是第一个被取出的数据。 在计算机世界里，栈拥有者不可思议的作用，事实上，在别的数据结构中还会看到栈的作用，甚至我们在学习经典算法或者算法设计的时候都将不可避免的看到栈，看起来很简单，但是应用起来非常广泛的数据结构。 无处不在的Undo操作（撤销） 程序调用所使用的系统栈 撤销操作其实很好理解，当我们在编辑器中输入内容时候，比如我们输入XXX、我、喜欢你，这一组数据的时候，其实就是一次入栈操作，依次将XXX、我、喜欢你、压入栈中。 当我们，感觉喜欢你，不如我爱你贴切的时候，可以执行撤销操作，将喜欢你从栈中取出来，然后输入爱你。 在我们系统执行中，总会碰到先终止，然后到另外的一个逻辑去执行，所谓的子函数的调用就是这个过程。这个时候，系统就会使用被称之为系统栈的数据结构，来记录程序调用的过程。我们同样通过画图的形式来带领大家理解。 通过上图中的业务逻辑，我们其实同时也可以很好的理解递归调用的原理，我们在上学时候，或者是在一些文章中总能看到说递归其实就是自己调用自己，这么说是为了让大家方便理解，但是其实真正的原理，就是系统帮助我们进行压栈。 栈的实现Stack\\ void push(E) 入栈 E pop() 出栈 E peek() 查看栈顶(top) int getSize() 获取栈的大小 boolean isEmpty(); 判断栈是否为空 从用户的角度来看，我们只需要支持这些操作就完全可以了。具体底层实现，用户是不关心的，实际上底层的实现有多重实现方法。 在这一篇文章中，我只介绍一种使用动态数组实现ArrayStack的栈，在后续文章中再去介绍另外一种实现方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package Array;public class ArrayStack&lt;T&gt; &#123; Array&lt;T&gt; array; public ArrayStack(int capacity) &#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayStack() &#123; array = new Array&lt;&gt;(); &#125; public int getSize() &#123; return array.getSize(); &#125; public boolean isEmpty() &#123; return array.isEmpty(); &#125; public int getCapacity() &#123; return array.getCapacity(); &#125; public void push (T e) &#123; array.addLast(e); &#125; public T pop() &#123; return array.removeLast(); &#125; public T peek() &#123; return array.getLast(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(\"Stack: [\"); for (int i = 0; i &lt; array.getSize(); i++) &#123; res.append(array.get(i)); if (i != array.getSize() - 1) &#123; res.append(\", \"); &#125; &#125; res.append(\"] top\"); return res.toString(); &#125;&#125; 注意其中的一段代码： 123public T peek() &#123; return array.getLast(); &#125; 在这里，我们复用来我们自己所编写的动态数组Array 类，但是并不完善，并没有提供 getLast 这个功能，其实这个很简单，只需要我们自己实现以下就好了，根据 Array.get 方法就可以轻松实现。 我们可以看得出来，整个栈的编写非常简单，没有任何复杂的代码，完全是使用我们自己所编写的 Array 类便可以轻松的实现。 括号匹配在我们编程的时候，编译器会自动匹配{}、[]、()，编译器其实也是使用栈结构来进行括号匹配的。 这是在 LeetCode 上的一道题，编号是20：https://leetcode-cn.com/problems/valid-parentheses/description/ 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 12输入: &quot;()&quot;输出: true 示例 2: 12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3: 12输入: &quot;(]&quot;输出: false 示例 4: 12输入: &quot;([)]&quot;输出: false 示例 5: 12输入: &quot;&#123;[]&#125;&quot;输出: true 如果当前我们有这样一串字符{[()]} 我们可以声明一个栈，然后遍历栈中的每一个字符，如果字符是一个左括号，我们就将他压入栈，第一个是{我们将其压栈，然后是[压栈，然后(压栈，这样左括号就全部压入了栈中，往后将是右括号，当走到）的时候，我们查看栈顶的括号是否可以和)匹配。 如果匹配，则表示通过了验证，然后出栈，然后在向右验证，直到栈中没有数据。其实就是栈顶元素反映了在嵌套层次关系中，最近的需要匹配的元素。 1234567891011121314151617181920212223242526class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length() ; i++) &#123; char c = s.charAt(i); if (c == '(' || c == '[' || c == '&#123;') &#123; stack.push(c); &#125; else &#123; if (stack.isEmpty()) &#123; return false; &#125; char topChar = stack.pop(); if (c == ')' &amp;&amp; topChar != '(') return false; if (c == ']' &amp;&amp; topChar != '[') return false; if (c == '&#125;' &amp;&amp; topChar != '&#123;') return false; &#125; &#125; //判断是否还有数据，如果还有数据则证明不完整，只有为空的时候则全都匹配上了。 return stack.isEmpty(); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.maksim.website/categories/数据结构与算法/"}],"tags":[]},{"title":"数据结构入门（02）：算法复杂度的分析","slug":"2018-05-02 数据结构入门（02）：算法复杂度的分析","date":"2018-05-01T16:00:00.000Z","updated":"2018-06-30T09:15:30.390Z","comments":true,"path":"2018/05/02/1/","link":"","permalink":"http://www.maksim.website/2018/05/02/1/","excerpt":"","text":"算法这一个词汇这两年异常的火爆，就算不是计算机从业人员也对算法如雷贯耳，AlphaGo狂虐各国高手，算法多么多么牛*。 但是身为计算机从业人员，我们要知道对于一个给定的算法，我们要做两项分析。第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。 而在证明算法是正确的基础上，第二部就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。因此，作为程序员，掌握基本的算法时间复杂度分析方法是很有必要的。 算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。 事后统计的方法 事前分析估算 这种方法可行，但不是一个好的方法。该方法有两个缺陷：一是要想对设计的算法的运行性能进行评测，必须先依据算法编制相应的程序并实际运行；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优势。 因事后统计方法更多的依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。因此人们常常采用事前分析估算的方法。 在编写程序前，依据统计方法对算法进行估算。一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 算法采用的策略、方法； 编译产生的代码质量； 问题的输入规模； 机器执行指令的速度。 一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。 时间复杂度时间频度一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间复杂度在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度 另外，上面公式中用到的 Landau符号其实是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。 Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。 T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T (n)的上界是**C \\ f(n)。其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2n2+n +1) = O (3n2+n+3) = O (7n2 + n) = O ( n2 ) ，一般都只用O(n2)**表示就可以了。 注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。 在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 从图中可见，我们应该尽可能选用多项式阶O(nk)的算法，而不希望用指数阶的算法。 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!) 一般情况下，对一个问题（或一类算法）只需选择一种基本操作来讨论算法的时间复杂度即可，有时也需要同时考虑几种基本操作，甚至可以对不同的操作赋予不同的权值，以反映执行不同操作所需的相对时间，这种做法便于综合比较解决同一问题的两种完全不同的算法。 求解算法的时间复杂度的具体步骤是⑴ 找出算法中的基本语句； 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 ⑵ 计算基本语句的执行次数的数量级； 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 ⑶ 用大Ο记号表示算法的时间性能。 将基本语句执行次数的数量级放入大Ο记号中。 如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如： 123456789for (i=1; i&lt;=n; i++) &#123; x++; &#125; for (i=1; i&lt;=n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; x++; &#125; &#125; 第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。 Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。 一般来说多项式级的复杂度是可以接受的，很多问题都有多项式级的解——也就是说，这样的问题，对于一个规模是n的输入，在n^k的时间内得到结果，称为P问题。有些问题要复杂些，没有多项式时间的解，但是可以在多项式时间里验证某个猜测是不是正确。比如问4294967297是不是质数？如果要直接入手的话，那么要把小于4294967297的平方根的所有素数都拿出来，看看能不能整除。还好欧拉告诉我们，这个数等于641和6700417的乘积，不是素数，很好验证的，顺便麻烦转告费马他的猜想不成立。大数分解、Hamilton回路之类的问题，都是可以多项式时间内验证一个“解”是否正确，这类问题叫做NP问题。 在计算算法时间复杂度时有以下几个简单的程序分析法则(1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间 (2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下”求和法则” 求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n))) 特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n)) (3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间 (4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下”乘法法则” 乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1T2=O(f(n)g(n)) (5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度 另外还有以下2个运算法则:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数 常见的时间复杂度进行示例说明(1)、O(1) 1Temp=i; i=j; j=temp; 以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。 注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 (2)、O(n2) 2.1. 交换i和j的内容 1234sum=0； （一次） for(i=1;i&lt;=n;i++) （n+1次） for(j=1;j&lt;=n;j++) （n2次） sum++； （n2次） 解：因为Θ(2n2+n+1)=n2（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n2)； 2.2. 123456for (i=1;i&lt;n;i++) &#123; y=y+1; ① for (j=0;j&lt;=(2*n);j++) &#123; x++; ② &#125; &#125; 解： 语句1的频度是n-1 语句2的频度是(n-1)(2n+1)=2*n2-n-1 f(n)=2n2-n-1+(n-1)=2n2-2； 又Θ(2n2-2)=n2该程序的时间复杂度T(n)=O(n2). 一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 (3)、O(n) 1234567a=0; b=1; ① for (i=1;i&lt;=n;i++) &#123; ② s=a+b; ③ b=a; ④ a=s; ⑤ &#125; 解： 语句1的频度：2, 语句2的频度： n, 语句3的频度： n-1, 语句4的频度：n-1, 语句5的频度：n-1, T(n)=2+n+3(n-1)=4n-1=O(n). (4)、O(log2n) 123i=1; ① while (i&lt;=n) i=i*2; ② 解： 语句1的频度是1, 设语句2的频度是f(n), 则：2^f(n)&lt;=n;f(n)&lt;=log2n 取最大值f(n)=log2n, T(n)=O(log2n ) (5)、O(n3) 123456for (i=0;i&lt;n;i++) &#123; for (j=0;j&lt;i;j++) &#123; for(k=0;k&lt;j;k++) x=x+2; &#125; &#125; 解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,…,m-1 , 所以这里最内循环共进行了0+1+…+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)1/2+…+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(*n3). 常用的算法的时间复杂度和空间复杂度 一个经验规则：其中c是一个常量，如果一个算法的复杂度为c 、 log2n 、n 、 n*log2n ,那么这个算法时间效率比较高 ，如果是2n ,3n ,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。 算法时间复杂度分析是一个很重要的问题，任何一个程序员都应该熟练掌握其概念和基本方法，而且要善于从数学层面上探寻其本质，才能准确理解其内涵。 算法的空间复杂度类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。 算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\\”进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。 如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。 【1】如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 12x=91; y=100;while(y&gt;0) if(x&gt;100) &#123;x=x-10;y--;&#125; else x++; 解答： T(n)=O(1)，这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?没。这段程序的运行是和n无关的，就算它再循环一万年，我们也不管他，只是一个常数阶的函数 【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 12345678x=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数： 则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3) 【3】算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。 在数值A[0..n-1]中查找给定值K的算法大致如下： 1234i=n-1; while(i&gt;=0&amp;&amp;(A[i]!=k)) i--; return i; 此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。 时间复杂度评价性能有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。 当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。 随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.maksim.website/categories/数据结构与算法/"}],"tags":[]},{"title":"数据结构入门（01）：数组","slug":"2018-05-01 数据结构入门（01）：数组","date":"2018-04-30T16:00:00.000Z","updated":"2018-06-29T16:02:18.236Z","comments":true,"path":"2018/05/01/1/","link":"","permalink":"http://www.maksim.website/2018/05/01/1/","excerpt":"","text":"数组基础数组其实就是把所有数据码成一排进行存放，数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。 在Java中数组所存放的类型是固定的，在 PHP 中数组是可以存储不同类型数据的。 数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 length - 1。 在这里我们需要注意，索引可以有语意；也可以没有语意。如上图，scores[2]这个索引2可以有实际的意义，上面的8个索引，可以代表八名学生的成绩，而索引可以代表他们的学号，那么scores[2]就是取2号学员的分数。 当我调用scores[2]的时候，我看的就是学号为2这个同学得了多少分，2是由实际的语意。当然也可以没有语意，这个0、1、2、3、4、5、6、7，只是简单的它存放在第几个元素而已，不代表学生的学号，就是恰好在2这个位置存了一个分，比如说是66分，存在任何索引的位置都可以，因为这个索引是没有语意的，我们只是想将分数存在数组中而已。 12345678910111213141516171819202122public class TestArray &#123; public static void main(String[] args) &#123; // 数组大小 int size = 8; // 定义数组 double[] scores = new double[8]; scores[0] = 55.6; scores[1] = 60.5; scores[2] = 30.3; scores[3] = 18.2; scores[4] = 43.0; scores[5] = 34.33; scores[6] = 34.0; scores[7] = 45.45; // 计算所有元素的总和 double total = 0; for (int i = 0; i &lt; size; i++) &#123; total += scores[i]; &#125; System.out.println(\"总和为： \" + total); &#125;&#125; 上面这段代码就是数组的操作，这里不再介绍其他语法，因为本文主要侧重于讲述数据结构，而不是Java的基础语法和使用。 数组最大的优点是快速查找，myList[2]，数组最好应用于“索引有语意”的情况。如果索引没有语义建议使用其他数据结构。 虽然如此，有很多场景即使我们可以给索引定义出语言，但是它可能并不适用使用数组，比如说身份证号，可以设计一个数组，存放一个人对应的工资情况，我想索引到不同的人，可能使用身份证号就是一个很好的方式。 身份证号：110103198512166666 但是我们不能使用身份证号做索引，因为这个数字太大了，我们要想使用这个数字当索引，我们至少要开辟身份证号那么大的空间，对于一般的计算机来说，开辟这么大的空间是不值当的，甚至是不可能的，更重要的是，我们就算开辟了这么大的空间，对于很多空间都是浪费的。 我们现在就要考察一个工作小组，里面只有十个人，为了十个人开辟这么大的空间显然是不合理的，很多空间明显是被浪费的，没有一个合法的身份证号是6666。 如果数组没有语意，又会产生很多新的问题。 在此时，数组只是一个待存放我们我们考察元素的一个空间，比如我们开辟了一个有八个元素的数组，但是可能我们只考察三个元素，此时就有问题了，剩下的空间就没有元素，当我们访问其余空间时就是非法的，因为从用户的角度来看，是没有3，4，5，6，7这些元素的，只有0、1、3，此时我们该如何表示没有的元素呢？ 与此同时我们还会向数组中提那家元素和删除元素，这些操作要如何做呢？ 还会有很多问题，最典型的就是我们的数组大小，在我们创建的时候就已经固定了，如果我们添加的元素，超过了八个我们要怎么做呢？ 这篇文章就会解决这些问题，但是我们要知道 Java 并没有提供这些功能，我们必须编写属于自己的方法，来为数组添加元素或者删除元素。 所以我们要基于 Java 的数组，二次封装一个属于我们自己的数组类。 封装属于我们自己的数组原本的数组属于静态数组，而我们要制作的是动态数组。 创建一个 Array 类，在其中封装一个 Java 的数组 data，针对data 进行增删改查，其实对于对于数据结构跟数据库是一样的，也是存储数据，之后在进行高效的操作，只不过我们设计的数据结构是把这些数据存储在内存中，针对这些数据结构添加的的操作，在大的类别上也是增删改查。 不过针对不同的数据结构，增删改查的方式是截然不同的，有的数据结构会忽略其中的某一个动作。 由于数组本身是静态的，也就是在我们创建的时候，就必须指定大小，将其称之为容量（capactiy）也就是数组空间最多装多少个元素。 但是要注意，我们的数组最多装多少个元素，和我们实际的装了多少个元素是没有关系的，我们数组中实际装了多少个元素，在 Array 类中用 size 变量控制。 当没有元素时，size 为0，也相当于指向了第一个没有盛放元素的相应的索引也就是0这个位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package Array;public class Array &#123; private int[] data; private int size; /** * 构造函数，传入数组的容量 capactiy 构造 Array * @param capactiy */ public Array(int capactiy) &#123; data = new int[capactiy]; &#125; /** * 无参数构造函数，默认数组的容量10 */ public Array() &#123; this(10); &#125; /** * 获取数组中元素的个数 * @return */ public int getSize()&#123; return size; &#125; /** * 获取数组的容量 * @return */ public int getCapacity() &#123; return data.length; &#125; /** * 返回数组是否为空 * @return */ public boolean isEmpty() &#123; return size == 0; &#125;&#125; 将 data 和 size 封装成了私有成员，因为不希望用户从外部直接获得这些数据的信息，否则就是危险的，data和 size 就会产生不一致的情况，比如说 data 中实际有三个有效的元素，size 本来也是三，但是 size 是公有的，用户就可以随意更改，这就破坏了类的封装性，这样在写程序的过程中有可能会产生更多 bug。 向数组添加元素向数组添加元素，最简单的形式就是向数组的末尾添加一个元素。向数组末尾添加元素，就等同于向 size 添加元素。因为 size 指向的是第一个没有盛放元素所对应的索引，添加完成后我们需要维护 size，此时多了一个元素所以 size 应该++。 1234567891011/** * 向数组末尾添加元素 * @param e */public void addLast(int e) &#123; if (size == data.length) &#123; throw new IllegalArgumentException(\"AddLast falid. Array is full\"); &#125; data[size] = e; size++;&#125; 在添加元素时候，我们需要检查一下数组的容量，当 size 和 data 容量相等时，表明开辟的数组已经被沾满了，应该给予提示，不过在之后的章节中，我们会对其进行改写，让其实现动态的特性。 向指定位置添加元素我们希望能够维护数组中的元素，让着个数组中的元素都是有序排列的，在这样的情况下，我们就不能将每一个元素都放到最后，我们需要将元素插入到指定的位置。 如果我们希望将一个元素插入到1的位置上，我们只需要将数组中的元素都向后挪一个位置。 再具体操作之后，我们需要从最后面的元素开始移动，否则的话，我们就会将其后面的元素覆盖掉了。 操作完成后，不要忘了维护 size，我们需要++。 12345678910111213141516171819202122/*** 向指定位置插入元素* @param index 位置* @param e 元素*/public void insert(int index, int e) &#123; if (size == data.length) throw new IllegalArgumentException(\"AddLast falid. Array is full\"); //index 必须为合法的 //如果 index 最大是取 size, 在这样的情况下，就相当于向所有的元素后面再添加一个元素 //如果 index 比 size 还大，说明元素不是紧密排列的，中间存在一些不是合法的元素 if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"AddLast falid. Require index &gt;= - and index &lt;= size\"); &#125; //后移元素 for (int i = size - 1; i &gt;= index; i--) &#123; data [i + 1] = data[i]; &#125; data[index] = e; size++;&#125; 当我们编写好INSERT方法后，其实 addlast 可以复用insert 方法，并且通过该方法，还可以写出向首位添加元素的方法。 12345678910111213141516/*** 向数组末尾添加元素* @param e*/public void addLast(int e)&#123; insert(size, e);&#125; /*** 想数组首位置添加元素* @param e*/public void addFirst(int e) &#123; insert(0 ,e);&#125; 在数组中查询和修改元素对于我们封装的数组而言，真正的数组是存储在我们静态数组data 中，我们可以非常方便的在[]中插入索引的方式直接取值。 1234567891011121314151617181920212223242526272829303132333435363738/** * 获取index 索引的元素 * @param index * @return */public int get(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Get failed, Index is illegal.\"); &#125; return data[index];&#125;/*** 修改 index 位置的元素* @param index* @param e*/public void set(int index, int e) &#123; //确保了用户永远无法查询没有使用的空间。 if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Get failed, Index is illegal.\"); &#125; data[index] = e; &#125;@Overridepublic String toString() &#123; StringBuilder res = new StringBuilder(); res.append(String.format(\"Array Szie = %d, capactiy = %d\", size, data.length)); res.append('['); for (int i = 0; i &lt; size; i++) &#123; res.append(data[i]); if (i != size -1) &#123; res.append(\",\"); &#125; &#125; res.append(']'); return re;&#125; 包含、搜索和删除检测是否包含很简单，只需要遍历我们的数组 123456789101112131415161718192021222324252627/** * 检测是否包含元素 * @param e * @return */public boolean contians(int e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i] == e) &#123; return true; &#125; &#125; return false;&#125; /** * 查找数组元素e 所在的索引，如果不存在元素e,则返回-1 * @param e * @return */public int find(int e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i] == e) &#123; return i; &#125; &#125; return -1; &#125; 删除索引很简单，与我们插入相反，他是从后向前移动。 12345678910111213141516/** * 从数组删除元素，并且返回删除的元素 * @param index * @return */public int remove(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Remove failed, Index is illegal.\"); &#125; int ret = data[index]; for (int i = index + 1; i &lt; size; i++ ) &#123; data[i - 1] = data[i]; &#125; size--; return ret; &#125; 同时我们可以添加删除首位置和末尾的元素 12345678910111213141516171819202122232425262728/** * 删除第一个元素，并且返回被删除的元素 * @return */public int removeFirst() &#123; int ret = remove(0); return ret;&#125; /** * 删除最后一个元素，并且返回被删除的元素 * @return */public int removeLast() &#123; int ret = remove(size-1); return ret;&#125;/** * 从数组中删除元素e * @param e */public void removeElement(int e) &#123; int index = find(e); if (index != -1) &#123; remove(index); &#125;&#125; 使用泛型优化数组现在对于我们的数组，存在最大的问题就是只支持 Int 类型，但是实际上数组类作为存放数据的容器，应该盛放任意类型的数据。 泛型不可以是基本类型，只能是类的对象。 Java 的基本类型： boolean byte char short int long float double 如果将我们的数组设置为泛型，就不能放置这些基本类型了。Java 为每个基础类型都有对应的包装类。 Boolean Byte Char Short Int Long Float Double 其实就是 Java 对基本类型的封装，两者之间可以无缝的进行转换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package Array;public class Array&lt;T&gt; &#123; private T[] data; private int size; /** * 构造函数，传入数组的容量 capactiy 构造 Array * @param capactiy */ public Array(int capactiy) &#123; data = (T[])new Object[capactiy]; &#125; /** * 无参数构造函数，默认数组的容量10 */ public Array() &#123; this(10); &#125; /** * 获取数组中元素的个数 * @return */ public int getSize()&#123; return size; &#125; /** * 获取数组的容量 * @return */ public int getCapacity() &#123; return data.length; &#125; /** * 返回数组是否为空 * @return */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 向数组末尾添加元素 * @param e */ public void addLast(T e) &#123; insert(size, e); &#125; /** * 想数组首位置添加元素 * @param e */ public void addFirst(T e) &#123; insert(0 ,e); &#125; /** * 向指定位置插入元素 * @param index 位置 * @param e 元素 */ public void insert(int index, T e) &#123; if (size == data.length) throw new IllegalArgumentException(\"AddLast falid. Array is full\"); //index 必须为合法的 //如果 index 最大是取 size, 在这样的情况下，就相当于向所有的元素后面再添加一个元素 //如果 index 比 size 还大，说明元素不是紧密排列的，中间存在一些不是合法的元素 if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"AddLast falid. Require index &gt;= 0 and index &lt;= size\"); &#125; //后移元素 for (int i = size - 1; i &gt;= index; i--) &#123; data [i + 1] = data[i]; &#125; data[index] = e; size++; &#125; /** * 获取index 索引的元素 * @param index * @return */ public T get(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Get failed, Index is illegal.\"); &#125; return data[index]; &#125; /** * 修改 index 位置的元素 * @param index * @param e */ public void set(int index, T e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Get failed, Index is illegal.\"); &#125; data[index] = e; &#125; /** * 检测是否包含元素 * @param e * @return */ public boolean contians(T e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return true; &#125; &#125; return false; &#125; /** * 查找数组元素e 所在的索引，如果不存在元素e,则返回-1 * @param e * @return */ public int find(T e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) &#123; return i; &#125; &#125; return -1; &#125; /** * 从数组删除元素，并且返回删除的元素 * @param index * @return */ public T remove(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Remove failed, Index is illegal.\"); &#125; T ret = data[index]; for (int i = index + 1; i &lt; size; i++ ) &#123; data[i - 1] = data[i]; &#125; size--; data[size] == null; return ret; &#125; /** * 删除第一个元素，并且返回被删除的元素 * @return */ public T removeFirst() &#123; T ret = remove(0); return ret; &#125; /** * 删除最后一个元素，并且返回被删除的元素 * @return */ public T removeLast() &#123; T ret = remove(size-1); return ret; &#125; /** * 从数组中删除元素e * @param e */ public void removeElement(T e) &#123; int index = find(e); if (index != -1) &#123; remove(index); &#125; &#125; /*** * 打印输出数组 */ @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(String.format(\"Array Szie = %d, capactiy = %d\", size, data.length)); res.append('['); for (int i = 0; i &lt; size; i++) &#123; res.append(data[i]); if (i != size -1) &#123; res.append(\",\"); &#125; &#125; res.append(']'); return res.toString(); &#125;&#125; 在这里需要注意的是，比较==运算进行了替换equals，那是因为==是值比较，而现在泛型比较的是对象，所以需要引用比较。 在 remove 代码中，可以看到最后有一行 1data[size] == null; 当我们使用泛型时，data 数组中存储的都是对象的引用，在这种情况下，删除了一个元素之后，此时的 data[size]还指着一个引用，在 Java中有一个垃圾回收技术，不过如果我们的 data[‘size’] 还存在引用的话，就不会被回收，将其值设置成 NULL 后对象就没有引用了，就会被自动回收。 其实在我们使用这个数组的时候，再添加一个新的元素，那么 data[size]指向的对象就会换成一个新的引用，原来的值就会被清理掉，对于这种对象有一个术语loitering objects，这个时候这个对象还在我们的系统中游荡，垃圾回收机制并不能把它回收，但是他已经没有用了，但是需要注意loitering objects的存在并不等于内存泄漏，只是为了程序的优化，如果能手动的把loitering objects给去除更好。 如果不写这段代码也是没有问题的。 动态数组现在我们实现的数组内部使用的还是 Java 为我们提供的静态数组，容量是有限的，可是很多时候，我们使用的数组类无法实现预估，不知道要放入多少个元素进我们的数组，在这种情况下，容量开的太大的话就会浪费很多空间，如果太小最后空间不够用，这种情况下，我们需要一种方案解决数组的容量是可伸缩的，也就是所谓的动态数组。 假设现在数组只有4个元素，并且现在4个元素已经装满了，现在向数组中再添加一个元素的话，显然是做不到的，会抛出异常。 我们首先再开创一个新的数组newData，newData 的空间要比原来的数组空间大一些，比如之前数组是4个元素，那么 newData 就开辟8个空间，然后将 data 中的数据放置到 newData 中。 其实就是使用 newData 取代 data。 在程序实现过程中，data 是一个引用，我们改变 data 的引用指向newData。 对于 newData 而言，在函数执行完成之后就会失效，但是 data 是成员变量，它的生命周期和类是一样的，只要类还在使用 data 的指向就是 newData 的空间。 只有4个元素的数组，由于没有变量指向它，就会被回收掉。 123456789101112131415161718192021222324252627282930/** * 向指定位置插入元素 * @param index 位置 * @param e 元素 */public void insert(int index, T e) &#123; //index 必须为合法的 //如果 index 最大是取 size, 在这样的情况下，就相当于向所有的元素后面再添加一个元素 //如果 index 比 size 还大，说明元素不是紧密排列的，中间存在一些不是合法的元素 if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"AddLast falid. Require index &gt;= 0 and index &lt;= size\"); &#125; if (size == data.length) resize(2 * data.length); //后移元素 for (int i = size - 1; i &gt;= index; i--) &#123; data [i + 1] = data[i]; &#125; data[index] = e; size++;&#125;private void resize(int capactiy) &#123; T[] newData = (T[])new Object[capactiy]; for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[i]; &#125; data = newData;&#125; 1resize(2 * data.length); 在扩容时候，我将其设置成了原有数组的二倍，在这里主要是不希望比原来的 data.length 再加上一个常数，扩容的大小到底取多少，其实很难判断，如果每一次只扩容十个空间，假设当前数组有一个10000元素了，然后我们扩容成10010个，很有可能我们的这个扩容是比较低效的，因为现在的数组装10000个数组已经装满了，又有新的元素来了，很有可能还会来新的元素，如果我们再次加入1000个元素，那么就需要扩容100次，这样的性能消耗实在是太大了。 如果每次都扩容1000个容量，但是这样做也有问题，如果当前整个数组只有10个的话，一次性扩容1000个空间，那么很大的概率大部分空间会被浪费掉。 现在2 * data.length 就是根据当前数组有多少容量是相关的，扩容的量是跟当前数组已经有用的容量是在一个数量级的，那么我当前有100元素，就给他扩容到200。 其实将其设置成2或者是3都是完全可以的，这只是一个参数选择上的问题，在 Java 中 ArrayList 的实现中这个参数选择的是1.5。 相对于扩容来说，同理在我们从元素中删除元素的时候，为了节省空间，我们也可以设置当删除到一定程度的时候，我们整个数组的容量进行一下缩小。 我们可以通过 resize 函数实现这个功能，对 remove 函数进行修改，如果是数组容积的二分之一的时候，我们就可以 resize。 1234567891011121314151617181920212223/** * 从数组删除元素，并且返回删除的元素 * @param index * @return */ public T remove(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException(\"Remove failed, Index is illegal.\"); &#125; T ret = data[index]; for (int i = index + 1; i &lt; size; i++ ) &#123; data[i - 1] = data[i]; &#125; size--; data[size] = null; if (size == data.length / 2) &#123; resize(data.length /2); &#125; return ret;&#125; 此时，我们就实现了一个真正意义上的动态数组。不过在真正意义上还不够完善，因为在删除元素时候，存在一个问题，如果我们要删除数组中的 ‘E’，当找到第一个 ‘E’的时候，程序删除掉就会停止执行，这个时候在后面的元素中也有可能会存在’E’，所以为了程序更加完善可以在添加一个删除所有，同时查找元素也存在这一问题。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.maksim.website/categories/数据结构与算法/"}],"tags":[]},{"title":"Linux典型应用实践：NFS共享文件","slug":"2017-08-12-Linux典型应用实践：NFS共享文件","date":"2018-04-11T16:00:00.000Z","updated":"2018-06-27T13:37:51.527Z","comments":true,"path":"2018/04/12/2/","link":"","permalink":"http://www.maksim.website/2018/04/12/2/","excerpt":"","text":"为什么要用NFSNFS（Network File System）网络文件系统，由 SUN 公司开发，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。 简单的来说：它就是是可以透过网络，让不同的主机、不同的操作系统可以共享存储。 以下是NFS最显而易见的好处： 节省本地存储空间，将常用的数据存放在一台NFS服务器上且可以通过网络访问，那么本地终端将可以减少自身存储空间的使用。 用户不需要在网络中的每个机器上都建有Home目录，Home目录可以放在NFS服务器上且可以在网络上被访问使用。 一些存储设备CDROM和Zip（一种高储存密度的磁盘驱动器与磁盘）等都可以在网络上被别的机器使用。这可以减少整个网络上可移动介质设备的数量。 NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，容许不同硬件及操作系统的系统共同进行文件的分享。 NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。 可以说NFS本身就是使用RPC的一个程序。或者说NFS也是一个RPC SERVER。所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。 NSF 的工作流程 由程序在NFS客户端发起存取文件的请求，客户端本地的RPC(rpcbind)服务会通过网络向NFS服务端的RPC的111端口发出文件存取功能的请求。 NFS服务端的RPC找到对应已注册的NFS端口，通知客户端RPC服务。 客户端获取正确的端口，并与NFS daemon联机存取数据。 存取数据成功后，返回前端访问程序，完成一次存取操作。 CentOS 7搭建NFS服务器实例 服务器系统 角色 IP CentOS 7 Server 192.168.0.100 CentOS 7 Client 192.168.0.101 1、因是测试环境，先关闭selinux和firewalld 关闭selinux 1[root@service ~]# sed -i s#SELINUX=enforcing#SELINUX=disabled#g /etc/selinux/config 停止防火墙 1[root@service ~]# systemctl stop firewalld.service 2、服务器部署 1）检查系统版本及NFS服务nfs-utils 和rpcbind有没有安装 123456789[root@service ~]# cat /etc/redhat-release #查看系统版本CentOS Linux release 7.5.1804 (Core)[root@service ~]# uname -r #查看系统内核版本3.10.0-862.el7.x86_64[root@servicer ~]# uname -m #查看系统是否64位x86_64[root@service ~]# rpm -qa nfs-utils rpcbind #检查安装的软件包rpcbind-0.2.0-44.el7.x86_64nfs-utils-1.3.0-0.54.el7.x86_64 2）如果没有安装在系统中通过yum 命令进行安装以上两个包 1[root@service ~]# yum install -y nfs-utils rpcbind #安装上述所需的两个软件包 3）启动rpcbind服务（一定要先启动rpcbind服务再启动nfs服务,由于在NFS服务过程中，必须先启动rpcbind，再启动nfs，这样才能让NFS在rpcbind上注册成功) 123456789101112[root@service ~]# systemctl start rpcbind #启动[root@service ~]# systemctl status rpcbind #查看状态● rpcbind.service - RPC bind service Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; enabled; vendor preset: enabled) Active: active (running) since 三 2018-06-27 16:02:27 CST; 29s ago Process: 1577 ExecStart=/sbin/rpcbind -w $RPCBIND_ARGS (code=exited, status=0/SUCCESS) Main PID: 1578 (rpcbind) CGroup: /system.slice/rpcbind.service └─1578 /sbin/rpcbind -w6月 27 16:02:27 bogon systemd[1]: Starting RPC bind service...6月 27 16:02:27 bogon systemd[1]: Started RPC bind service. 123456[root@service ~]# lsof -i :111 #查询rpcbind监听状态 (111是rpcbind的主端口)COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMErpcbind 1578 rpc 6u IPv4 19786 0t0 UDP *:sunrpcrpcbind 1578 rpc 8u IPv4 19788 0t0 TCP *:sunrpc (LISTEN)rpcbind 1578 rpc 9u IPv6 19789 0t0 UDP *:sunrpcrpcbind 1578 rpc 11u IPv6 19791 0t0 TCP *:sunrpc (LISTEN) 1234567[root@service ~]# netstat -lntup |grep rpcbind #查询rpcbind服务启动状态 (同lsof查询端口效果一样)tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN 1578/rpcbindtcp6 0 0 :::111 :::* LISTEN 1578/rpcbindudp 0 0 0.0.0.0:905 0.0.0.0:* 1578/rpcbindudp 0 0 0.0.0.0:111 0.0.0.0:* 1578/rpcbindudp6 0 0 :::905 :::* 1578/rpcbindudp6 0 0 :::111 :::* 1578/rpcbind 12345678[root@service ~]# rpcinfo -p localhost #查看nfs服务向rpc注册的端 口信息program vers proto port service 100000 4 tcp 111 portmapper 100000 3 tcp 111 portmapper 100000 2 tcp 111 portmapper 100000 4 udp 111 portmapper 100000 3 udp 111 portmapper 100000 2 udp 111 portmapper 1234[root@service ~]# systemctl list-unit-files | grep rpcbind #检查rpcbind自启动情况rpcbind.service enabledrpcbind.socket enabledrpcbind.target static 如果rpcbind.service不是enable将其加入自启动 1[root@service ~]# systemctl enable rpcbind.service 4）启动NFS服务并查看其状态 12345678910111213[root@service ~]# systemctl start nfs #启动NFS[root@service ~]# systemctl status nfs #查看NFS● nfs-server.service - NFS server and services Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; disabled; vendor preset: disabled) Active: active (exited) since 三 2018-06-27 16:15:44 CST; 30s ago Process: 9397 ExecStart=/usr/sbin/rpc.nfsd $RPCNFSDARGS (code=exited, status=0/SUCCESS) Process: 9392 ExecStartPre=/bin/sh -c /bin/kill -HUP `cat /run/gssproxy.pid` (code=exited, status=0/SUCCESS) Process: 9391 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=0/SUCCESS) Main PID: 9397 (code=exited, status=0/SUCCESS) CGroup: /system.slice/nfs-server.service6月 27 16:15:44 bogon systemd[1]: Starting NFS server and services...6月 27 16:15:44 bogon systemd[1]: Started NFS server and services. 1234567[root@NFS-server ~]# netstat -lntup|grep nfs #查看NFS端口启动(FNS默认端口为2049)[root@NFS-server ~]# lsof -i :2049 #查看NFS端口启动(FNS默认端口为2049)[root@NFS-server ~]# netstat -lntup|grep 2049 #查看NFS端口启动(FNS默认端口为2049)tcp 0 0 0.0.0.0:2049 0.0.0.0:* LISTEN -tcp6 0 0 :::2049 :::* LISTEN -udp 0 0 0.0.0.0:2049 0.0.0.0:* -udp6 0 0 :::2049 :::* - 1[root@NFS-server ~]# rpcinfo -p localhost #启动NFS过后rpcbind服务已经启用了对FNS的端口映射 1234567891011121314151617[root@NFS-server ~]# systemctl list-unit-files | grep nfs #查看nfs的开机自启动情况proc-fs-nfsd.mount staticvar-lib-nfs-rpc_pipefs.mount staticnfs-blkmap.service disablednfs-config.service staticnfs-idmap.service staticnfs-idmapd.service staticnfs-lock.service staticnfs-mountd.service staticnfs-rquotad.service disablednfs-secure.service staticnfs-server.service disablednfs-utils.service staticnfs.service disablednfslock.service staticnfs-client.target enabled[root@NFS-server ~]# systemctl enable nfs #让FNS开机自启动 5）授权nfsnobody于/data/bbs让客户端挂载后可写可读 1[root@service /]# chown nfsnobody:nfsnobody /data/bbs 6）创建测试目录及文件 12[root@service ~]# mkdir /data/bbs -p[root@service ~]# mkdir /data/bbs/test.txt 7）配置NFS服务的export文件 1[root@service ~]# echo \"/data/bbs/ 192.168.0.0/24(rw,sync,root_squash)\"&gt;&gt;/etc/exports 重新加载nfs配置文件 12[root@service ~]# exportfs -rvexporting 192.168.0.0/24:/data/bbs exportfs：NFS服务端发布共享控制命令。 -r：表示重新刷新共享 -a：表示将配置文件/etc/exports中的所有定义共享发布出去。 -v：显示确认共享设置 -u：表示不发布共享 查看nfs服务器挂载情况 123[root@service ~]# showmount -e localhostExport list for localhost:/data/bbs 192.168.10.1/24 ro：目录只读 rw：目录读写 sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性 async：将数据先保存在内存缓冲区中，必要时才写入磁盘 all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组(nfsnobody) no_all_squash：与all_squash取反(默认设置) root_squash：将root用户及所属组都映射为匿名用户或用户组(默认设置) no_root_squash：与rootsquash取反 anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户(UID=xxx) anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户 3、客户端配置 1[root@localhost ~]# yum install nfs-utils rpcbind 把rpcbind加入开机自启动 1[root@localhost bbs]# systemctl enable rpcbind.service 创建测试目录文件 1[root@localhost ~]# mkdir /data/bbs/ -p 扫描NFS服务器的文件共享列表 123[root@localhost bbs]# showmount -e 192.168.0.100Export list for 192.168.0.100:/data/bbs 192.168.0.100/24 把服务器的目录挂载到客户端 的目录下 1234567891011[root@localhost ~]# mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs[root@localhost ~]# df -h文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 6.2G 1.1G 5.1G 18% /devtmpfs 485M 0 485M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 6.8M 490M 2% /runtmpfs 496M 0 496M 0% /sys/fs/cgroup/dev/sda1 1014M 129M 886M 13% /boottmpfs 100M 0 100M 0% /run/user/0192.168.0.100:/data/bbs 6.2G 1.1G 5.1G 18% /data/bbs 数据测试Service 12[root@service /]# cd /data/bbs[root@service bbs]# touch a.txt Client 1[root@localhost ~]# ls /data/bbsa.txt 提示: 配置NFS服务端后，不用重启NFS服务，只要使用exportfs -rv rpc主程序Centos5.8下为portmap 、Centos6.4和Centos7下为rpcbind NFS共享目录不要授权于777权限，可以改所属主和组为nfsnobody，因为nfsnobody权限不是很大，也不能登陆 配置客户端 开机自动挂载NFS共享目录12345678910111213[root@localhost ~]# chmod +x /etc/rc.d/rc.local #centos7需要给rc.local赋予执行权限后，rc.local文件才能生效[root@localhost ~]# echo \"mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs\"&gt;&gt;/etc/rc.local[root@localhost ~]# cat /etc/rc.local#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot. mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs 客户端mount挂载优化在企业生产环境中，NFS客户端挂载的参数有noexec、nosuid、nodev、noatime、rsize、wsize、nodiratime等， 一般来说，NFS服务器共享的只是普通静态数据（图片、附件、视频），不需要执行suid、exec等权限，挂载的这个文件系统只能作为数据存取之用，无法执行程序，对于客户端来讲增加了安全性，例如：很多*修改站点文件都是由上传入口上传的程序存储目录，然后执行，因此在挂载时，用下面的命令是有必要的， 普遍安全挂载参数： 1mount -t nfs -o nosuid,noexec,nodev,rw 192.168.10.150:/data/bbs /data/bbs 挂载的读写缓存 wsize和rsize写和读缓存 wsize和rsize的最大值 NFSV2 rsize=8192 wsize=8192 NFSV3 rsize=32768 wsize=32768 NFSV4 rsize=65536 wsize=65536 现在一般centos5.8以上的系统都己经增加了读写缓存，如需修改可以加以上参数 例如： 1mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs mount的一些常用挂载优化参数： wsize和rsize写和读缓存 async 数据不同步写到磁盘，提高性参，但降低数据安全，不推荐使用 noatime和nodiratime 这两个选是说在读写磁盘时，不更新文件和目录的时间戳，而更新文件时间戳对于工作数据必要性不大，增加了磁盘IO的次数，拖慢系统性参， defaults 这个缺省值包括rw,suid,dev,exec,auto,nouser,and async cat /etc/fstab的结果默认大部人都是缺省值 noauto 不会自动挂载文件系统 noexec 不允许安装的直接执行任何二进制文件 ro 挂载一个只读文件系统 rw 挂载一个可写的文件系统 sync 把数据同步写入硬盘 nosuid 不允许设置用户标识或设置组标识符位 nodev 不解释字符或文件块特殊设备 intr 表示可以中断 企业生产环境中nfs性参优化挂载例子： 12mount -t nfs -o noatime,nodiratime 192.168.10.150:/data/bbs /data/bbsmount -t nfs -o nosuid,noexec,nodev,noatime,nodiratime,intr,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs 如果是本地系统： 1mount -o defaults,async,noatime,data=writeback,barrier=0 /dev/sdb1 /mnt data=writeback,barrier=0 是日志文件系统的优化 提示：本地文件系统挂载如果加nodiratime会报错， 加优化参数和不加的数据写入测试使用普通挂载 1[root@localhost ~]# mount -t nfs 192.168.0.150:/data/bbs /data/bbs 测试单个文件写入速度 12345678[root@localhost ~]# cd /data/bbs[root@localhost bbs]# time dd if=/dev/zero of=/data/bbs/dingjianfile bs=9k count=20002000+0 records in2000+0 records out18432000 bytes (18 MB) copied, 0.114592 s, 161 MB/sreal 0m0.125suser 0m0.000ssys 0m0.021s 测试批量创建文件的写入速度 1234[root@localhost bbs]# time for ((i=1;i&lt;10000;i++));do /bin/cp /bin/touch /data/bbs/test$i;donereal 2m2.877suser 0m10.242ssys 0m33.882s 加优化参数挂载: 1[root@localhost bbs]#mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs 测试单个文件写入速度 1234567[root@localhost bbs]# time dd if=/dev/zero of=/data/bbs/dingjianfile bs=9k count=20002000+0 records in2000+0 records out18432000 bytes (18 MB) copied, 0.10043 s, 184 MB/sreal 0m0.107suser 0m0.001ssys 0m0.017s 测试批量创建文件的写入速度 1234[root@localhost bbs]# time for ((i=1;i&lt;10000;i++));do /bin/cp /bin/touch /data/bbs/test$i;donereal 1m38.526suser 0m9.989ssys 0m32.788s 配置fstab文件令开机自动加载网络文件系统和本地的文件系统(和rc.local效果一样)12345678910111213[root@localhost bbs]# vi /etc/fstab# /etc/fstab# Created by anaconda on Wed Jun 27 15:39:33 2018## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/centos-root / xfs defaults 0 0UUID=cbf5711b-4a2b-44ca-a6da-69d181f03617 /boot xfs defaults 0 0/dev/mapper/centos-swap swap swap defaults 0 0192.168.0.100:/data/bbs /data/bbs nfs defaults,nosuid,noatime,nodiratime,noexec,nodev,intr,rsize=65536,wsize=65536 0 0~ 参考资料： 《centos7下NFS使用与配置》 http://blog.51cto.com/mrxiong2017/2087001 《详细讲解NFS配置过程》https://www.cnblogs.com/alonones/p/6105586.html 百度百科 https://baike.baidu.com/item/NFS/812203?fr=aladdin","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[]},{"title":"写作的准备-读《完全写作指南》","slug":"2018-04-08 写作的准备-读《完全写作指南》","date":"2018-04-07T16:00:00.000Z","updated":"2018-06-25T12:39:07.539Z","comments":true,"path":"2018/04/08/1/","link":"","permalink":"http://www.maksim.website/2018/04/08/1/","excerpt":"","text":"写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样： 目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改 从理论上讲，按照这个顺序操作，你就能得到一篇组织得当、逻辑严谨的完美稿件。这个方法对一部分人是有用的，但是如果你和大多数人一样，那么他可能就不适合你。在现实生活中，大部分都不是线性思维的写作者。 这六个步骤没错，错的是这个强制性的顺序。当遵循渐进编程了因循守旧，它可能会阻碍你写作能力的发挥。 你可以以这个步骤中任意一步作为起点，头脑风暴、提纲或者是写初稿。 明确目标当要写作时，首先我们要确定自己的目标是什么，你希望达到什么目的。 仔细思考写作目的能帮你搞清楚该说什么，以及怎么说。又去的是，这样一来你的读者也会更加轻松，如果你也有过收到大量简历的经理，你就会知道一封周到、工整且有针对性的求职信会让你干到多么轻松。 了解你的读者除了私人日记之外，所有的作品都是有读者的，你的作品需要指向这些特定的读者。 站在读者的角度进行思考，有两个关键问题： 信息 态度 选择信息的黄金法则是：要有足量的有效信息，让你的读者行动起来。 了解读者潜在的态度也是成功的关键。 你的读者会有什么样的反应？ 他们很容易接受你的信息吗? 还是会有抵触情绪？ 他们是否怀有敌意。 笔者说： 在这里，可以读《美国航空航天局科学家给赞比亚修女的一封信》，这是一封大师级的回信，在本文结束处。 用他头脑风暴锁定你想表达的内容头脑风暴有一些规则。如果你在学校或者工作的地方参加过头脑风暴式的讨论，那么你很可能看到过这些规则： 相处的点子越多越好。如果你能把注意力放在数量而非质量上，那么提出有用的点子概率就会更大，点子都多多益善。 不要审查，不要评论。头脑风暴时，让你的思绪自由发散。这并不是对点子进行评论的时候，不要说这个点子不太好，那个点子不合适。把脑袋里评论的声音关掉，把所有想到的东西都写出来。你可以之后再删除。 接受不同寻常的想法。不要考虑你的想法靠不靠谱。你的这些想法可能完全超出预料，但它们当中可能会有一个非常有用，或至少能为你的思考指引方向的点子。充分发挥自己的想象力。 合并改进你的点子。如果你任由思绪自由发散，那么点子很可能会有一些重合。观察它们的相似之处，并加以合并调整。 当写完初稿后，发现内容不够完整，不够有说服力时候甚至可以重新进行头脑风暴。 美国航空航天局科学家给赞比亚修女的一封信背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。 1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ernst Stuhlinger）博士写了一封信。施图林格因在火星之旅工程中的原创性研究，成为NASA（美国航空航天局）马绍尔太空航行中心的科学副总监。信中，玛丽·尤肯达修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。施图林格很快给尤肯达修女回了信，同时还附带了一张题为“升起的地球”的照片，这张标志性的照片是宇航员威廉·安德斯于1968年在月球轨道上拍摄的（照片中可以看到月球的地面）。他这封真挚的回信随后由NASA以《为什么要探索宇宙》为标题发表。 1970年5月6日 亲爱的玛丽·尤肯达修女：每天，我都会收到很多类似的来信，但这封对我的触动最深，因为它来自一颗慈悲的饱含探求精神的心灵。我会尽自己所能来回答你这个问题。首先，请允许我向你以及你勇敢的姐妹们表达深深的敬意，你们献身于人类最崇高的事业：帮助身处困境的同胞。 在来信中，你问我在目前地球上还有儿童由于饥饿面临死亡威胁的情况下，为什么还要花费数十亿美元来进行飞向火星的航行。 我清楚你肯定不希望这样的答案：“哦，我之前不知道还有小孩子快饿死了，好吧，从现在开始，暂停所有的太空项目，直到孩子们都吃上饭再说。”事实上，早在了解火星之旅的技术之前，我已经对儿童的饥荒问题有所了解。而且，同我很多朋友的看法一样，我认为此时此刻，我们就应该开始通往月球、火星乃至其他行星的伟大探险。从长远来看，相对于那些要么只有年复一年的辩论和争吵，要么连妥协之后也迟迟无法落实的各种援助计划来说，我甚至觉得探索太空的工程给更有助于解决人类目前所面临的种种危机。 在详细说明我们的太空项目如何帮助解决地面上的危机之前，我想先简短讲一个真实的故事。那是在400年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。 然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气，“我们还在受瘟疫的苦”，他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！”伯爵听到后不为所动，“我会尽可能地接济大家”，他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。” 果不其然，他的工作赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。 伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。 我们目前面临类似的问题。美国总统的年度预算共有2000亿美元，这些钱将用于医疗、教育、福利、城市建设、高速公路、交通运输、海外援助、国防、环保、科技、农业以及其他多项国内外的工程。今年，预算中的1.6%将用于探索宇宙，这些花销将用于阿波罗以计划、其他一些涵盖了天体物理学、深空天文学、空间生物学、行星探测工程、地球资源工程的小项目以及空间工程技术。为担负这些太空项目的支出，平均每个年收入10,000美元的美国纳税人需要支付约30美元给太空，剩下的9,970美元则可用于一般生活开支、休闲娱乐、储蓄、别的税项等花销。 也许你会问：“为什么不从纳税人为太空支付的30美元里抽出5美元或3美元或是1美元来救济饥饿的儿童呢？”为了回答这个问题，我需要先简单解释一下我们国家的经济是如何运行的，其他国家也是类似的情形。政府由几个部门（如内政部、司法部、卫生部与公众福利部、教育部、运输部、国防部等）和几个机构（国家科学基金会、国家航空航天局等）组成，这些部门和机构根据自己的职能制定相应的年度预算，并严格执行以应对国务委员会的监督，同时还要应付来自预算部门和总统对于其经济效益的压力。当资金最终由国会拨出后，将严格用于经预算批准的计划中的项目。 显然，NASA的预算中所包含的项目都是和航空航天有关的。未经国会批准的预算项目，是不会得到资金支持的，自然也不会被课税，除非有其他部门的预算涵盖了该项目，借此花掉没有分配给太空项目的资金。由这段简短的说明可以看出，要想援助饥饿的儿童，或在美国已有的对外援助项目上增加援助金额，需要首先由相关部门提出预算，然后由国会批准才行。 要问是否同意政府实施类似的政策，我个人的意见是绝对赞成。我完全不介意每年多付出一点点税款来帮助饥饿的儿童，无论他们身在何处。 我相信我的朋友们也会持相同的态度。然而，事情并不是仅靠把去往火星航行的计划取消就能轻易实现的。相对的，我甚至认为可以通过太空项目，来为缓解乃至最终解决地球上的贫穷和饥饿问题作出贡献。解决饥饿问题的关键有两部分：食物的生产和食物的发放。食物的生产所涉及的农业、畜牧业、渔业及其他大规模生产活动在世界上的一些地区高效高产，而在有的地区则产量严重不足。通过高科技手段，如灌溉管理，肥料的使用，天气预报，产量评估，程序化种植，农田优选，作物的习性与耕作时间选择，农作物调查及收割计划，可以显著提高土地的生产效率。 人造地球卫星无疑是改进这两个关键问题最有力的工具。在远离地面的运行轨道上，卫星能够在很短的时间里扫描大片的陆地，可以同时观察计算农作物生长所需要的多项指标，土壤、旱情、雨雪天气等等，并且可以将这些信息广播至地面接收站以便做进一步处理。事实证明，配备有土地资源传感器及相应的农业程序的人造卫星系统，即便是最简单的型号，也能给农作物的年产量带来数以十亿美元计的提升。 如何将食品发放给需要的人则是另外一个全新的问题，关键不在于轮船的容量，而在于国际间的合作。小国统治者对于来自大国的大量食品的输入很难做出准确的判断，他们害怕伴随着食物一同而来的还有外国势力对其统治地位的影响。恐怕在国与国之间消除隔阂之前，饥饿问题无法得以高效解决了。我不认为太空计划能一夜之间创造奇迹，然而，探索宇宙有助于促使问题向着良好的方向发展。 以最近发生的阿波罗13号事故为例。当宇航员处于关键的大气层再入期时，为了保证通讯畅通，苏联关闭了境内与阿波罗飞船所用频带相同的所有广播通信。同时派出舰艇到太平洋和大西洋海域以备第一时间进行搜救工作。如果宇航员的救生舱降落到俄方舰船附近，俄方人员会像对待从太空返回的本国宇航员一样对他们进行救助。同样，如果俄方的宇宙飞船遇到了类似的紧急情况，美国也一定会毫不犹豫地提供援助。 通过卫星进行监测与分析来提高食品产量，以及通过改善国际关系提高食品发放的效率，只是通过太空项目提高人类生活质量的两个方面。下面我想介绍另外两个重要作用：促进科学技术的发展和提高一代人的科学素养。 登月工程需要历史上前所未有的高精度和高可靠性。面对如此严苛的要求，我们要寻找新材料，新方法；开发出更好的工程系统；用更可靠的制作流程；让仪器的工作寿命更长久；甚至需要探索全新的自然规律。 这些为登月发明的新技术同样可以用于地面上的工程项目。每年，都有大概一千项从太空项目中发展出来的新技术被用于日常生活中，这些技术打造出更好的厨房用具和农场设备，更好的缝纫机和收音机，更好的轮船和飞机，更精确的天气预报和风暴预警，更好的通讯设施，更好的医疗设备，乃至更好的日常小工具。你可能会问为什么先设计出宇航员登月舱的维生系统，而不是先为听力障碍患者造出有声阅读设备呢。答案很简单：解决工程问题时，重要的技术突破往往并不是按部就班直接得到的，而是来自能够激发出强大创新精神，能够燃起的想象力和坚定的行动力，以及能够整合好所有资源的充满挑战的目标。 太空旅行无可置疑地是一项充满挑战的事业。通往火星的航行并不能直接提供食物解决饥荒问题。然而，它所带来大量的新技术和新方法可以用在火星项目之外，这将产生数倍于原始花费的收益。若希望人类生活得越来越好，除了需要新的技术，我们还需要基础科学不断有新的进展。包括物理学和化学，生物学和生理学，特别是医学，用来照看人类的健康，应对饥饿、疾病、食物和水的污染以及环境污染等问题。 我们需要更多的年轻人投入到科学事业中来，我们需要给予那些投身科研事业的有天分的科学家更多的帮助。随时要有富于挑战的研究项目，同时要保证对项目给予充分的资源支持。在此我要重申，太空项目是科技进步的催化剂，它为学术研究工作提供了绝佳和实践机会，包括对月球和其他行星的眼睛、物理学和天文学、生物学和医学科学等学科，有它，科学界源源不断出现令人激动不已研究课题，人类得以窥见宇宙无比瑰丽的景象；为了它，新技术新方法不断涌现。 由美国政府控制并提供资金支持的所有活动中，太空项目无疑最引人瞩目也最容易引起争议，尽管其仅占全部预算的1.6%，不到全民生产总值的千分之三。作为新技术的驱动者和催化剂，太空项目开展了多项基础科学的研究，它的地位注定不同于其他活动。从某种意义上来说，以太空项目的对社会的影响，其地位相当于3-4千年前的战争活动。 如果国家之间不再比拼轰炸机和远程导弹，取而代之比拼月球飞船的性能，那将避免多少战乱之苦！聪慧的胜利者将满怀希望，失败者也不用饱尝痛苦，不再埋下仇恨的种子，不再带来复仇的战争。 尽管我们开展的太空项目研究的东西离地球很遥远，已经将人类的视野延伸至月亮、至太阳、至星球、直至那遥远的星辰，但天文学家对地球的关注，超过以上所有天外之物。太空项目带来的不仅有那些新技术所所提供的生活品质的提升，随着对宇宙研究的深入，我们对地球，对生命，对人类自身的感激之情将越深。太空探索让地球更美好。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.maksim.website/categories/读书笔记/"}],"tags":[]},{"title":"Linux 安全系列之删除特殊的用户和用户组","slug":"2018-04-02 Linux 安全系列之删除特殊的用户和用户组","date":"2018-04-01T16:00:00.000Z","updated":"2018-06-20T05:07:51.210Z","comments":true,"path":"2018/04/02/1/","link":"","permalink":"http://www.maksim.website/2018/04/02/1/","excerpt":"","text":"Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。 Linux 系统中可以删除的默认用户和用户组大致如下： 可删除的用户，如 adm、lp、sync、shutdown、halt、news、uucp、operator、games、gopher 等。 可删除的用户组，如 adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers 等。 删除的方法很简单，下面以删除 games 用户和用户组为例介绍具体的操作。 删除用户所使用的命令： 1userdel games 删除用户组使用的命令： 1groupdel games 有些时候，某些用户仅仅作为进程调度或者用户组调用，并不需要登录功能，此时可以禁止这些用户登录系统的功能，例如要禁止 nagios 用户的登录功能，可以执行如下命令： 1usermod -s /sbin/nologin nagios 其实要删除哪些用户和用户组，并没有固定要求，可以根据服务器的用途来决定，如果服务器用于 Web 应用的，那么系统默认的 Apache 用户和用户组就无需删除；如果服务器用于数据库应用，那么建议删除系统默认的 Apache 用户和用户组。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[]},{"title":"AndroidStudio解决一直处于Building gradle project info的问题","slug":"2018-03-10 AndroidStudio 解决一直处于Building-gradle-project-info的问题","date":"2018-03-09T16:00:00.000Z","updated":"2018-06-25T12:39:00.687Z","comments":true,"path":"2018/03/10/1/","link":"","permalink":"http://www.maksim.website/2018/03/10/1/","excerpt":"","text":"问题的原因是gradle包（即gradle-wrapper.properties里的gradle压缩文件）本地没有需要下载，因为墙的原因，一直卡在下载的环节。 有三个解决方案：（选其一，推荐第三个方案） 科学#上网，不多说，必备。加载多久看你网速了。（但即使是如此速度依旧很慢） 将 gradle-wrapper.properties中的版本改为已经存在的版本，找一个可以编译的项目复制 gradle 版本号即可。 下载对应离线包放到本地（如：C:\\Users\\Administrator.gradle\\wrapper\\dists\\gradle-4.0.1-all\\26awvqv6f41r14q9x72t4n0s，不解压，重启as），离线包地址：services.gradle.org/distributions/或者http://download.csdn.net/album/detail/2265；然后打开File-&gt;Settings-&gt;Build, Exectution, Deployment-&gt;Gradle ，设置 “Gradle home” 为解压目录即可. 原文地址：http://blog.csdn.net/nifanggge/article/details/53397942","categories":[{"name":"Andriod","slug":"Andriod","permalink":"http://www.maksim.website/categories/Andriod/"}],"tags":[]},{"title":"Nginx的安装","slug":"2018-02-27 Nginx的安装","date":"2018-02-26T16:00:00.000Z","updated":"2018-06-25T12:39:20.550Z","comments":true,"path":"2018/02/27/1/","link":"","permalink":"http://www.maksim.website/2018/02/27/1/","excerpt":"","text":"Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。 在安装 Nginx 时，我们可以通过以下两种方式进行安装： 使用包管理器安装 Nginx 通过源代码安装 Nginx 使用包管理器安装 Nginx使用包管理器安装 Nginx 的机会，是你使用的操作系统已经提供了 Nginx 的安装包。使用包管理器安装 Nginx 的方式很简单，只需要在终端输入： Linux(基于 deb，如 Ubunut) 1sudo apt-get install nginx Linux（基于 rpm，如 CentOS) 1sudo yum install nginx FreeBSD 1sudo pkg_install -r nginx 通过上述命令，Nginx 将会安装到操作系统的标准位置下。如果使用操作系统的安装包安装 Nginx，那么通过上面的命令来安装是最佳方式。 Nginx 核心团队也提供了稳定的二进制版本，可以从 http://nginx.org/en/download.html 页面下载可用版本。未发布 Nginx 安装包的系统用户（例如，CentOS），可以使用下面指导来安装预测试、预编译二进制版本。 通过创建下面的文件，在系统中添加 Nginx 仓库的 yum 配置： 1234sudo vi /etc/yum.repos.d/nginx.repo[nginx]name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0enabled=1 然后，听过执行如下命令来安装 Nginx： 1sudo yum install nginx 也可以按照前面介绍的 URL 下载 nginx 发行版安装。 从源代码安装 NginxNginx 代码提供了两种独立的下载分支——开发版与稳定版。开发分支是一个正处于积极开发状态的版本。在这个版本中，会有一些新功能被集成到其中，在稳定版中是找不到这些功能的。当发布一个“开发”版时，它会经历同样的 QA 和作为稳定版本的一组类似测试功能。因此无论哪一个分支都一颗用于生产环境中，两者主要的不同，在于对第三方模块的支持。在开发板中，内部的 API 可能会发生改变，而稳定版则保持不变。因此，为了与第三方模块向下兼容，在稳定版中第三方模块都可以有效使用。 准备编译环境为了从源代码编译 Nginx，系统需要满足某些必要条件，除了编译器外，如果想分别启用 SSL 支持和使用 rewrite 模块，那么还需要提供响应的 OpenSSL 与 PCRE（Perl Compatible Regular Expressions）库及开发头文件。rewrite 模块是默认安装的。如果你还没有 PCRE 库与开发头文件，你需要在配置阶段禁用 rewrite 模块。这依赖于系统，也有可能在系统中已经默认安装了这些必要条件。如果没有安装，则需要从其安装包安装或者从源码下载并且解压安装，在 Nginx 配置脚本中指定他们在系统中的安装位置。 如果在配置文件中使用了—with-\\=\\选项，那么 Nginx 会视图建立一个静态依赖库。如果你想让 Nginx 不依赖于系统的任何其他部分，或是想获得些 Nginx 的二进制额外性能，那么你可能会使用构建静态库的做法。如果你使用外部库功能只能从某一个版本起有效（例如，NPN[Next Protocol Negotiation]TLS扩展从 OpenSSL1.0.1版有效），那么你就不得不将其指定到特定版本解压后的源代码路径中。 根据自己的喜好，你可能会提供其他的、可选安装包。你可以为这些安装包提供支持。他们包括 MD5和 SHA-1以支持散列算法、zip 压缩库、libatomic 库。在 Nginx 中，很多地方法会用到散列库，例如为了计算 URI 散列进而计算缓存 key。 zlib 压缩裤被用来投递 gzip 压缩内容。如果 atomic_ops 库有效，那么 Nginx 会用它来实现自动内存更新操作，以实现高性能的内存锁定代码。 从源代码编译读者可以从 http://nginx.org/en/download.html 下载 Nginx，在该页面找到.tar.gz 或者.zip 格式的源代码分支，安装如下步骤将下载的安装包解压到一个临时目录中: 12$ mkdir ~/bulid$ cd ~/bulid &amp;&amp; tar xzf nginx-&lt;version-number&gt;.tar.gz 使用下面命令配置 Nginx: 1$ cd ~/bulid/nginx-&lt;version-number&gt; &amp;&amp; ./configure 然后，使用下面命令进行编译安装： 1$ make &amp;&amp; sudo make install 在编译自己的二进制 nginx 时，你会有很大的灵活性来包含你仅使用的功能。你已经指定使用哪个用户运行 Nginx 了吗?你要使用默认的 logfile 位置，以便不用在 Nginx 的配置文件明确地说明它们吗?表 1-1 所示是配置选项列表，通过它来帮助你设计出自己的 nginx 命令。这些选项对 Nginx 都是有效的，模块可以被独立激活。 选项 解释 –prefix=\\ Nginx 安装的根路径，所有其他的安装路径都要依赖于该选项 –sbin-path=\\ 指定 Nginx 二进制文件的路径。如果没有指定，那么这个路径依赖于——prefix 选项 –conf-path=\\ 如果在命令行没有指定配置文件，那么将会通过这里指定的路径，Nginx 将会去那里寻找它的配置文件 –error-log-path=\\ 指定错误文件的路径，Nginx 会将其中写入错误日志文件，除非有其他配置 –pid-path=\\ 指定的文件将会写入 Nginx master 进程的pid，通常在/var/run 下 –lock-path=\\ 共享存储器互斥锁文件的路径 –user=\\ worker 进程运行的用户 –group=\\ worker 进程运行的组 –with-file-aio 为 FreeBSD4.3+和 Linux2.6.22+系统启用异步 I/O –with-debug 这个选项用于启用调试日志。在生产环境中不推荐使用该选项。 你可以使用优化编译，单但是如果使用包管理工具进行安装将无法获得这些优化，如下表： 选项 说明 –with-cc=\\ 如果想设置一个不再默认 Path 下的编译器 –with-cpp=\\ 设置 C 预处理器的响应路径 –with-cc-opt=\\ 指定必要的 include 文件路径，可能（-I\\）指出，也可能是优化(-O4)并指定64位构建 –with-ld-opt=\\ 包含连接器库的路径(-L\\)和运行路径(-R\\) —with-cpu-opt=\\ 通过该选项为特定的 CPU 构建 Nginx 配置 SSL 支持对于 TLS/SSL 协议，Nginx 使用 OpenSSL 项目。有关此开源工具包的更多信息，请访问 https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对 SSL 的支持。如果使用不带–with-ssl 选项的–with-http_ssl_module 或者–with-mail_ssl_module，你正在使用执行了 configure 命令的、安装在计算机上的 OpenSSL 库。如果你想要针对特定版本的 OpenSSL 进行编译，请下载该分发包，将其解压缩到一个目录中，然后将该目录的路径指定为–with-openssl 的参数。使用–with-openssl-opt 选项为 OpenSSL本身指定额外的构建选项。 例如，为了使用具有优化椭圆曲线的 OpenSSL 来构建 Nginx，您将使用如下的命令: 1$ ./configure --with-http_ssl_module --with-openssl=$&#123;BUILD_DIR&#125;/openssl-1.0.1p --with-openssl-opt=enable-ec_nistp_64_gcc_128 查找并安装第三方模块由于有多个开源项目，所以在 Nginx 周围就会有一个活跃的开发社区。由于 Nginx 的模块化特性，这个社区能够开发和发布模块，从而为 Nginx 提供额外的功能。它们涵盖了广泛的应用，所以着手开发自己的模块之前应该看看有什么可用模块。 安装第三方模块的过程相当简单，步骤如下。 1.定位你想要使用的模块(在 https://github.com 或者是 http://wiki.nginx.org/3rdPartyModules查找)。 2.下载该模块。 3.解压缩源代码安装包。 4.如果有 README 文件，那么阅读 README 文件，查看在安装中是否有依赖安装。 5.通过./configure–add-module=\\选项配置使用该模块。 这个过程会给你的 nginx 二进制文件与模块附加这个功能。 需要注意的是，很多第三方模块是实验性质的。因此，在将这些模块用于生产系统之前，首先要测试使用这些模块。另外请记住，Nginx 的开发版本中可能会有 API 的变化，会导致第三方模块出现问题。 添加对 Lua 的支持特别应该提到的是 ngx_lua 这个第三方模块，ngx_lua 模块提供了启用 Lua 的功能，而不是像 Perl 一样在配置时嵌入式脚本语言。该模块对于 perl 模块来说最大的优点就是它的无阻塞性，并与其他第三方模块紧密集成。对于它的安装说明的完整描述详见:https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。 小结通过编译你自己的二进制文件，你可以定制 Nginx能够为你提供哪些功能。对于你来说，构建和安装软件应该不会陌生。所以，创造一个构建环境或者确保所有依赖关系都存在，这并不会花费你很多的时间。一个 Nginx 的安装应该是按照你的需要，能随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。 参考资料： 《精通 Nginx》第二版","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[]},{"title":"利用Pathogen安装VIM插件","slug":"2018-02-23 利用Pathogen安装VIM插件","date":"2018-02-22T16:00:00.000Z","updated":"2018-06-20T03:25:08.862Z","comments":true,"path":"2018/02/23/1/","link":"","permalink":"http://www.maksim.website/2018/02/23/1/","excerpt":"","text":"pathogen的安装其实非常简单。git上有非常全面的介绍和文档，http://github.com/tpope/vim-pathogen。简单的几条命令即可搞定pathogen的安装： 12mkdir -p ~/.vim/autoload ~/.vim/bundle curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 也就是在 ~/.vim目录下（如果没有，则新建）新建目录autoload、bundle（插件会放在这个目录），然后将pathogen放在autoload目录下即可 安装完成之后，这时候，pathogen还没有生效，需要在~/.vimrc添加： 1execute pathogen#infect() 如果没有~/.vimrc则需要新建文件，并添加如下内容： 123execute pathogen#infect() syntax on filetype plugin indent on 完成之后，就可以使用pathogen管理vim插件了，只需要将插件放在~/.vim/bundle目录下即可。","categories":[{"name":"工具","slug":"工具","permalink":"http://www.maksim.website/categories/工具/"}],"tags":[]},{"title":"function与感叹号","slug":"2018-02-01 function And !","date":"2018-01-31T16:00:00.000Z","updated":"2018-07-20T04:44:12.572Z","comments":true,"path":"2018/02/01/1/","link":"","permalink":"http://www.maksim.website/2018/02/01/1/","excerpt":"","text":"function与感叹号最近有空可以让我静下心来看看各种代码，function与感叹号的频繁出现，让我回想起2个月前我回杭州最后参加团队会议的时候，@西子剑影抛出的一样的问题：如果在function之前加上感叹号 (!) 会怎么样？比如下面的代码： 1!function()&#123;alert('iifksp')&#125;() // true 在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？ 平时我们可能对添加括号来调用匿名函数的方式更为习惯： 1(function()&#123;alert('iifksp')&#125;)() // true 或者： 1(function()&#123;alert('iifksp')&#125;()) // true 虽然上述两者括号的位置不同，不过效果完全一样。 那么，是什么好处使得为数不少的人对这种叹号的方式情有独钟？如果只是为了节约一个字符未免太没有必要了，这样算来即使一个100K的库恐怕也节省不了多少空间。既然不是空间，那么就是说也许还有时间上的考量，事实很难说清，文章的最后有提到性能。 回到核心问题，为什么能这么做？甚至更为核心的问题是，为什么必须这么做？ 其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是让一个函数声明语句变成了一个表达式。 1function a()&#123;alert('iifksp')&#125; // undefined 这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错： 1function a()&#123;alert('iifksp')&#125;() // SyntaxError: unexpected_token 因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 a，就应该以 a(); 的方式调用。 但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。 所以，任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别。比如： 123var i = function()&#123;return 10&#125;(); // undefined1 &amp;&amp; function()&#123;return true&#125;(); // true1, function()&#123;alert('iifksp')&#125;(); // undefined 赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些一元运算都是有效的： 1234!function()&#123;alert('iifksp')&#125;() // true+function()&#123;alert('iifksp')&#125;() // NaN-function()&#123;alert('iifksp')&#125;() // NaN~function()&#123;alert('iifksp')&#125;() // -1 甚至下面这些关键字，都能很好的工作： 123void function()&#123;alert('iifksp')&#125;() // undefinednew function()&#123;alert('iifksp')&#125;() // Objectdelete function()&#123;alert('iifksp')&#125;() // true 最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的： 12(function()&#123;alert('iifksp')&#125;)() // undefined(function()&#123;alert('iifksp')&#125;()) // undefined 说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。 最后讨论下性能。我在jsperf上简单建立了一个测试：http://jsperf.com/js-funcion-expression-speed ，可以用不同浏览器访问，运行测试查看结果。我也同时将结果罗列如下表所示（由于我比较穷，测试配置有点丢人不过那也没办法：奔腾双核1.4G，2G内存，win7企业版）： Option Code Ops/sec Chrome 13 Firefox 6 IE9 Safari 5 ! !function(){;}() 3,773,196 10,975,198 572,694 2,810,197 + +function(){;}() 21,553,847 12,135,960 572,694 1,812,238 - -function(){;}() 21,553,847 12,135,960 572,694 1,864,155 ~ ~function(){;}() 3,551,136 3,651,652 572,694 1,876,002 (1) (function(){;})() 3,914,953 12,135,960 572,694 3,025,608 (2) (function(){;}()) 4,075,201 12,135,960 572,694 3,025,608 void void function(){;}() 4,030,756 12,135,960 572,694 3,025,608 new new function(){;}() 619,606 299,100 407,104 816,903 delete delete function(){;}() 4,816,225 12,135,960 572,694 2,693,524 = var i = function(){;}() 4,984,774 12,135,960 565,982 2,602,630 &amp;&amp; 1 &amp;&amp; function(){;}() 5,307,200 4,393,486 572,694 2,565,645 \\ \\ 0 \\ \\ function(){;}() 5,000,000 4,406,035 572,694 2,490,128 &amp; 1 &amp; function(){;}() 4,918,209 12,135,960 572,694 1,705,551 \\ 1 \\ function(){;}() 4,859,802 12,135,960 572,694 1,612,372 ^ 1 ^ function(){;}() 4,654,916 12,135,960 572,694 1,579,778 , 1, function(){;}() 4,878,193 12,135,960 572,694 2,281,186 可见不同的方式产生的结果并不相同，而且，差别很大，因浏览器而异。 但我们还是可以从中找出很多共性：new方法永远最慢——这也是理所当然的。其它方面很多差距其实不大，但有一点可以肯定的是，感叹号并非最为理想的选择。反观传统的括号，在测试里表现始终很快，在大多数情况下比感叹号更快——所以平时我们常用的方式毫无问题，甚至可以说是最优的。加减号在chrome表现惊人，而且在其他浏览器下也普遍很快，相比感叹号效果更好。 当然这只是个简单测试，不能说明问题。但有些结论是有意义的：括号和加减号最优。 但是为什么这么多开发者钟情于感叹号？我觉得这只是一个习惯问题，它们之间的优劣完全可以忽略。一旦习惯了一种代码风格，那么这种约定会使得程序从混乱变得可读。如果习惯了感叹号，我不得不承认，它比括号有更好的可读性。我不用在阅读时留意括号的匹配，也不用在编写时粗心遗忘—— 当我也这么干然后嚷嚷着这居然又节省了一个字符而沾沾自喜的时候，却忘了自己仓皇翻出一本卷边的C语言教科书的窘迫和荒唐……任何人都有忘记的时候，当再捡起来的时候，捡起的就已经不单单是忘掉的东西了。 2011-10-31更新：如果你使用aptana，那么在使用（!+-）时要注意一点，它们会让aptana的解析失效，导致Outline窗口没有任何显示。但是就代码本身而言，其运行没有任何问题。 本文转自扩葵中剑的博客 原文地址：https://swordair.com/function-and-exclamation-mark/","categories":[{"name":"javascript","slug":"javascript","permalink":"http://www.maksim.website/categories/javascript/"}],"tags":[]},{"title":"高并发和大流量解决方案（11）：Web服务器负载均衡","slug":"2018-01-14 高并发和大流量解决方案（11）：Web服务器负载均衡","date":"2018-01-13T16:00:00.000Z","updated":"2018-07-21T06:30:02.075Z","comments":true,"path":"2018/01/14/3/","link":"","permalink":"http://www.maksim.website/2018/01/14/3/","excerpt":"","text":"负载均衡，英文名称为 LoadBalance，其意思就是将负载(工作任务)进行平衡，分摊到多个操作单元上进行执行(例如Web服务器、FTP服务器等)，实现多个服务器共同完成工作任务的目标。负载均衡建立在现有网络结构之上，它提升了服务器的性能、提高了带宽利用率，增强了网络的灵活性和可靠性。 七层负载均衡的实现基于URL等应用层信息的负载均衡，Nginx 的 proxy 是它一个很强大的功能，实现了7层负载均衡。 功能强大，性能卓越，运行稳定 配置简单灵活 能够自动剔除工作不正常的后端服务器 上传文件可以使用异步模式 支持多种分配策略，可以分配权重，分配方式灵活 NGINX 拥有两种策略：内置策略、扩展策略 内置策略是NGINX安装后内置，开箱即用的均衡策略，而扩展策略反之，需要我们安装特定的模块才能进行使用。 内置策略： IP Hash、加权轮询 扩展策略：fair策略、通用hash、一致性hash。 加权轮询：首先将请求都发给高权的机器，直到该机器的权值降到了比其他机器底，才开始将请求分给下一个高权重的机器。当所有后端机器都 down 掉时，NGINX 会立即将所有机器的标志位清成初始状态，以避免所有的机器都处于 timeout 的状态。 IP Hash： 流程和轮询很类似，只是其中的算法和具体的策略有些变化，IP HASH算法算是一种变相的轮询算法。 fair 策略：根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流。 通用hash、一致性hash：比较简单，可以以 NGINX 内置的变量为key进行hash，一致性hash采用了NGINX内置的一致性Hash环，支持 memcache。 1234567891011121314http &#123; upstream cluster &#123; ip hash; server serv1; server serv2; server serv3; &#125; server &#123; listen 80; location/ &#123; proxy_pass http://cluster; &#125; &#125;&#125; 四层负载均衡的实现通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。 在四层负载均衡上，我们可以使用LVS （Linux Virtual Server），意即Linux 虚拟服务器，是一个虚拟服务器的集群系统。该软件是在1998年5月由章文嵩山博士创建，是国内最早出现的自由软件项目之一，它具有良好的可靠性、可扩展性和可操作性。 实现原理LVS 是基于 IP 地址的调度方法实现的，是最高效的实现方法，IP 负载均衡是通过 IPVS 内核模块实现的，IPVS 是 LVS 集群系统的核心软件。 也就是说在我们使用 LVS 之前，我们必须要先安装 ipvs 软件。 安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP（VIP-Virtual IP）地址。在进行域名解析的时候，我们需要将域名解析到 VIP 上。然后根据 VIP 找到 Director Server分发到真实的服务器上。 访问的请求首选in 经过 VIP 到负载调度器，由负载调度器从 Real Server 列表中选取一个节点响应用户的请求。 Real Server 节点返回给用户数据使用过 ipvs 实现的，ipvs 实现负载均衡的机制有三种：NAT(地址转发)，DR （直接路由）和TUN（隧道模式）。 LVS 安装上文提到过，安装 LVS 需要安装 ipvs，我们需要到其官网进行下载： http://www.linuxvirtualserver.org/software/index.html 在下载软件时我们需要注意，要下载对应的内核版本号，使用 uname -r 查看当前 Linux 的内核版本。 同时，我们也可以使用 Linux 自带的包管理器进行安装 1yum -y install ipsadm NAT 模式地址转换技术 DR 只需要将 VIP 配置到 DR 上，将受到的集群服务请求报文目标地址转换成根据算法计算得出的后端主机 IP 地址。 然后后端主主机将相应报文发送至 DR，再由 DR 将原地址转换成 VIP 地址。下面是他的网络拓扑图： 在 LVS（Director）上面需要两双网卡：DIP（内网）和 VIP（外网） 内网的 Real Server 主机的 IP 必须和 DIP 在同一个网络中，并且要求其网关都需要指向 DIP 的地址。 RIP 都是私有 IP地址，仅用于各个节点之间的通信，Director 位于 client 和 Real Server 之间，负责处理所有的进站、出站的通信，支持端口映射。 应用在较大规模的应用场景中，但 Director 容易成为整个架构的瓶颈。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"高并发和大流量解决方案（10）：MySQL优化","slug":"2018-01-14 高并发和大流量解决方案（10）：MySQL优化","date":"2018-01-13T16:00:00.000Z","updated":"2018-06-25T12:49:07.254Z","comments":true,"path":"2018/01/14/2/","link":"","permalink":"http://www.maksim.website/2018/01/14/2/","excerpt":"","text":"在本文中，并没有实现过程，算是一个提纲，当我们需要对MySQL进行优化的时候，可以通过本篇文章，了解一下，我们要对MySQL进行哪些优化，也算是对MySQL的优化先要有一个总体的认知。 因为如果要将所有的操作过程都放到这篇文章中，估计还没等看完，你就已经睡着了，具体的操作，我会在其他系列的博文中陆续的更新出来。 优化方向 数据表数据类型优化 索引优化 SQL 语句优化 存储引擎的优化 数据表结构设计的优化 数据库服务器架构的优化 数据表数据类型优化在做数据表结构类型优化时，我们需要考虑如下几点： 字段使用什么样的数据类型更合适 字段使用什么样的数据类型性能更快 Int: tinyint、smallint、bigint在使用Int类型存储值的时候，一定要按需选择，需要对空间、范围进行考虑，比如存储年龄通常是0~120多，所以我们选择一个最小的tinyint类型，如果加上无符号那么最大值是255，足够我们存储年龄，选择smallint或者bigint明显是一种浪费。 char、varcharchar 的空间效率要比 varchar 要好，如果是存储电话号码，固定为11位，这种类似的需求，使用char要更好。 对于varchar存储一些可变的数据，如用户名。 ### enum 特性、固定的分类可以使用 enum 存储，效率更快。 一定要是固定的分类，如果将来的分类会变，就不适合使用enum，因为这样我们就需要去修改数据库表结构，扩展性会变得很差。 IP 地址的存储IP 地址一般会采用字符型来进行存储，但是这种存储方式会带来很大的空间占用，我们可以使用整型来进行存储，PHP为我们提供了转换函数 ip2lang 索引优化在做索引型优化时，我们需要考虑如下几点： 建立合适的索引 索引在什么场景下效率最高 索引的创建原则 索引不是越多越好，在合适的字段上创建合适的索引，索引本身会影响我们的写操作的速度，并且会占用磁盘空间。 符合索引的前缀原则。 索引的注意事项 符合索引的前缀原则 like 查询%的问题 全表扫描优化 or 条件索引使用情况 字符串类型索引失效的问题 SQL 语句的优化 优化查询过程中的数据访问 使用Limit 返回列不用 * 优化长难句的查询语句 变复杂为简单 切分查询 分解关联查询 优化特定类型的查询语句 优化count() 优化关联查询 优化子查询 优化 Group by 和 distinct 优化 limit 和 union 存储引擎的优化 尽量使用 InnoDB 存储引擎 数据表结构设计的优化 分区操作 通过特定的策略对数据表进行物理拆分 对用户透明 partition by 分库分表 水平拆分 垂直拆分 数据库架构的优化 主从复制 读写分离 双主热备 负载均衡 通过 LVS 的三种基本模式实现负载均衡 MyCat 数据库中间件实现负载均衡。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"高并发和大流量解决方案（9）：数据库缓存","slug":"2018-01-14 高并发和大流量解决方案（09）：数据库缓存","date":"2018-01-13T16:00:00.000Z","updated":"2018-07-20T04:42:52.891Z","comments":true,"path":"2018/01/14/1/","link":"","permalink":"http://www.maksim.website/2018/01/14/1/","excerpt":"","text":"什么是数据库缓存MySQL 等一些常见的关系型数据库的数据都存储在硬盘当中，在高并发场景下，业务应用对 MySQL 产生的增、删、改、查的操作造成巨大的I/O开销和查询压力，这无疑对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生。 使用数据库缓存可以极大的解决我们数据的压力，提高应用数据的响应速度，因为不用再动态查询了，直接将静态数据返回，无论是速度还是效率都要更快一些，节省了，很多查询和计算的时间。 常见的缓存形式：内存缓存，文件缓存 为了避免I/O开销，应该尽量使用内存缓存。 为什么要使用缓存缓存诗句是为了让客户端很少，甚至是不访问数据库服务器进行数据的查询，高并发下，能最大程度地降低对数据库服务器的访问压力。 当我们默认情况下不使用缓存的情况下，我们的执行顺序如下： 用户请求 数据查询 链接数据库服务器并查询数据 将数据缓存起来（HTML、内存、JSON、序列化数据） 显示给客户端 当我们第二次请求或者是新用户访问时候，执行顺序如下： 用户再次请求或者新用户访问 数据查询 直接从缓存中获取数据 显示给客户端 缓存需要考虑的内容 缓存方式的选择 缓存场景的选择 缓存数据的实时性 缓存数据的稳定性 使用 MySQL查询缓存启用MySQL查询缓存 1query_cache_type 查询缓存类型，有0、1、2三个取值。 0 不是用查询缓存 1 始终使用查询缓存 2 按需查询缓存 query_cache_type为1时，也可以关闭查询缓存 1SELECT SQL_NO_CACHE * FROM my_table WHERE condition; query_cache_type为2时，可以按需使用查询缓存 1SELECT SQL_CACHE * FROM my_table WHERE condition; 1query_cache_size 默认情况下query_cache_size为0，表示查询缓存预留的内存为0，则无法使用查询缓存。 1SET GLOBAL query_cache_size = 134217728; 查询缓存可以看成是 SQL 文本和查询结果的映射。 第二查询的SQL和第二次查询的SQL要完全相同，才会使用缓存。 我们可以通过下面的语句查看缓存的命中次数。 1SHOW STATUS LIKE &apos;Qcache_hits&apos;; 表的结构发生改变时候，查询缓存中的数据不再有效。 清理缓存如下： 123FLUSH QUERY CACHE; //清理查询缓存内部碎片RESET QUERY CACHE; //从查询花村中移出所有查询FLUSH TABLES; //关闭所有打开的表，同时该操作将会清空查询缓存中的内容。 使用 Memcache对于大型的站点，如果没有中间缓存层，当流量打入数据库层的时候，即便有之前的几层为我们挡住了大量流量，但是在大并发的请胯下，还是会有大量请求涌入数据库，这样对于数据库服务器的压力冲击很大，响应速度也会下降，因此添加中间缓存层很有必要。 Memcache 是一套分布式的高速缓存系统， 由 LiveJournal 的Brad Fitzpatrick 开发，但目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著。 工作原理Memcache 是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的Hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索出来的结果等。简单的说就是讲数据调用到内存，然后从内存中读取，从而大大提高读取速度。 工作流程先检查服务端的请求数据是否在 memcached中，如果存在直接把请求数据返回，不再对数据库进行任何操作。如果请求的数据不再memcached中，就去查询数据库, 把从数据库中获取的诗句返回给客户端，同时把数据缓存一份到memcached中。 方法获取：get(key) 设置：set(key, val, expire) 删除 : delete(key) 通用缓存机制用查询的方法名 + 参数作为查询时的key value对应中的key值。 使用 Redis与Memcache的区别 性能相差不大 Redis 在2.0版本后增加了自己的 VM 特性，突破了物理内存的限制 Memcache 可以修改最大可用内存，采用 LRU（缓存淘汰） 算法 Redis 依赖客户端来实现分布式读写 Memcache 本身没有数据冗余机制 Redis 支持（快照、AOF），依赖快照进行持久化，AOF 增强了可靠性的同时，对性能也有所影响 Memcache 不支持持久化，通常做缓存，提升性能 Memcache 在并发场景下，用 cas 保证一致性，Redis 事务支持比较弱，只能保证事务中的每个操作的连续执行 Redis 支持多种数据类型 Redis 用于数据量较小的高性能操作和运算上 Memcache 用于动态系统中减少数据库负载，提升性能；适合做缓存，提高性能","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"高并发和大流量解决方案（7）：动态语言静态化","slug":"2018-01-13 高并发和大流量解决方案（07）：动态语言静态化","date":"2018-01-12T16:00:00.000Z","updated":"2018-07-20T04:43:04.021Z","comments":true,"path":"2018/01/13/3/","link":"","permalink":"http://www.maksim.website/2018/01/13/3/","excerpt":"","text":"什么是动态语言静态化将现有 PHP 等动态语言的逻辑代码生成为静态HTML 文件，用户访问动态脚本重定向到静态 HTML 文件的过程。 如果页面中的的数据一直都在变化，那么不建议使用静态化。 为什么要静态化动态脚本通常会做逻辑运算和数据查询，访问量越大，服务器压力越大。 访问量大的时候可能造成 CPU 负载过高，数据服务器压力过大，静态化可以减轻逻辑处理能力，降低数据库服务器的查询压力。 静态化的实现方式使用模板引擎可以使用 Smarty 的缓存机制生成静态 HTML 缓存文件。 123$smarty-&gt;cache_dir = $ROOT.'/cache'; //缓存目录$smarty-&gt;caching = true; //是否开启缓存$smarty-&gt;cache_lifetime = '3600'; //缓存时间 1$smarty-&gt;display(strign template [,string cache_id[, strign compile_id]]); 如果开启了缓存，Smarty 会自动的生成 HTML 缓存文件。 123$smarty-&gt;clear_all_cache(); //清除所有缓存$smarty-&gt;clear_cache('file.html'); //清除指定缓存$smarty-&gt;clear_cache('article,html', $cache_id) //清除一同模板下的指定缓存号的缓存。 利用 OB 系列函数 ob_start()：打开输出控制缓冲 ob_get_contents()：返回输出缓冲区的内容 ob_clean()：清空输出缓冲区 ob_end_flush()：冲刷出（送出）输出缓冲区内容并且关闭缓冲 12345ob_start();输出到页面的 HTML 代码ob_get_contents();ob_end_flush();fopen()写入 可以使用 filectime 函数 判断文件的 inode 修改时间，判断是否过期。 123456789101112131415161718192021&lt;?php$cache_name = md5(__FILE__).'html';$cache_lifetime = 3600;if ( filectime(__FILE__) &lt;= filectime($cache_name) file_exists($cache_name) &amp;&amp; filectime($cache_name) + $cache_lifetime &gt; time()) &#123; //判断 PHP 文件修改时间 //判断是否存在缓存 //判断是否过期 include $cache_name; exit;&#125;ob_start();?&gt;&lt;b&gt; This is my Script&lt;/b&gt;&lt;?php$content = ob_get_contents(); $ob_end_flush();$handle = fopen($cache_name, 'w');fwrite($handle, $content);fclose($handle);?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"高并发和大流量解决方案（6）：动态语言并发处理","slug":"2018-01-13 高并发和大流量解决方案（06）：动态语言并发处理","date":"2018-01-12T16:00:00.000Z","updated":"2018-07-20T04:43:09.598Z","comments":true,"path":"2018/01/13/2/","link":"","permalink":"http://www.maksim.website/2018/01/13/2/","excerpt":"","text":"什么是进程、线程、协程进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 进程的三态模型进程的三态模型：多道程序系统中，进程在处理器上交替运行，状态不断地发生变化 运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单机处理系统，处于运行状态的进程只有一个。没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。 就绪：当一个程序获得了除处理机意外的一切所需资源，一旦得到处理机即可运行，则称此进程出于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程处于时间片用完而进入就绪状态时，排入低优先级队列；当前进程由 I/O 操作完成而进入就绪状态时，排入高优先队列。 阻塞：也称之为等待或者睡眠状态，一个进程正在等待某一事件发生（例如请求 I/O而等待 I/O 完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程出于阻塞状态。 进程的五态模型进程的五态模型：对于一个实际的系统，进程的状态及其转换更为复杂分为新建态、活跃就绪/静止就绪、运行、活跃阻塞/静止阻塞、终止态,可见下图。 新建态：对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息。 活跃就绪：是指进程在主内存并且可被调度的状态。 静止就绪（挂起就绪）：是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将被挂起就绪态进程调回主存并转化为活跃就绪。 活跃阻塞：是指进程已在主存，一旦等待事件产生便进入活跃就绪状态 静止阻塞：进程对换到辅存时的阻塞状态，一旦等地啊的事件产生便进入静止就绪状态。 终止态：进程已经结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中有关信息。 线程由于我们用户的并发请求，为每一个请求都创建一个进程显然是行不通的，从系统资源开销方面或是响应用户请求的效率方面来看。因此系统中线程概念便被引进了。 线程，有时被称之为轻量级的进程（Lightweight Process, LWP），是程序执行流的最小单元。 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属的一个进程的其他线程共享进程所拥有的全部资源。 一个线程可以创建和撤销另一个线程，统一进程的多个线程之间可以并发执行。 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。 在单个程序中同事运行多个线程完成不同的工作，称之为多线程。 每一个程序都只要有一个线程，若程序只有一个线程，那就是程序本身。 线程的状态：就绪、阻塞、运行。 就绪状态：线程具备运行的所有条件，逻辑上可以运行，在等待处理机。 阻塞状态：线程在等待一个事件（如某个信号量），逻辑上不可执行。 运行状态：线程占有处理机正在运行。 协程协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程已拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈基本没有内核切换开销，可以不加锁访问全局变量，所以上下文的切换非常快。 如果想要深入的了解协程的实现，可以读鸟哥有关于协程的博文，里面详细介绍了PHP协程 的实现——传送门。 线程与进程的区别 线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间。 进程是资源分配和拥有的单元，同一个进程内的线程共享进程的资源。 线城市处理器调度的基本单位，进程不是。 两者均可并发执行 每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程和协程的区别 一个线程可以有多个协程，一个协程也可以单独拥有多个协程 线程进程都是同步机制，而协程这是异步 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 什么是多进程，多线程多进程是指同一时间里，统一计算机系统中如果允许两个或者两个以上的进程处于运行状态，就是多进程。多开一个进程，多分配一份资源，进程间通信不方便。 多线程就是把一个进程分为很多片，每一片都可以是一个独立的流程与多进程的却别是只会使用一个进程的资源，线程间可以直接通信。 同步阻塞模型在最早的服务器端程序透视通过多进程、多线程来解决并发IO的问题。 一个请求创建一个进程，然后子进程进入循环同步阻塞地与客户端进行交互，收发处理数据。 多线程模式实现非常简单，线程可以直接向某一个客户端连接发送数据。 步骤： 创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现。 进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入睡眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket 主进程在多进程模型下通过fork（PHP: pcntl_fork）创建子进程，多线程模型下使用pthread_create（PHP: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。 子进程创建成功后进入while循环，阻塞在recv（PHP: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（PHP: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。 当客户端连接关闭时，子进程/线程退出并销毁所有资源。主进程/线程会回收掉此子进程/线程。 缺点： 这种模型严重依赖进程的数量解决并发问题，一个客户端连接就需要占用一个进程，工作进程的数量有多少，并发处理能力就有多少。操作系统可以创建的进程数量是有限的。 启动大量进程会带来额外的进程调度消耗。数百个进程时可能进程上下文切换调度消耗占CPU不到1%可以忽略不计，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到 CPU 的百分之几十甚至 100%。 另外有一些场景多进程模型无法解决，比如即时聊天程序（IM），一台服务器要同时维持上万甚至几十万上百万的连接（经典的C10K问题），多进程模型就力不从心了。 还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100 ms，100个进程可以提供1000 QPS，这样的处理能力还是不错的。但是如果请求内要调用外网HTTP接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到QPS，这样的处理能力就太差了。 123456789101112131415161718//创建scoket监听$scokserv = stream_scoket_server('tcp://0.0.0.0:8880', $errno, $errstr);for ($i = 0; $i &lt; 5; $i++)&#123; if（pcntl_fork() == 0） &#123; while (true) &#123; $conn = stream_scoket_accept($sockserv); if ($conn == false) &#123; continue; &#125; $request = fread($conn, 9000); $response = 'hello'; fwrite($conn, $response); fclose($conn); &#125; exit(); &#125; &#125; 异步非阻塞模型现在各种高并发异步IO的服务器程序都是基于 epoll 实现的。 在早期Linux就提供了select，可以在一个进程内维持1024个连接，后来加入了poll，可以维持任意数量个连接。 但是poll需要循环检测是否有事件，如果服务器当前有100 W个连接，但是某一个时间内只有一条连接向服务器发送数据，这样系统就会循环100 W次，对于CPU是一种浪费。 Linux在2.6时提供了epoll，可以在系统内维持无数个连接，而且无需轮训。 IO复用异步非阻塞程序使用经典的 Reactor 模型，Reactor 顾名思义，就是反应堆的意思，它本身不处理任何数据收发，只是可以监视一个socket句柄的事件变化。 Reactor模型： Add: 添加一个 SOCKET到 Reactor Set： 修改 SOCKET 对应的事件，如可读可写 Del： 从 Reactor 中移除 Callback： 事件发生后回调指定的函数 PHP 并发编程实践PHP的Swoole扩展PHP的异步、并行、高性能的网络通信引擎，使用纯C语言编写，提供了PHP语言的异步多线程服务器，异步TCP/UDP 网络客户端，异步 MySQL，异步 Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步 DNS 查询。 除了异步IO的支持之外，Swoole 为 PHP 多进程的模式设计了多个并发数据结构和 IPC 通信机制，可以大大简化多进程并发编程的工作。 Swoole 2.0支持了类似Go语言的协程，可以使用完全同步的代码实现异步程序。 Swoole 的异步MySQL实现123456789101112131415161718192021222324252627282930$db = new swoole_mysql;$server = array( 'host' =&gt; '192.168.56.102', 'port' =&gt; 3306, 'user' =&gt; 'test', 'password' =&gt; 'test', 'database' =&gt; 'test', 'charset' =&gt; 'utf8', //指定字符集 'timeout' =&gt; 2, // 可选：连接超时时间（非查询超时时间），默认为SW_MYSQL_CONNECT_TIMEOUT（1.0）);$db-&gt;connect($server, function ($db, $r) &#123; if ($r === false) &#123; var_dump($db-&gt;connect_errno, $db-&gt;connect_error); die; &#125; $sql = 'show tables'; $db-&gt;query($sql, function(swoole_mysql $db, $r) &#123; if ($r === false) &#123; var_dump($db-&gt;error, $db-&gt;errno); &#125; elseif ($r === true ) &#123; var_dump($db-&gt;affected_rows, $db-&gt;insert_id); &#125; var_dump($r); $db-&gt;close(); &#125;);&#125;); 消息队列用户注册场景说明：当用户注册后，需要发注册邮件和注册短信。 串行方式：将注册信息写入数据库成功以后，发送注册邮件，再发送注册短信。 并行方式：将注册写入数据库成功后，发送注册邮件的同事，发送注册短信。 消息队列方式：将注册信息写入数据库成功后，将成功信息写入队列，此时直接返回成功给用户，写入队列的时间非常短，可以忽略不计，然后异步发送邮件和短信。 解耦操作场景说明：用户下单后，订单系统需要通知库存系统。假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。此时需要进行解耦。 引入队列： 用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户下单成功。 库存系统订阅下单的消息，采用拉/推得方式，获取下单信息，库存系统根据下单信息，进行库存操作。 流量削峰应用场景：秒杀活动，流量瞬间激增，服务器压力大 用户发起请求，服务器接收后，先写入消息队列，假如消息队列长度超过最大值，则直接报错或提示用户。 后续程序读取消息队列，在进行处理。 日志处理应用场景：解决大量日志的传输 日志采集程序可以将日志写入消息队列，然后通过日志处理程序的订阅消费日志。 消息通讯应用场景： 聊天室 多个客户端订阅同一主题，进行消息发布和接收。 常见的消息队列产品kafka、ActiveMQ、ZeroMQ, RabbitMQ、Redis等等。 接口的并发请求curl_multi系列函数。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"高并发和大流量解决方案（5）： CDN 加速","slug":"2018-01-13 高并发和大流量解决方案（05）： CDN 加速","date":"2018-01-12T16:00:00.000Z","updated":"2018-07-20T04:43:14.112Z","comments":true,"path":"2018/01/13/1/","link":"","permalink":"http://www.maksim.website/2018/01/13/1/","excerpt":"","text":"什么是CDNCDN 的全城是 Content Delivery Network，即内容分发网络，尽可能避开互联网上有可能影响数据传输速度和稳定性的平静和环节，是内容传输的更快、更稳定。 在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层只能虚拟网络，比如说我们现在有一个服务器的集群，现在在北京，有几台服务器在北京，在上海访问北京服务器就会比较慢，我们就可以使用 CDN 解决这样的问题，可以在香港、上海建立一个 CDN 节点，这样当我的用户在某一个节点访问我们的网站时，可以去请求香港的 CDN 节点，这样距离他比较近，CDN 已经把真实服务器的数据缓存到了 CDN 当中，相当于一个镜像。 CDN 系统能够实时地根据网络流量和各节点的连接、敷在情况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 使用 CDN 的优势本地 Cache 加速，提高企业站点（尤其含有大量图片和静态资源页面站点）的访问速度。 跨运营商的网络加速，保证不同网络的用户能得到最好的访问质量。 远程访问用户根据 DNS 负载均衡技术只能选择 Cache 服务器。 自动生成服务器的远程 Mirror（镜像）Cache 服务器，远程用户访问时从 Cache 服务器上读取数据，减少远程访问的带宽、分带网络流量、减轻原站点 WEB 服务器负载等能力。 广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵。 CDN 的工作原理传统访问用户在浏览器输入域名发起请求–&gt;解析域名获取服务器 IP 地址–&gt;根据 IP 地址找到对应的服务器—&gt;服务器响应并返回。 使用 CDN 访问用户发起请求–&gt;只能 DND 解析（根据 IP 判断地理位置、接入网类型、选择路由最短和负载最轻的服务器）–&gt;获得缓存服务器 IP–&gt;把内容返回给用户（如果缓存中有）—&gt;向源站发起请求—&gt;将结果返回给用户—&gt;将结果存入缓存服务器。 CDN 适用场景 站点或者应用中大量静态资源的加速分发，例如：CSS，JS，图片和 HTML。 大文件下载 直播网站 CDN 的实现BAT 等都有提供 CDN 服务。 可用 LVS 做4层负载均衡。 可用 Nginx，Varnish，Squid，Apache TrafficServer 做7层负载均衡和 Cache。 使用 squid 反向代理，或者 Nginx 等的反向代理","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"高并发和大流量解决方案（8）：独立图片服务器的部署","slug":"2018-01-13 高并发和大流量解决方案（08）：独立服务器的部署","date":"2018-01-12T16:00:00.000Z","updated":"2018-07-20T04:42:58.550Z","comments":true,"path":"2018/01/13/4/","link":"","permalink":"http://www.maksim.website/2018/01/13/4/","excerpt":"","text":"独立图片服务器的必要性我们知道，无论对于Apache还是Nginx，图片始终是最消耗系统资源的，如果将图片服务和应用服务放在同一个服务器的话，应用服务器很容易会因为图片的 高I/O负载而崩溃，因此对于有些大型网站项目，我们有必要将图片服务器和应用服务器分离。 部署独立的图片服务器（甚至是服务器集群）是大型网站图片存储解决方案中最基础的，因为有了独立的图片服务器后，我们才能对图片服务器做更有针对性的性能优化，为图片服务器设置针对性的缓存方案，减少带宽成本，提高访问速度。 从硬件角度说，图片服务器可以配置高端的硬盘，7200转的换成15000转的，而CPU只需要使用一般的CPU就可以了。 从软件角度说，可以为图片服务器配置特殊的文件系统来满足对图片的I/O请求，如淘宝 的TFS，就很好地解决了大规模小图片文件带来的I/O噩梦，同时，我们也可以采用Nginx、squid来代理图片请求，通过增加图片服务器，提高图片吞吐能力。 分担 Web 服务器的 I/O 负载-将耗资源的图片服务分离出来，提高服务器的性能、稳定性和扩展性。 采用独立域名注意，这里是指独立域名，不是子域哦，比如yahoo.com图片服务器用了yimg.com的域名，而不是用二级域名img.yahoo.com。 同一域名下浏览器的并发链接数有限制，突破浏览器链接数的限制，通常情况下浏览器的并发连接数是2到6个。 这样，我们如果给图片服务器配置独立的域名，那么在一个页面中加载图片时，就可以突破浏览器连接数的限制，理论上，增加一个独立域名，并发连接数加倍。 另外还有由于 Cookie 的原因，大部分 Web Cache都只缓存不带 Cookie 的请求，导致每次的图片请求都不能命中 Cache。而仍旧要去原始服务器获取图片，导致图片缓存意义不大。所以，还是给单独搞一个图片独立域名吧，当然，不只是图片，CSS和JavaScript文件也可以参照这个思路来搞。 如何进行图片上传和图片同步?NFS 共享方式NFS是Network File System（网络文件系统）。主要功能是通过网络让不同的服务器之间可以共享文件或者目录。 NFS客户端一般是应用服务器（比如web，负载均衡等），可以通过挂载的方式将NFS服务器端共享的目录挂载到NFS客户端本地的目录下。 NFS在文件传送过程中依赖与RPC（远程过程调用）协议。NFS本身是没有提供信息传送的协议和功能的，但是能够用过网络进行图片，视频，附件等分享功能。只要用到NFS的地方都需要启动RPC服务，不论是NFS的服务端还是客户端。 NFS和RPC的关系：可以理解为NFS是一个网络文件系统（比喻为租房的房主），而RPC是负责信息的传输（中介），客户端（相当于租房的租客） 了解 NFS 可以看我的另外一篇博文《LInux 典型应用：》 利用 FTP 同步用户上传完图片后是利用 FTP 同步到各个图片服务器的，PHP、Java、Asp.net基本上都能操作 FTP。这样的话 每个图片服务器就都保存一份图片的副本，也起到了备份的作用。但是缺点是将图片ftp到服务器比较耗时，如果异步去同步的话又会有延时，不过一般的小图片 文件也还好了。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"高并发和大流量解决方案（4）：浏览器缓存和压缩优化技术","slug":"2018-01-12 高并发和大流量解决方案（04）：浏览器压缩","date":"2018-01-12T13:29:10.000Z","updated":"2018-07-20T04:43:32.721Z","comments":true,"path":"2018/01/12/2/","link":"","permalink":"http://www.maksim.website/2018/01/12/2/","excerpt":"","text":"HTTP 缓存机制缓存分类在HTTP缓存模型中，如果请求成功会有三种情况。 200 from cache 304 Not Modified 200 OK 200 from cache: 直接从本地缓存中获取响应，最快速，最省流量，因为根本没有向服务器发送请求I看到。 浏览器本身就有缓存机制，当我们浏览器检测到该资源在本地存在，那么就不需要向服务器发送请求，从下图中我们可以看到size没有大小显示的是 from cache，就是读取的缓存。 查看其响应头我们可以看到下图。 304 Not Modified: 协商缓存，浏览器在本地没有命中的情况下请求头中发送一定的教研数据到服务端，如果服务端数据没有改变，浏览器从本地缓存响应，返回304。 快速，发送的数据很少，只会返回一些基本的响应头信息，数据量很小，不发送实际响应体。 200 OK： 以上两种缓存全部失效，服务器返回完整响应。没有用到缓存，相对较慢，对于200 OK不能称之为缓存，因为根本没有用到缓存机制。 相关 Header Pragma Expires Cache-Control Pragma： HTTP 1.0 时代的遗留产物，该字段被设置为no-cache时，会告知浏览器禁用本地缓存，即每次都向服务器发送请求。 Expires：HTTP 1.0 时代用来启用本地缓存的字段，expires值对应一个形式如Thu, 31 Dec 2037 23:55:55 GMT的格林威治时间，告诉浏览器缓存实现的时刻，如果还没到该时刻，标明缓存有效，无需发送请求。 浏览器与服务器的时间无法保持一致，如果时间差比较大，就会影响缓存结果。我们可以保证服务器的时间，但是无法保证客户端的时间与服务器时间的一致。（QQ 空间就有对客户端时间进行检测，感兴趣的可以将本地时间调整一下然后去访问QQ空间） Cache-Control：HTTP 1.1 针对 Expires 时间不一致的解决方案，运用 Cache-Control 告知浏览器缓存过期时间间隔，而不是时刻，即使具体时间不一致，也不影响缓存的管理。 在Cache-Control下我们还可以设置一些头信息： no-store：禁止浏览器缓存响应 no-cache：不允许直接使用本地缓存，先发起请求和服务器协商，也就是协商缓存 max-age=delta-seconds：告知浏览器该响应本地缓存有效的最长期限，以秒为单位。 优先级： Pragma &gt; Cache-Control &gt; Expires 在上图中，我们可以看到上面的头信息，设置了Cache-Control和Expires。 协商缓存当浏览器没有命中本地缓存，如果本地缓存过期或者响应中生命不允许直接使用本地缓存（Pragma或者Cache-Control设置成了no-cache），那么浏览器肯定会发起服务端请求。服务端会验证数据是否修改，如果没有通知浏览器使用本地缓存。 相关的Header: Last-Modified：通知浏览器资源的最后修改时间，格式如上图。 If-Modified-Since：这是与Last-Modified相对应的一个头信息，得到资源的最后修改时间后，会将这个信息通过If-Modified-Since提交到服务器进行检查，如果没有修改则返回304状态码。 ETag: HTTP 1.1 推出，文件的指纹标识符，如果文件内容修改，指纹会改变，Last-Modified只能精确到秒，而 ETag 如果发生了改变，它就会改变，它就相当于文件的标识（”78437822c-6739”），也更加准确。 If-Node-Match：与ETag相对应的一个头信息，本地缓存失效，会携带此值去请求服务端，服务端判断该资源是否改变，如果没有改变直接使用本地缓存，返回304 通过下面的两张图，我们可以看到完整的协商缓存交互： 缓存策略的选择适合的内容： 不变的图像，如logo，图标等 js、css静态文件 可下载的内容，媒体文件 建议使用协商缓存： HTML文件 经常替换的图片 经常修改的js、css js、css问价你的加载可以加入文件的签名来拒绝缓存 （index.css?签名、index.签名.js） 不建议缓存的内容： 用户隐私等敏感数据 经常改变的 api 数据接口 NGINX 配置缓存策略首先，我们使用PHP模拟NGINX的缓存。 1234567891011121314&lt;?php //1. 获取If-Modified-Since $since = $_SERVER['HTTP_IF_MODIFIED_SINCE']; //2. 设置过期时间一个小时 $lifetime = 3600; //3. 如果没有过期直接返回304告诉浏览器使用本地缓存 if (strtotime($since) + $lifetime &gt; time()) &#123; header('HTTP/1.1 304 Not Modified'); exit; &#125; //4. 设置最后修改时间 header('Last-Modified:'. gmdate('D, d M Y H:i:s', time()). ' GMT'); //5. 网页显示的内容，用于验证是否开启缓存 echo time(); 上述代码就是NGINX的缓存原理，不过NGINX判断的不是3600秒，而是文件的修改时间。 本地缓存配置 add_header指令：添加状态码为2XX和3XX的响应头信息。 1add_header name value [always]; 可以设置Pragma/Expires/Cache-Control，可以继承 expires指令：通知浏览器过期市场 expires time; 为负值时表示Cache-Control:no-cache； 为正或0时，就表示Cache-Control:max-age=指定的时间； 12345678location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$&#123; expires 30d;&#125;location ~ .*\\.(js|css)?$ ｛ expires 12h;｝ 当设为max时，会把Expires设置为”Thu, 31 Dec 2037 23:55:55 GMT”，Cache-Control设置到10年。 协商缓存配置 ETag指令：指定签名 etag on | off 默认是on 1234location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$&#123; etag on;&#125; Cache-Control 1234location ~ .*\\.(js|css)?$ ｛ add_header cache-control max-age = 3600;｝ 前端代码和资源的压缩 优势 让资源文件更小 加快文件在网络中的传输 让网页更快的展示 降低带宽和流量的开销 压缩方式 JS、CSS、图片、HTML代码的压缩 Gzip压缩 JavaScript代码压缩JavaScript压缩的原理一般是去掉多余的空格和回车、替换长变量名、简化一些代码的写法。 压缩工具有很多，有在线工具、有应用程序、有编辑器插件。 常用的压缩工具： UglifyJs： 压缩、语法检查、美化代码、代码缩减、转化 YUI compressor：来自Yahoo，只有压缩功能 Closure Compiler：来自Google、功能和UglifyJs有些类似，压缩的方式不太一样。 CSS代码压缩原理和JavaScript压缩原理类似，同样是去除空白符、注释并且优化一些CSS语义规则。 常用的压缩工具： YUI compressor：来自Yahoo，只有压缩功能 CSS Compiler：压缩时候可以选择模式，也可以对一些语法进行优化 HTML代码压缩不建议使用代码压缩，有时会破坏代码结构，可以使用Gzip压缩，当然也可以使用htmlcompressor工具，不过转换后一定要检查代码结构。 图片压缩除了代码的压缩外，有时对图片的压缩也是很有必要的，一般情况下图片在Web系统的比重都比较大。 压缩工具 tinypng JpegMini ImageOptim Gzip压缩GZIP最早由Jean-loup Gailly和Mark Adler创建，用于UNⅨ系统的文件压缩。我们在Linux中经常会用到后缀为.gz的文件，它们就是GZIP格式的。现今已经成为Internet 上使用非常普遍的一种数据压缩格式，或者说一种文件格式。 HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来.一般对纯文本内容可压缩到原大小的40%.这样传输就快了，效果就是你点击网址后会很快的显示出来.当然这也会增加服务器的负载. 一般服务器中都安装有这个功能模块的。 NGINX配置： 123456789gzip on|of #是否开启gzipgzip_buffres 32 4k| 16 8k; #缓冲（在内存中缓冲几块，每块多大）gzip_comp_level [1-9] #推荐6 压缩级别（级别越高，压缩的越小，越浪费CPU计算资源）gzip_disable #正则匹配UA什么样的Uri不进行gzipgzip_min_length 200 #开始压缩的最小长度gzip_http_version 1.0|1.1 #开启压缩的http协议版本gzip_proxied #设置请求者代理服务器，该如何缓存内容gzip_types text/plain applecation/xml #对那些文件类型使用压缩gzip_vary on | off #是否传输gzip压缩标志 其他工具 自动化构建工具Grunt","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://www.maksim.website/tags/高并发/"}]},{"title":"高并发和大流量解决方案（3）：减少 HTTP 请求","slug":"2018-01-12 高并发和大流量解决方案（03）：HTTP 请求","date":"2018-01-12T11:29:10.000Z","updated":"2018-07-20T04:43:28.694Z","comments":true,"path":"2018/01/12/1/","link":"","permalink":"http://www.maksim.website/2018/01/12/1/","excerpt":"","text":"为什么要减少HTTP请求性能黄金法则：只有10%~20%的最终永不响应时间花在接收请求的HTML文档上，剩下的80%~90%时间花在HTML文档所引用的所有组件（图片，script，css，flash等等）进行的HTTP请求上。 如何改善改善响应时间的最简单途径就是减少组件的数量，并由此减少HTTP请求的数量。 HTTP链接产生的开销域名解析 – TCP链接 – 发送请求 – 等待 – 下载资源 – 解析时间 需要注意 DNS 缓存也需要时间，多个缓存就要查找多次有可能缓存会被清除 HTTP1.1 协议规定请求只能串行发送，也就是说一百个请求必须一次逐个发送，前面的一个请求完成才能开始下一个请求。 减少HTTP请求的方式图片地图图片地图允许你在一个图片上关联多个URL。目标URL的选择取决于用户单击了图片上的哪个位置。 我们可以通过使用五个分开的图片，然后每个图片对应一个超链接产生了5个HTTP请求，我们的目标是要减少HTTP请求。 将五个图片合并成为一张图片，然后以位置信息定位超链接。 把HTTP请求减少为一个 ，可以暴增设计的完整性和功能的齐全性。 1&lt;map&gt;&lt;area&gt;&lt;/map&gt;&lt;/map&gt; 实例未使用图像地图的例子： http://stevesouders.com/hpws/imagemap-no.php 使用图像地图的例子： http://stevesouders.com/hpws/imagemap.php CSS SpritesCSS Sprites 中文翻译为 CSS 精灵，通过使用合并图片，通过指定 CSS 的 backgroud-image 和backgroud-position来显示元素。 backgroud-position属性 backgroud-position:x,y; x和y可以写负值也可以写正值，我们可以想象图片的左上方为（0，0），以（0，0）坐标向右是为负数的 X 轴，以（0，0）坐标向下是为负数的 y 轴。 使用图片精灵的案例： http://stevesouders.com/hpws/sprites.php 图片地图和 CSS Sprites 的响应时间基本相同，但比使用各自独立图片的方式要快50%以上。 合并脚本和样式表使用外部的 JS 和 CSS 文件引用的方式，因为这要比直接写在页面中性能要更好一点。 独立的一个 JS 比用多个 JS 文件组成的页面载入要快38%。 把多个脚本合并为一个脚本，把多个样式表合并成为一个样式表。 http://stevesouders.com/hpws/combo-none.php http://stevesouders.com/hpws/combo.php 图片使用base64编码减少页面请求数采用Base64的编码方式将图片直接嵌入到网页中，而不是从外部载入。 1&lt;img src=\"data:image/gif;base64,/9j/4AAqsKZJ.....\"&gt; http://stevesouders.com/hpws/inline-images.php http://stevesouders.com/hpws/inline-css-images.php","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://www.maksim.website/tags/高并发/"}]},{"title":"高并发和大流量解决方案（2）：Web资源防盗链","slug":"2018-01-11 高并发和大流量解决方案（02）：资源防盗链","date":"2018-01-11T04:20:11.000Z","updated":"2018-07-20T04:43:24.364Z","comments":true,"path":"2018/01/11/2/","link":"","permalink":"http://www.maksim.website/2018/01/11/2/","excerpt":"","text":"什么是防盗链盗链是指在自己的页面上展示一些并不在自己服务器上的内容。 获得他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容。 常见的是小站盗用大站的图片、音乐、视频、软件等资源。 通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器。 防盗链就是防止别人通过一些技术手段绕过本站的资源展示页面，盗用本站的资源，让绕开本站资源展示页面的资源链接失效。 防盗链的工作原理通过 Referer 或者签名，网站可以检测目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示它的网页地址。 一旦检测到来源不是本站即进行组织或者返回指定的页面。 Nginx防盗链的实现Nginx RefererNginx 模块 ngx_http_referer_module 用于阻挡来源非法的域名请求。 Nginx 指令 valid_referers，全局变量$invalid_referer。 1valid_referers none | blocked | server_names| string ...; none: “Referer” 来源头部为空的情况 blocked: “Referer”来源头部不为空，但是里面的值被代理或者防火墙删除了，这些值都以 http://或者 https://开头。 server_names: “Referer” 来源头不包含当前的 server_names 123456789location ~.*\\.(gif|jpg|png|flv|swf|rar|zip)$&#123; valid_referers none blocked maksim.website *.maksim.website; if ($invalid_referer) &#123; #return 403; rewrite ^/http://www.maksim.website/403.jpg; &#125;&#125; 针对目录 123456789location /images/&#123; valid_referers none blocked maksim.website *.maksim.website; if ($invalid_referer) &#123; #return 403; rewrite ^/http://www.maksim.website/403.jpg; &#125;&#125; Nginx HTTPAccessKeyModule 加密签名1234accesskey on | offaccesskey_hashmethod md5 | sha-1 accesskey_arg GET参数名称accesskey_signatrue 加密规则 1234567location ~.*\\.(gif|jpg|png|flv|swf|rar|zip)$&#123; accesskey on accesskey_hashmethod md5 accesskey_arg \"key\" accesskey_signatrue \"maksim$remote_addr\"&#125; 1234&lt;?php //md5(maksim.ip) $sign = md5('maksim'.$_SERVER['REMOTE_ADDR']); echo '&lt;img src=\"./image/maksim.png?sign='. $sign .'\"&gt;';","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"高并发和大流量解决方案（1）：起步","slug":"2018-01-10 高并发和大流量解决方案（01）：起步","date":"2018-01-10T02:20:11.000Z","updated":"2018-07-20T04:43:19.859Z","comments":true,"path":"2018/01/10/1/","link":"","permalink":"http://www.maksim.website/2018/01/10/1/","excerpt":"","text":"PHP 如何解决网站大流量与高并发的问题高并发架构的相关概念高并发的概念 并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任意一个时刻点上只 有一个程序在处理机上运行。 上面这一段是摘自百度百科的一段话，但是上面的定义很明显不是我们通常所说的并发，在互联网时代，所讲的并发、高并发，通常是指并发访问。也就是在某一个时间点，有多少个访问同时到来。 高并发： 通常如果一个系统的日 PV 在千万以上，有可能是一个高并发的系统，有的公司完全不走技术路线，全靠机器堆，这不再我们的讨论范围。 高并发中需要关注相关概念 QPS: 每秒钟请求或者查询的数量，在互联网领域，指的是每秒响应请求数（指的是HTTP请求）。 吞吐量：单位时间内处理的请求数量（通常由QPS与并发数决定） 响应时间： 从请求发出到收到响应花费的时间。例如系统处理一个HTTP请求需要 100ms, 这个 100ms 就是系统的响应时间。 PV： 综合浏览量（Page View），即页面浏览量或者点击量，一个访客在24小时内访问的页面数量。同一个人浏览你的网站统一页面，只记录一次 PV。 UV： 独立访客（UniQue Visitor），即一定时间范围内相同访客多次访问网站，只计算为一个独立访客。 带宽： 计算带宽大小需关注两个指标，峰值流量和页面的平均大小 日网站带宽： PV/统计时间（换算到秒）*平均页面大小（单位KB）* 8，峰值一般为平均值的倍数，根据实际情况来定。 压力测试： 测试服务器能够最大承受的最大并发数和QPS值，对于计算机来说，我们应该知道这台服务器最大能够承受多少QPS，而我们可以通过一天的PV来计算出峰值的QPS，这样我们就可以根据需求进行优化。 QPS 不等于并发数数量，QPS是每秒HTTP请求数量，并发连接数是系统同时处理的请求数量。 (总PV数 80%) / (6小时秒数 20%) = 峰值每秒请求数量(QPS)， 80%的访问量集中在20%的时间，那为什么是6个小时呢？ 6个小时主要是做了一个简单的估计，比如说我们访问网站中午两个小时，下午两个小时，晚上两个小时。 AB 压力测试工具常用的性能测试工具：** ab、wrk、http_load、Web Bench、Siege、 Apache Jmeter ab 全称是 Apache benchmark，是 Apache 官方推出的工具创建多个并发访问线程，模拟多个访问者同时访问某一URL 地址进行访问。它的测试目标是基于 URL 的，因此，它既可以用来测试 Apache 的负载压力，也可以测试 Nginx、lighthttp、tomact、IIS 等其它 Web 服务器的压力。 ab 的简单使用模拟并发请求100次，总共请求5000次。 ab -c 100 -n 5000 待测试网站 注意事项 测试机器与北侧机器分开 不要对线上服务做压力测试 观察测试工具 ab 所在机器，以及被测试的前端机的 CPU，内存，网络等都不超过最高限度的75%。 Q PS 达到极限随着 QPS 的增长，每个阶段需要根据实际情况来进行优化，优化的方案也与硬件、网络带宽息息相关。 QPS 达到50可以称之为小型网站，一般的服务器都可以应付 QPS 达到100假设关系型数据库的每次请求在0.01秒完成。 假设单页面只有一个 SQL 查询，那么100QPS 意味着1秒钟完成100个请求，但是此时我们并不能保证数据库查询能完成100次。 方案：数据库缓存层、数据库的负载均衡 QPS 达到800假设我们使用百兆带宽，意味着网站出口的实际带宽是8M 左右，假设每个页面只有10K，在这个并发条件下，百兆带宽已经吃完了。 方案：CDN 加速、负载均衡 QPS 达到1000假设使用 Memcache 缓存数据库查询数据，每个页面对 Memcache 的请求远大于直接 DB 的请求。 Memcache 的悲观并发数在2W 左右，但有可能在之前内王带宽已经吃光，表现出不稳定 方案：静态 HTML缓存 QPS 达到2000这个级别下，文件系统访问锁都成了灾难。 方案：做业务隔离，分布式存储 高并发解决方案案例流量优化 防盗链处理 前段优化 减少 HTTP 请求 添加异步请求 启用浏览器缓存和文件压缩 CDN 加速 建立独立的图片服务器 服务端优化 页面静态化 并发处理 队列处理 数据库优化 数据库缓存 分库分表、分区操作 读写分离 负载均衡 Web 服务器优化 负载均衡（Nginx、LVS）","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"创建型设计模式之抽象工厂","slug":"2018-01-09 抽象工厂","date":"2018-01-09T12:44:02.000Z","updated":"2018-06-25T12:52:46.078Z","comments":true,"path":"2018/01/09/1/","link":"","permalink":"http://www.maksim.website/2018/01/09/1/","excerpt":"","text":"原文地址：http://designpatternsphp.readthedocs.io 在软件工程中，创建型设计模式承担着对象创建的职责，尝试创建适合程序上下文的对象，对象创建设计模式的产生是由于软件工程设计的问题，具体说是向设计中增加复杂度，创建型设计模式解决了程序设计中对象创建的问题。 抽象工厂目的创建一系列互相关联或依赖的对象时不需要指定将要创建的对象对应的类，因为这些将被创建的对象对应的类都实现了同一个接口。抽象工厂的使用者不需要关心对象的创建过程，它只需要知道这些对象是如何协调工作的。 UML 图 代码在 GitHub 上查看代码 AbstractFactory.php 123456789101112&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;/** * In this case, the abstract factory is a contract for creating some components * for the web. There are two ways of rendering text: HTML and JSON */abstract class AbstractFactory&#123; abstract public function createText(string $content): Text;&#125; JsonFactory.php 1234567891011&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;class JsonFactory extends AbstractFactory&#123; public function createText(string $content): Text &#123; return new JsonText($content); &#125;&#125; HtmlFactory.php 1234567891011&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;class HtmlFactory extends AbstractFactory&#123; public function createText(string $content): Text &#123; return new HtmlText($content); &#125;&#125; Text.php 12345678910111213141516&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;abstract class Text&#123; /** * @var string */ protected $text; public function __construct(string $text) &#123; $this-&gt;text = $text; &#125;&#125; JsonText.php 12345678&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;class JsonText extends Text&#123; // do something here&#125; HtmlText.php 12345678&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory;class HtmlText extends Text&#123; // do something here&#125; 测试12345678910111213141516171819202122232425262728&lt;?phpnamespace DesignPatterns\\Creational\\AbstractFactory\\Tests;use DesignPatterns\\Creational\\AbstractFactory\\HtmlFactory;use DesignPatterns\\Creational\\AbstractFactory\\HtmlText;use DesignPatterns\\Creational\\AbstractFactory\\JsonFactory;use DesignPatterns\\Creational\\AbstractFactory\\JsonText;use PHPUnit\\Framework\\TestCase;class AbstractFactoryTest extends TestCase&#123; public function testCanCreateHtmlText() &#123; $factory = new HtmlFactory(); $text = $factory-&gt;createText('foobar'); $this-&gt;assertInstanceOf(HtmlText::class, $text); &#125; public function testCanCreateJsonText() &#123; $factory = new JsonFactory(); $text = $factory-&gt;createText('foobar'); $this-&gt;assertInstanceOf(JsonText::class, $text); &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"DOM本质","slug":"2018-01-05 DOM本质","date":"2018-01-04T16:00:00.000Z","updated":"2018-06-25T12:40:57.234Z","comments":true,"path":"2018/01/05/2/","link":"","permalink":"http://www.maksim.website/2018/01/05/2/","excerpt":"","text":"抛出问题! DOM是那种基本的数据结构？ DOM操作的常用API都有哪些？ DOM节点的attr和property有何区别？ 解答问题: 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;title&gt;Reminder&lt;/title&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt; &lt;other&gt; &lt;a&gt;&lt;/a&gt; &lt;b&gt;&lt;/b&gt; &lt;/other&gt;&lt;/note&gt; DOM本质上面的代码是一段XML，这是一个结构化语言，跟它其同样作用的还有JSON，他们可以用于描述一切可以结构化的数据。 这段代码快描述了一封信，to收件人，from 来源，title标题，body内容。 DOM本质上是一个树形结构。我们可以将其理解为，浏览器把拿到的HTML代码，结构化成一个浏览器能够识别且能被js操作的一个模型。 我们知道HTML本质上就是字符串，计算机处理字符串是一件相当头疼的一件事情，通过DOM，我们就可以将HTML文件抽象成一个树形结构，只要是结构化的数据，计算机处理起来，无论你的逻辑结构有多复杂，他都能够轻松的进行处理。 获取DOM节点1234567var div1 = document.getElementById('div1') //元素 var divList = document.getElementByTagName('div') //集合console.log(divList.length)console.log(divList[0])var containerList = document.getElementsByClassName('.container'); //集合var pList = document.querySelectorAll('p') //集合 上面的代码都是JavaScript的基础API，有的人可能用jQuery或其他的的库时间长了，就把基础API给忘了，或者是基础并不是很牢，一直都在用库，这样的话最好将基础补齐，因为在面试的时候，大多数的面试题都是问的基础。 在面试的时候有个技巧，不要轻易的撩起用的熟，但是不知道实现原理的东西，比如说你会用jQuery的绑定事件，面试官肯定会问你实现原理。 Property12345678910var pList = document.querySelectorAll('p')var p = pList[0]console.log(p.style.width) //获取样式p.style.width = '100px;'console.log(p.className)p.className = 'p1'//获取nodeName 和 nodeTypeconsole.log(p.nodeName)console.log(p.nodeType) 在这里我们需要知道P是个什么东西，它不就是个DOM节点吗？ 其实它本质上就是一个JS对象。上面我们说过DOM的本质是一个JS可识别可操作的。既然本质上是一个对象，我们就可以操作他的属性，那这些属性都是怎么进去的？ 这是浏览器规定的，W3C就是这么规定的。 12345var obj &#123;x:100, y:200&#125;;console.log(obj.x) // 100var p = document.getElementsByTagName('p')[0]cosnole.log(p.nodeName); //p Attribute123456var pList = document.querySelectorAll('p')var p = pList[0]p.getAttribute('data-name')p.setAttribute('data-name', 'maksim')p.getAttribute('style')p.setAttribute('style', 'font-size:30px;') 我们在上述代码中该的 data-name 和 style 到底是什么呢？ 其实就是HTML文档里的标签，并不是JavaScript里的对象。这也是两者之间的区别。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maksim.website/categories/JavaScript/"}],"tags":[]},{"title":"cookie, sessionStorage和localStorage的区别","slug":"2018-01-05 cookie,-sessionStorage和localStorage的区别","date":"2018-01-04T16:00:00.000Z","updated":"2018-06-25T12:40:53.535Z","comments":true,"path":"2018/01/05/1/","link":"","permalink":"http://www.maksim.website/2018/01/05/1/","excerpt":"","text":"在HTML5出来之前，只有cookie作为本地存储的一个方法（JavaScript Web API）。 cookie 本身用于客户端和服务器端通信的， 但是它有本地存储的功能， 于是被“借用” 使用document.cookie = … 获取和修改即可，用起来特别麻烦 缺点： 存储量太小，只有4kb 所有http请求都带着，会影响获取资源的效率，所以cookie只适合保存很小的数据，如会话标识 API简单，需要封装才能用document.cookie = … 有效时长根据设定的过期时间而定。 ​ sessionStorage 和localStorage HTML5专门为存储而设计，因为不需要像服务端发送数据，所以最大容量5M API简单易用： localStorage.setItem(key, value); localStorage.getItem(key) sessionStorage当关闭浏览器后便会被清除，localStorage则不会，即使关闭浏览器localStorage也会一直存在，直到删除 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的 在iOS Safari 隐匿模式下，localStorage.getItem会报错，建议同一使用try-catch Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.maksim.website/categories/JavaScript/"}],"tags":[]},{"title":"如何学习 - 读《请停止无效努力》","slug":"2017-12-02 如何学习 - 读《请停止无效努力》","date":"2017-12-01T16:00:00.000Z","updated":"2018-06-25T12:41:03.623Z","comments":true,"path":"2017/12/02/1/","link":"","permalink":"http://www.maksim.website/2017/12/02/1/","excerpt":"","text":"我们从出生直至死亡都在学习中度过，出生后我们学习如何行走，说话，恋爱，各式各样种样繁多的知识，到死了，我们要学会放下。 通过阅读《请停止无效努力》一书中就详细的介绍了如何学习，怎样学习更高效，这本书的核心的观点就是靠意志力学习是幻想。 如何快乐地学习 第一，我们喜欢这个学习内容，或者学习本身。 第二，我们能够学得好，能够让自己有成就感 第三，这种学习能够帮我们带来价值 如何快乐并且有效地持续学习 第一，按需学习：学习这个东西是否对现阶段有价值。 第二，调整心态：对待学习的态度，决定了我们是否喜欢它。 第三，提升元认知策略：每个人有不同的学习风格，了解自己的风格并且调整学习方法，能够大大提高学习效率。 第四，正确犯错：人类的大脑是从犯错中学习的，能否从错误中学习，决定了我们从学习中获得的成就感还是挫败感。 成人与孩子对于学习的区别 第一，自愿 第二，经验 第三，自主 第四，行动 由于成人与孩子的学习方式不同，综合以上四点，在选择学习内容的时候，我们需要遵循的原则是： 原则一——有用：对我们现阶段有用的，这个用处不一定是工作或者赚钱，也可以是让人放松等等。 原则二——匹配：跟我们的经验北京相匹配的，不会太粗浅，也不会太深奥。 原则三——参与：能够有参与感的，手脚是的学习最好不要参与。 原则四——应用：可以应用到行动中去的，跟我们的工作、生活相结合的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.maksim.website/categories/读书笔记/"}],"tags":[]},{"title":"玩转消息队列（01）：Beanstalkd","slug":"2017-11-20 玩转消息队列 (01)：Beanstalkd ","date":"2017-11-19T16:00:00.000Z","updated":"2018-09-12T14:38:04.682Z","comments":true,"path":"2017/11/20/cjlz9pr6z0065abrdo9k7nt2z/","link":"","permalink":"http://www.maksim.website/2017/11/20/cjlz9pr6z0065abrdo9k7nt2z/","excerpt":"","text":"Beanstalk是一个高性能、轻量级的、分布式的、内存型的消息队列系统。最初设计的目的是想通过后台异步执行耗时的任务来降低高容量Web应用系统的页面访问延迟。其实Beanstalkd是典型的类Memcached设计，协议和使用方式都是同样的风格。其基本设计思想很简单：高性能离不开异步，异步离不开队列，而内部都是生产者-消费者模式的。 Beanstalk主要包括4个部分。 job:一个需要异步处理的任务，需要放在一个tube中。 tube:一个有名的任务队列，用来存储统一类型的job，是producer和consumer操作的对象。 producer:job的生产者，通过put命令来将一个job放到一个tube中。 consumer:job的消费者，通过reserve、release、bury、delete命令来获取job或改变job的状态。 Beanstalkd使用场景： 用作延时队列：比如可以用于如果用户30分钟内不操作，任务关闭。 用作循环队列：用release命令可以循环执行任务，比如可以做负载均衡任务分发。 用作兜底机制：比如一个请求有失败的概率，可以用Beanstalk不断重试，设定超时时间，时间内尝试到成功为止。 用作定时任务：比如可以用于专门的后台任务。 用作异步操作：这是所有消息队列都最常用的，先将任务仍进去，顺序执行。 Job的生命周期一个工作任务job当client使用put命令时创建。在整个生命周期中job可能有四个工作状态：ready，reserved，delayed，buried。在put之后，一个job的典型状态是ready，在ready队列中，它将等待一个worker取出此job并设置为其为reserved状态。worker占有此job并执行，当job执行完毕，worker可以发送一个delete指令删除此job。 Status Description ready 等待被取出并处理 reserved 如果job被worker取出，将被此worker预订，worker将执行此job delayed 等待特定时间之后，状态再迁移为ready状态 buried 等待唤醒，通常在job处理失败时 job典型的生命周期 12 put reserve delete-----&gt; [READY] ---------&gt; [RESERVED] --------&gt; *poof* job可能的状态迁移 123456789101112131415161718 put with delay release with delay----------------&gt; [DELAYED] &lt;------------. | | kick | (time passes) | | | put v reserve | delete-----------------&gt; [READY] ---------&gt; [RESERVED] --------&gt; *poof* ^ ^ | | | \\ release | | | `-------------&apos; | | | | kick | | | | bury | [BURIED] &lt;---------------&apos; | | delete `--------&gt; *poof* Tubes一个服务器有一个或者多个tubes，用来储存统一类型的job。每个tube由一个就绪队列与延迟队列组成。每个job所有的状态迁移在一个tube中完成。consumers消费者可以监控感兴趣的tube，通过发送watch指令。consumers消费者可以取消监控tube，通过发送ignore命令。通过watch list命令返回所有监控的tubes，当客户端预订一个job，此job可能来自任何一个它监控的tube。 当一个客户端连接上服务器时，客户端监控的tube默认为defaut，如果客户端提交job时，没有使用use命令，那么这些job就存于名为default的tube中。 tube按需求创建，无论他们在什么时候被引用到。如果一个tube变为空（即no ready jobs，no delayed jobs，no buried jobs）和没有任何客户端引用，它将会被自动删除。 安装首先我们需要安装依赖 1yum install libevent libevent-devel 然后下载项目到服务器中 123456[root@MyDB1 beanstalkd-1.10]# wget https://github.com/kr/beanstalkd/archive/v1.10.tar.gz[root@MyDB1 beanstalkd-1.10]# tar -zxvf v1.10.tar.gz[root@MyDB1 beanstalkd-1.10]# cd beanstalkd-1.10[root@MyDB1 beanstalkd-1.10]# make[root@MyDB1 beanstalkd-1.10]# make install install beanstalkd /usr/local/bin/beanstalkd 启动 1beanstalkd -l 127.0.0.1 -p 11300 &amp; PHP 操作 Beanstalkd当我们安装后之后，想要操作队列，需要使用 Pheanstalk 库。","categories":[{"name":"MessageQueue","slug":"MessageQueue","permalink":"http://www.maksim.website/categories/MessageQueue/"}],"tags":[]},{"title":"C语言中的内存","slug":"2017-10-21 C语言中的内存","date":"2017-10-20T16:00:00.000Z","updated":"2018-07-02T14:07:37.285Z","comments":true,"path":"2017/10/21/1/","link":"","permalink":"http://www.maksim.website/2017/10/21/1/","excerpt":"","text":"C 程序在编译后，会以三种形式使用内存。 静态变量/全局内存 静态声明的变量分配在这里，全局变量也会使用这部分内存。这些内存在程序开始运行时分配，直到程序终止才会消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。 自动内存 这些变量在函数内部声明，并且在函数被调用时才能创建。它们的作用域局限于函数内部，而且在函数被调用才创建。它们的作用域局限于函数内部，热切声明周期限制在函数的执行时间内。 动态内存 内存分派在堆上，可以根据需要存放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.maksim.website/categories/C-C/"}],"tags":[]},{"title":"PHP 基础面试全覆盖（07）： 写出 PHP 类的权限控制修饰符？","slug":"2017-10-17 PHP 基础面试全覆盖（07）： 写出 PHP 类的权限控制修饰符？","date":"2017-10-16T16:00:00.000Z","updated":"2018-06-26T15:25:04.718Z","comments":true,"path":"2017/10/17/3/","link":"","permalink":"http://www.maksim.website/2017/10/17/3/","excerpt":"","text":"面试真题：写出 PHP 类的权限控制修饰符？ 考点：PHP的类权限控制修饰符 延伸：面向对象的封装、继承和多态 延伸：魔术方法 延伸：设计模式 这一题的单很简单，就是考察我们的基础知识：public、protected、private。 public：修饰的成员变量拥有最高权限，我们可以在类的内部、外部，子类中使用。 protected：可是在类的内部，类的子类中使用，可以被继承，但是不能在外部使用。 private: 只能在类的内部使用，不能被继承。 单一继承在面试过程中经常会问到PHP的继承模式，这里我们需要注意，PHP是单一继承; 方法重写继承还有方法重写，在继承的时候，如果子类存在于父类相同的方法名时，子类会覆盖掉父类的方法，如果不想被子类重写，需要使用 final 关键字！ 如果子类重写父类方法后，需要使用父类该方法的功能，需要使用 parent关键字。 多态PHP面试很少回去考多态，但是我们需要了解抽象类和接口的定义。 魔术方法下列魔术方法需要我们特别记忆： __construct() __destruct() __call() __callStatic() __get() __set() __isset() __unset() __sleep() __wakeup() __toString() __clone() 设计模式常见的设计模式：工厂模式、单利模式、注册树设计模式、适配器模式、观察者模式和策略模式","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP基础","slug":"PHP基础","permalink":"http://www.maksim.website/tags/PHP基础/"}]},{"title":"PHP 基础面试全覆盖（05）：运算符","slug":"2017-10-17 PHP 基础面试全覆盖（06）：运算符 ","date":"2017-10-16T16:00:00.000Z","updated":"2018-06-26T15:33:06.501Z","comments":true,"path":"2017/10/17/2/","link":"","permalink":"http://www.maksim.website/2017/10/17/2/","excerpt":"","text":"面试真题foo()和@foo()之间的区别考点分析 PHP 的运算符的错误控制符@的使用 延伸 PHP 所有的运算符考点 运算符的优先级 比较运算符 递增/递减运算符 逻辑运算符 错误运算符PHP 支持一个错误运算符：@，当将其放置在一个 PHP 表达式之前，该表达式可能产生一个任何错误信息都被忽略。 运算符优先级如果看过 PHP 手册应该都知道，在其中有一个表格。 结合方向 运算符 附加信息 无 clone new clone 和 new 左 [ array() 右 \\ 算术运算符 右 ++ – ~ (int) (float) (string) (array) (object) (bool) @ 类型和递增／递减 无 instanceof 类型 右 ! 逻辑运算符 左 ** / %* 算术运算符 左 + - . 算术运算符和字符串运算符 左 &lt;&lt; &gt;&gt; 位运算符 无 &lt; &lt;= &gt; &gt;= 比较运算符 无 == != === !== &lt;&gt; &lt;=&gt; 比较运算符 左 &amp; 位运算符和引用 左 ^ 位运算符 左 *\\ * 位运算符 左 &amp;&amp; 逻辑运算符 左 *\\ \\ * 逻辑运算符 左 ?? 比较运算符 左 ? : ternary right = += -= =* *= /= .= %= &amp;= \\ = ^= &lt;&lt;= &gt;&gt;=* 赋值运算符 左 and 逻辑运算符 左 xor 逻辑运算符 左 or 逻辑运算符 上面这一章大表，我们不需要全部记忆，应该着重记忆在面试中经常出现的考点。 递增/递减 &gt; ! &gt; 算数运算符 &gt; 大小比较 &gt; （不）相等比较 &gt; 引用 &gt; 位运算 (^)&gt; 位运算(|)&gt;逻辑与 &gt; 逻辑或 &gt; 三目 &gt; 赋值 &gt; and &gt; xor &gt; or 注意 括号可以增加代码的可读性，推荐使用 不建议使用 ++、–，因为这样的代码可读性不高，在 swift 中都已经废弃了此类运算符。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"PHP 基础面试全覆盖（08）： 开发环境与运行原理","slug":"2017-10-17 PHP 基础面试全覆盖（08）： 开发环境与运行原理","date":"2017-10-16T16:00:00.000Z","updated":"2018-07-02T13:51:16.185Z","comments":true,"path":"2017/10/17/4/","link":"","permalink":"http://www.maksim.website/2017/10/17/4/","excerpt":"","text":"真题：你是否使用过版本控制器，如果有你使用的版本控制器的名称是什么？考点： 版本控制软件 PHP 的运行原理 PHP 常见的配置项 常见的版本控制软件分为集中式和分布式，其中 SVN 就是集中式的，有一个中央服务器，代码编写完成后将代码同步至中央服务器，版本信息只保存在中央服务器。 Git是目前最流行的分布式的版本控制器，没有中央服务器，所有客户机都有一套完整的版本库信息，对于版本控制的容灾性。 PHP 的运行原理 NGINX + PHP-fmCGI，早期的 Web Server 服务只能处理一些简单的 HTMl 文件，随着技术的发展出现了动态语言比如说PHP、Python，如果说我们要处理PHP的话，需要交给PHP解析器去处理，处理完成后需要与Web服务进行通信。为了解决不同语言与Web Server的通信，就出现了 CGI 协议，只要按照 CGI 程序编写程序就能够实现语言解析器和Web Server的通信 FastCGI: 虽然CGI解决PHP和Web Server通信的问题，但是它的效率很低，因为Web Server每接收一个请求都会fork一个CGI进程，然后请求结束后再Kill掉这个进程，如果有一万个、十万个请求就会产生大量的进程，然后在Kill掉，这样一来会浪费掉很多资源。这样 FastCGI 出现了，主要是以 CGI 的改良版本出现的，请求完成后不会kill掉进程，而是保留进程，使这个进程可以处理多个进程，这样就不用fork 进程了，节约了大量的资源。 PHP-FPM:是PHP的 FastCGI 的进程管理器，PHP-FPM 是 FastCGI 的一个实现，并且实现了进程管理的功能，其中包括master和work进程，master进程负责监听端口号（默认是9000）接收来自Web Server的请求，work进程有多个，根据FPM的配置进行定义，每个进程都会嵌入一个PHP解析器，也就是PHP代码真正执行的地方。 NGINX通过反向代理，代理PHP-FPM监听的端口。 PHP常见的配置项 register_globals allow_url_fopen allow_url_include date.timezone display_errors error_reporting safe_mode upload_max_filesize max_file_uploads post_max_size","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP基础","slug":"PHP基础","permalink":"http://www.maksim.website/tags/PHP基础/"}]},{"title":"PHP 基础面试全覆盖（05）：  =与==、===的区别","slug":"2017-10-17 PHP 基础面试全覆盖（05）： PHP 解惑 引用变量","date":"2017-10-16T16:00:00.000Z","updated":"2018-06-26T15:34:17.849Z","comments":true,"path":"2017/10/17/1/","link":"","permalink":"http://www.maksim.website/2017/10/17/1/","excerpt":"","text":"什么是引用变量？在 PHP 当中，用什么符号定义引用变量？ 在 PHP 中引用意味着通过不同的名字访问相同的变量内容。使用&amp;符号。 工作原理 12//定义一个变量$a = range(0, 1000); PHP 在定义变量的时候，会在内存中开辟出一块内存空间，然后将$a 指向该内存空间。 12//定义变量 b，将 a 变量的值赋值给变量 b$a = $b; 此时在定义 $b 的时候并不会在内存中开辟空间，因为对于 PHP 来说有一个 Copy On Write机制（写时复制），也就是在 $a, $b 修改的时候才会进行 copy。 12//对 a 进行修改$a = range(0, 1000); 此时才会开辟一块空间，在 PHP 中我们无法像 C 语言一个做到输出指针地址，所以无法查看内存分配情况，但是我们可以使用memory_get_usage()来查看内存的使用情况。 123456789//定义一个变量$a = range(0, 1000);var_dump(memory_get_usage());//定义变量 b，将 a 变量的值赋值给变量 b$a = $b;var_dump(memory_get_usage());//对 a 进行修改$a = range(0, 1000);var_dump(memory_get_usage()); 123int(369104) //声明赋值 aint(369224) //声明变量 b，将 a 变量的值复制给 bint(513728) //写时复制 123456789//定义一个变量$a = range(0, 1000);var_dump(memory_get_usage());//定义变量 b，将 a 变量的值赋值给变量 b$a = &amp;$b;var_dump(memory_get_usage());//对 a 进行修改$a = range(0, 1000);var_dump(memory_get_usage()); 在上一段代码中使用了&amp;引用变量，这个时候就不会再出现重新分配空间的情况了，因为 $b 指向的就是 $a 的内存空间。 123//zval 变量容器$a = range(0, 3);xdebug_debug_zval('a'); 执行上面的代码就可以看到 zval 结构体 1a:(refcount=1, is_ref=0)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3) refcount: 引用计数器 is_ref :是否引用 123456//zval 变量容器$a = range(0, 3);xdebug_debug_zval('a');$b = $a;xdebug_debug_zval('a'); 123a:(refcount=1, is_ref=0)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3)a:(refcount=2, is_ref=0)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3) 此时 refcount 就变成了2 12345678910//zval 变量容器$a = range(0, 3);xdebug_debug_zval('a');$b = $a;xdebug_debug_zval('a');//修改 aa = range(0, 3);xdebug_debug_zval('a'); 12345a:(refcount=1, is_ref=0)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3)a:(refcount=2, is_ref=0)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3)a:(refcount=1, is_ref=0)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3) 到第三步的时候 refcount 恢复到了1，因为 $a 进行了写操作。 12345678$a = range(0 ,3);xdebug_debug_zval('a');$b = &amp;a;xdebug_debug_zval('a');a = range(0, 3);xdebug_debug_zval('a'); 12345a:(refcount=1, is_ref=0)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3)a:(refcount=2, is_ref=1)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3)a:(refcount=2, is_ref=1)=array(0 =&gt; (refcount=1, is_ref=0) )=0, 1=&gt;(refcount=1, is_ref=0)=1,2=&gt;(refcount=1, is_ref=0)=2,3=&gt;(refcount=1, is_ref=0)=3) 当我们使用unse函数时，需要知道，只会取消引用，不会销毁空间。 1234$a = 1;$b = &amp;$a;unset($b);echo $a. \"\\n\"; 11 对象本身就是引用传递 1234567891011class Person&#123; public $name = 'zhangsan';&#125;$p1 = new Person;xdebug_debug_zval('p1');$p2 = $p1;xdebug_debug_zval('p1');$p2-&gt;name = 'lisi';xdebug_debug_zval('p1'); 123p1: (refcount=1, is_ref=0) = class Person &#123; public $name = (refcount=2, is_ref=0)=&apos;zhangsan&apos;&#125;p1: (refcount=2, is_ref=0) = class Person &#123; public $name = (refcount=2, is_ref=0)=&apos;zhangsan&apos;&#125;p1: (refcount=2, is_ref=0) = class Person &#123; public $name = (refcount=1, is_ref=0)=&apos;zhangsan&apos;&#125; 面试题： 写出如下程序结果 1234567&lt;?php$data = ['a', 'b', 'c'];foreach ($data as $key =&gt; $value) &#123; $value = &amp;$data[$key];&#125; 程序运行时，每一次循环结束后变量$data 的值是什么？请解释。 程序执行完成后，变量$data 的值是什么？请解释 答案: 12345671.[a,b,c][b,b,c][b,c,c]2.[b,c,c] 123456789101112$k=0;$v=a;$v=&amp;d[0];$k=1;$v=b =&gt; d[0] = b;$v=&amp;$d[1];$k=2;$v=c;d[1] = c;$v=&amp;$d[2];","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"PHP 基础面试全覆盖（04）：常量以及数据类型","slug":"2017-10-16 PHP 基础面试全覆盖（04）：  常量及数据类型","date":"2017-10-15T16:00:00.000Z","updated":"2018-06-26T16:04:12.348Z","comments":true,"path":"2017/10/16/4/","link":"","permalink":"http://www.maksim.website/2017/10/16/4/","excerpt":"","text":"PHP 中字符串可以使用哪三种定义方法以及各自的区别是什么？ PHP的字符串的定义方式 单引号 双引号 hereDoc 和 newdoc 单引号的区别 单引号不能解析变量 单引号不能解析转义字符，只能解析单引号和反斜线本身 变量和变量、变量和字符串、字符串和字符串之间可以用.链接 双引号的区别 双引号可以解析变量，变量可以使用特殊字符和{}包含 双引号可以解析所有的转义字符 也可以使用.连接 单引号的效率要高于双引号 12$str = 'abcdef $a g'; // $a 会被原样输出$str = \"abcdef '&#123;$a&#125;' gh\"; // 不会输出&#123;&#125;只做分割的作用 1234$sql = \"SELECT * FROM user WHERE name = '$name'\";//可以用单引号改写成$sql = 'SELECT * FROM user WHERE name = \\''.$name.'\\''; Heredoc 和 NewDoc 的区别 Heredoc 类似于双引号 Newdoc 类似于单引号 12345678910111213//HereDoc$str &lt;&lt;&lt; EoT...EoT;//NewDoc$str &lt;&lt;&lt; 'EoT'...EoT; 浮点类型 不能用于比较运算当中 1234567$a = 0.1;$b = 0.7;if ($a + $b == 0.8) &#123; //$a + $b == 0.7999 echo 'true';&#125; PHP 在进行计算的时候，会把0.1和0.7交给 CPU 进行计算，CPU 会将浮点型转换为二进制，就会出现损耗。 布尔类型 FALSE 的七种情况： 整型0、浮点0.0、布尔 FALSE、空字符串、0字符串、空数组、NULL 10, 0.0, '', '0', false, array(), NULL //if 判断为 FALSE 超全局数组 $GLOBALS、$_GET、$_POST、$_REQUEST、$_SESSION、$_COOKIE、$_SERVER、$_FILES、$_ENV $_SERVER[‘SERVER_ADDR’]：服务器的 IP 地址_ $_SERVER[‘SERVER_NAME’]：服务器的名称 $_SERVER[‘REQUEST_TIME’]：请求时间 $_SERVER[‘ QUERY_STRING’]：请求参数 $_SERVER[‘HTTP_REFERER’]: 访问来源 $_SERVER[‘HTTP_USER_AGENT’]：HTTP_USER_AGENT信息 $_SERVER[‘REMOTE_ADDR’]：客户端 IP $_SERVER[‘REQUEST_URI’]：http://www.www.com/1 后面的1 $_SERVER[‘PATH_INFO’]：路径部分 NULL的三种情况 直接赋值 NULL、未定义的变量、unset 销毁的变量 常量定义区别 const 是语言结构更快 define 是函数 define 不能用于类常量的定义，const 可以 预定义常量 1__FILE__;__LINE__;__DIR__;__FUNCTION__;__CLASS__;__TRAIT__;__METHOD__;__NAMESPACE__","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP基础","slug":"PHP基础","permalink":"http://www.maksim.website/tags/PHP基础/"}]},{"title":"PHP 基础面试全覆盖（03）：=与==、===的区别","slug":"2017-10-16 PHP 基础面试全覆盖（03）： =与==、===的区别","date":"2017-10-15T16:00:00.000Z","updated":"2018-06-25T13:10:23.076Z","comments":true,"path":"2017/10/16/3/","link":"","permalink":"http://www.maksim.website/2017/10/16/3/","excerpt":"","text":"首先等于号（=）在大多数语言中都是赋值操作； ==和===都是比较运算符，用来比较两个变量间的关系，他们两个都有“等于”的含义，不过===是恒等计算符。两侧数据类型不一致时会返回 false，在官方文档中给出如下： ==如果两侧的变量类型不同时，会转化类型后在进行比较。 例子 名称 结果 $a == $b 等于 TRUE，如果类型转换后 $a 等于 $b。 $a === $b 全等 TRUE，如果 $a 等于 $b，并且它们的类型也相同。 上表摘自 PHP 手册。下面来看一个例子： 123456&lt;?php $age = 18; var_dump($age == 18)l //bool(true) var_dump($age === 18); //bool(true) var_dump($age == '18'); //bool(true) var_dump($age === '18'); //bool(false)","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP基础","slug":"PHP基础","permalink":"http://www.maksim.website/tags/PHP基础/"}]},{"title":"PHP 基础面试全覆盖（01）： 为什么要省略结束标签","slug":"2017-10-16 PHP 基础面试全覆盖（01）： 为什么要省略结束标签","date":"2017-10-15T16:00:00.000Z","updated":"2018-06-25T13:09:55.421Z","comments":true,"path":"2017/10/16/1/","link":"","permalink":"http://www.maksim.website/2017/10/16/1/","excerpt":"","text":"对于PHP编译器来说，脚本的结束标签?&gt;是可选的，在写程序时你可以忽略它。你或许碰见过：在使用include()、require()或输入输出缓冲函数时，页面顶部有时会多空行或者出现“header had send”之类的错误信息，这类问题与结束标签有关。 省略结束标签适合纯PHP文件。如果是PHP与HTML混合开发，则不可省略。 忽略结束标签不仅能少些两个字符，而且可以使得我们开发的过程更加顺利。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP基础","slug":"PHP基础","permalink":"http://www.maksim.website/tags/PHP基础/"}]},{"title":"PHP 基础面试全覆盖（02）： emtpy、isset、is_null的区别","slug":"2017-10-16 PHP 基础面试全覆盖（02）：  emtpy、isset、is_null的区别","date":"2017-10-15T16:00:00.000Z","updated":"2018-06-25T13:13:59.275Z","comments":true,"path":"2017/10/16/2/","link":"","permalink":"http://www.maksim.website/2017/10/16/2/","excerpt":"","text":"PHP提供了3个用于测试变量值的函数，分别是isset()、empty()、is_null（从这里就可以看出PHP系统函数变量名命名的混乱，这也是一直被人诟病的地方）.这几个函数均返回布尔值，有时使用不当会造成意想不到的结果。 比如，用isset()和empty()返回的结果是相反的，但却并非一直如此。 isset()用来检测一个变量是否已声明且值不为null。只能在变量不是null时返回真。 empty()用来检测一个变量是否为空，也就是说有如下情况时返回真值：变量是一个空字符串，false，空数组,null,’’,以及被unset删除后的变量。 在PHP5.5之后，empty()函数可以接受任意类型的表达式 is_null()函数用来判断变量内容是否是null，即返回真值的条件仅为变量值是null，值得一提的是，is_null() 是 isset() 的反函数，区别是isset()函数可以应用到未知变量，但is_null()只能针对以声明的变量。 对比项 变量值($var) isset($var) empty($var) is_null($var) “”（空字符串） bool(true) bool(true) bool(false) “ “(空格) bool(true) bool(false) bool(false) FALSE bool(true) bool(true) bool(false) TRUE bool(true) bool(false) bool(false) array() bool(true) bool(true) bool(true) NULL bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true) bool(true)","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"RESTful API架构","slug":"2017-10-12 RESTFul 是什么？","date":"2017-10-11T16:00:00.000Z","updated":"2018-06-25T12:41:34.083Z","comments":true,"path":"2017/10/12/1/","link":"","permalink":"http://www.maksim.website/2017/10/12/1/","excerpt":"","text":"RESTFul 是什么？RESTful的本质是一种软件架构风格，核心是面向资源，主要用来解决降低开发的复杂性，提高系统的可伸缩性。随着互联网的发展，各种终端层出不穷，手机浏览器，手机 APP 为了节约成本，我们可以使用 RESTful 架构，只需要封装好一套完善的API就可以为多套终端提供服务。 设计概念和准则 网络上所有事物都可以被抽象为资源 每一个资源都有唯一的标识符，对资源的操作不会改变这些标识 所有的操作都是无状态的 所谓的资源就是网络上的一个实体，或者说是网络上一个具体的信息。 HTTP 协议 - URL HTTP 是一个属于应用层的协议，特点是简捷、快速 1schema://host[:port]/path[?query-string][#anchor] schema 指定底层使用的协议（如：http,https） host 服务器的 IP 地址或者域名 port 服务器端口 path 访问资源的路径 query-string 发送给 http 服务器的数据 anchor 锚 HTTP RESTful API的设计一、协议API与用户的通信协议，总是使用HTTPs协议。 二、域名应该尽量将API部署在专用域名之下。 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1https://example.org/api/ 三、版本（Versioning）应该将API的版本号放入URL。 1https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 四、路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/employees 五、HTTP动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的HTTP动词。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 下面是一些例子。 GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 六、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 七、状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 状态码的完全列表参见这里。 八、错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: &quot;Invalid API key&quot;&#125; 九、返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 十、Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 123456&#123;\"link\": &#123; \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\"&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 12345&#123; \"current_user_url\": \"https://api.github.com/user\", \"authorizations_url\": \"https://api.github.com/authorizations\", // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。 1234&#123; \"message\": \"Requires authentication\", \"documentation_url\": \"https://developer.github.com/v3\"&#125; 上面代码表示，服务器给出了提示信息，以及文档的网址。 十一、其他（1）API的身份认证应该使用OAuth 2.0框架。 （2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 引用： 理解RESTful架构 地址：http://www.ruanyifeng.com/blog/2011/09/restful.html","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"MySQL常用存储引擎之Innodb","slug":"2017-10-10 MySQL常用存储引擎之Innodb","date":"2017-10-10T12:20:10.000Z","updated":"2018-07-02T14:08:43.067Z","comments":true,"path":"2017/10/10/cjlz9pr5t0054abrdfkya05z5/","link":"","permalink":"http://www.maksim.website/2017/10/10/cjlz9pr5t0054abrdfkya05z5/","excerpt":"","text":"Mysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。 和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。 特点： 灾难恢复性好 支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的 使用行级锁 对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的 实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引 支持外键 支持热备份 Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由innodb_file_per_table这个参数决定。 如果值为 ON,会为每个 innodb 表建立一个tablename.ibd的系统文件，如果该参数为OFF时会把数据存储到系统的表空间ibdataX 引用 《打造扛得住的 MySQL》 慕课网 《高性能 MySQL》","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"MySQL性能优化（06）：索引优化","slug":"2017-09-19 MySQL 性能优化(06)： 索引优化","date":"2017-09-16T16:00:00.000Z","updated":"2018-09-08T05:25:27.186Z","comments":true,"path":"2017/09/17/7/","link":"","permalink":"http://www.maksim.website/2017/09/17/7/","excerpt":"","text":"索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构，索引对于良好的性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响越发重要，不过在数据量较小而且负载较低时，不恰当的索引对性能的影响可能还不明显，担当数据量组件增大时，性能则会几急剧下降。 而且当表中的数据比较少时，查询的频率比较低的情况下，索引的作用可能不太明显，因为这个时候表中的数据差不多都可以缓存到内存中。所以就算是进行全表扫描，效率也不会太慢。 但是当数据量越来越庞大，查询频率也越来越高，内存无法缓存所有数据的时候，索引的作用就会显得越来越重要。 在日常工作中，人们总是忽略或者过分的强调索引的作用，有的时候甚至是会出现两个极端。 表中除了主键之外一条索引都没有 表中的每一列都建立索引 既然是两个极端，那么也就意味着，这两种方法都不正确太少或者太多的索引都会对系统带来一定的影响。只有在正确的列上，建立正确的索引的情况下，才能提升数据库的索引能力。 为了能够正确的使用索引，我们先来看看MySQL所支持的索引类型。 在开头，我们说过，索引的作用是告诉存储引擎如何快速的找到所需要的数据，所以索引是在引擎层上实现的，而不是 在 MySQL 服务器层上实现的，所以也就导致不同存储引擎之间实现的方式是不同的，同时的也不是所有的引擎支持所有的索引类型。 #B-Tree索引 B-Tree索引是MySQL中最常见的索引类型，当人们谈论索引的时候，如果没有特别指明类型，那么多半说的就是B-tree索引，它使用B-Tree的结构存储数据，在B-Tree种，每一个叶子节点都会包含一个指向下一个节点的指针。这样可以方便叶子节点之间的遍历。 B-tree结构存储数据通过简单的图例，讲解讲解一下B-tree的存储结构。 从图中，我们可以看到B+树是一种平衡的查找树，每一个叶子到根部的距离都是相同的，所有的记录节点都是按照键值的大小顺序排列的在同一个节点上的。 并且每个节点之间是使用指针连接的这就时一个典型的B树存储结构，对于不同的存储引擎的实现可能会有所不同，比如说 MyISAM 索引在叶子节点上是通过物理位置来引用行的，InnoDB则是通过主键来引用行的。 B-tree索引能够加快数据的查询速度。 通常情况下，索引的大小远小于表中数据的大小，使用了B-tree索引，存储引擎就不需要进行全表扫描，取而代之的是从索引的根节点进行搜索，根节点存储了指向下一层节点的指针，存储引擎根据这些指针向下层查找。 通过比较接节点页的值和要查找的值，找到合适的指针进入下一层的子节点，而这些指针实际上是定义了子节点值得上限和下限，所以最终存储引擎要找到对应的值或者是不存在的。 最终存储引擎通过b-tree查找到子节点，子节点的指针指向的是数据。 B-tree更适合范围查找 因为B-tree是顺序存储 什么情况下可以使用B树索引。 全值匹配的查询 order_sn = &#39;201723010222&#39; 匹配最左侧前缀的查询 匹配列前缀查询 order_sn like &#39;9876%&#39; 匹配范围值得查询 order_sn &gt; &#39;201723010222&#39; AND order_sn &lt; &#39;201723010333&#39; 精确匹配左前列并范围匹配另外一列 只访问索引的查询 B-tree索引的使用限制使用索引命中了表中大部分数据时，MySQL查询优化器，使用全表扫描的方式性能可能更好，所以就不适用索引查询了。 此外在使用B-tree索引的时候还会受一些限制。 如果偶不是按照索引最左列开始找茬，则无法使用索引 使用索引时不能跳过索引中的列 Not in 和 &lt; &gt;操作无法使用索引 如果查询中有某个列的范围查询，则其右侧所有列都无法使用索引 Hash索引在MySQL的一些存储引擎中还有支持Hash索引的存储引擎，MyISAM 就是同时支持Hash和B-tree，默认情况下使用的是Hash索引，InnoDB支持Hash索引，不过它的Hash索引不是我们来建立的，而是根据B-tree的使用情况自行建立的，也成为自适应Hash索引。 Hash索引时基于Hash表实现的，只有查询条件精确匹配Hash索引的所有列时，才能使用Hash索引，也就是说Hash索引只能用于等值查询上，如果要进行范围或者模糊查询就无法使用Hash索引。 对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"MySQL性能优化(4)：操作系统优化","slug":"2017-09-17 MySQL 性能优化(04)： 操作系统优化","date":"2017-09-16T16:00:00.000Z","updated":"2018-09-08T05:24:31.551Z","comments":true,"path":"2017/09/17/1/","link":"","permalink":"http://www.maksim.website/2017/09/17/1/","excerpt":"","text":"影响数据库性能的主要因素有很多，主要包括以下几点： 服务器硬件 服务器系统 数据库存储引擎的选择 数据库参数配置 数据库结构设计和SQL语句 服务器系统MySQL本身支持很多操作系统： Windows FreeBSD Solaris Linux 很多人都习惯将开发环境的数据库部署在Windows上，将生产环境的数据库部署在Linux上，这就会导致一个问题，MySQL 的schema存储方式在文件系统上实际是一个目录，在Windows平台上，大小写是不敏感的，而在Linux上大小写是敏感的，所以这就会导致，数据库和表的名字在Windows是可以运行的，但是当移植到Linux下就会找不到相关数据库和表的错误。 CentOS系统参数优化内核相关参数（/etc/sysctl.conf） 12345678910111213141516171819202122232425262728293031# net.core.somaxconn = 65535net.core.netdev_max_backlog = 65535net.ipv4.tcp_max_syn_backlog = 65535# TCP连接回收net.ipv4.tcp_fin_timeout = 10net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.core.wmen_default = 87380net.core.wmen_max = 16777216net.core.rmem_default = 87380net.core_rmem_max = 1677216net.ipv4.tcp_keeplive_time = 120net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 3kernel.shmmax = 4294967295# Linux内核参数最重要的参数之一，用于定义单个共享内存段的最大值# 1. 这个参数应该设置的足够大，以便能在一个共享内存段下容纳下整个Innodb缓冲池的大小# 这个值的大小对于64位Linux系统，可取的最大值为物理内存值-1byte,建议设置为物理内存的一半，一半取决于Innodb缓冲池的大小即可，可以取物理内存-1bytevm.swappiness = 0 # 这个参数当内存不足时会对性能产生较明显的影响# Linux系统内存交换区。# 禁用交换分区所带来的风险：# 1. 降低操作系统的性能# 2。 容易造成内存溢出，崩溃，或者被操作系统kill掉# 在MySQL服务器上保留叫分区还是有必要的额，但是要控制何时使用交换分区，vm.swappiness = 0 ，就是告诉内核除非虚拟内存完全满了，否则就不会使用交换分区 增加资源限制（/etc/security/limit.conf），这个文件实际上是Linux PAM也就是插入式认证模块的配置文件。 123456789* soft nofile 65535* hard nofile 65535# * 表示对所有用户有效# soft 指的是当前系统生效的设置# hard 表明系统中所设定的最大值# nofile 表示所限制的资源是打开文件的额最大数目# 65535 就是限制的数量# 把可打开的文件数量增加到65535个，以保证可以打开足够多的文件句柄，这个文件的修改需要重启系统后生效 磁盘调度策略(/sys/block/devname/queue/scheduler) 12cat /sys/block/devname/queue/schedulernoop anticipatory deadline [cfq] noop（电梯式调度策略）NOOP实现了一个FIFO队列，它像电梯的工作方式一样对I/O请求进行组织，当有一个新的请求到来时，它将请求合并到最近的请求之后，以此来保证请求同一个介质。NOOP倾向于饿死读而利于写，因此NOOP对于闪存设备，RAM以及嵌入式是最好的选择。 deadline（介质时间调度策略）Deadline确保了在一个截至时间内服务请求，这个截至时间是可调整的，而默认读期限短于写期限。这样就防止了写操作因为不能被读取而饿死的现象。Deadline对数据库类应用是最好的选择。 anticipatory（预料I/O调度策略）本质上与Deadline一样，但在最后一次读操作后，要等待6ms，才能继续进行对其他I/O请求进行调度。它会在每个6ms中插入新的I/O操作，而会将一些小写入流合并成一个大写入流，用写入延时换取最大的写入吞吐量。AS适合于写入较多的环境，比如文件服务器，AS对数据库环境表现很差。 通过下面方法修改磁盘策略： 1echo deadline &gt; /sys/block/devname/queue/scheduler 文件系统在Windows环境下，仅有FAT和NTFS两种文件系统，但其实现在只使用NTFS。 在Linux环境下就不同了，目前主流的文件系统有EXT3、EXT4、XFS。这三种文件系统都带有日志，安全性可以得到保证，江湖传闻XFS新更能更好。 EXT3/4系统的挂在参数(/etc/fstab) 1234# 日志写入data = writeback | ordered | jouranlnoatime, nodiratime/dev/sda1/ext4 noatime,nodiratime,data=writeback 1 1 writeback 只有元数据写入到日志，这是最快的一种配置，因为 innodb 有自己的日志，所以writeback对于 innodb 是最好的选择。 ordered journal 提供了院子","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"MySQL性能优化（5）：服务器参数对 MYSQL 的影响","slug":"2017-09-17 MySQL 性能优化(05)：服务器参数对 MYSQL 的影响","date":"2017-09-16T16:00:00.000Z","updated":"2018-09-08T05:24:40.355Z","comments":true,"path":"2017/09/17/2/","link":"","permalink":"http://www.maksim.website/2017/09/17/2/","excerpt":"","text":"人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。 MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。 从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。 ## MySQl获取配置信息路径 命令行参数 mysqld_safe --datadir=/data/sql_data 配置文件 mysqld --help --verbose | grep -A 1 &#39;Default options&#39; MySQL会先从/etc/my.cnf文件下读取配置信息，然后是/etc/mysql/my.cnf。 MySQL配置参数的作用域 全局参数 set global 参数名 = 参数值; set @@global。参数名:=参数值; 会话参数 set [session] 参数名=参数值; set @@session.参数名:=参数值; 会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。 在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。 内存配置相关参数MySQL对于内存的使用我们可以分为两个类来看。 无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存 可以通过参数配置控制的，各类的缓冲池所需要的内存。 对内存参数配置之前，我们需要进行考虑： 确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。 确定MySQL的每个连接使用的内存，例如排序缓冲和临时表 把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。 sort_buffer_size join_buufer_szie read_buffer_size read_rnd_buffer_size 确定需要为操作系统保留多少内存给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。 数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。 另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。 如何为缓冲池分配内存Innodb_buffer_pool_size，Innodb缓冲区 总内存-（每个线程所需要的内存*连接数）- 系统保留内存 手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。 key_buffer_size设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而 1select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos; I/O相关配置参数Innodb I/O相关配置 安全相关配置参数expire_logs_days 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"MySQL性能优化（5）：MySQL体系结构","slug":"2017-09-16  MySQL 性能优化(05)：MySQL体系结构","date":"2017-09-15T16:00:00.000Z","updated":"2018-09-08T05:23:30.241Z","comments":true,"path":"2017/09/16/5/","link":"","permalink":"http://www.maksim.website/2017/09/16/5/","excerpt":"","text":"数据库产品的架构一般可以分为应用层、逻辑层、物理层，对于MySQL，同样可以理解为如下3个层次。 其中Connectors可以理解为各种客户端、 应用服务； Connection Pool可以理解为应用层，负责和客户端、用户进行交互，需要和不同的客户端（PHP,Java,C API,.Net以及ODBC,JDBC等等）和中间服务器进行交互，这一层主要完成的是链接处理，授权认证，和安全等一些功能，连接到MySQL的客户端在其进程中，都会有一个独立的线程，连接的查询只会在这个登录线程中进行查询。 Management Services&amp;Utilities、SQL Interface、 Parser、 Optimizer、 Caches&amp;Buffers、 Pluggable Storage Engines可以理解为数据库的大脑——逻辑层。 负责具体的查询处理、事务处理、存储管理、恢复管理，以及其他附加功能。查询处理器负责查询的解析、执行。当接收到客户端的查询时，数据库会分配一个县城来处理它。先友查询处理器（优化器）生成执行计划，然后交由计划执行器来执行，执行器有时需要访问更底层的事务管理器、存储管理器来操作数据，事务管理器、存储管理器主要负责事务控制、并发控制、存储管理。在其中，将由事务管理来保证“ACID”特性，通过锁管理器来控制并发，由日志管理器来确保数据持久化，存储故那里器一般还包括一个缓冲管理器，有它来确定磁盘和缓存之间的数据传输。 根据上面的架构图，我们可以看到在逻辑层中Pluggable Storage Engines 这是MySQL服务逻辑架构中的第三层，是MySQL的存储引擎，MySQL提供出了存储引擎接口，第三方可以根据自己的业务逻辑需求开发自己的存储引擎，Innodb起初就是由Innobase Oy公司所开发，2006年5月被甲骨文公司并购。 服务器通过API与存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作，但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层和服务的请求。 注意：存储引擎是针对于表的而不是针对于库的，不同的表可以使用不同的引擎； 最下方的Files&amp;Logs可以理解为物理层，实际物理磁盘（存储）上的数据库文件，比如数据文件、日志文件等等。 引用： 《MySQL DBA修炼之道》 作者陈晓勇 出版社：华章图书 《打造扛得住的MySQL》 电子工业出版社","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"MYSQL性能优化（7）：存储引擎的选择","slug":"2017-09-16  MySQL 性能优化(07)：存储引擎的选择","date":"2017-09-15T16:00:00.000Z","updated":"2018-09-08T05:27:07.100Z","comments":true,"path":"2017/09/16/7/","link":"","permalink":"http://www.maksim.website/2017/09/16/7/","excerpt":"","text":"MyISAMMyISAM存储引擎是MySQL5.5之前版本默认的存储引擎，由于这个原因，现在还有大量的数据库在使用MyISAM的表。 同时它也是MySQL大部分系统表和临时表使用的而存储引擎，这个临时表并非是我们使用CREATE TEMPORARY TABLE所建立的临时表。 使用CREATE TEMPORARY TABLE语句创建的临时表，我们可以使用MySQL各种存储引擎的，这里所说的临时表指的是在排序、分组等操作中，当当数量超过一定大小后，由查询优化器所建立的磁盘临时表。 MyISAM存储引擎表由MYD和MYI组成。 在这里，我们建立一个myIsam的表，并且存储引擎使用了MyISAM。 1234CREATE TABLE `myIsam` ( `id` int(11) DEFAULT NULL, `c1` varchar(10) DEFAULT NULL)ENGINE= MyISAM DEFAULT CHARSET=utf8 下图为MyISAM在文件系统上的存储方式： 以frm为扩展名存储的文件并非是MyISAM存储引擎独有，它是用于记录表的结构。MyISAM表可以存储的记录数，一般首选治愈可用磁盘空间，或者是操作系统单个文件最大尺寸的限制。 作为MySQL最早的存储引擎之一，MyISAM有一些已经开发出来很多年的特性，可以满足用户的实际需求。 加锁与并发 MyISAM使用的是表级锁，进行读取操作时会对需要读到的所有表加共享锁，写入时则会对表加排他锁。但是在表有读取查询的同时，可以往表中插入新的记录，这也被称之为并发插入，CONCURRENT INSERT 修复 对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作，但是此处的修复和事务恢复以及崩溃恢复并不是一个概念，执行表的修复可能导致数据的丢失，而且修复操作时非常慢的。可以通过CHECK TABLE table检查表的错误，如果存在错误可以通过REPAIR TABLE table进行修复。在MySQL服务器处于关闭状态时，可以通过myisamcheck命令工具进行检查和恢复，切记是处于关闭状态。 索引 对于MyISAM表，即使是BLOG和TEXT等长字段，也可以基于前500个字符创建索引，而且MyISAM也支持全文索引。 延迟更新索引（Delayed Key Write）创建MyISAM表的时候，如果制定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃的时候会造成索引损坏，需要执行修复操作。此属性可以再全局设置，也可以为单个表设置。 压缩 如果表在创建并导入数据以后，不会再进行修改操作，可以使用myisampa对表进行压缩（打包）。压缩表不能进行修改，除非解除压缩，压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升性能，压缩表支持索引，但索引也是只读的。 压缩时表中的记录是独立压缩的，所以读取单行的时候不需要去解压整个表。 限制 版本&lt;MySYQL5.0时默认表大小为4G，如存储大表则需要修改MAX_Rows和AVG_ROW_LENGTH这两个参数，调整后表会进行重建，这需要很长的时间。 版本 &gt; 5.0时默认支持256TB 适用场景： 非事务性应用 只读类应用 空间类应用（在5.7之前，MyISAM是唯一支持空间函数的存储引擎） InnoDBMysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。 和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。 特点： 灾难恢复性好 支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的 使用行级锁 对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的 实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引 支持外键 支持热备份 Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由innodb_file_per_table这个参数决定。 如果值为 ON,会为每个 innodb 表建立一个tablename.ibd的系统文件，如果该参数为OFF时会把数据存储到系统的表空间ibdataX","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"MySQL性能优化（3）：服务器硬件对 MYSQL 带来的影响","slug":"2017-09-16 MySQL 性能优化(03)：服务器硬件对 MYSQL 带来的影响","date":"2017-09-15T16:00:00.000Z","updated":"2018-09-08T05:24:16.045Z","comments":true,"path":"2017/09/16/3/","link":"","permalink":"http://www.maksim.website/2017/09/16/3/","excerpt":"","text":"影响数据库性能的主要因素有很多，主要包括以下几点： 服务器硬件 服务器系统 数据库存储引擎的选择 数据库参数配置 数据库结构设计和SQL语句 服务器硬件：每当大促或者一些活动的时候，我们监控系统时会发现，CPU和可用内存的资源都是很紧张的，特别对于一些计算密集型的应用，CPU的资源可能会变成系统的瓶颈。 当我们工作所需要的热数据的大小大于可用内存大小的时候，IO系统就会变成我们的瓶颈。 网络也算是一种IO，它对于性能的影响往往发生在大量的数据被查询时，特别是使用MemCache这类缓存系统时，当缓存大量失效时，就会造成大量的网络传输从而影响服务性能。 当发生这类问题的时候，我们可以升级I/O子系统，来增加大量的内存。 如何选择CPU？我们是选择更多的CPU，还是更快的CPU？Intel Xeon E7-8890 v2 主频2.5GHz 核心数量：18核36线程 正常情况下，这两点我们都想要，但是现实是残酷的，44499RMB的价格，并不是所有公司都能够接受的。 首先，我们需要考虑几个问题。 ####我们的应用是CPU密集型的应用吗？ 如果是CPU密集型的应用要加快SQL的处理速度，显然我们需要的是更快的CPU而不是核心较多的CPU。 值得注意的是，MySQL目前还不支持多CPU对同一SQL并发处理。 也就是说，一条SQL只能使用一颗CPU来进行处理，多颗CPU对于一条SQL的处理效率是没有帮助的。 我们系统的并发量如何？ 虽然单个SQL无法利用到多个CPU资源，如果要提高系统的吞吐量和并发处理量呢？ 这时我们就需要CPU越多越好。 在Web应用中，CPU的数量就要比频率要重要一些。 我们所使用的MySQL版本也会决定如何选择CPU，老版本的MySQL对于多核CPU的支持并不好，5.0之前的版本限制是非常严重的，5.6、5.7对多核CPU的支持已经有了很好的改善。 选择32位还是64位的CPU？这个问题已经是多余的了，目前64位已经是默认配置了，而且MySQL对于64位CPU的支持已经很好了。 不过值得注意的是，在64位CPU上使用32位操作系统，意味着我们不能使用大的内存，任何一个单独的进程都不能寻址到4G以上的内存，MySQL是一个单线程的服务，这样就会对MySQL的性能造成极大的影响。 内存、更大更快？内存的大小直接影响数据库的性能，目前内存的IO效率要远远高于磁盘，所以把数据缓存到内存中可以大大提高数据库性能。 MyISAM会把索引缓存到内存中，数据放到系统上进行缓存。 InnoDB会在内存上同时缓存索引和数据，所以可以提高运行效率 内存的确是越多越好，可是数据库的性能影响也是有限的，并不能无限增加性能，数据库可以利用的内存是有限的。 当所有的数据都被缓存到内后，再增加内存大小就变成没有意义的了。 如果我们的数据的大小是100G，内存是64G，我们可以通过扩展内存到128G来扩大数据库的缓冲区来提高数据库性能。 可是如果此时内存以经256G了，并且数据库的缓存池大小已经达到了196G的情况下，就不能指望增加内存来提高数据库心梗了。 多余的内存可以增加操作系统等其他服务的性能。 缓存虽然不能避免磁盘的写操作，但是可以起到延缓作用，把多次写入变成一次写入。 ### 内存的选择？ 内存的频率越高读取也就越快，应该选择主板所支持的最高主频，组成购买升级，每个通道的内存最高相同品牌、颗粒、频率、电压、校验技术和型号。单条容量要尽可能的大。 根据数据库大小选择内存，例如现在热数据有100G，那么我们就可以选择128G的内存。但是还有一个问题，那就是数据的增长率，为了避免短时间内多次升级硬件，可以选择更大一些的内存。 ##I/O子系统（磁盘的配置和选择） 虽然内存对数据库的性能影响很重要，通过增加内存大小可以解决大部分性能问题，但是并不能忽视I/O子系统对性能影响。 有时我们需要以牺牲内存为代价提高I/O子系统的性能，因为无论如何最终，数据都要通过磁盘来进行持久化的存储。 目前主流的四种磁盘配置： 使用传统机器磁盘 使用RAID增强传统机器磁盘 使用固态存储SSD和PCIe卡 使用网络存储NAS和SAN 传统机器硬盘传统机器磁盘是目前最常见的选择，使用最多，这类磁盘价格低，存储空间大，但是读、写速度较慢，传统机器硬盘的读、写效率取决于它的存储机制。 传统机器硬盘读取数据的过程： 移动磁头到磁盘表面的正确位置 等待磁盘旋转，使所需的数据在磁头之下 等待磁盘旋转过去，所有所需的数据都被磁头读取 磁盘执行这些操作有多快，也就决定了磁盘的读取速度，第1,2步骤被称之为访问时间，第3步称之为传输速度。 如何选择传统机器硬盘 存储容量 传输速度 访问时间 主轴转速 物理尺寸 RAID增强机器硬盘的性能首先我们要知道什么是RAID，RAID是磁盘冗余队列的简称（Redundant Arrays of independent Disks）简单来说RAID的作用就是可以把多个容量较小的磁盘组成一组容量更大的磁盘，并提供数据冗余保证数据完整性的技术。 数据库中使用的RAID 0级别：RAID 0是最早出现的RAID模式，也称之为数据条带，是组建磁盘阵列中最简单的一种形式，只需要两块以上的硬盘即可，成本低，可以提高整个磁盘的性能和吞吐量。RAID 0没有提供冗余或错误修复能力，但是实现成本是最低的。 RAID 0 就是多个独立的磁盘串联到一起，比如有三块300G的磁盘组合到一起，就可以组成一块900G的磁盘，在写入时可以并发同时对三块磁盘进行写入，理论上写入效率就是普通磁盘的三倍。 RAID 0可能是性价比最高的解决方案，但是如果考虑到数据的恢复、可靠性因素，RAID 0就变成了一种成本最高的一种解决方案。 因为在RAID 0 中数据没有冗余，数据损坏的几率要比单块磁盘的几率还要高，因为RAID 0中任意一块磁盘损坏了，都会造成数据丢失。 所以RAID 0比较适合于不担心数据丢失的情况，比如可以随时从其他数据库克隆的备存，或者是一次性使用的数据。 数据库中使用的RAID 1级别RAID 1又称磁盘镜像，原理是把一块磁盘的数据镜像到另一个磁盘上，也就是说数据写入一块磁盘的同事，会在另一块限制的磁盘上生成镜像文件，在不影响性能的情况下最大限度的保证系统的可靠性和可修复性。 RAID 1当一块硬盘失效时，系统会忽略该硬盘，转而使用剩余的镜像盘来读取数据，拥有很好的冗余能力，虽然这样对数据的安全性而言是绝对安全的，但是却似的成本增加，磁盘的利用率仅有百分之五十，以4块300G的硬盘而言，能够利用的空间仅有600G，出现故障后的RAID系统也不在可靠了，应当及时更换损坏的硬盘，否则其他的镜像盘也出现问题了，会导致系统的崩溃。 更换硬盘后需要很长的时间同步镜像，虽然对数据的访问不会受到影响，但是对整个系统的性能是会有所下降的。 RAID 1在读的速度上要比RAID 0快。 ####数据库中使用的RAID 5级别 RAID 5又称之为分布式奇偶校验磁盘阵列，通过分布式奇偶校验块把数据分散到多个磁盘上，这样如果任何一个盘数据失效，都可以从奇偶校验块中重建。但是如果两块磁盘失效，则整个卷的数据都无法恢复。 在RAID 5上随机比较慢，因为每次写都需要两次读和两次写，以计算校验位的数值，比较适合以读为主的数据库业务。 最大的性能问题，发生在磁盘失效的时候，因为数据需要重新分布到其他磁盘上，这样会严重影响数据库性能，如果要使用RAID 5的话，最好使用在从服务器上。 数据库中使用的RAID 10级别RAID 10又称分片的镜像，她是对磁盘先做RAID 1之后对两组RAID 1的磁盘再做RAID 0，所以对读写都有良好的性能，相对于RAID 5重建起来更简单，速度也更快。 RAID级别的选择 等级 特点 是否冗余 盘数 读 写 RAID 0 便宜，快速，危险 无 N 快 快 RAID 1 高速读，简单，安全 有 2 快 慢 RAID 5 安全，成本这种 有 N+1 快 取决于最慢的盘 RAID 10 贵，告诉，安全 有 2N 快 快 固态存储 拥有更好的随机读写性能。 能够更好的支持并发 更容易损坏 在数据库存储中，我们常用的固态存储设备是SSD和PCI-E SSD。 SSD 使用SATA接口，可以替换传统磁盘而无需任何改变 SATA接口的SSD同样支持RAID技术 PCI-E SSD 无法使用SATA接口，需要独特的驱动和配置 价格相比SSD要贵，但是性能比SSD更好 PCI-E会占用服务器的内存。 固态存储的使用场景 适用于存在大量随机I/O的场景 使用于解决单线程负载的I/O场景 如果只有一块固态存储设备我们更应该将其放在从服务器上，因为从服务器是单线程的，而主DB是多线程的写入，为了产生更少的延迟，我们应该增加从服务器的I/O性能，而且由于固态设备易损耗，在主服务器上使用存在一定的安全隐患。 网络存储SAN和NASSAN(Storage Area Network)和NAS(Network-Attached Storage)是两种外部文件存储设备加载到服务器上的方法 SAN设备通过光纤连接到服务器，设备通过块接口访问，服务器可以将其当做硬盘使用。 NAS设备使用网络连接，通过基于文件的协议如NFS或SMB来访问。 网络存储适用的场景网络存储在随机I/O比较差，并不适合MySQL数据库存储数据，有一些人认为可以使用网络存储实现服务的高可用性，比如两台服务器挂在同一网络环境下的磁盘，当主服务器可以由主备服务器来接管磁盘来提供服务，提高系统的可用性。 虽然能够在一定条件下能够提高系统的可用性，可是却是以牺牲性能为代价，而且，一旦网络存储设备出现问题，则需要更多的时间进行恢复。 不过，我们可以利用网络存储设备来存储数据库的备份文件，当一台独立服务器出现故障，短时间内无法恢复的情况下，可以利用网络存储设备上存储的备份文件恢复是实例。 网络接口设备对数据库性能的影响 网络带宽对性能的影响 网络质量对性能的影响 建议 采用高性能和高贷款的网络设备和交换机 对多个网卡进行绑定，增强可用性和带宽 尽可能的进行网络隔离 总结：CPU 64位的CPU一定要工作在64位的系统下 对于并发比较高的场景CPU的数量比频率更重要 对于CPU密集性场景和复杂SQL则频率越高越好 内存 选择主板所能使用的最高频率的内存 内存的大小对性能很重要，所以尽可能的大 I/O子系统 PCie -&gt; SSD -&gt; Raid10 &gt; 磁盘 -&gt; SAN","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"MYSQL性能优化（2）：大表对MySQL带来的影响","slug":"2017-09-16 MySQL 性能优化(02)：大表对MySQL带来的影响","date":"2017-09-15T16:00:00.000Z","updated":"2018-09-08T05:23:58.480Z","comments":true,"path":"2017/09/16/2/","link":"","permalink":"http://www.maksim.website/2017/09/16/2/","excerpt":"","text":"什么样的表才可以被称之为大表?所谓的大表都是相对而言的，对不同的存储引擎都有不同的限制，Innodb并没有定义每张表的最大行数，只要物理磁盘允许，我们就可以将数据存入数据库中。 在实际使用过程中，当数据量超过千万行之后，就会对数据库的性能造成影响。 记录行数巨大，单表超过前往行 表数据文件巨大，表数据文件超过10G 当然这也是相对的，也要跟我们的业务场景，磁盘 IO情况而定，如果这个表只是用来记录日志的，只有INSERT、SELECT 操作，而几乎没有 UPDATE 和 DELETE的操作，就算是超过了千万行，对我们的业务操作也没有太大的影响。 但是也有例外的情况，如果我们要对超过10G 的日志表追加列，如果这个时候，这个表被同步到N台服务器上后，就会变成一场灾难。 大表对查询的影响慢查询：很难在一定的时间内过滤出所需要的重要数据。 大表对 DDL 操作的影响：建立索引需要很长的时间。 风险： MYSQL 版本 &lt; 5.5 建立索引会锁表 MYSQL 版本 &gt;= 5.5 虽然不会锁表但会引起长时间的主从延迟 修改表结构需要长时间锁表风险： 会造成长时间的主从延迟，由于主从复制的机制都是现在主库上完成操作，再传输到从库上，在执行相同操作，如果在主库上需要使用480s 的时间来完成 DDL 操作，在从服务器上至少也需要480s。 影响正常数据库操作。进行 DDL 时会被锁表，这样一来就会造成堵塞，在这一个阶段，数据库连接数会被激增，一旦数据库连接数被沾满，前台就会出现500错误。 如何处理数据库中的大表分库分表把一张大表分成多个小表难点： 1.分表主键的选择。 这个往往根据业务的不同，有多种分表的方式，比如对于订单表来说，可以根据订单号分表，也可以根据供应商和地区域来进行分表，选择合适的分区键对于后期的分表是十分重要的。 2.分表后跨分区数据的查询和统计 不要认为选择了好的分区键后就不需要跨分区进行查询了，好的分区键只能尽量避免跨分区查询。 大表的历史数据归档使用这种方法，可以减少对前后端业务的影响，因为表结构并没有发生变化，一切的程序都可以正常的使用，对于历史订单可以开放一个接口。 而且归档表可以跟正在使用的表放在不同的服务器上，一方面减少了热数据所在服务器的表容量，同时也减少了服务器的查询压力，对于后端业务而言，应该是已经完成相关操作和统计的历史数据。 难点： 归档时间点的选择。 如何进行归档操作，对于大表的增删改查都要十分的小心，既然我们要归档，就要把要归档的数据从数据库中移除，从一个上亿行的数据表中移出上百万行的时候，就要注意方式了，轻则会产生主从延迟，严重会产生大量的阻塞。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"MySQL性能优化（00）：提高 MySQL 的性能，从数据库设计规范开始","slug":"2017-09-15 MySQL 性能优化(00):命名规范","date":"2017-09-14T16:00:00.000Z","updated":"2018-09-12T14:39:01.329Z","comments":true,"path":"2017/09/15/1/","link":"","permalink":"http://www.maksim.website/2017/09/15/1/","excerpt":"","text":"在一些小型开发团队中可能并没有专业的 DBA ，这个时候在数据库的设计上可能会存在巨大的缺陷，在项目初期可能并没有太大影响，但是随着项目越来越庞大，将会暴露出大量的问题。 例如：数据冗余、字段命名不统一，错误的字段类型，等等。 这都将为未来的维护留下巨大的隐患，而且很可能是数据库运行效率低下的罪魁祸首。 其实，在团队研发过程中，完全可以在数据库设计之初建立规范以规避这类问题。 命名规范拥有良好的命名规范，可以节约大量的时间，甚至有的人认为好的命名要比文档重要，一个好的命名将会避免很多歧义、开发人员一眼看去就能够了解这个表存在的意义。 1. 所有数据库对象名称必须使用小写字母并使用下划线分割由于 MySQL数据库的对象名称默认情况下是大小写敏感的，特别是在 Linux 系统下，MySQL 的数据库和表实际上的存储方式就是 Linux 下的一个文件，由于 Linux 系统是对大小写敏感的，所以 MySQL 也就对大小写敏感，这就意味着 DbName dbname 是完全不同的两个数据库。 如果在开发过程中使用大小写混用的情况下，就会对未来的开发工作造成很多不必要的麻烦，要时刻注意数据库对象的大小写。 2. 所有的数据库对象名称禁止使用 MySQL 的保留字段1SELECT id, username from ,age from tb_user; 在上述SQL 语句中存在两个 from，由于 MySQL 并不知道这两个 from 有什么区别，若是执行这条 SQL 语句肯定会报错，但是在建表的时候却不会报错。 若是已经使用了关键字做了字段名，那就需要在字段名前后加上反引号，示例如下： 1select id,username `from` ,age from tb_user; 反引号是为了区分MySQL关键字和保留字与普通字符而引入的符号，保留字的列表请点击此网页查看 https://dev.mysql.com/doc/refman/5.7/en/keywords.html 3. 数据库对象的命名要做到见名识义，而且最好不要超过32个字符MySQL 的限制长度是64个字符，但是表名和列名一旦过长，在使用过程中将会很不方便，而且还会增加网络传输的开销。 例如： 12用户数据库： ex_userdb用户账户表： user_account 4. 所有的临时表必须以 tmp为前缀并以日期为后缀在我们的日常工作中，会在数据库中建立一些临时表或者中间表，往往无法第一时间将其清理掉，时间一长便无法分清，哪些是临时表或者是持久化表，这样一来就会造成很多的垃圾数据。 5. 备份表必须以bak为前缀并以日期为后缀在日常工作中，我们会对数据库进行备份，在备份的时候，以 bak 开头可以清晰的表示出这是一个备份表，并且以时间结尾标注了这个表是在什么时间进行的备份，这样一来能够设计出更加整洁的数据库，并且结构清晰。 6. 所有存储相同数据的列明和列类型必须一致。通着这这种字段都是以关联字段进行使用的，如果两个表的关联字段的数据类型不一致，在关联时MySQL 会进行隐式类型转换，造成字段索引失效，影响数据库的运行性能，导致不必要的开销。 基本设计规范1. 在没有特殊要求的情况下，所有表必须使用 Innodb 存储引擎比如列存储、在5.7版本之前存储空间数据，如果还在使用MyISAM 引擎如果在升级到5.6之后应该尽快将存储引擎升级到 Innodb，因为在5.6之后的默认引擎就是 Innodb，Innodb 支持事务，行级锁，更好的恢复性，高并发下性能更好。 2. 数据库和表的字符集使用 UTF8统一的字符集可以避免由于字符集转换禅城的乱码，MySQL 中 UTF8字符集汉字站3个字节，ASCII 码占用1个字节，若我们定了一个 varchar(255)的列，并且存储中文的话，255个中文字符将会占用725个字节。 3. 所有的表和字段都需要添加注释使用 comment 从句添加表和列的备注，从一开始就进行数据字典维护。 4. 尽量控制单表数据量的大小，建议控制在500万行以内500万并不是 MySQL数据库的限制，MySQL 的存储数据量取决于存储设置和文件系统，修改表结构，备份，恢复都会有很大问题。 可以使用历史数据归档，分库分表等手段来控制数据量的大小，历史数据归档常用语系统日志，分库分表主要应用在业务表上。 5. 谨慎的使用 MySQL 分区表。分区表在物理上表现为多个文件，在逻辑上表现为一个表。谨慎的选择分区键，跨分区查询效率可能更低。 建议采用物理分表的方式管理大数据。 6. 尽量做到冷热数据分离，减小表单的宽度MySQL 限制最多存储4096列，并且每一行的大小是不能超过65535个字节的。最好将经常用到的列放到一个表中，这样一来可以减少磁盘 IO，保证热数据的内存缓存命中率。利用更有效的利用缓存，避免读入无用的冷数据。 7. 禁止在表中建立预留字段预留字段的命名很难做到见名识义，预留字段无法确认存储的数据类型，所以无法选择合适的类型。对预留字段类型的修改，会对表进行锁定，修改一个字段类型的成本远高于新建一个字段。 8. 禁止在数据库中存储图片，文件等二进制数据这类文件都会很大，会在短时间内造成数据量的疯涨，在数据库读取的时会产生大量的 IO 操作，非常好事，影响数据库性能，常规的做法是将图片保存在对应的文件服务器上，然后在数据库中保存地址信息就可以了。 9. 禁止在线上做数据库压力测试如果使用生产环境进行压力测试一方面会对正常的业务访问造成影响，另一方面也会对数据库造成影响，产生大量的垃圾数据。 10. 禁止从开发环境，测试环境直接连生产环境数据库会对生产环境的数据的完整性进行破坏。 数据库索引设计规范1. 限制每张表上的索引数量，建议单表索引不超过5个索引数量是和列的数量是成正比的，通常列的数量越多索引的数量也会越多，索引并不是越多越好，索引可以提高效率单同样也可以鉴定效率，索引可以增加查询效率，但是同样也会降低插入和更新的效率。 由于 MySQL 优化器在选择优化查询时，会根据统计信息对每一个可以用到的索引进行评估，以生成出一个最好的执行计划，如果同时有很多索引都可以用于查询，就会增加 MySQL优化器生成优化器的时间，同样机会降低 SQL 查询的性能。 禁止给表中的每一个列都建立单独的索引。 2. 每一个 Innodb表都必须有一个主键Innodb 是一种索引组织表，数据存储的逻辑顺序与索引的顺序是相同的，每一个表上上都会有很多索引，但是存储顺序只有一种，Innodb是按照主键索引进行组织表的。 如果没有主键，那么 Innodb 会优先以第一非空，唯一索引当做主键，在没有非空唯一所以的情况下，MySQL 会生成一个站位6个字节的主键，这个自动生成的主键性能并不是最好的。 在表的设计中不要使用更新频繁的列作为主键，不使用多列主键（联合索引），因为 Innodb是一个索引组织表的缘故，如果主键频繁被更新，那么久意味着，数据存储的顺序就会频繁的变动，必然会带来大量的 IO 操作。 不要使用 UUID，MD5，HASH，字符串列作为主键。因为这类数据无法保证数据的顺序增长，如果后面插入的值比已经存在的值还要小，则为了保证索引的顺序，则会把新的数据插入到前面，这样就会造成所有大于这个值的数据要想后移带来大量的 IO 操作。 建议使用自增 ID 作为主键。 3. 常见索引列建议1.SELECT、UPDATE、DELETE语句的WHERE 从句中的列出现的字段中添加索引2.包含在 ORDER BY、GROUP BY、DISTINCT 中的字段3.多表JOIN的关联列 4. 如何选择索引列的顺序在联合索引中索引的使用顺序是由从左到右的顺序来使用的。所以我们需要将区分度最高的列放在联合索引的最左侧，尽量把字段长度小的列房子啊联合索引的最左侧，私用最频繁的列放在联合索引的左侧。 5. 避免建立冗余索引和重复索引重复索引： 1primary key(id)、index(id)、unique index(id) 冗余索引： 1index(a,b,c) 、index(a,b)、index(a) 6. 对于频繁的查询优先考虑使用覆盖索引覆盖索引：就是包含了所有查询字段的索引 避免 Innodb 表进行索引的二次查找， 数据库字段设计规范1.优先选择符合存储需要的最小的数据类型 将字符串转换为数字类型存储 INET_ATON(‘255.255.255.255’) = 4294967295 INET_NTOA(4294967295) = ‘255.255.255.255’ 对于非负型的数据来说，要有限选用无符号整型来存储，无符号相对于有符号可以多出一倍的存储空间 VARCHAR（N）中的 N 代表的是字符数，而不是字节数 使用 UTF8存储汉字 VARCHAR(255)=765个字节 过大的长度会消耗更多的内存，因为当数据被载入到内存时为了提高效率是按照所定义的类型长度来申请内存的。 2.避免使用 Text、BLOG 的数据类型Text列分为四种 TinyText、Text、MidumText、LongText，Text类型可以存储下64K的数据，备注或者说明很少会使用到64K 这么庞大的数据，使用 Varchar 类型就可以了。另外由于MySQL 内存表是不支持 Text 和 Blog 的，因此我们在对这种大数据类型进行排序的时候无法使用内存表，而必须使用磁盘内置表，这类数据MySQL 在读取数据时会进行二次查询，所以会使得 SQL 的性能变的很差。 建议把 BLOG 或是 TEXT列分离到单独的扩展表中 ，并且在查询时一定不要使用 select * 的方式，而是取出必要的列，在使用 BOLOG 或者 TEXT 类型的时候就不要查询该列。 TEXT或 BLOG 类型只能使用前缀索引，并且 TEXT 的列上是不能有默认值的。 3.避免使用 ENUM 数据类型枚举类型是一个很特别的类型，在其他关系型数据库中并不存在这一类型，枚举本身是一个字符串类型，但是其本身却是以整数类型，所以能够存储65535种不同的枚举值，前面提到要将字符串类型转换成整数进行存储，从这一点看枚举是一种很好的数据类型，有助于我们很好的进行优化。 但是枚举类型也存在着很大的缺陷，修改 ENUM 值需要使用 ALTER 语句，频繁的对表结构进行修改很容易造成失误，在修改元数据的时候会生成元数据锁，在大量数据访问的时候会造成数据库系统的阻塞，对枚举数据进行操作的时候是存在一定的操作风险的。 ENUM 类型的 ORDER BY 操作效率低，需额外操作，由于是按照整型进行存储的，所以在查询的时候会对其进行字符串转化然后在进行排序，这种装换是无法使用索引的，所以枚举值排序性能比较差。 禁止使用数值作为 ENUM 的枚举值，因为枚举本身是索引顺序存储的，如果枚举值也是用整型进行存储，很容易会造成逻辑上的一种混淆，一般情况下枚举值是整型，通常建议使用整型代替。 4.尽量可能把所有列定义为 NOT NULL索引 NULL 列需要额外的空间来保存，所以需要占用更多的空间，索引空间占用的越低越好。 进行比较和计算时候对 NULL 值做特别的处理，所以可能会造成索引失效。 5.使用 TIMESTAMP 或DATETIME 类型存储时间字符串存储日期型的数据（不正确的做法） 缺点1：无法用日期函数进行计算和比较。缺点2：用字符串存储日期要占用更多的空间 TIMESTAMP 1970-01-01 00：00：01 ~ 2038-01-19 03：14：07 其实TimeStamp是以 Int 类型存储的，但是以日期格式显示，TimeStamp占用4字节和 INT 相同，但比 Int 可读性高， 当超出 TimeStamp 类型的存储范围时我们需要使用 DateTime 类型来进行存储。 6.同财务相关的金额类数据，必须使用 decimal 类型Decimal 类型为精准浮点数，在计算时不会丢失精度，占用空间油定义的宽度决定，可用于存储比 bigint 更大的整数数据。 数据库 SQL 开发规范1.建议使用预编译语句进行数据库 只传参数，比传递 SQL 语句更高效 相同语句可以一次解析，多次使用，提高处理效率 防范 SQL 注入的风险 2.避免数据类型的隐式转换隐式转换一般发生在 Where 从句中，当列类型和参数类型不一致时就会出现隐式转换。， 隐式转换会导致索引失效 3.充分利用表上已经存在的索引尽量避免用%号的查询 例如 a like ‘%123%’ 一个 SQL 只能利用到符合索引中的一列进行范围查询 使用 left join 活 not exists 来优化 not in 操作。 4.程序链接不同的数据库使用不同的账号，禁止跨库查询。 为了数据库迁移和分库分表留出余地 降低业务耦合度 避免由于权限过大产生的安全风险 5.禁止使用 SELECT *必须使用 SELECT&lt;字段列表&gt;查询 消耗更多的 CPU 和 IO 以及网络带宽资源 无法使用覆盖索引 可减少表结构变更带来的影响 6.禁止使用不含字段列表的 insert 语句12insert into t values ('a','b','c'); //不包含字段列表的 insertinsert into t(c1,c2,c3) values('a','b','c'); //正确的写 可以减少表结构变更带来的影响 7.避免使用子查询，可以把子查询优化为join 并不是所有的子查询都可以使用 join进行优化，一般情况下只有子查询在 IN 子句中，并且子查询是一个简单的 SQL ，例如其中不包含 order by之类的复杂查询，才可以进行转换。 子查询的结果集无法使用索引 子查询会产生临时表操作，如果子查询数据量大则严重影响性能 临时表会消耗过多 CPU 以及 IO 资源 8.避免使用 JOIN 关联太多的表 每Join 一个表会占用一部分内存（join buffer size） 会产生临时表操作，影响查询效率 MySQL 最多允许关联61个表，建议不超过五个 9.减少同数据库的交互次数 数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率 10.使用 in 代替or in 的值不要超过500个 in 操作可以有效的利用索引 11.禁止使用 order by rand(）进行随机排序 会把表中所有符合条件的数据装载到内存中进行排序 会消耗大量的 CUP 和 IO 以及内存支援 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式 12.WHERE 从句中禁止对列进行函数转换和计算 对列进行函数转换或计算会导致无法使用索引 12where date(createtime) = '20160901'where createtime &gt;= '20160901' and createtime&lt; '20160902' 13.有明显不会重复值时使用 UNION ALL 而不是UNION UNION 会把所有数据放到临时表中然后进行去重操作 UNION ALL 不会对结果集进行去重操作 14.拆分复杂的大 SQL 为多个小 SQL MySQL 一个 SQL 只能使用一个 CPU进行计算 SQL 拆分后可以进行并行执行来提高处理效率 数据库操作行为规范1.超100万行的批量写操作，需分批多次进行操作 大批量操作可能会造成严重的主从延迟 binlog 日志为row 格式时会产生大量的日志 避免产生大事务操作 2.对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。对于大表使用 pt-online-schema-change 修改表结构，可以避免主从延时、表锁的问题。 3.禁止为程序使用的账户赋予 super 权限 当达到最大连接数贤之士，MySQL 允许1个有 super 权限的用户连接 super 权限只能留给 DBA 处理问题的账户使用 4.对于程序链接数据库账户，遵循权限最小原则 程序使用数据库账号只能在一个 DB下使用，不准夸库 程序使用账号原则上不准有 drop权限","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL 设计规范","slug":"MySQL-设计规范","permalink":"http://www.maksim.website/tags/MySQL-设计规范/"}]},{"title":"从搭建MySQL主从结构到PHP原生操作","slug":"2017-09-10 MySQL主从数据库","date":"2017-09-09T16:00:00.000Z","updated":"2018-09-12T14:40:00.746Z","comments":true,"path":"2017/09/10/1/","link":"","permalink":"http://www.maksim.website/2017/09/10/1/","excerpt":"","text":"什么是mysql主从同步？当master(主)库的数据发生变化的时候，变化会实时的同步到slave(从)库。 ##主从同步有什么好处？ 水平扩展数据库的负载能力。 容错，高可用。Failover(失败切换)/High Availability 数据备份。 主从同步的原理是什么？首先我们来了解master-slave的体系结构。 如下图： 不管是delete、update、insert，还是创建函数、存储过程，所有的操作都在master上。当master有操作的时候,slave会快速的接收到这些操作，从而做同步。 但是，这个机制是怎么实现的呢？ 在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);在slave机器上，slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。 如此，就实现了主从同步了！ 下面我们来详细的了解。 主从同步事件有哪些上面说到： 在master机器上，主从同步事件会被写到特殊的log文件中(binary-log); 主从同步事件有3种形式:statement、row、mixed。 statement：会将对数据库操作的sql语句写入到binlog中。 row：会将每一条数据的变化写入到binlog中。 mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。 在master机器上的操作 当master上的数据发生改变的时候，该事件(insert、update、delete)变化会按照顺序写入到binlog中。 binlog dump线程 当slave连接到master的时候，master机器会为slave开启binlog dump线程。 当master 的 binlog发生变化的时候，binlog dump线程会通知slave，并将相应的binlog内容发送给slave。 在slave机器上的操作当主从同步开启的时候，slave上会创建2个线程。 I/O线程。该线程连接到master机器，master机器上的binlog dump线程会将binlog的内容发送给该I/O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log。 SQL线程。该线程读取I/O线程写入的relay log。并且根据relay log的内容对slave数据库做相应的操作。 如何在master、slave上查看上述的线程？使用SHOW PROCESSLIST命令可以查看。 如图，在master机器上查看binlog dump线程。 如图，在slave机器上查看I/O、SQL线程。 讲了这么多，一图以蔽之 实战环境12345os:ubuntu16.04mysql:5.7.17master IP:192.168.33.22slave IP:192.168.33.33 master机器上的操作1、更改配置文件我们找到文件 /etc/mysql/mysql.conf.d/mysqld.cnf。配置如下： 123bind-address = 192.168.33.22 #your master ipserver-id = 1 #在master-slave架构中，每台机器节点都需要有唯一的server-idlog_bin = /var/log/mysql/mysql-bin.log #开启binlog 2、重启MySQL1sudo systemctl restart mysql 3、创建主从同步的mysql user。12345678910$ mysql -u root -pPassword:##创建slave1用户，并指定该用户只能在主机192.168.33.33上登录。mysql&gt; CREATE USER 'slave1'@'192.168.33.33' IDENTIFIED BY 'slavepass';Query OK, 0 rows affected (0.00 sec)##为slave1赋予REPLICATION SLAVE权限。mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'slave1'@'192.168.33.33';Query OK, 0 rows affected (0.00 sec) 4、为MYSQL加读锁为了主库与从库的数据保持一致，我们先为mysql加入读锁，使其变为只读。 12mysql&gt; FLUSH TABLES WITH READ LOCK;Query OK, 0 rows affected (0.00 sec) 5、记录下来MASTER REPLICATION LOG 的位置该信息稍后会用到。 1234567mysql&gt; SHOW MASTER STATUS;+------------------+----------+--------------+------------------+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 | 613 | | | |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec) 6、将master DB中现有的数据信息导出1$ mysqldump -u root -p --all-databases --master-data &gt; dbdump.sql 7、接触master DB的读锁1mysql&gt; UNLOCK TABLES; 8、将步骤6中的dbdump.sql文件copy到slave1scp dbdump.sql ubuntu@192.168.33.33:/home/ubuntu slave机器上的操作1、更改配置文件我们找到文件 /etc/mysql/mysql.conf.d/mysqld.cnf。更改配置如下： 123bind-address = 192.168.33.33 #your slave ipserver-id = 2 #master-slave结构中，唯一的server-idlog_bin = /var/log/mysql/mysql-bin.log #开启binlog 2、重启mysql，以使配置文件生效1sudo systemctl restart mysql 3、导入从master DB。 导出的dbdump.sql文件，以使master-slave数据一致1$ mysql -u root -p &lt; /home/ubuntu/dbdump.sql 4、使slave与master建立连接，从而同步12345678910111213141516$ mysql -u root -pPassword:mysql&gt; STOP SLAVE;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; CHANGE MASTER TO -&gt; MASTER_HOST=&apos;192.168.33.22&apos;, -&gt; MASTER_USER=&apos;slave1&apos;, -&gt; MASTER_PASSWORD=&apos;slavepass&apos;, -&gt; MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;, -&gt; MASTER_LOG_POS=613;Query OK, 0 rows affected, 2 warnings (0.01 sec)mysql&gt; START SLAVE;Query OK, 0 rows affected (0.00 sec) MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;与MASTER_LOG_POS=613的值，是从上面的 SHOW MASTER STATUS 得到的。 经过如此设置之后，就可以进行master-slave同步了~ PHP代码实现数据库读写分离1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?phpclass Db&#123; private $res; function __construct($sql) &#123; $querystr = strtolower(trim(substr($sql,0,6))); //如果是select，就连接slave服务器 if($querystr == 'select') &#123; $res=$this-&gt;slave_select($sql); $this-&gt;res=$res; &#125; //如果不是select，就连接master服务器 else &#123; $res=$this-&gt;master_change($sql); $this-&gt;res=$res; &#125; &#125; /** * slave从库返回sql查询结果 * @param $sql * @return array */ private function slave_select($sql)&#123; //该处只是随机获取slave节点的ip，当然，还可以采用其他算法获取slave_ip $slave_server=$this-&gt;get_slave_ip(); $dsn=\"mysql:host=$slave_server;dbname=test\"; $user='root'; $pass='123456'; $dbh=new PDO($dsn, $user, $pass); return $dbh-&gt;query($sql)-&gt;fetchAll(PDO::FETCH_ASSOC); &#125; /**master主库返回sql执行结果 * @param $sql * @return int */ private function master_change($sql)&#123; $master_server='192.168.33.22'; $dsn=\"mysql:host=$master_server;dbname=test\"; $user='root'; $pass='123456'; $dbh=new PDO($dsn, $user, $pass); return $dbh-&gt;exec($sql); &#125; /** * 随机获取slave-ip * @return mixed */ private function get_slave_ip()&#123; $slave_ips=['192.168.33.33','192.168.33.44']; $count=count($slave_ips)-1; $random_key=mt_rand(0,$count); return $slave_ips[$random_key]; &#125; /** * 获取结果 * @return int */ public function get_res()&#123; return $this-&gt;res; &#125;&#125;$sql1 = \"select * from t1\";$sql2 = \"insert into t1 (name) values ('haha')\";$sql3 = \"delete from t1 where id=1\";$sql4 = \"update t1 set name='Jerry' where id=2\";$db = new Db($sql1);//$db = new Db($sql2);//$db = new Db($sql3);//$db = new Db($sql4);var_dump($db-&gt;get_res());","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"法律结构条、款、项、目","slug":"2017-09–05 法律结构条、款、项、目","date":"2017-09-04T16:00:00.000Z","updated":"2018-04-10T11:12:36.431Z","comments":true,"path":"2017/09/05/1/","link":"","permalink":"http://www.maksim.website/2017/09/05/1/","excerpt":"","text":"公司的新项目上线了，我们要为律师团队开发一套内部系统，其中包括爬虫抓来的问答、法律条款的检索。 而法律条文不能直接以文章的形式存储，因为后期可能会涉及到法律条文的引用，例如： 《烟草专卖法》第二条第二款 一般来讲，一件(部)法律由章、节、条、款、项、目组成，个别重要的法典还分编。 编、章、节是对法条的归类，所以，在适用法律时只需引用到条、款、项、目即可，无需指出该条所在的编、章、节。因此，弄懂法律规范中条、款、项、目的含义，在执法活动中正确适用法律规范的条、款、项、目，对于规范执法行为，提高执法质量是大有益处的。 一、“条”1. 条的概念法律规范的“条”，又称“法条”，是组成法律规范的基本单位。一部法律，都是由若干法条组成的。如《烟草专卖法》由46个法条组成，《烟草专卖法实施条例》由70个法条组成。 法律规范的“条”，是法律规范对某一个具体法律问题的完整规定，如： 《烟草专卖法》第三十条 违反本规定擅自收购烟叶的，由烟草专卖行政主管部门处以罚款，并按照国家规定的价格收购违法收购的烟叶；数量巨大的，没收违法收购的烟叶和违法所得。 这一条就是对擅自收购烟叶法律责任的完整规定。 ### 2. 条的书写 ​ 一般来讲，条的数目的书写应使用中文，如《烟草专卖法》第三十条。但也有使用阿拉伯数字的，如《烟草专卖法》第30条。 ​ 执法活动中，对一个涉法问题作出决定时，可能要适用多个法条。如对无证运输的人进行处罚时，应同时适用《烟草专卖法》第三十一条第一款、《条例》第五十五条第一项和第六十九条的规定。 二、“款”1. 款的概念。 “款”是“条”的组成部分。在一般情况下，每一款都是一个独立的内容或是对其前一款内容的补充表述。如： 《烟草专卖法》第二条 本法所称烟草专卖品是指卷烟、雪茄烟、烟丝、复烤烟叶、烟叶、卷烟纸、滤嘴棒、烟用丝束、烟草专用机械。 卷烟、雪茄烟、烟丝复烤烟叶统称烟草制品。 《烟草专卖法》第二条有二款。其中第一款界定了烟草专卖品的范围，第二款进一步界定了烟草制品的范围。 2. 款的表现形式。“款”的表现形式为条中的自然段，每个自然段为一款。 “款”前不冠以数字以排列其顺序。如《烟草专卖法》第二条的两款，款前均无数字。有数字排列的不称为款。如： 《条例》第七条取得烟草专卖生产企业许可证，应当具备下列条件： (一)有与生产烟草专卖品相适应的资金； (二)有生产烟草专卖品所需要的技术、设备条件； (三)符合国家烟草行业的产业政策要求； (四)国务院烟草专卖行政主管部门规定的其他条件。 上条第一段冒号下为：(一) 有与生产烟草专卖品相适应的资金。该段文字虽然是另起一行，但因为上段结束符号是冒号，本段开始前有(一)，因此，该段文字不视为是一个自然段，也不能认为其是一款。 3. 关于款的数目的书写。款的数目的书写一般应当使用中文，不用阿拉伯数字。如《烟草专卖法》第二条第二款，不写作《烟草专卖法》第二条第2款。 4. 款的适用 款一般可以独立适用，如《烟草专卖法》第二条第二款，但也有例外的，但与烟草专卖有关的法律法规中少见。 一个法条有两款或者两款以上的，应当适用到款。一个法条只有一款的，应当直接适用该法条，不应称作该条第一款，如： 《条例》第三条烟草专卖品中的烟丝是指用烟叶、复烤烟叶、烟草薄片为原料加工制成的丝、末、粒状商品。 在引用时，就应该写作“根据《实施条例》第三条”，而不是“根据《实施条例》第三条第一款”。 参照最高人民法院《关于引用法律、法令等所列条、款、项,目顺序的通知》，如果某一条下面没有分款而直接分列几项的，就不要加“第一款”，例如《条例》第七条只有（一）（二）（三）三项，就不要写“第七条第一款第一项”，而直接写“第七条第一项”。 三、“项”1. 项的概念 一般来讲，“项”是以列举的形式对前段文字的说明。如： 《条例》第四十九条烟草专卖行政主管部门查处违反《烟草专卖法》和本条例的案件时，可以行使下列职权： (一)询问违法案件的当事人、嫌疑人和证人； (二)检查违法案件当事人的经营场所，依法对违法生产或者经营的烟草专卖品进行处理； (三)查阅、复制与违法活动有关的合同、发票、账册、单据、记录、文件、业务函电和其他资料。 ​ 该条的三个项是对前段文字中“下列职权”的列举式说明。 2. 项的表现形式含有项的法条，其前段文字中一般都有“下列”二字或相应的文字表述。“项”前冠以数字以对列举的内容进行排列。如《条例》四十九条，各项前都冠以(一)、(二)、(三)等数字，而且这些数字只能以中文数字加括号的形式出现。 3. 项的数目的书写项的数目的书写一般应当使用中文加括号，不用阿拉伯数字。如《条例》第四十九条第（三）项，不写作《条例》第四十九条第3项。 4. 项的适用对含有项的法条，适用时应当适用到项；如对无证运输的处罚，应当适用《条例》第五十五条第(一)项。适用到项，是对被处罚的无证运输行为性质和情节的一种界定。如果不适用到项，该无证运输的行为就不知是四种行为之中的哪一种行为，有适用法律不准确之嫌。 根据立法技术的不同需要，“项”可以依附于条，也可以依附于款。即条中可以有项，款中也可以有项。 四、“目”1. 目的概念 “目”隶属于项，是法律规范中最小的单位。“目”的特性与作用与“项”相似，不同的是项对条或款的列举式说明，而“目”是对项的列举式说明。如《条例》第五十五条第(二)项： (二)有下列情形之一的，没收违法运输的烟草专卖品和违法所得： 非法运输的烟草专卖品价值超过5万元或者运输卷烟数量超过100件（每1万支为1件）的； 被烟草专卖行政主管部门处罚两次以上的； 抗拒烟草专卖行政主管部门的监督检查人员依法实施检查的； 非法运输走私烟草专卖品的； 运输无烟草专卖生产企业许可证的企业生产的烟草专卖品的； 利用伪装非法运输烟草专卖品的； 利用特种车辆运输烟草专卖品逃避检查的； 其他非法运输行为，情节严重的。 ​ 这八种情形，就是该项的八个目，列举没收违法运输的烟草专卖品和违法所得的八种情况。 2. 目的表现形式​ 目的前面冠以阿拉伯数字，并在阿拉伯数字后加点(在具体引用法条的目时，只注明阿拉伯数字，无须加点)，例如《条例》第五十五条第(二)项第7目。 3. 目的适用如果某个法条或款的内容有“项”，而“项”下还有“目”的，在适用法律时就应当适用到“目”。如烟草专卖局在对非法运输走私烟草专卖品的行为进行处罚时，就应当适用《条例》第五十五条第(二)项第4目。当然，如果既非法运输走私烟草专卖品又利用特种车辆运输逃避检查，在作出处罚决定时就应同时适用相应的两个目。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.maksim.website/categories/随笔/"}],"tags":[]},{"title":"一本深入学习PHP内核的书 -《PHP internals Book》","slug":"2017-08-20 《PHP-internals-Book》-介绍","date":"2017-08-19T16:00:00.000Z","updated":"2018-07-02T13:53:42.164Z","comments":true,"path":"2017/08/20/10/","link":"","permalink":"http://www.maksim.website/2017/08/20/10/","excerpt":"","text":"今天给大家介绍一本 PHP 扩展开发相关的书籍《PHP internals Book》，这本书是几个PHP开发人员之间的协作努力，可以更好地记录和描述PHP内部的工作原理。 《PHP internals Book》 有三个主要目标： 记录和描述PHP内部工作原理。 记录并描述如何使用扩展扩展语言。 记录并描述如何与社区进行交互以开发PHP本身。 《PHP internals Book》 主要面向具有C编程语言经验的开发人员。然而，尽管如此，我们将尝试提炼信息并对其进行总结，以便不了解C的开发人员仍然能够理解内容。 但是，让我们坚持。如果您不知道C语言，您将无法实现高效，稳定（任何平台下的崩溃），性能和实用性。以下是有关C语言本身，生态系统和构建工具以及操作系统API的一些非常好的在线资源： http://www.tenouk.com/ https://en.wikibooks.org/wiki/C_Programming http://c-faq.com/ https://www.gnu.org/software/libc/ http://www.faqs.org/docs/Linux-HOWTO/Program-Library-HOWTO.html http://www.iecc.com/linker/linker10.html","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"Invert a Binary Tree","slug":"2017-08-13 Invert-a-Binary-Tree","date":"2017-08-13T05:01:00.000Z","updated":"2018-06-20T05:18:37.434Z","comments":true,"path":"2017/08/13/2/","link":"","permalink":"http://www.maksim.website/2017/08/13/2/","excerpt":"","text":"12345 4 4 / \\ / \\ 2 7 to 7 2 / \\ / \\ / \\ / \\1 3 6 9 9 6 3 1 解答： 1234567891011121314151617181920/** * Definition for a binary tree node. * strcut TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode (index x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125; */class Solution &#123; public: TreeNode *invertTree(TreeNode* root) &#123; if (root == NULL) return NULL; TreeNoe * tmpNode = root-&gt;left; root-&gt;left = invertTree(root-&gt;right); root-&gt;right = invertTree(tmpNode); return root; &#125;&#125;; 利用的递归这个概念，短短几行就完成了一个翻转二叉树，只是在翻转二叉树的左右子数。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.maksim.website/categories/C-C/"}],"tags":[{"name":"C/C++,算法","slug":"C-C-算法","permalink":"http://www.maksim.website/tags/C-C-算法/"}]},{"title":"算法笔试入门题目Memmove","slug":"2017-08-13 算法笔试入门题目Memmove","date":"2017-08-13T04:02:10.000Z","updated":"2018-06-20T05:16:07.704Z","comments":true,"path":"2017/08/13/1/","link":"","permalink":"http://www.maksim.website/2017/08/13/1/","excerpt":"","text":"1234void *memmove (void *dest, const void *src, size_t n)&#123; //implementation here&#125; 这是 C 语言中的一个库函数，他的功能是吧内存中一块内容从src拷贝到dest，固定的长度是n。 这是笔试中的一个入门体 12345678910void *memmove (void *dest, const void *scr, size_t n)&#123; char *p1 = dest; char *p2 = src; while (*p2 != \\0) *p1++ = *p2++; return p1;&#125; 上面的这份代码，可以完成要求，可是却存在一些问题，我们先来看一下，C语言中的一些让人进场不会注意到的陷阱。 内存重叠的处理，从一个指针，它指向的内存地址，拷贝到另外一个地址，那么有没有可能是完全重合，或者有一部分是重合的。 临时变量太多 或者没有安全释放 没有测试内存越界，size 是否小于零，指针是否为空？ 指针操作熟悉 内存是否重叠？ ) 正确的写法 123456789101112131415161718void *memmove (void *dest, const void *scr, size_t n)&#123; char *p1 = dest; const char *p2 = src; //o用常量表示src //判断src 和 dest 的位置关系 if (p2 &lt; p1) &#123; p2 += n; p1 += n; while (n-- != 0) *--p1 = *--p2; &#125; else &#123; while (n-- != 0) &#123; *p1++ = *p2++; &#125; &#125; return p1;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.maksim.website/categories/C-C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.maksim.website/tags/算法/"}]},{"title":"Array&String算法","slug":"2017-08-12 Array&String 算法","date":"2017-08-11T16:00:00.000Z","updated":"2018-04-10T11:12:49.011Z","comments":true,"path":"2017/08/12/1/","link":"","permalink":"http://www.maksim.website/2017/08/12/1/","excerpt":"","text":"12345//Returns the position of the first occurrence of string target in string source or -1 if target is not part of source.int strStr (String source, String target) &#123; &#125; 希望在 string 里面寻找target，如果找到一个完全匹配的话，就返回他所在的位置，如果不存在就返回-1; 字符串匹配两种比较容易实现的字符串比较算法。 假设在长度为 n的沐川中匹配长度为 m的子串。 Brute-Force 算法： 顺序遍历母串，将每个字符作为匹配的起始字符，判断是否匹配子串。时间复杂度 O(m*n) Brute-Force 123456789101112131415char* StrStr(const char *str, const char *target) &#123; if(!*target) return str; char *p1 = (char *)str; while(*p1) &#123; char *p1Begin = p1, *p2 = (char*)target; while(*p1 &amp;&amp; *p2 &amp;&amp; *p1 == *p2) &#123; p1++; p2++; &#125; if (!*p2) //发现p2走到了末尾，就意味着有匹配到的字符串，那么直接返回p1Begin;所记录的位置 return p1Begin; p1 = p1Begin + 1; &#125; return NULL;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.maksim.website/categories/C-C/"}],"tags":[]},{"title":"Linux 和 GNU 工程","slug":"2017-08-10 GNU&Linux","date":"2017-08-10T12:01:00.000Z","updated":"2018-06-20T05:23:27.889Z","comments":true,"path":"2017/08/10/3/","link":"","permalink":"http://www.maksim.website/2017/08/10/3/","excerpt":"","text":"每天都有许多计算机用户使用一个被改动过的GNU 系统 (18k 字节)，但是他们并没有意识到它。 经过一系列的事件，现在被广泛使用的 GNU 版本则经常被称作“Linux”，可是许多用户并不了解与之相关的 GNU 工程。 Linux 确实存在；它是一个内核，许多人都在使用它。但是你不能仅使用内核本身。内核只有作为整个系统的一个部分才有用处。Linux 是和 GNU 操作系统结合在一起使用：系统本身是 GNU，与 Linux 作为内核一起工作。 许多用户没有并不完全了解 Linux 内核和被称作“Linux”的整个系统的区别。而不加区别地使用这个名字并不能对理解有帮助。 程序员一般都知道 Linux 是一个内核。但是因为他们也听到整个系统被称作“Linux”，他们会根据名字去想象历史。比如，很多人认为当 Linus Torvalds 完成了内核后，他的朋友四处寻找其他的自由软件，而且所有的可以被组装成一个类似 Unix 系统的程序都是现成的。 他们的发现不是巧合 – 这就是 GNU 系统。 可用的自由软件加在一起就组成了一个完整的系统，这是由于自 1984 年就开始的 GNU 工程一直在为此努力。GNU 宣言(31k 字节) 早已设立了开发一个类似 Unix 的自由系统的目标，称作 GNU。GNU 工程的最初公告 也勾画了 GNU 系统的原始提纲。在 Linux 被编写时，这个系统几乎已经完成。 大多数自由软件的工程都是为了特定的工作开发特定的程序。比方说，Linus Torvalds 编写类似 Unix 的内核(Linux); Donald Knuth 编写一个文本格式化工具(TeX); Bob Scheifler 开发一个窗口系统(X Window System)。对于这项工程编写的程序都作出了贡献，对这些贡献进行评估是很自然的。 如果以这种方法来衡量对 GNU 工程的贡献，我们会得出什么结论？一个 CD-ROM的提供商发现在他们的“Linux 发行版”中，GNU 软件 占最大的比重，大约占全部源代码的 28% ，而且这还包括一些关键的部件，没有这些部件，系统就无法工作。Linux 本身占大约 3%。所以如果你要根据程序的作者来选择一个名字的话，最合适的选择是“GNU”。 但是我们不认为这是一个解决问题的适当方法。GNU 工程以前不是，现在也不是一个开发某个软件包的工程。它不是一个 开发 C 编译器的工程, 尽管我们做了。它也不是一个开发一个文本编辑器的工程，尽管我们也做了。GNU 工程的目标是开发一个完全自由的类似 Unix 的系统: GNU。 许多人已经为系统中的自由软件作出了重大贡献，他们都应该获得荣誉。但 GNU 是一个系统而不是一些实用程序的组合的原因是，GNU 工程的最初目标就是做一个完整系统。我们曾经为完成一个完整的系统做了一个所需程序清单，而且我们有系统地寻找，编写这些程序，并且寻找别人编写清单上的每一个程序。我们编写了关键的但是十分枯燥的主要部件，比如汇编语言和连接器，因为这是系统所必需的。除了编程工具，一个完整的系统还需要更多的东西， Bourne Again SHell 程序, PostScript 解释器 Ghostscript, 和 GNU C 库 同样是很重要的。 到了 90 年代初期，我们曾经把除了内核以外的东西放到一起组成了一个系统（我们同时也在做内核的工作）称为 GNU Hurd, 运行在 Mach 上)。开发这个内核比我们想象的要难得多，我们现在仍然在 为此工作。 庆幸的是，你不必再等了，因为 Linux 开发成功。当 Linus Torvalds 写成了 Linux，他填补了一个重要的空白。人们可以将 Linux 和 GNU 系统组成一个完整的自由系统：基于 Linux 的 GNU 系统（或简称为 GNU/Linux 系统）。 把它们组合到一起听起来很容易，但是这并不是一个简单的工作。 GNU C 库 (简称 glibc) 需要作大量的修改。集成到一个完整的发行系统中也是一项很大的工作。它需要对如何安装和启动系统进行定位 – 这个问题直到现在还在完善，因为我们还没有抓住要点。那些开发了不同的发行系统的人们作出了巨大贡献。 除了 GNU，还有一个独立进行的工程开发了一个自由的类似 Unix 的操作系统。这个系统被称为 BSD，它是由 UC Berkeley 开发的。 在 GNU 工程的鼓舞下，BSD 的开发者开始进行他们自己的自由软件的开发工作，并时常受到 GNU 人士的鼓励，但是他们的实际工作与 GNU 差别不大。今天 BSD 系统采用一些 GNU 软件，就象不同版本的 GNU 系统也采用 BSD 的软件一样。总的说来，它们是两套独立开发的不同的系统。今天一个免费的操作系统几乎都是采用 GNU 或 BSD 系统的一个派生版本。 GNU 工程支持 GNU/Linux 系统，就象支持 GNU 系统一样 – 包括资金的支持。我们为重写与 Linux 相关的 GNU C 库提供资金，以至于它们现在可以很好地集成在一起，直到最新版本的 GNU/Linux 仍在使用这个库而无需修改。我们也为早期 Debian GNU/Linux 的开发提供资金。 今天我们的绝大多数的工作都在基于 Linux 的 GNU 系统上完成，我们希望你也如此。但是请不要含糊地使用 Linux 而使公众迷惑。Linux 是内核，系统的关键部件之一。系统或多或少实际上都应该是 GNU 系统，再加上 Linux。当你在讨论到这个组合系统时，请使用 “GNU/Linux”。 如果要为 GNU/Linux 作链接，本页和 http://www.gnu.org/gnu/the-gnu-project.html 都是很好的选择。如果你想为 Linux（内核）作链接，http://www.kernel.org/是一个很好 URL。 本文摘 https://www.gnu.org/gnu/linux-and-gnu.html Copyright 1997, 1998 Richard Stallman 中文翻译：白若玉翻译校正：刘昭宏 全文在保证完整性的前提下可以在任意媒体转载 - 须保留此标注。 Updated: 30 Nov 2000 paulv","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[{"name":"Linux,GNU","slug":"Linux-GNU","permalink":"http://www.maksim.website/tags/Linux-GNU/"}]},{"title":"Virtualbox下安装 CentOS  minimal 后设置上网","slug":"2017-08-10 Virtualbox下安装 CentOS  minimal 后设置上网","date":"2017-08-10T08:04:12.000Z","updated":"2018-06-20T05:16:15.562Z","comments":true,"path":"2017/08/10/2/","link":"","permalink":"http://www.maksim.website/2017/08/10/2/","excerpt":"","text":"在虚拟机中以minimal安装 CentOS 后无法上网，因为CentOS的默认网卡未激活。 可以设置 文件 /etc/sysconfig/network-scripts/ifcfg-enp0s3 将 ONBOOT=no 改为 ONBOOT=yes 保存后重启网卡： service network restart 这样就可以上网了，我用的是桥接模式。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[{"name":"Linux,Centos","slug":"Linux-Centos","permalink":"http://www.maksim.website/tags/Linux-Centos/"}]},{"title":"CentOS中Live、netinstall、minimal、DVD 等版本的区别","slug":"2017-08-10 CentOS版本区别","date":"2017-08-10T07:04:12.000Z","updated":"2018-04-10T11:12:57.464Z","comments":true,"path":"2017/08/10/1/","link":"","permalink":"http://www.maksim.website/2017/08/10/1/","excerpt":"","text":"LiveCD 和LiveDVD 是可以直接光盘运行的胸痛，但不能安装，两者差别在于容量大小，DVD 包含的软件要多一些。 netinstall 用于网络安装和系统救援的镜像文件。 minimal 这个镜像文件用于安装一个非常基本的 CentOS系统,包含了一些基本所需的最小安装包。 DVD 镜像包含了完整的发布版，可以用于安装完整的 CentOS 系统。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.maksim.website/categories/Linux/"}],"tags":[{"name":"Linux,Centos","slug":"Linux-Centos","permalink":"http://www.maksim.website/tags/Linux-Centos/"}]},{"title":"MySQL索引","slug":"2017-08-06 Mysql-索引","date":"2017-08-05T16:00:00.000Z","updated":"2018-04-09T10:30:21.930Z","comments":true,"path":"2017/08/06/1/","link":"","permalink":"http://www.maksim.website/2017/08/06/1/","excerpt":"","text":"数据库索引，是数据库管理系统中一个排序的数据结构，用于协助快速查询、更新数据库表中的数据。它类似于书本上的索引，通过索引可以更便捷地找到书里面的内容而不需要查阅整本书。对于海量数据的检索，索引往往是最有效的。 目前MySQL主要支持的几种索引有:B树索引(B-tree)、散列索引(hash)、空间索引(R-tree)和全文索引(full-text)。如果没有特别指明，本书指的就是B-Tree索引。由于索引是在存储引擎层实现的，所以不同的存储引擎的索引实现会有一些差异。以下所述的是一些较通用的索引知识。 逻辑上又可以分为:单列索引、复合索引(多列索引)、唯一(Unique)索引和非唯一(Non Unique)索引。 如果索引键值的逻辑顺序与索引所服务的表中相应行的物理顺序相同，那么该索引被称为簇索引(cluster index)，也称为聚集索引、聚簇索引，也就是说数据和索引(B+树)在一起，记录被真实地保存在索引的叶子中，簇索引也称为索引组织表，反之为非聚集索引。我们常用的InnoDB表其实使用的就是聚集索引。 簇索引是一个很重要的概念，InnoDB作为最常使用的引擎，只有在熟悉了它的数据存储方式之后，才可能有针对性地对它进行调优。 簇索引的一些优点如下。 将相关的的数据保持在一起，叶子节点内可保存相邻近的记录。·因为索引和数据存储在一起，所以查找数据通常比非簇索引更快。由于主键是有序的，很显然，对于InnoDB表，最高效的存取方式是按主键存取唯一记录或进行小范围的主键扫描。 如果充分利用簇索引，它可以极大地提升性能，但簇索引也有许多不足之处。 簇索引对I/O密集型的负荷性能提升最佳，但如果数据是在内存中(访问次序不怎么重要)，那么簇索引并没有明显益处。 插入操作很依赖于插入的顺序，按primary key的顺序插入是最快的。 更新簇索引列的成本比较高，因为InnoDB不得不将更新的行移动到新的位置。 全表扫描的性能不佳，尤其是数据存储得不那么紧密时，或者因为页分裂(page split)而导致物理存储不连续。 二级索引的叶节点中存储了主键索引的值，如果主键采用的是较长的字符，那么索引可能会很大，且通过二级索引查找数据也需要进行两次索引查找。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"在Mac上编译安装线程安全的PHP7.2","slug":"2017-08-05 在-Mac上编译安装线程安全的-PHP7.2","date":"2017-08-05T04:04:12.000Z","updated":"2018-06-20T05:09:19.586Z","comments":true,"path":"2017/08/05/1/","link":"","permalink":"http://www.maksim.website/2017/08/05/1/","excerpt":"","text":"因为项目需求后期可能会需要使用到进程守护和消息队列，于是上网查了一下，看到Netkiller PHP 手札中有介绍到PHP使用 Pthread实现优雅守护进程的方法。 可是由于我本地的 PHP 是使用brew进行安装的，在 Linux 下使用 yum或者 apt进行安装的 PHP 同样不支持线程安全。 于是开始折腾起来，将 PHP 卸载掉后使用编译进行重新安装，开启--enable-maintainer-zts 后在编译过程中遇到了 Clang 报错，经过了一番 Google、百度过后，原来是编译器在作怪。Mac 由于 Xcode 的原因，默认使用的编译器是 Clang，在编译到 pthread 的时候，就会报错。 解决方法也很简单，在./configure 命令的最后加上 CC=gcc ，告诉make 我要使用 GCC 编译器进行编译即可。 其实在日常的开发中PHP开发者，很少会接触到多线程这一块。甚至有的PHP 开发者都搞不清楚什么是线程、进程和协程。 那是因为在 Web 开发中根本使用不了多线程，因为 PHP 本身并不提供多线程API，其多线程的支持是由 Pthread 扩展提供的，而 Pthread 扩展的文档中有说明： Warning 不可以在 web 服务器环境中使用 pthreads 扩展，PHP 多线程开发仅限于命令行模式的应用。 Windows版的PHP从版本5.2.1开始有Thread Safe(线程安全)和None Thread Safe(NTS，非线程安全)之分，这两者不同在于何处？到底应该用哪种？ 从2000年 10月20日发布的第一个Windows版的PHP3.0.17开始的都是线程安全的版本，这是由于与Linux/Unix系统是采用多进程的工作方式不同的导致的。 Windows系统是采用多线程的工作方式。如果在IIS下以CGI方式运行PHP会非常慢，这是由于CGI模式是建立在多进程的基础之上的，而非多线程。一般我们会把PHP配置成以ISAPI的方式来运行，ISAPI是多线程的方式，这样就快多了。 但存在一个问题，很多常用的PHP扩展是以 Linux/Unix的多进程思想来开发的，这些扩展在ISAPI的方式运行时就会出错搞垮IIS。因此在IIS下CGI模式才是PHP运行的最安全方式，但CGI模式对于每个HTTP请求都需要重新加载和卸载整个PHP环境，其消耗是巨大的。 为了兼顾IIS下PHP的效率和安全，微软 给出了FastCGI的解决方案。FastCGI可以让PHP的进程重复利用而不是每一个新的请求就重开一个进程。同时FastCGI也可以允许几个进程同时执行。这样既解决了CGI进程模式消耗太大的问题，又利用上了CGI进程模式不存在线程安全问题的优势。 因此，如果是使用ISAPI 的方式来运行PHP就必须用Thread Safe(线程安全)的版本；而用FastCGI模式运行PHP的话就没有必要用线程安全检查了，用None Thread Safe(NTS，非线程安全)的版本能够更好的提高效率。 从上面这段描述我们可以清楚的知道，如果不是使用 ISAPI 的话，不使用多线程特性，那么基本上就用不Thread Safe。 查看自己的 PHP版本是否是线程安全你的只需要在命令行中输入 PHP -v查看 PHP 的版本即可，如下： 引用： PHP线程安全和非线程安全有什么区别 http://www.cnblogs.com/T8881/p/6397264.html PHP Internals Book（《PHP内部书》PHP 内核开发者合著) http://www.phpinternalsbook.com/index.html PHP运行模式 http://www.cnblogs.com/xia520pi/p/3914964.html Netkiller PHP 手札 http://netkiller.github.io/php/index.html","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"多线程,PHP7.2,编译安装,GCC","slug":"多线程-PHP7-2-编译安装-GCC","permalink":"http://www.maksim.website/tags/多线程-PHP7-2-编译安装-GCC/"}]},{"title":"在SQL中使用变量","slug":"2017-08-05 在SQL中使用变量","date":"2017-08-05T00:04:12.000Z","updated":"2018-06-25T12:41:48.685Z","comments":true,"path":"2017/08/05/2/","link":"","permalink":"http://www.maksim.website/2017/08/05/2/","excerpt":"","text":"MySQL 李的变量可分为用户变量和系统变量 1. 用户变量 MySQL允许用户在语句中自定义变量，对于用户变量的值，可以先保存在用户变量中，然后在引用它；这样就可以将值从一个语句传到另外一个语句。 用户变量与连接有关。一个客户端定义的变量不能被其他客户端看到货使用。当客户端退出时，该客户端连接的所有变量将自动释放。这点不同于在函数或存储过程中通过 DECLAER 药监局声明的局部变量，局部变量的生存周期在它被声明的“BEGIN...END”块内。 用户变量的表现形式为：@var_name 设置用户变量的一个途径是执行 SET 语句，语法如下： 1SET @var_name= expr[, @var_name= expr] ... 对于SET，可以使用“=”或“:=”作为分配符。分配给每个变量的expr可以为整数、实数、字符串或NULL值。如: 1mysql&gt; SET @t1=0, @t2=0, @t3=0; 或 1SET @minMid=(select min(id) FROM table_name) ; 2.系统变量 MySQL服务器维护着两种系统变量: 全局变量影响MySQL服务的整体运行方式 会话变量影响具体客户端连接的操作 当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中对指定的选项进行更改。服务器启动后，通过连接服务器并执行SET GLOBAL var_name语句，可以动态更改这些全局变量。要想更改全局变量，必须具有SUPER权限。 服务器还为每个连接的客户端维护一系列的会话变量。在连接时使用相应全局变量的当前值对客户端的会话变量进行初始化。对于动态会话变量，客户端可以通过SET SESSION var_name语句更改它们。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其他客户端的会话变量。 访问全局变量的任何客户端都可以看见对全局变量所做的更改。然而，它只影响更改后连接的客户的相应会话变量，而不会影响目前已经连接的客户端的会话变量(即使客户端执行SET GLOBAL语句也不影响)。 也就是说，如果你的连接是短连接，那么修改全局变量后，客户端有重连的操作，就会立刻影响到客户端。而对于长连接、连接池来说，连接可能一直在MySQL里没有被销毁，也就不会有重连的操作，所以这种情况下对全局变量的修改一般不会影响到客户端。 可以使用如下几种语法形式来设置或检索全局变量或会话变量(下面的例子使用sort_buffer_size作为示例变量名)。 要想设置一个GLOBAL变量的值，可使用下面的语法。 12mysql&gt; SET GLOBAL sort_buffer_size=value; mysql&gt; SET @@global.sort_buffer_size=value; 要想设置一个SESSION变量的值，可使用下面的语法。 123mysql&gt; SET SESSION sort_buffer_size=value; mysql&gt; SET @@session.sort_buffer_size=value; mysql&gt; SET sort_buffer_size=value; 如果设置变量时不指定GLOBAL、SESSION或LOCAL，则默认使用SESSION。 要想检索一个GLOBAL变量的值，可使用下面的语法。 12mysql&gt; SELECT @@global.sort_buffer_size;mysql&gt; SHOW GLOBAL VARIABLES LIKE 'sort_buffer_size'; 要想检索一个SESSION变量的值，可使用下面的语法。 12mysql&gt; SELECT @@sort_buffer_size;mysql&gt; SELECT @@session.sort_buffer_size; mysql&gt; SHOW VARIABLES LIKE 'sort_buffer_size'; 当用SELECT@@var_name搜索一个变量时(也就是说，不指定GLOBAL、SESSION)，MySQL会返回SESSION值(如果存在SESSION变量的话)，否则返回GLOBAL值。 对于SHOW VARIABLES，如果不指定GLOBAL、SESSION的话，MySQL会返回SESSION值。 引用 《MySQLDBA 修炼之道》 作者：陈晓勇 MySQL 官方文档 9.4 User-Defined Variables","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"你真的知道什么是数据库吗? 读《修炼之道：数据库管理员的第一本书》","slug":"2017-08-04 读书笔记之什么是数据库？","date":"2017-08-04T13:04:12.000Z","updated":"2018-06-20T05:08:57.034Z","comments":true,"path":"2017/08/04/601/","link":"","permalink":"http://www.maksim.website/2017/08/04/601/","excerpt":"","text":"“数据库基础”可不是一件小事。问题是，有时人们认为他们知道的很多。 例如，这个问题:什么是数据库? 我敢说大多数的人相信他们知道这个问题的答案。但其中一部分人(或者很多)都会答错。SQL Server 不是数据库，它只是一种 DBMS(数据库管理系统)。你可以使用 SQL Server 来创建数据库，但 SQL Server 本身不是一种数据库。 那么，什么是数据库?数据库是一种有组织的数据存储，其中的数据可以通过指定的数据元素(比如，字段、记录和文件)来访问(详见图 1-1)。 数据库是一种有组织的数据存储，其中的数据可以通过指定的数据元素来访问。 DBMS 是一种使终端用户或程序员能够共享数据的软件。它提供了一套操作数据库的系 统性方法:创建、更新、检索和存储信息。DBMS 通常还负责数据完整性、数据安全性、数据访问控制和优化、自动回退、重起和恢复。 对外行人来说，你可以把数据库想象成一个文件夹，把 DBMS 想象成文件柜，且所容纳的所有文件都贴有标签。DBMS 管理着数据库，通过 DBMS 来实现和访问数据库实例。所以说，DB2、Oracle 和 SQL Server 都是数据库管理系统。工资单应用使用工资单的数据库，该数据库可以使用 DB2、Oracle 或者 SQL Server 来实现。 摘自DBA 《修炼之道：数据库管理员的第一本书》","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"利用 MySQL 权限机制设置用户权限","slug":"2017-08-04 Mysql权限控制","date":"2017-08-04T05:01:00.000Z","updated":"2018-08-04T02:50:25.898Z","comments":true,"path":"2017/08/04/600/","link":"","permalink":"http://www.maksim.website/2017/08/04/600/","excerpt":"","text":"MySQL 权限控制包含如下两个阶段。 阶段1： 服务器检测是否允许你链接。 阶段2： 假定你能连接，服务器将检测你发出的每一个请求，查看你是否有足够的权限实施它。例如你从数据库表中选择（SELECT）行或从数据库中删除表，那么服务器要确定你是否对表有SELECT权限或对数据库有DROP权限。 MySQL是通过用户名、密码、IP(主机名)3个要素来验证用户的。当你想要访问MySQL服务器时，MySQL客户端程序一 般会要求你指定如下参数。 MySQL服务器的IP(主机名)， 端口 用户名 密码 以下是连接MySQL服务器的一个示例，你需要以实际的IP、端口、用户名、密码代替相应的内容。 1mysql -h host_ip_address -u user_name -pyour_password -P server_port 一般在生产环境下，程序账号有增加、删除、查询、修改这4项功能即可。 如下命令用于赋予查询、插入、修改、删除权限，并进行密码设置。 1grant select,insert,update,delete on db_name.* to user_name@ '10.%' identified by 'password'; 如下命令用于回收上面所赋予的权限。 1revoke select,insert,update,delete on db_name.* from user_name@ '10.%';","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/tags/MySQL/"}]},{"title":"PHP7 微信支付不能回调，让我们的团队损失1.00CNY。","slug":"2017-07-14 PHP7微信支付","date":"2017-07-14T06:15:20.000Z","updated":"2018-06-19T01:30:43.876Z","comments":true,"path":"2017/07/14/cjlz9pr3j0036abrde6ru68yi/","link":"","permalink":"http://www.maksim.website/2017/07/14/cjlz9pr3j0036abrde6ru68yi/","excerpt":"","text":"公司目前正在使用一套基于 TP5的开源商城，在线上测试过程中碰到了一个问题，微信支付完成后无法进行回调更新订单状态，简单点说就是钱没了，啥也没得到。 What？这可是一个无法容忍的错误。 原本以为是微信支付配置环节出了问题，于是便去查看微信官网给出的帮助手册，又顺着流程走了一边，信心满满的又测试了一边，结果尴尬了，又损失了0.01人民币。 反复确认流程后，确认并不是配置的问题，于是便开始了百度，原来这一切都是在微信官网给出的SDK中的一段代码惹的祸，就这么一段代码让我们团队损失了接近1人民币。 12//获取通知的数据$xml = $GLOBALS['HTTP_RAW_POST_DATA']; // WxPay.Api.php 414 line 这段代码如果放在PHP7之前的版本是不会有任何问题的，但是在 PHP7版本中却已经废除了 HTTP\\_RAW\\_POST\\_DATA 。 在官方文档中给了说明： Warning This feature was DEPRECATED in PHP 5.6.0, and REMOVED as of PHP 7.0.0. 在PHP5.6.0发布的时候，就已经不推荐只用这种方法，于是在PHP 社区在开发 PHP7.0的时候直接就将其废弃掉了。 而官方也给出了替代的方案，那就是php://input php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP\\_RAW\\_POST\\_DATA，因为它不依赖于特定的php.ini指令。 而且，这样的情况下 $HTTP\\_RAW\\_POST\\_DATA 默认没有填充， 比激活 always\\_populate\\_raw\\_post\\_data潜在需要更少的内存。 enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的。 Note: 在 PHP 5.6 之前 php://input 打开的数据流只能读取一次； 数据流不支持 seek 操作。 不过，依赖于 SAPI 的实现，请求体数据被保存的时候， 它可以打开另一个 php://input 数据流并重新读取。 通常情况下，这种情况只是针对 POST 请求，而不是其他请求方式，比如 PUT 或者 PROPFIND。 于是我将这段代码改为了： 12//获取通知的数据$xml = file_get_contents(\"php://input\"); // WxPay.Api.php 414 line 最后我又以0.01人民币的代价确认修复了这个 BUG。 PHP7:&quot;怪我喽，让你经常看文档，哼！&quot;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"wechat pay,php, php7, php://input","slug":"wechat-pay-php-php7-php-input","permalink":"http://www.maksim.website/tags/wechat-pay-php-php7-php-input/"}]},{"title":"人人都懂设计模式","slug":"2017-07-14 人人都懂设计模式","date":"2017-07-13T16:00:00.000Z","updated":"2018-07-03T12:40:32.624Z","comments":true,"path":"2017/07/14/1/","link":"","permalink":"http://www.maksim.website/2017/07/14/1/","excerpt":"","text":"英文：kamranahmedse， 编译：伯乐在线 - Justin_YGG 简介设计模式用于解决反复出现的问题，是解决特定问题的指导方针。设计模式不是在应用中引用的类、package 或者库，而是在某些特定场景下解决特定问题的指导方针。 设计模式用于解决反复出现的问题，是解决某些特定问题的指导方针。 维基百科中这样描述设计模式： 在软件工程中，设计模式是针对软件设计中普遍存在（反复出现）的各种问题，所提出的可复用型解决方案。设计模式并不直接完成代码的编写，而是描述在不同情况下如何解决问题。 注意 设计模式并非解决所有问题的银弹。 不要强制使用设计模式，否则结果可能适得其反。谨记：设计模式是用来解决问题的，而不是来寻找问题的，不要过度思考。 如果在对的地方对的时机使用设计模式，它会是你的救世主。反之，将会一团糟。 另注：下面的示例代码是用 PHP7 实现的，因为概念是一样的，所以语言并不会阻碍你理解设计模式。其他语言版本的实现正在进行中。 设计模式分类 创建型模式 结构型模式 行为型模式 创建型模式 概述 创建型模式专注于如何初始化对象 。 维基百科 在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决这些问题。 分类 简单工厂模式 工厂方法模式 抽象工厂模式 生成器模式 原型模式 单例模式 简单工厂模式 现实生活示例 想象一下，你正在建造一座房子而且需要几扇房门，如果每次需要房门的时候，不是用工厂制造的房门，而是穿上木匠服，然后开始自己制造房门，将会搞得一团糟。 概述 简单工厂模式只是为客户端创建实例，而不将任何实例化逻辑暴露给客户端。 维基百科 在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。通常来讲，工厂是指某个功能或方法，此功能或方法返回不同类型的对象或者类的某个方法调用，返回的东西看起来是「新的」。 程序示例 首先是房门的接口和实现 12345678910111213141516171819202122232425262728293031323334interface Door&#123; public function getWidth(): float; public function getHeight(): float;&#125; class WoodenDoor implements Door&#123; protected $width; protected $height; public function __construct(float width, float height) &#123; this-&gt;width = width; this-&gt;height = height; &#125; public function getWidth(): float &#123; return $this-&gt;width; &#125; public function getHeight(): float &#123; return $this-&gt;height; &#125;&#125; 然后是生产房门的工厂 123456789class DoorFactory&#123; public static function makeDoor(width, height): Door &#123; return new WoodenDoor(width, height); &#125;&#125; 这样使用 12345$door = DoorFactory::makeDoor(100, 200);echo 'Width: ' . $door-&gt;getWidth();echo 'Height: ' . $door-&gt;getHeight(); 何时使用？ 如果创建对象不仅仅是一些变量的初始化，还涉及某些逻辑，那么将其封装到一个专用工厂中取代随处使用的重复代码是有意义的。 工厂方法模式 现实生活示例 考虑招聘经理的情况。一个人不可能应付所有职位的面试，对于空缺职位，招聘经理必须委派不同的人去面试。 概述 工厂方法模式提供了一种将实例化逻辑委托给子类的方法。 维基百科 在基于类的编程中，工厂方法模式是一种使用了工厂方法的创建型设计模式，在不指定对象具体类型的情况下，处理创建对象的问题。创建对象不是通过调用构造器而是通过调用工厂方法（在接口中指定工厂方法并在子类中实现或者在基类中实现，随意在派生类中重写）来完成。 程序示例 以上述招聘经理为例，首先给出一个面试官接口及实现 12345678910111213141516171819202122interface Interviewer&#123; public function askQuestions();&#125;class Developer implements Interviewer&#123; public function askQuestions() &#123; echo 'Asking about design patterns!'; &#125;&#125;class CommunityExecutive implements Interviewer&#123; public function askQuestions() &#123; echo 'Asking about community building'; &#125;&#125; 然后创建 HiringManager 12345678910111213abstract class HiringManager&#123; // Factory method abstract public function makeInterviewer(): Interviewer; public function takeInterview() &#123; $interviewer = $this-&gt;makeInterviewer(); $interviewer-&gt;askQuestions(); &#125;&#125; 现在，任何子类都可以继承 HiringManager 并委派相应的面试官 1234567891011121314151617class DevelopmentManager extends HiringManager&#123; public function makeInterviewer(): Interviewer &#123; return new Developer(); &#125;&#125; class MarketingManager extends HiringManager&#123; public function makeInterviewer(): Interviewer &#123; return new CommunityExecutive(); &#125;&#125; 这样使用 12345$devManager = new DevelopmentManager();$devManager-&gt;takeInterview(); // Output: Asking about design patterns$marketingManager = new MarketingManager();$marketingManager-&gt;takeInterview(); // Output: Asking about community building. 何时使用？ 类中的一些常见处理需要在运行时动态决定所需的子类，换句话说，当客户端不知道可能需要的确切子类时，使用工厂方法模式。 抽象工厂模式 现实生活示例 扩展一下简单工厂模式中的房门例子。基于所需，你可能需要从木门店获取木门，从铁门店获取铁门或者从相关的门店获取 PVC 门。进一步讲，你可能需要不同种类的专家来安装房门，比如木匠安装木门，焊接工安装铁门等等。正如你所料，房门有了依赖，木门需要木匠，铁门需要焊接工。 概述 一组工厂的工厂：将相关或者互相依赖的单个工厂聚集在一起，而不指定这些工厂的具体类。 维基百科 抽象工厂模式提供了一种方式，这种方式可以封装一组具有共同主题的个体工厂，而不指定这些工厂的具体类。 编程示例 以上述房门为例，首先给出 Door 接口和一些实现 12345678910111213141516171819202122interface Door&#123; public function getDescription();&#125;class WoodenDoor implements Door&#123; public function getDescription() &#123; echo 'I am a wooden door'; &#125;&#125;class IronDoor implements Door&#123; public function getDescription() &#123; echo 'I am an iron door'; &#125;&#125; 然后根据每种房门类型给出对应的安装专家 1234567891011121314151617181920212223242526interface DoorFittingExpert&#123; public function getDescription();&#125;class Welder implements DoorFittingExpert&#123; public function getDescription() &#123; echo 'I can only fit iron doors'; &#125;&#125;class Carpenter implements DoorFittingExpert&#123; public function getDescription() &#123; echo 'I can only fit wooden doors'; &#125;&#125; 现在抽象工厂可以将相关的对象组建在一起，也就是说，木门工厂会生成木门并提供木门安装专家，铁门工厂会生产铁门并提供铁门安装专家。 1234567891011121314151617181920212223242526272829303132333435363738394041interface DoorFactory&#123; public function makeDoor(): Door; public function makeFittingExpert(): DoorFittingExpert;&#125;// Wooden factory to return carpenter and wooden doorclass WoodenDoorFactory implements DoorFactory&#123; public function makeDoor(): Door &#123; return new WoodenDoor(); &#125; public function makeFittingExpert(): DoorFittingExpert &#123; return new Carpenter(); &#125;&#125; // Iron door factory to get iron door and the relevant fitting expertclass IronDoorFactory implements DoorFactory&#123; public function makeDoor(): Door &#123; return new IronDoor(); &#125; public function makeFittingExpert(): DoorFittingExpert &#123; return new Welder(); &#125;&#125; 这样使用 12345678910111213141516171819202122$woodenFactory = new WoodenDoorFactory();$door = $woodenFactory-&gt;makeDoor();$expert = $woodenFactory-&gt;makeFittingExpert();$door-&gt;getDescription(); // Output: I am a wooden door$expert-&gt;getDescription(); // Output: I can only fit wooden doors // Same for Iron Factory$ironFactory = new IronDoorFactory();$door = $ironFactory-&gt;makeDoor();$expert = $ironFactory-&gt;makeFittingExpert();$door-&gt;getDescription(); // Output: I am an iron door$expert-&gt;getDescription(); // Output: I can only fit iron doors 正如你看到的，木门工厂将木匠和木门封装在一起，同样地，铁门工厂将铁门和焊接工封装在一起。这样就可以帮助我们确保，对于每一扇生产出来的门，都能搭配正确的安装工。 何时使用？ 当存在相关的依赖并涉及到稍复杂的创建逻辑时，使用抽象工厂模式。 生成器模式 现实生活示例 想象一下你在 Hardee’s 餐厅点了某个套餐，比如「大 Hardee 套餐」，然后工作人员会正常出餐，这是简单工厂模式。但是在很多情况下，创建逻辑可能涉及到更多步骤。比如，你想要一个定制的 Subway 套餐，对于你的汉堡如何制作有几个选项可供选择，比如你想要什么类型的酱汁？你想要什么奶酪？ 在这种情况下，建造者模式便可以派上用场。 概述 允许创建不同风格的对象，同时避免构造器污染。当创建多种风格的对象时或者创建对象时涉及很多步骤，可以使用生成器模式。 维基百科 生成器模式是一种对象创建软件设计模式，其目的是找到重叠构造器反面模式的解决方案。 既然提到了，那我就补充一下什么是重叠构造器反面模式。 我们时不时地会看到如下构造函数： 1234public function __construct($size, $cheese = true, $pepperoni = true, $tomato = false, $lettuce= true)&#123;&#125; 正如你看到的，构造器参数的数量可能会迅速失控，并且参数的排列可能让人难以理解。 如果将来要添加更多选项，此参数列表可能会不断增长，这被称为重叠构造器反面模式。 程序示例 理想之选是使用生成器模式，首先给出汉堡类 123456789101112131415161718192021222324252627282930class Burger&#123; protected $size; protected $cheese = false; protected $pepperoni = false; protected $lettuce = false; protected $tomato = false; public function __construct(BurgerBuilder $builder) &#123; $this-&gt;size = $builder-&gt;size; $this-&gt;cheese = $builder-&gt;cheese; $this-&gt;pepperoni = $builder-&gt;pepperoni; $this-&gt;lettuce = $builder-&gt;lettuce; $this-&gt;tomato = $builder-&gt;tomato; &#125;&#125; 然后是 builder 123456789101112131415161718192021222324252627282930313233343536373839404142class BurgerBuilder&#123; public $size; public $cheese = false; public $pepperoni = false; public $lettuce = false; public $tomato = false; public function __construct(int $size) &#123; $this-&gt;size = $size; &#125; public function addPepperoni() &#123; $this-&gt;pepperoni = true; return $this; &#125; public function addLettuce() &#123; $this-&gt;lettuce = true; return $this; &#125; public function addCheese() &#123; $this-&gt;cheese = true; return $this; &#125; public function addTomato() &#123; $this-&gt;tomato = true; return $this; &#125; public function build(): Burger &#123; return new Burger($this); &#125;&#125; 这样使用 123456789$burger = (new BurgerBuilder(14)) -&gt;addPepperoni() -&gt;addLettuce() -&gt;addTomato() -&gt;build(); 何时使用？ 当需要构建不同风格的对象，同时需要避免构造器重叠时使用生成器模式。与工厂模式的主要区别在于：当创建过程一步到位时，使用工厂模式，而当创建过程需要多个步骤时，使用生成器模式。 原型模式 现实生活示例 还记得多莉吗？那只克隆羊。这里不深入细节，关键点在于克隆。 概述 基于现有对象通过克隆创建对象。 维基百科 在软件开发过程中，原型模式是一种创建型设计模式。当要创建的对象类型由原型实例确定时，将通过克隆原型实例生成新对象。 简言之，原型模式允许你创建现有对象的副本并根据需要进行修改，而不是从头开始创建对象并进行设置。 编程示例 使用 PHP 的 clone 方法可以轻松实现 123456789101112131415161718192021222324252627282930313233343536class Sheep&#123; protected $name; protected $category; public function __construct(string name, string category = 'Mountain Sheep') &#123; this-&gt;name = name; this-&gt;category = category; &#125; public function setName(string $name) &#123; this-&gt;name = name; &#125; public function getName() &#123; return $this-&gt;name; &#125; public function setCategory(string $category) &#123; this-&gt;category = category; &#125; public function getCategory() &#123; return $this-&gt;category; &#125;&#125; 可以像下面这样克隆 12345678910111213141516$original = new Sheep('Jolly');echo $original-&gt;getName(); // Jollyecho $original-&gt;getCategory(); // Mountain Sheep// Clone and modify what is requiredcloned = clone original;$cloned-&gt;setName('Dolly');echo $cloned-&gt;getName(); // Dollyecho $cloned-&gt;getCategory(); // Mountain sheep 此外，你可以使用魔术方法 **clone 来修改克隆行为。 何时使用 当需要创建一个与已有对象类似的对象，或者当创建对象的成本比克隆更高时，使用原型模式。 单例模式 现实生活示例 一个国家同一时间只能有一位总统。只要使命召唤，这个总统就必须采取行动。 这里的总统就是一个单例。 概述 确保特定类的对象只被创建一次。 维基百科 在软件工程中，单例模式是一种软件设计模式，用来限制类初始化为对象。当恰恰只需要一个对象来协调整个系统的功能时，单例模式非常有用。 实际上，单例模式被认为是反模式，应该避免过度使用。 单例模式并非不好，可能有时候很有用，但应谨慎使用，因为它在你的应用程序中引入了全局状态，一处更改可能会影响其他地方，并且可能会变得很难调试。 另外不好的一点是单例模式会使代码紧耦合，单例也很难mock。 编程示例 要创建一个单例，需要将构造函数设为 private，禁用克隆，禁用扩展名，并创建静态变量来容纳实例 1234567891011121314151617181920212223242526272829final class President&#123; private static $instance; private function __construct() &#123; // Hide the constructor &#125; public static function getInstance(): President &#123; if (!self::$instance) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; private function __clone() &#123; // Disable cloning &#125; private function __wakeup() &#123; // Disable unserialize &#125;&#125; 这样使用 123$president1 = President::getInstance();$president2 = President::getInstance();var_dump(president1 === president2); // true 结构型设计模式 概述 结构型设计模式主要关注对象组合，换句话说，关注实体之间如何互相使用。 或者还有另外一个解释，结构型设计模式有助于回答“如何构建软件组件？” 维基百科 在软件工程中，结构型设计模式是借由一以贯之的方式来了解元件间的关系，从而简化设计的一种设计模式。 分类 适配器模式 桥接模式 组合模式 修饰模式 外观模式 享元模式 代理模式 适配器模式 现实生活示例 考虑这样一个场景，你的存储卡中有一些照片，你需要将其传输到计算机。为此，你需要某种与计算机端口兼容的适配器，以便将存储卡连接到计算机上。在这种情况下，读卡器就是适配器。另外一个例子就是大名鼎鼎的电源适配器：一个三脚插头不能连接到双插头插座，需要使用电源适配器使其与双插头插座兼容。另外一个例子是译者将一个人说的话翻译给另一个人。 概述 适配器模式可以将不兼容的对象包装成适配器来适配其它类。 维基百科 在软件工程中，适配器模式是允许将现有类的接口用作另一个类接口的软件设计模式。它通常用于现有类与其他类的协作，而无需修改现有类的代码。 - 程序示例 考虑一个游戏场景，有一个猎人，他狩猎狮子。 首先给出Lion接口，所有种类的狮子都要实现这个接口。 123456789101112131415161718interface Lion&#123; public function roar();&#125;class AfricanLion implements Lion&#123; public function roar() &#123; &#125;&#125;class AsianLion implements Lion&#123; public function roar() &#123; &#125;&#125; 猎人希望可以狩猎任何实现 Lion 接口的狮子 123456class Hunter&#123; public function hunt(Lion $lion) &#123; &#125;&#125; 结构型设计模式概述结构型设计模式主要关注对象组合，换句话说，关注实体之间如何互相使用。 或者还有另外一个解释，结构型设计模式有助于回答“如何构建软件组件？” 维基百科在软件工程中，结构型设计模式是借由一以贯之的方式来了解元件间的关系，从而简化设计的一种设计模式。 分类 适配器模式 桥接模式 组合模式 修饰模式 外观模式 享元模式 代理模式 适配器模式现实生活示例考虑这样一个场景，你的存储卡中有一些照片，你需要将其传输到计算机。为此，你需要某种与计算机端口兼容的适配器，以便将存储卡连接到计算机上。在这种情况下，读卡器就是适配器。另外一个例子就是大名鼎鼎的电源适配器：一个三脚插头不能连接到双插头插座，需要使用电源适配器使其与双插头插座兼容。另外一个例子是译者将一个人说的话翻译给另一个人。 概述适配器模式可以将不兼容的对象包装成适配器来适配其它类。 维基百科在软件工程中，适配器模式是允许将现有类的接口用作另一个类接口的软件设计模式。它通常用于现有类与其他类的协作，而无需修改现有类的代码。 程序示例 考虑一个游戏场景，有一个猎人，他狩猎狮子。 首先给出 Lion 接口，所有种类的狮子都要实现这个接口。 123456789101112131415161718interface Lion&#123; public function roar();&#125;class AfricanLion implements Lion&#123; public function roar() &#123; &#125;&#125;class AsianLion implements Lion&#123; public function roar() &#123; &#125;&#125; 猎人希望可以狩猎任何实现 Lion 接口的狮子 123456class Hunter&#123; public function hunt(Lion $lion) &#123; &#125;&#125; 现在我们假定猎人在游戏中也可以狩猎野狗。但是目前我们无法实现，因为狗是通过其他接口实现。为了让猎人可以狩猎野狗，我们需要创建一个适配器，来兼容这种情况。 1234567891011121314151617181920212223// This needs to be added to the gameclass WildDog&#123; public function bark() &#123; &#125;&#125;// Adapter around wild dog to make it compatible with our gameclass WildDogAdapter implements Lion&#123; protected $dog; public function __construct(WildDog $dog) &#123; $this-&gt;dog = $dog; &#125; public function roar() &#123; $this-&gt;dog-&gt;bark(); &#125;&#125; 这样，在游戏中通过 WildDogAdapter 就可以使用 WildDog 12345$wildDog = new WildDog();$wildDogAdapter = new WildDogAdapter($wildDog);$hunter = new Hunter();$hunter-&gt;hunt($wildDogAdapter); 桥接模式现实生活示例假如你有一个网站，上面有不同的网页，并且允许用户更改主题。你会如何实现呢？是为每个页面的各个主题创建多个副本，还是创建单独的主题，并根据用户的偏好来加载主题呢？桥接模式可以帮你实现后者。 不使用桥接模式 使用桥接模式 概述桥接模式主打的是组合优于继承。实现细节从对象的层次结构推送给具有单独层次结构的另一个对象。 维基百科桥接模式是软件工程中使用的设计模式，旨在“将抽象与实现分离，使得两者可以独立变化” 程序示例 以上面提到的网页为例，下面是 WebPage 的结构 1234567891011121314151617181920212223242526272829303132333435interface WebPage&#123; public function __construct(Theme $theme); public function getContent();&#125;class About implements WebPage&#123; protected $theme; public function __construct(Theme $theme) &#123; $this-&gt;theme = $theme; &#125; public function getContent() &#123; return \"About page in \" . $this-&gt;theme-&gt;getColor(); &#125;&#125;class Careers implements WebPage&#123; protected $theme; public function __construct(Theme $theme) &#123; $this-&gt;theme = $theme; &#125; public function getContent() &#123; return \"Careers page in \" . $this-&gt;theme-&gt;getColor(); &#125;&#125; 独立的 主题 结构 1234567891011121314151617181920212223242526interface Theme&#123; public function getColor();&#125;class DarkTheme implements Theme&#123; public function getColor() &#123; return 'Dark Black'; &#125;&#125;class LightTheme implements Theme&#123; public function getColor() &#123; return 'Off white'; &#125;&#125;class AquaTheme implements Theme&#123; public function getColor() &#123; return 'Light blue'; &#125;&#125; 都是两层结构 1234567$darkTheme = new DarkTheme();$about = new About($darkTheme);$careers = new Careers($darkTheme);echo $about-&gt;getContent(); // \"About page in Dark Black\";echo $careers-&gt;getContent(); // \"Careers page in Dark Black\"; 组合模式现实生活示例每个公司都是由员工组成，每个员工都有一些共同特征比如薪资以及所承担的某些责任，会或者不会向其他人汇报工作，有或者没有下属等。 概述组合模式让客户端以统一的方式对待各个对象。 维基百科在软件工程中，组合模式是一种分治设计模式。组合模式对待一组对象的处理方式与对待对象的单个实例相同。组合的意图是将对象“组合”成树状结构以呈现部分-整体的层次结构。实现组合模式可以使客户端能够均匀地处理单个对象和组合。 程序示例 以上面提到的员工为例，下面是不同的员工类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172interface Employee&#123; public function __construct(string $name, float $salary); public function getName(): string; public function setSalary(float $salary); public function getSalary(): float; public function getRoles(): array;&#125;class Developer implements Employee&#123; protected $salary; protected $name; public function __construct(string $name, float $salary) &#123; $this-&gt;name = $name; $this-&gt;salary = $salary; &#125; public function getName(): string &#123; return $this-&gt;name; &#125; public function setSalary(float $salary) &#123; $this-&gt;salary = $salary; &#125; public function getSalary(): float &#123; return $this-&gt;salary; &#125; public function getRoles(): array &#123; return $this-&gt;roles; &#125;&#125;class Designer implements Employee&#123; protected $salary; protected $name; public function __construct(string $name, float $salary) &#123; $this-&gt;name = $name; $this-&gt;salary = $salary; &#125; public function getName(): string &#123; return $this-&gt;name; &#125; public function setSalary(float $salary) &#123; $this-&gt;salary = $salary; &#125; public function getSalary(): float &#123; return $this-&gt;salary; &#125; public function getRoles(): array &#123; return $this-&gt;roles; &#125;&#125; 包含几种不同类型员工的公司 1234567891011121314151617181920class Organization&#123; protected $employees; public function addEmployee(Employee $employee) &#123; $this-&gt;employees[] = $employee; &#125; public function getNetSalaries(): float &#123; $netSalary = 0; foreach ($this-&gt;employees as $employee) &#123; $netSalary += $employee-&gt;getSalary(); &#125; return $netSalary; &#125;&#125; 然后可以这样调用 12345678910// Prepare the employees$john = new Developer('John Doe', 12000);$jane = new Designer('Jane Doe', 15000);// Add them to organization$organization = new Organization();$organization-&gt;addEmployee($john);$organization-&gt;addEmployee($jane);echo \"Net salaries: \" . $organization-&gt;getNetSalaries(); // Net Salaries: 27000 装饰器模式现实生活示例想象一下，你在经营一家提供多种服务的汽车服务站。现在如何计算收费帐单呢？选择一项服务，并动态地向其添加价格，直到获得最终成本。这里每种类型的服务就是装饰器。 概述通过将对象包装在装饰器类的对象中，装饰器模式可以在运行时动态地更改对象的行为。 维基百科装饰器模式，是面向对象编程领域中，一种动态地或静态地往一个类中添加新行为而不影响相同类中其他对象的设计模式。装饰器模式对于遵守单一责任原则通常是有用的，因为它允许在具有独特领域的类之间划分功能。 程序示例 我们以咖啡为例，首先我们通过咖啡接口实现一个简单咖啡 123456789101112131415161718interface Coffee&#123; public function getCost(); public function getDescription();&#125;class SimpleCoffee implements Coffee&#123; public function getCost() &#123; return 10; &#125; public function getDescription() &#123; return 'Simple coffee'; &#125;&#125; 我们希望代码可扩展，以允许选项在需要时进行修改。 增加一些附加项（装饰器） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MilkCoffee implements Coffee&#123; protected $coffee; public function __construct(Coffee $coffee) &#123; $this-&gt;coffee = $coffee; &#125; public function getCost() &#123; return $this-&gt;coffee-&gt;getCost() + 2; &#125; public function getDescription() &#123; return $this-&gt;coffee-&gt;getDescription() . ', milk'; &#125;&#125;class WhipCoffee implements Coffee&#123; protected $coffee; public function __construct(Coffee $coffee) &#123; $this-&gt;coffee = $coffee; &#125; public function getCost() &#123; return $this-&gt;coffee-&gt;getCost() + 5; &#125; public function getDescription() &#123; return $this-&gt;coffee-&gt;getDescription() . ', whip'; &#125;&#125;class VanillaCoffee implements Coffee&#123; protected $coffee; public function __construct(Coffee $coffee) &#123; $this-&gt;coffee = $coffee; &#125; public function getCost() &#123; return $this-&gt;coffee-&gt;getCost() + 3; &#125; public function getDescription() &#123; return $this-&gt;coffee-&gt;getDescription() . ', vanilla'; &#125;&#125; 下面我们来做杯咖啡吧 123456789101112131415$someCoffee = new SimpleCoffee();echo $someCoffee-&gt;getCost(); // 10echo $someCoffee-&gt;getDescription(); // Simple Coffee$someCoffee = new MilkCoffee($someCoffee);echo $someCoffee-&gt;getCost(); // 12echo $someCoffee-&gt;getDescription(); // Simple Coffee, milk$someCoffee = new WhipCoffee($someCoffee);echo $someCoffee-&gt;getCost(); // 17echo $someCoffee-&gt;getDescription(); // Simple Coffee, milk, whip$someCoffee = new VanillaCoffee($someCoffee);echo $someCoffee-&gt;getCost(); // 20echo $someCoffee-&gt;getDescription(); // Simple Coffee, milk, whip, vanilla 外观模式现实生活示例请问你会如何打开计算机呢？你会回答：“按电源键就行！”。你会这样想是因为你在使用计算机对外提供的简易接口，但是在内部，计算机完成了很多工作后才得以启动，这种复杂子系统的简单接口就是外观模式。 概述外观模式提供了一个简化复杂系统的简单接口。 维基百科外观模式是指针对像类库这种大体积代码提供简化接口的对象。 程序示例 以上面提到的计算机为例，给出计算机类 12345678910111213141516171819202122232425262728293031323334353637class Computer&#123; public function getElectricShock() &#123; echo \"Ouch!\"; &#125; public function makeSound() &#123; echo \"Beep beep!\"; &#125; public function showLoadingScreen() &#123; echo \"Loading..\"; &#125; public function bam() &#123; echo \"Ready to be used!\"; &#125; public function closeEverything() &#123; echo \"Bup bup bup buzzzz!\"; &#125; public function sooth() &#123; echo \"Zzzzz\"; &#125; public function pullCurrent() &#123; echo \"Haaah!\"; &#125;&#125; 下面是计算机的外观 123456789101112131415161718192021222324class ComputerFacade&#123; protected $computer; public function __construct(Computer $computer) &#123; $this-&gt;computer = $computer; &#125; public function turnOn() &#123; $this-&gt;computer-&gt;getElectricShock(); $this-&gt;computer-&gt;makeSound(); $this-&gt;computer-&gt;showLoadingScreen(); $this-&gt;computer-&gt;bam(); &#125; public function turnOff() &#123; $this-&gt;computer-&gt;closeEverything(); $this-&gt;computer-&gt;pullCurrent(); $this-&gt;computer-&gt;sooth(); &#125;&#125; 可以这样使用外观模式 123$computer = new ComputerFacade(new Computer());$computer-&gt;turnOn(); // Ouch! Beep beep! Loading.. Ready to be used!$computer-&gt;turnOff(); // Bup bup buzzz! Haah! Zzzzz 享元模式现实生活示例你是否在某个摊位上喝过茶？店主总是会多做一些茶，以预留给其他顾客，以此来节省资源比如燃气。享元模式所讲的就是共享。 概述享元模式通过相似对象之间尽可能的资源共享，来最小化内存使用或计算开销。 维基百科在计算机编程中，享元模式是一种软件设计模式。享元模式是通过与其他类似对象共享尽可能多的数据来最小化内存使用的对象; 当简单的重复对象过多占用内存时，可以通过享元模式来处理大量相似对象的情况。 程序示例 以茶为例，首先定义茶的种类及茶具 1234567891011121314151617181920// Anything that will be cached is flyweight.// Types of tea here will be flyweights.class KarakTea&#123;&#125; // Acts as a factory and saves the teaclass TeaMaker&#123; protected $availableTea = []; public function make($preference) &#123; if (empty($this-&gt;availableTea[$preference])) &#123; $this-&gt;availableTea[$preference] = new KarakTea(); &#125; return $this-&gt;availableTea[$preference]; &#125;&#125; 然后定义茶店来接单及提供服务 12345678910111213141516171819202122class TeaShop&#123; protected $orders; protected $teaMaker; public function __construct(TeaMaker $teaMaker) &#123; $this-&gt;teaMaker = $teaMaker; &#125; public function takeOrder(string $teaType, int $table) &#123; $this-&gt;orders[$table] = $this-&gt;teaMaker-&gt;make($teaType); &#125; public function serve() &#123; foreach ($this-&gt;orders as $table =&gt; $tea) &#123; echo \"Serving tea to table# \" . $table; &#125; &#125;&#125; 下面可以这样使用 1234567891011$teaMaker = new TeaMaker();$shop = new TeaShop($teaMaker);$shop-&gt;takeOrder('less sugar', 1);$shop-&gt;takeOrder('more milk', 2);$shop-&gt;takeOrder('without sugar', 5);$shop-&gt;serve();// Serving tea to table# 1// Serving tea to table# 2// Serving tea to table# 5 代理模式现实生活示例有没有过使用门禁卡进门的经历呢？打开门的方法有多种，既可以使用门禁卡，也可以按下门上的安全按钮。门的主要功能是打开，但在其上添加一个代理，便可以给门添加一些功能。下面的代码示例可以给出更好的解释。 概述使用代理模式，一个类可以代理另外一个类的功能。 维基百科一个代理，其最一般的形式，是一个作为其他类接口的类。代理是由客户端调用的包装器或代理对象，用来访问幕后的真实服务对象。使用代理可以简单地向真实对象做转发，或者可以提供额外的逻辑。在代理模式中，可以提供额外的功能，例如当在真实对象上的操作是资源密集型时进行缓存，或者在调用真实对象的操作之前进行预处理。 程序示例 以安全门为例，首先给出安全门接口及实现 123456789101112131415161718interface Door&#123; public function open(); public function close();&#125;class LabDoor implements Door&#123; public function open() &#123; echo \"Opening lab door\"; &#125; public function close() &#123; echo \"Closing the lab door\"; &#125;&#125; 然后使用代理来确保门的安全 12345678910111213141516171819202122232425262728class Security&#123; protected $door; public function __construct(Door $door) &#123; $this-&gt;door = $door; &#125; public function open($password) &#123; if ($this-&gt;authenticate($password)) &#123; $this-&gt;door-&gt;open(); &#125; else &#123; echo \"Big no! It ain't possible.\"; &#125; &#125; public function authenticate($password) &#123; return $password === '$ecr@t'; &#125; public function close() &#123; $this-&gt;door-&gt;close(); &#125;&#125; 可以这样使用 12345$door = new Security(new LabDoor());$door-&gt;open('invalid'); // Big no! It ain't possible.$door-&gt;open('$ecr@t'); // Opening lab door$door-&gt;close(); // Closing lab door 另一个例子是实现某种数据映射器。例如，我最近使用这种模式为 MongoDB 做了一个 ODM（对象数据映射器），其中我使用魔术方法__call（） 在 mongo 类上编写代理。所有的方法调用被代理到原始的 mongo 类，并且检索的结果原样返回，但如果调用 find 或 findOne，数据会被映射到所需的类对象，并且返回了对象而不是Cursor。 行为型模式概述行为型设计模式关心对象之间的责任分配。与结构型设计模式不同的是，行为型设计模式不仅仅指定结构，而且还概述了它们之间的消息传递/通信的模式。或者换句话说，行为型模式帮助回答了“软件组件是如何运行的？” 维基百科在软件工程中，行为型设计模式为设计模式的一种类型，用来识别对象之间的常用交流模式并加以实现。如此，可以在交流时增强灵活性。 分类 责任链模式 命令模式 迭代器模式 中介者模式 备忘录模式 观察者模式 访问者模式 策略模式 状态模式 模板方法模式 责任链模式现实生活示例例如，你的帐户中有三种付款方式（A，B 和 C）; 每种方式付款额不同。 A 可支付 100 美元，B 可支付 300 美元，C 可支付 1000 美元，支付的优先级为 A-&gt;B-&gt;C。现在想要购买价值 210 美元的东西。使用责任链模式，首先将检查帐户 A 是否可以进行购买，如果可以购买，链条将被破坏。如果不能购买，将继续检查账号 B 是否可以购买，如果可以购买，链条将被破坏，否则请求将继续转发，直到找到合适的处理程序。这里的 A、B 和 C 就是责任链的链条，整个现象就是责任链模式。 概述责任链模式有助于建立一个对象链。请求从一端进入，在对象之间转发，直到找到合适的处理程序。 维基百科责任链模式是面向对象程序设计的一种软件设计模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，不能处理的命令对象传递给该链中的下一个处理对象。 程序示例 以上面的支付账号为例，首先给出账户基类，包含链接账号的逻辑以及一些不同类型的账户 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657abstract class Account&#123; protected $successor; protected $balance; public function setNext(Account $account) &#123; $this-&gt;successor = $account; &#125; public function pay(float $amountToPay) &#123; if ($this-&gt;canPay($amountToPay)) &#123; echo sprintf('Paid %s using %s' . PHP_EOL, $amountToPay, get_called_class()); &#125; elseif ($this-&gt;successor) &#123; echo sprintf('Cannot pay using %s. Proceeding ..' . PHP_EOL, get_called_class()); $this-&gt;successor-&gt;pay($amountToPay); &#125; else &#123; throw new Exception('None of the accounts have enough balance'); &#125; &#125; public function canPay($amount): bool &#123; return $this-&gt;balance &gt;= $amount; &#125;&#125;class Bank extends Account&#123; protected $balance; public function __construct(float $balance) &#123; $this-&gt;balance = $balance; &#125;&#125;class Paypal extends Account&#123; protected $balance; public function __construct(float $balance) &#123; $this-&gt;balance = $balance; &#125;&#125;class Bitcoin extends Account&#123; protected $balance; public function __construct(float $balance) &#123; $this-&gt;balance = $balance; &#125;&#125; 然后通过上面定义的链接（即 Bank, Paypal, Bitcoin）形成责任链 12345678910111213141516171819202122// Let's prepare a chain like below// $bank-&gt;$paypal-&gt;$bitcoin//// First priority bank// If bank can't pay then paypal// If paypal can't pay then bit coin$bank = new Bank(100); // Bank with balance 100$paypal = new Paypal(200); // Paypal with balance 200$bitcoin = new Bitcoin(300); // Bitcoin with balance 300$bank-&gt;setNext($paypal);$paypal-&gt;setNext($bitcoin);// Let's try to pay using the first priority i.e. bank$bank-&gt;pay(259);// Output will be// ==============// Cannot pay using bank. Proceeding ..// Cannot pay using paypal. Proceeding ..:// Paid 259 using Bitcoin! 命令模式现实生活示例一个典型的例子是你在餐厅点菜，你（即客户）向服务员（即 Invoker）点餐（即命令），服务员只需将需求转达给会烹饪的厨师。 另外一个例子是你（即客户端）使用遥控器（Invoker）打开（即命令）电视机（即接收器）。 概述命令模式允许将操作封装在对象中，其背后的关键思想是提供客户端与接收器分离的方法。 维基百科在面向对象程序设计的范畴中，命令模式是一种行为型设计模式。将所有需要的信息封装到对象中，用于之后的动作（action）或者事件触发。被封装的信息包括方法名以及拥有方法及参数的对象。 程序示例 首先给出一个接收器，实现了可能会执行的动作： 12345678910111213// Receiverclass Bulb&#123; public function turnOn() &#123; echo \"Bulb has been lit\"; &#125; public function turnOff() &#123; echo \"Darkness!\"; &#125;&#125; 然后给出一个接口，（Bulb）中的每个命令都要实现这个接口，得到一组命令集： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657interface Command&#123; public function execute(); public function undo(); public function redo();&#125;// Commandclass TurnOn implements Command&#123; protected $bulb; public function __construct(Bulb $bulb) &#123; $this-&gt;bulb = $bulb; &#125; public function execute() &#123; $this-&gt;bulb-&gt;turnOn(); &#125; public function undo() &#123; $this-&gt;bulb-&gt;turnOff(); &#125; public function redo() &#123; $this-&gt;execute(); &#125;&#125;class TurnOff implements Command&#123; protected $bulb; public function __construct(Bulb $bulb) &#123; $this-&gt;bulb = $bulb; &#125; public function execute() &#123; $this-&gt;bulb-&gt;turnOff(); &#125; public function undo() &#123; $this-&gt;bulb-&gt;turnOn(); &#125; public function redo() &#123; $this-&gt;execute(); &#125;&#125; 然后是Invoker，客户端将与之交互以处理各种命令： 12345678 // Invokerclass RemoteControl{ public function submit(Command $command) { $command-&gt;execute(); }} 最后来看一下如何在客户端中使用： 12345678 $bulb = new Bulb(); $turnOn = new TurnOn($bulb);$turnOff = new TurnOff($bulb); $remote = new RemoteControl();$remote-&gt;submit($turnOn); // Bulb has been lit!$remote-&gt;submit($turnOff); // Darkness! 命令模式也可用于实现基于事务的系统。在执行命令时，需要持续保存命令的历史，如果最后一条命令成功执行，皆大欢喜，否则遍历历史记录，并对所有执行过的命执行撤销。 迭代器模式现实生活示例老式的无线电设备将是一个很好的迭代器示例，用户可以在某个频道上启动，然后使用下一个或上一个按钮来切换频道。或者以 MP3 播放器或电视机为例，你可以按下一个按钮和上一个按钮进行连续的频道切换。换句话说，它们都提供了一个界面来遍历相应的频道，歌曲或广播电台。 概述迭代器模式提供了一种方法，可以访问对象的元素而不暴露底层实现。 维基百科在面向对象程序设计中，迭代器模式是一种设计模式，其中迭代器用于遍历容器并访问容器的元素。迭代器模式将算法与容器解耦; 在某些情况下，算法是特定容器必需的，因此不能解耦。 程序示例 通过PHP，使用 SPL（PHP标准库）可以轻松实现迭代器模式，以上述收音机为例，首先给出 RadioStation 类 1234567891011121314class RadioStation&#123; protected $frequency; public function __construct(float $frequency) &#123; $this-&gt;frequency = $frequency; &#125; public function getFrequency(): float &#123; return $this-&gt;frequency; &#125;&#125; 然后是 迭代器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354use Countable;use Iterator;class StationList implements Countable, Iterator&#123; /** [@var](http://www.jobbole.com/members/variable) RadioStation[] $stations */ protected $stations = []; /** [@var](http://www.jobbole.com/members/variable) int $counter */ protected $counter; public function addStation(RadioStation $station) &#123; $this-&gt;stations[] = $station; &#125; public function removeStation(RadioStation $toRemove) &#123; $toRemoveFrequency = $toRemove-&gt;getFrequency(); $this-&gt;stations = array_filter($this-&gt;stations, function (RadioStation $station) use ($toRemoveFrequency) &#123; return $station-&gt;getFrequency() !== $toRemoveFrequency; &#125;); &#125; public function count(): int &#123; return count($this-&gt;stations); &#125; public function current(): RadioStation &#123; return $this-&gt;stations[$this-&gt;counter]; &#125; public function key() &#123; return $this-&gt;counter; &#125; public function next() &#123; $this-&gt;counter++; &#125; public function rewind() &#123; $this-&gt;counter = 0; &#125; public function valid(): bool &#123; return isset($this-&gt;stations[$this-&gt;counter]); &#125;&#125; 可以这样使用 123456789101112$stationList = new StationList();$stationList-&gt;addStation(new RadioStation(89));$stationList-&gt;addStation(new RadioStation(101));$stationList-&gt;addStation(new RadioStation(102));$stationList-&gt;addStation(new RadioStation(103.2));foreach($stationList as $station) &#123; echo $station-&gt;getFrequency() . PHP_EOL;&#125;$stationList-&gt;removeStation(new RadioStation(89)); // Will remove station 89 中介者模式现实生活示例典型的例子是你通过手机与他人通话，你与通话者之间有一个网络供应商，对话将通过供应商传递而非直接传递。这种情况下网络供应商就是中介者。 概述中介者模式添加了第三方对象（称为中介者）来控制两个对象（称为 colleague）之间的交互。中介者模式有助于减少通信类之间的耦合，因为类之间无需知道对方的实现。 维基百科在软件工程中，中介者模式包装了一系列对象相互作用的方式。这种模式被认为是一种行为模式，因为它可以改变程序的运行时行为。 程序示例 下面是一个最简单的用户（即 colleague）在聊天室（中介者）中互相发送消息的示例 首先给出中介者及聊天室 12345678910111213141516interface ChatRoomMediator &#123; public function showMessage(User $user, string $message);&#125;// Mediatorclass ChatRoom implements ChatRoomMediator&#123; public function showMessage(User $user, string $message) &#123; $time = date('M d, y H:i'); $sender = $user-&gt;getName(); echo $time . '[' . $sender . ']:' . $message; &#125;&#125; 然后是用户即 colleague 1234567891011121314151617class User &#123; protected $name; protected $chatMediator; public function __construct(string $name, ChatRoomMediator $chatMediator) &#123; $this-&gt;name = $name; $this-&gt;chatMediator = $chatMediator; &#125; public function getName() &#123; return $this-&gt;name; &#125; public function send($message) &#123; $this-&gt;chatMediator-&gt;showMessage($this, $message); &#125;&#125; 用法 1234567891011$mediator = new ChatRoom();$john = new User('John Doe', $mediator);$jane = new User('Jane Doe', $mediator);$john-&gt;send('Hi there!');$jane-&gt;send('Hey!');// Output will be// Feb 14, 10:58 [John]: Hi there!// Feb 14, 10:58 [Jane]: Hey! 备忘录模式现实生活示例以计算器（即发起者）为例，每当执行一些计算时，最后一次计算结果将保存在内存中（即备忘录），以便数据可以恢复，也可以使用某些操作按钮（即临时代理）来恢复数据。 概述备忘录模式以一种稍后可平滑恢复的方式捕捉并存储对象的当前状态。 维基百科备忘录模式是一种软件设计模式，可以将对象恢复到之前的状态（通过回滚来撤销） 需要提供撤销操作时，备忘录模式通常很有用。 程序示例 首先给出可以存储编辑器状态的备忘录对象 1234567891011121314class EditorMemento&#123; protected $content; public function __construct(string $content) &#123; $this-&gt;content = $content; &#125; public function getContent() &#123; return $this-&gt;content; &#125;&#125; 然后是使用备忘录对象的编辑器及发起者 123456789101112131415161718192021222324class Editor&#123; protected $content = ''; public function type(string $words) &#123; $this-&gt;content = $this-&gt;content . ' ' . $words; &#125; public function getContent() &#123; return $this-&gt;content; &#125; public function save() &#123; return new EditorMemento($this-&gt;content); &#125; public function restore(EditorMemento $memento) &#123; $this-&gt;content = $memento-&gt;getContent(); &#125;&#125; 这样使用 12345678910111213141516171819$editor = new Editor();// Type some stuff$editor-&gt;type('This is the first sentence.');$editor-&gt;type('This is second.');// Save the state to restore to : This is the first sentence. This is second.$saved = $editor-&gt;save();// Type some more$editor-&gt;type('And this is third.');// Output: Content before Savingecho $editor-&gt;getContent(); // This is the first sentence. This is second. And this is third.// Restoring to last saved state$editor-&gt;restore($saved);$editor-&gt;getContent(); // This is the first sentence. This is second. 观察者模式现实生活示例一个很好的例子是，求职者订阅了一些招聘网站，每当有匹配的工作机会时，求职者就会收到通知。 概述定义了对象之间的依赖，一旦其中一个对象的状态发生改变，依赖它的对象都会收到通知。 维基百科观察者模式是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。通常通过调用目标对象所提供的方法来实现。 程序示例 以上述求职订阅为例，首先给出求职者，有职位发布时会收到通知 123456789101112131415161718192021222324252627282930class JobPost&#123; protected $title; public function __construct(string $title) &#123; $this-&gt;title = $title; &#125; public function getTitle() &#123; return $this-&gt;title; &#125;&#125;class JobSeeker implements Observer&#123; protected $name; public function __construct(string $name) &#123; $this-&gt;name = $name; &#125; public function onJobPosted(JobPost $job) &#123; // Do something with the job posting echo 'Hi ' . $this-&gt;name . '! New job posted: '. $job-&gt;getTitle(); &#125;&#125; 然后是求职者订阅的职位发布类 123456789101112131415161718192021class JobPostings implements Observable&#123; protected $observers = []; protected function notify(JobPost $jobPosting) &#123; foreach ($this-&gt;observers as $observer) &#123; $observer-&gt;onJobPosted($jobPosting); &#125; &#125; public function attach(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; public function addJob(JobPost $jobPosting) &#123; $this-&gt;notify($jobPosting); &#125;&#125; 这样使用 123456789101112131415// Create subscribers$johnDoe = new JobSeeker('John Doe');$janeDoe = new JobSeeker('Jane Doe');// Create publisher and attach subscribers$jobPostings = new JobPostings();$jobPostings-&gt;attach($johnDoe);$jobPostings-&gt;attach($janeDoe);// Add a new job and see if subscribers get notified$jobPostings-&gt;addJob(new JobPost('Software Engineer'));// Output// Hi John Doe! New job posted: Software Engineer// Hi Jane Doe! New job posted: Software Engineer 访问者模式现实生活示例假如有人前往迪拜，他们需要有证件（比如签证）就可进入迪拜。到达后，无需获得许可或做一些跑腿工作，他们便可以自由前往迪拜的任何地方; 只要是知道的地方，就能游览。访问者模式可以做到这一点，它可以帮助你添加访问地点，以便在无需跑腿的情况下，可以尽可能多地访问。 概述访问者模式可以在无需修改对象的情况下增加一些额外操作。 维基百科在面向对象编程和软件工程中，访问者设计模式是一种从对象结构中分离算法的方式。这种分离的实际结果是能够向现有的对象结构添加新的操作，而无需修改这些结构。这是遵循开放/封闭原则的一种方式。 编程示例 以模拟动物园为例，动物园里有几种不同种类的动物，我们需要让它们发出叫声，下面使用访问者模式实现 12345678910111213// Visiteeinterface Animal&#123; public function accept(AnimalOperation $operation);&#125;// Visitorinterface AnimalOperation&#123; public function visitMonkey(Monkey $monkey); public function visitLion(Lion $lion); public function visitDolphin(Dolphin $dolphin);&#125; 然后实现各种动物 1234567891011121314151617181920212223242526272829303132333435363738class Monkey implements Animal&#123; public function shout() &#123; echo 'Ooh oo aa aa!'; &#125; public function accept(AnimalOperation $operation) &#123; $operation-&gt;visitMonkey($this); &#125;&#125;class Lion implements Animal&#123; public function roar() &#123; echo 'Roaaar!'; &#125; public function accept(AnimalOperation $operation) &#123; $operation-&gt;visitLion($this); &#125;&#125;class Dolphin implements Animal&#123; public function speak() &#123; echo 'Tuut tuttu tuutt!'; &#125; public function accept(AnimalOperation $operation) &#123; $operation-&gt;visitDolphin($this); &#125;&#125; 接下来实现访问者 1234567891011121314151617class Speak implements AnimalOperation&#123; public function visitMonkey(Monkey $monkey) &#123; $monkey-&gt;shout(); &#125; public function visitLion(Lion $lion) &#123; $lion-&gt;roar(); &#125; public function visitDolphin(Dolphin $dolphin) &#123; $dolphin-&gt;speak(); &#125;&#125; 可以这样使用 123456789$monkey = new Monkey();$lion = new Lion();$dolphin = new Dolphin();$speak = new Speak();$monkey-&gt;accept($speak); // Ooh oo aa aa! $lion-&gt;accept($speak); // Roaaar!$dolphin-&gt;accept($speak); // Tuut tutt tuutt! 当需要为动物添加新动作时，我们本可以通过动物支持继承来实现，但是需要修改动物类。但现在就不必修改动物类了。例如，假设需要向动物添加跳跃行为，我们可以通过创建一个新的访问者来简单地添加此行为，即： 1234567891011121314151617class Jump implements AnimalOperation&#123; public function visitMonkey(Monkey $monkey) &#123; echo 'Jumped 20 feet high! on to the tree!'; &#125; public function visitLion(Lion $lion) &#123; echo 'Jumped 7 feet! Back on the ground!'; &#125; public function visitDolphin(Dolphin $dolphin) &#123; echo 'Walked on water a little and disappeared'; &#125;&#125; 这样使用 12345678910$jump = new Jump();$monkey-&gt;accept($speak); // Ooh oo aa aa!$monkey-&gt;accept($jump); // Jumped 20 feet high! on to the tree!$lion-&gt;accept($speak); // Roaaar!$lion-&gt;accept($jump); // Jumped 7 feet! Back on the ground!$dolphin-&gt;accept($speak); // Tuut tutt tuutt!$dolphin-&gt;accept($jump); // Walked on water a little and disappeared 策略模式现实生活示例考虑排序的例子，我们实现了冒泡排序，但数据开始增长，冒泡排序开始变得非常慢。为了解决这个问题，我们实现了快速排序。尽管快速排序算法对于大型数据集来说效果很好，但对于较小的数据集却非常慢。为了解决这个问题，我们实施了一个策略，小数据集使用冒泡排序，大数据集使用快速排序。 概述策略模式允许你基于场景转换算法或策略。 维基百科在计算机编程中，策略模式是一种行为设计模式，可以在运行时选择算法的行为。 编程示例 以上述排序为例，首先给出策略接口及不同的策略实现 1234567891011121314151617181920212223242526interface SortStrategy&#123; public function sort(array $dataset): array;&#125;class BubbleSortStrategy implements SortStrategy&#123; public function sort(array $dataset): array &#123; echo \"Sorting using bubble sort\"; // Do sorting return $dataset; &#125;&#125;class QuickSortStrategy implements SortStrategy&#123; public function sort(array $dataset): array &#123; echo \"Sorting using quick sort\"; // Do sorting return $dataset; &#125;&#125; 客户端可以使用任意策略 1234567891011121314class Sorter&#123; protected $sorter; public function __construct(SortStrategy $sorter) &#123; $this-&gt;sorter = $sorter; &#125; public function sort(array $dataset): array &#123; return $this-&gt;sorter-&gt;sort($dataset); &#125;&#125; 用法 1234567$dataset = [1, 5, 4, 3, 2, 8];$sorter = new Sorter(new BubbleSortStrategy());$sorter-&gt;sort($dataset); // Output : Sorting using bubble sort$sorter = new Sorter(new QuickSortStrategy());$sorter-&gt;sort($dataset); // Output : Sorting using quick sort 状态模式现实生活示例想象一下，你正在使用一些绘图应用程序，你可以选择笔刷来绘画，刷子根据所选颜色改变其行为，即如果选择红色，它将绘制为红色，如果选择蓝色，那么它将绘制蓝色等。 概述当状态改变时，类的行为也发生改变。 维基百科状态模式是以面向对象的方式实现状态机的行为设计模式。对于状态模式，通过将每个单独状态实现为派生类的状态模式接口, 来实现一个状态机，并通过调用模式超类的方法来实现状态转换。状态模式可以被解释为一种策略模式，它能够通过调用模式接口定义的方法来切换当前策略。 程序示例 以文本编辑器为例，编辑器可以改变文本的状态如选中粗体，就会以粗体输入文本，选中斜体便以斜体输入。 首先是状态接口和一些状态实现 12345678910111213141516171819202122232425262728interface WritingState&#123; public function write(string $words);&#125;class UpperCase implements WritingState&#123; public function write(string $words) &#123; echo strtoupper($words); &#125;&#125;class LowerCase implements WritingState&#123; public function write(string $words) &#123; echo strtolower($words); &#125;&#125;class Default implements WritingState&#123; public function write(string $words) &#123; echo $words; &#125;&#125; 然后是文本编辑器 12345678910111213141516171819class TextEditor&#123; protected $state; public function __construct(WritingState $state) &#123; $this-&gt;state = $state; &#125; public function setState(WritingState $state) &#123; $this-&gt;state = $state; &#125; public function type(string $words) &#123; $this-&gt;state-&gt;write($words); &#125;&#125; 用法 1234567891011121314151617181920$editor = new TextEditor(new Default());$editor-&gt;type('First line');$editor-&gt;setState(new UpperCase());$editor-&gt;type('Second line');$editor-&gt;type('Third line');$editor-&gt;setState(new LowerCase());$editor-&gt;type('Fourth line');$editor-&gt;type('Fifth line');// Output:// First line// SECOND LINE// THIRD LINE// fourth line// fifth line 模板方法模式现实生活示例假设我们要造一座房子，建造的大体步骤如下： 打地基 垒墙 封顶 铺地板 这些步骤的顺序不能被打乱，比如说，你不能在垒墙之前先封顶。但是其中的每一步可以定制，比如墙的材料可以使用木头、聚酯纤维或者石头。 概述模板方法模式定义了如何执行某种算法的框架，但是将这些步骤的实现推迟到子类中。 维基百科在软件工程中，模板方法模式是一种行为设计模式，用于定义操作中算法的程序框架，将一些步骤推迟到子类实现。它允许在不改变算法结构的情况下重新定义算法的某些步骤。 程序示例 假如我们有一个构建工具，可以帮助我们测试，构建并生成构建报告（即代码覆盖报告，linting报告等），并将应用程序部署到测试服务器上。 首先是用于确定构建算法框架的基类 1234567891011121314151617abstract class Builder&#123; // Template method final public function build() &#123; $this-&gt;test(); $this-&gt;lint(); $this-&gt;assemble(); $this-&gt;deploy(); &#125; abstract public function test(); abstract public function lint(); abstract public function assemble(); abstract public function deploy();&#125; 然后提供一些基类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445class AndroidBuilder extends Builder&#123; public function test() &#123; echo 'Running android tests'; &#125; public function lint() &#123; echo 'Linting the android code'; &#125; public function assemble() &#123; echo 'Assembling the android build'; &#125; public function deploy() &#123; echo 'Deploying android build to server'; &#125;&#125;class IosBuilder extends Builder&#123; public function test() &#123; echo 'Running ios tests'; &#125; public function lint() &#123; echo 'Linting the ios code'; &#125; public function assemble() &#123; echo 'Assembling the ios build'; &#125; public function deploy() &#123; echo 'Deploying ios build to server'; &#125;&#125; 用法 1234567891011121314151617$androidBuilder = new AndroidBuilder();$androidBuilder-&gt;build();// Output:// Running android tests// Linting the android code// Assembling the android build// Deploying android build to server$iosBuilder = new IosBuilder();$iosBuilder-&gt;build();// Output:// Running ios tests// Linting the ios code// Assembling the ios build// Deploying ios build to server","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"利用规约设计模式（Specification）开发整洁的规格校验（PHP 语言描述）","slug":"2017-06-01 理解Specification设计模式","date":"2017-05-31T16:00:00.000Z","updated":"2018-06-20T05:03:26.184Z","comments":true,"path":"2017/06/01/cjlz9pr3d0033abrd8mtpwk57/","link":"","permalink":"http://www.maksim.website/2017/06/01/cjlz9pr3d0033abrd8mtpwk57/","excerpt":"","text":"规格校验是使我们在日常的开发过程中中比较常见的一种业务需求，最直观的使用是我们在开发电商类网站时我们会对商品的一些规格进行限定，例如重量大小不能超过 N（kg） 。 如果是一个刚刚加入业界的程序员，很有可能会编写出大量的if语句来进行解决此类的业务逻辑，这样编码可行吗？ 答案是可以，因为顺利的完成了业务逻辑代码的编写任务，但是却违反了类设计中的开闭原则，而且一看就是没有经过正规的训练，没有对于 OOP 编程有更深的了解。 那么有没有一种设计模式可以让我们设计出优雅而又整洁的逻辑代码呢，答案是显而易见的，要不然也就不会出现这篇文章，它就是——规模设计模式。 我们可以利用规约模式来解决这一实际问题，开发出优雅而又健全的业务逻辑代码。 规约设计模式的主要设计目的就是为了生成业务规则的明确规范，通过isSatisfiedBy方法来检测对象是否符合规范。 下图是规约模式 UML 类图（不懂的同学推荐去看由谭云杰所编写的《大象：Thinking in UML》） 即使看不懂 UML 类图也没有关系，编码能力的提高是要根据不断的实践才能有所增长的。当你顺着我的思路打完代码，你就已经可以明白规约设计模式的设计理念以及作用。 当然我还是要解释一下这个类图所代表的含义。 既然是规格校验，那么一个规格校验到底包括什么呢？ 一般而言主要有：区间、大于、小于、不等于，这几样，那么我们是不是可以将其抽象成一个类呢？ 这就是上面那张 UML 的简单含义，其中主要是用于描述其类的关系，UML 就是帮助我们对类进行抽象的一个工具。 下面让我们撸起袖子打代码。首先我们应该新建了 Goods类用于表示被规约的产品，其中包含一个 Price 价格属性，然后在建立对 Price 属性的规约，用来检验最新实例化的 Goods 是否满足约定。 123456789101112131415161718192021&lt;?php//商品类namespace DesignPatterns\\Behavioral\\Specification;class Goods&#123; /** * @var float */ private $price; public function __construct(float $price) &#123; $this-&gt;price = $price; &#125; public function getPrice(): float &#123; return $this-&gt;price; &#125;&#125; 在建立规约之前，我们需要建立一个接口，这个接口中定了了一个方法isSatisfiedBy,也就是上文提到的那个检测对象是否满足规约条件的那个方法。 12345678&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;interface SpecificationInterface&#123; public function isSatisfiedBy(Goods $goods): bool;&#125; Ok，在我们编写其余代码之前，我们需要来做一个思考，在程序语言当中，判断条件中的操作符是不是有或、与、非这三个判断条件，对应着 ||、&amp;&amp;、！。 那么我们是否可以将其抽象成一个又一个的类呢？ OrSpecification规约用来表示 Or 的关系，与我们的逻辑判断一样，表示在两个规约之间只要满足一条便返回 true。 123456789101112131415161718192021222324252627282930namespace DesignPatterns\\Behavioral\\Specification;class OrSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface[] */ private $specifications; /** * @param SpecificationInterface[] ...$specifications */ public function __construct(SpecificationInterface ...$specifications) &#123; $this-&gt;specifications = $specifications; &#125; /** * if at least one specification is true, return true, else return false */ public function isSatisfiedBy(Item $item): bool &#123; foreach ($this-&gt;specifications as $specification) &#123; if ($specification-&gt;isSatisfiedBy($item)) &#123; return true; &#125; &#125; return false; &#125;&#125; AndSpecification 用于表示 And 关系，两条以上规约时，必须都满足条件才会返回 true否则返回false. 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class AndSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface[] */ private $specifications; /** * @param SpecificationInterface[] ...$specifications */ public function __construct(SpecificationInterface ...$specifications) &#123; $this-&gt;specifications = $specifications; &#125; /** * if at least one specification is false, return false, else return true. */ public function isSatisfiedBy(Item $item): bool &#123; foreach ($this-&gt;specifications as $specification) &#123; if (!$specification-&gt;isSatisfiedBy($item)) &#123; return false; &#125; &#125; return true; &#125;&#125; NotSpecification.php 用于表示Not。 123456789101112131415161718192021&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class NotSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface */ private $specification; public function __construct(SpecificationInterface $specification) &#123; $this-&gt;specification = $specification; &#125; public function isSatisfiedBy(Item $item): bool &#123; return !$this-&gt;specification-&gt;isSatisfiedBy($item); &#125;&#125; 逻辑判断抽编码好了之后，我们就要开始真正的规约了，我们建立一个 Price 规约，其中主要设定了 Price 的范围，构造函数中包含最大值与最小值，并且实现isSatisfiedBy用来判断输入的值是否符合范围。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class PriceSpecification implements SpecificationInterface&#123; /** * @var float|null */ private $maxPrice; /** * @var float|null */ private $minPrice; /** * @param float $minPrice * @param float $maxPrice */ public function __construct($minPrice, $maxPrice) &#123; $this-&gt;minPrice = $minPrice; $this-&gt;maxPrice = $maxPrice; &#125; public function isSatisfiedBy(Item $item): bool &#123; if ($this-&gt;maxPrice !== null &amp;&amp; $item-&gt;getPrice() &gt; $this-&gt;maxPrice) &#123; return false; &#125; if ($this-&gt;minPrice !== null &amp;&amp; $item-&gt;getPrice() &lt; $this-&gt;minPrice) &#123; return false; &#125; return true; &#125;&#125; 下面我们进行单元测试，如果不懂单元测试的朋友，也可以直接使用上面的代码进行测试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification\\Tests;use DesignPatterns\\Behavioral\\Specification\\Item;use DesignPatterns\\Behavioral\\Specification\\NotSpecification;use DesignPatterns\\Behavioral\\Specification\\OrSpecification;use DesignPatterns\\Behavioral\\Specification\\AndSpecification;use DesignPatterns\\Behavioral\\Specification\\PriceSpecification;use PHPUnit\\Framework\\TestCase;class SpecificationTest extends TestCase&#123; public function testCanOr() &#123; $spec1 = new PriceSpecification(50, 99); $spec2 = new PriceSpecification(101, 200); $orSpec = new OrSpecification($spec1, $spec2); $this-&gt;assertFalse($orSpec-&gt;isSatisfiedBy(new Item(100))); $this-&gt;assertTrue($orSpec-&gt;isSatisfiedBy(new Item(51))); $this-&gt;assertTrue($orSpec-&gt;isSatisfiedBy(new Item(150))); &#125; public function testCanAnd() &#123; $spec1 = new PriceSpecification(50, 100); $spec2 = new PriceSpecification(80, 200); $andSpec = new AndSpecification($spec1, $spec2); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(150))); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(1))); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(51))); $this-&gt;assertTrue($andSpec-&gt;isSatisfiedBy(new Item(100))); &#125; public function testCanNot() &#123; $spec1 = new PriceSpecification(50, 100); $notSpec = new NotSpecification($spec1); $this-&gt;assertTrue($notSpec-&gt;isSatisfiedBy(new Item(150))); $this-&gt;assertFalse($notSpec-&gt;isSatisfiedBy(new Item(50))); &#125;&#125; 这样一来，我们就设计出了优雅而又健壮的代码。 说明： 本文章代码，来自于 Github 开源项目，点击链接进入查看http://designpatternsphp.readthedocs.io/","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maksim.website/tags/设计模式/"}]},{"title":"在MYSQL中进行日期操作","slug":"2017-04-08 MySQL日期","date":"2017-04-07T16:00:00.000Z","updated":"2018-06-25T12:34:46.093Z","comments":true,"path":"2017/04/08/1/","link":"","permalink":"http://www.maksim.website/2017/04/08/1/","excerpt":"","text":"平时比较常用的时间、字符串、时间戳之间的互相转换，虽然常用但是几乎每次使用时候都喜欢去搜索一下用法；本文将作为一个笔记，整理一下三者之间的 转换（即：date转字符串、date转时间戳、字符串转date、字符串转时间戳、时间戳转date，时间戳转字符串）用法，方便日后查看； 涉及的函数date_format(date, format) 函数MySQL日期格式化函数date_format() str_to_date(str, format) 函数 把字符串转换为日期 from_unixtime(unix_timestamp, format) 函数，MySQL时间戳格式化函数from_unixtime 时间转换时间转字符串1select date_format(now(), '%Y-%m-%d'); #结果：2016-01-05 时间转时间戳1select unix_timestamp(now()); #结果：1452001082 字符串转时间1select str_to_date('2016-01-02', '%Y-%m-%d %H'); #结果：2016-01-02 00:00:00 字符串转时间戳1select unix_timestamp('2016-01-02'); #结果：1451664000 时间戳转时间1select from_unixtime(1451997924); #结果：2016-01-05 20:45:24 时间戳转字符串1select from_unixtime(1451997924,'%Y-%d'); #结果：2016-01-05 20:45:24 附表MySQL日期格式化（format）取值范围。 值 含义 秒 %S、%s 两位数字形式的秒（ 00,01, …, 59） 分 %I、%i 两位数字形式的分（ 00,01, …, 59） 小时 %H 24小时制，两位数形式小时（00,01, …,23） %h 12小时制，两位数形式小时（00,01, …,12） %k 24小时制，数形式小时（0,1, …,23） %l 12小时制，数形式小时（0,1, …,12） %T 24小时制，时间形式（HH:mm:ss） %r 12小时制，时间形式（hh:mm:ss AM 或 PM） %p AM上午或PM下午 周 %W 一周中每一天的名称（Sunday,Monday, …,Saturday） %a 一周中每一天名称的缩写（Sun,Mon, …,Sat） %w 以数字形式标识周（0=Sunday,1=Monday, …,6=Saturday） %U 数字表示周数，星期天为周中第一天 %u 数字表示周数，星期一为周中第一天 天 %d 两位数字表示月中天数（01,02, …,31） %e 数字表示月中天数（1,2, …,31） %D 英文后缀表示月中天数（1st,2nd,3rd …） %j 以三位数字表示年中天数（001,002, …,366） 月 %M 英文月名（January,February, …,December） %b 英文缩写月名（Jan,Feb, …,Dec） %m 两位数字表示月份（01,02, …,12） %c 数字表示月份（1,2, …,12） 年 %Y 四位数字表示的年份（2015,2016…） %y 两位数字表示的年份（15,16…） 文字输出 %文字 直接输出文字内容","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[]},{"title":"PHP Closures","slug":"2017-03-15 PHP 的闭包","date":"2017-03-15T14:15:16.000Z","updated":"2018-06-20T05:02:56.751Z","comments":true,"path":"2017/03/15/cjlz9pr38002xabrdfv0hk1tb/","link":"","permalink":"http://www.maksim.website/2017/03/15/cjlz9pr38002xabrdfv0hk1tb/","excerpt":"","text":"闭包函数（closures）也就做匿名函数（Anonymous functions），是指在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。 理论上，闭包和匿名函数是不同的概念，不过 PHP 将其视作相同的概念，所以闭包与匿名函数相等。 匿名函数其实就是没有名字的函数。匿名函数可以赋值给变量，还能像其他任何 PHP 对象那样传递。不过匿名函数仍然是函数，因此可以调用，还可以传入参数。匿名函数特别适合作为函数或方法的回调。 创建闭包12345$closure = function ($name) &#123; return sprintf('Hello %s', $name);&#125;;echo $closure('Maksim');//输出 Hello Maksim 创建一个闭包对象，然后将其复制给$closure 变量。闭包和普通的 PHP 函数很想：使用语句相同，也接受参数，而且能返回值。不过，匿名函数没有名称。 我们通常把 PHP 闭包当做函数和方法的回调使用。很多 PHP 函数都会用到回调函数，例如 array_map()和 preg_replace_callback()。这是使用 PHP 匿名函数的最佳时机！ 记住，闭包和其他值一样，可以作为参数传入其他 PHP 函数，我们把一个闭包对象当做回调参数，传给 array_map()函数。 12345$numbersPlusOne = array_map(function ($number)&#123; return $number + 1;&#125;,[1,2,3]);print_r($numbersPlusOne);//([0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4) 在闭包出现之前，PHP 开发者只能单独创建普通函数，然后使用名称引用那个函数，这么做，代码执行的稍微慢一点，而且把回调场景和使用场景分割开了，如下： 123456$numbersPlusOne = array_map('incrementNumber',[1,2,3]);function incrementNumber($number)&#123; return $number + 1;&#125;print_r($numbersPlusOne);//([0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4) 这样的代码虽然可用，但是没有使用闭包来的间接。如果只需要使用一次回调，没有必要单独定义具名函数。把闭包当做回调使用，写出的代码更加简洁、清晰。 使用附加状态前面演示了如何把匿名函数当做回调使用，下面探讨如何为 PHP 闭包附加兵封装状态。JavaScript 开发者可能对 PHP 的闭包感到奇怪，因为 PHP 闭包不会像真正的 JavaScript 闭包那样自动封装应用状态。在 PHP 中，必须手动调用闭包对象的 bindTo()方法或者使用 use 关键字，把状态附加到 PHP 闭包上。 使用 use 关键字附加闭包状态常见得多，因此我们先看这种方式。使用 use 关键字把变量附加到闭包上时，附加的变量会记住附加时赋给它的值。 123456789101112function enclosePerson($name) &#123; return function ($doCommand) use ($name) &#123; return sprintf('%s, %s', $name, $doCommand); &#125;;&#125;//把字符串“Maksim”封装在闭包中$clay = enclosePerson('Clay');//掺入参数，调用闭包echo $clay('get sweet tea');// Clay, get sweet tea 使用 use 关键字可以把多个参数传入闭包，此时要像 PHP 函数或者方法的参数一样，使用逗号分割多个参数 PHP 闭包是对象。与其他 PHP 对象类似，每个闭包实例都可以使用$this 关键字获取闭包的内部状态。闭包对象的默认状态没什么用，不过有一个__invoke()魔术方法和 bindTo()方法，仅此而已。 但是，bindTo()方法为闭包增加了一些有趣的潜力。我们可以把使用这个方法把 Closure 对象的内部状态绑定到其他对象上。bindTo()方法的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的 PHP 类。因此闭包可以访问绑定闭包的对象中受保护和私有的成员变量。 你会发现，PHP 框架经常使用 bindTo()方法把路由 URL 映射到匿名回调函数上。框架会把匿名函数绑定到应用对象上，这么做可以把这个匿名函数中使用$this 关键字引用重要的应用对象。 12345678910111213141516171819202122232425&lt;?phpclass App&#123; protected $routes = array(); protected $responseStatus = '200 Ok'; protected $responseContentType = 'text/html'; protected $responseBody = 'Hello world'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this,__CLASS__); &#125; public function dispatch($currentPath) &#123; foreach ($this-&gt;routes as $routePath =&gt; $callback) &#123; if ($currentPath === $currentPath) &#123; $callback(); &#125; &#125; header('HTTP/1.1 '. $this-&gt;responseStatus); header('Content-type: ' . $this-&gt;responseContentType); header('Content-length: ' . mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; &#125;&#125; 我们要特别注意 addRoute（）方法。这个方法的参数分别是一个路由路径（例如/users/josh）和一个路由回调。dispatch()方法的参数是当前 HTTP 请求的路径，它调用匹配的路由回调。第10行是重点所在，我们把路由回调绑定到了当前 APP 实例上。这么做能够在回调函数中处理 APP 实例的状态。 1234567$app = new App();$app-&gt;addRoute('/users/josh', function ()&#123; $this-&gt;responseContentType = 'application/json;charset=utf8'; $this-&gt;responseBody = '&#123;\"name\":\"json\"&#125;';&#125;);$app-&gt;dispatch('/users/josh'); 参考 现代 PHP 官方手册","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"Closures","slug":"Closures","permalink":"http://www.maksim.website/tags/Closures/"}]},{"title":"MYSQL DBA 学习笔记（03）：解密 MySQL databock and Binlog 的格式","slug":"2017-01-24 MYSQL DBA 学习笔记（03）：解密 MySQL databock and Binlog 的格式","date":"2017-01-23T16:00:00.000Z","updated":"2018-08-04T12:32:25.119Z","comments":true,"path":"2017/01/24/1/","link":"","permalink":"http://www.maksim.website/2017/01/24/1/","excerpt":"","text":"本文内容 InnoDB 物理存储结构 innoDB 逻辑存储结构 InnoDB 文件结构 InnoDB Page结构 InnoDB 航记录结构 InnoDB 数据块解析 Binlog 日志生成的流程 Biglog 日志解析 InnoDB 的物理存储结构 当我们创建一张表的时候. 1234567CREATE TABLE `gyj_t5` ( `id` int(11) NOT NULL DEFAULT &apos;0&apos;, `name` varchar(10) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_name` (`name`)) ENGINE = InnoDB DEFAULT CHARSET=utf8 然后在其中插入四条记录。 id name age 1 Tom 10 2 Joe 20 3 Alis 30 4 Rose 40 那么他在物理上的存储结构就应该是如上图左边看到B+树结构，InnoDB 天生就是一个 BTree 索引表，即索引存放在一起，数据就是索引，索引就是数据，相当于 Oracle 的索引组织表，最上面的节点是根，第二层是枝叶，第三层是叶子，叶子上存储着数据和PVK（主键），RowData（数据）、XID（事务的 ID），Roll_Ptx（回滚的指针）。 现在，我们通过二级索引，也就是普通索引name，去查询数据 1234567mysql&gt; explain select * from gyj_t5 where name = &apos;Joe&apos;;+----+-------------+--------+------+---------------+----------+---------+-------+------+-----------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+---------------+----------+---------+-------+------+-----------------------+| 1 | SIMPLE | gyj_t5 | ref | idx_name | idx_name | 33 | const | 1 | Using index condition |+----+-------------+--------+------+---------------+----------+---------+-------+------+-----------------------+1 row in set (0.01 sec) 通过二级索引，也就是 name，上图的右边，找到 name 之后，普通索引的值对应的 PKV主键值，如果要把年龄找出来的话，会找到 ID=2，然后通过2主键索引把RowData的其他字段找出来。 所以说，二级索引最终是要指向到主键索引上的。 我们的这张表由两个索引组成，但是实际上，主键第一个索引就是表，如果没有主键就会去寻找不为空的唯一键，如果没有唯一键，系统会生成一个6字节的rowid的主键，但是对用户是不可见的。 Innodb 的逻辑存储结构 InnoDB 的逻辑存储结构又大到小分别是Tablespace（表空间）、Segment（段落），区，页、行。 在 MySQL InnoDB 实际上一个表就对应一个表空间，他有一个 space id来标识这个表空间， 我们有一个参数可以设置这个表空间是独立的表空间，还是共享的表空间。 如果是独立的表空间，那就是一个表一个表空间，会用 space id 来区分。 1234567mysql&gt; show variables like &apos;%per_table%&apos;;+-----------------------+-------+| Variable_name | Value |+-----------------------+-------+| innodb_file_per_table | ON |+-----------------------+-------+1 row in set (0.00 sec) 如果设置成 ON 就说明设置成为独立表空间了，如果不为 ON 则所有的数据都放到了 ibdata 里面，所有的其实放在共享表空间和独立表空间中性能是一样的，不过在进行管理和迁移数据的时候比较方便，放到一起的话一个文件管理起来比较麻烦 。 现在我们来创建一张表 1create table gyj_t1 (id int, name varchar(10)); 进入到数据库目录我们可以看到： 1234567[root@MyDB1 test]# ll -lh总用量 236K-rw-r--r-- 1 mysql mysql 65 11月 28 2016 db.opt-rw-rw---- 1 mysql mysql 8.4K 7月 20 19:01 gyj_t1.frm-rw-rw---- 1 mysql mysql 96K 7月 20 19:01 gyj_t1.ibd-rw-rw---- 1 mysql mysql 8.5K 7月 20 18:46 gyj_t5.frm-rw-rw---- 1 mysql mysql 112K 7月 20 18:47 gyj_t5.ibd frm 中存储着表的定义，ibd 存放着索引和数据，我们上面说了 ibdata 对应着表空间，我们可以使用如下命令查看。 1234567891011121314151617mysql&gt; select * from information_schema.INNODB_SYS_TABLES;+----------+----------------------------+------+--------+-------+-------------+------------+---------------+| TABLE_ID | NAME | FLAG | N_COLS | SPACE | FILE_FORMAT | ROW_FORMAT | ZIP_PAGE_SIZE |+----------+----------------------------+------+--------+-------+-------------+------------+---------------+| 14 | SYS_DATAFILES | 0 | 5 | 0 | Antelope | Redundant | 0 || 11 | SYS_FOREIGN | 0 | 7 | 0 | Antelope | Redundant | 0 || 12 | SYS_FOREIGN_COLS | 0 | 7 | 0 | Antelope | Redundant | 0 || 13 | SYS_TABLESPACES | 0 | 6 | 0 | Antelope | Redundant | 0 || 16 | mysql/innodb_index_stats | 1 | 11 | 2 | Antelope | Compact | 0 || 15 | mysql/innodb_table_stats | 1 | 9 | 1 | Antelope | Compact | 0 || 18 | mysql/slave_master_info | 1 | 26 | 4 | Antelope | Compact | 0 || 17 | mysql/slave_relay_log_info | 1 | 11 | 3 | Antelope | Compact | 0 || 19 | mysql/slave_worker_info | 1 | 15 | 5 | Antelope | Compact | 0 || 21 | test/gyj_t1 | 1 | 5 | 7 | Antelope | Compact | 0 || 20 | test/gyj_t5 | 1 | 6 | 6 | Antelope | Compact | 0 |+----------+----------------------------+------+--------+-------+-------------+------------+---------------+11 rows in set (0.02 sec) 我们可以看到我们刚刚创建的那个表 gyj_t1 的表空间 id 是7,我们可以看到每一张表都有对应的变空间 id，而0则代表是系统表空间。 Tablespace 中可以存放很多的segment（段） 因为 InnoDB 是 B 树索引其中段又被分为叶子段和非叶子段，除了这些表空间还可以存放回滚段，也就是事务段。 Segment，其实就是我们的表，Segment 和 Table 的区别是，Segment 是物理上存放数据的，而表是逻辑上的一个定义。 段的管理是由InnoDB 存储引擎来完成的，在段下面由多个Extent（区）组成的，区实际上是分配空间的最小单位，比如说向数据库中插入一条记录，这个空间不够了并不是给他分配一个 Page，而是分配一个Extent，Extent 的分配标准是1MB，Extent 是由 Page 组成的，可以理解成 Block(块)，在内存里面叫做 Page，在磁盘里面叫做 Block。 刚才说分配最小单位是一个 Extent 单位是 1MB，而 Page 标准的话是 16K，也就是说一个 Extent 是由 连续的64个 Page 组成的。 Page 是最小的 IO 单位，比如说要读一行数据从硬盘读到内存，是以 Page 为单位读到内存。 在上一篇笔记里面也提到过，Page 有好多种，数据页，Undo 页等等。 Page 下面就是 Row（行），Row 就放在索引结构的叶子上面，里面包括了事务 id 、回滚指针，数据组成 InnoDB 的文件结构","categories":[{"name":"MySQL DBA","slug":"MySQL-DBA","permalink":"http://www.maksim.website/categories/MySQL-DBA/"}],"tags":[]},{"title":"MySQL DBA 学习笔记（02）：MySQL 体系结构","slug":"2017-01-19 MYSQL DBA 学习笔记（02）：MySQL 体系结构","date":"2017-01-18T16:00:00.000Z","updated":"2018-07-31T14:27:41.615Z","comments":true,"path":"2017/01/19/cjlz9pr34002uabrdzj572k7m/","link":"","permalink":"http://www.maksim.website/2017/01/19/cjlz9pr34002uabrdzj572k7m/","excerpt":"","text":"MySQL 是单进程、多线程的架构，Oracle 多进程架构，Oracle 除了 Windows 也是单进程的，这两种架构哪种更好，单进程，多线程上下文切换的代价会比比较小，所以对 CPU 的消耗会比较小一些，多进程的话并发性会好一些，两种对比的话，可能单线程多进程会比多进程要好一点，不过还要看使用场景，如果对并发性要求较高的话性能会更好一些。 MySQL 里面可以用 ps -ef | grep 3306查看进程。 在 MySQL 架构里面有个非常有特色的地方，它的存储引擎是可插拔的，如果没有学过 MySQL 的人可能会对存储引擎的概念不是很清楚，在 MySQL 中存储引擎是用来处理数据库相关的 CRUD 的操作，每个数据库都有存储引擎，学过 Oracle 的同学可能会知道堆表，簇表，索引组织表，实际上这些都是存储引擎，在 Oracle 中这些存储引擎都是它自己的，所以没有去强调。 MySQL 里面存储引擎有很多，是可插拔式的，存储引擎和文件系统有些相似，就像是 Linux 中的 ext2/3，Windows 中的 NTFS，FAT32。 存储引擎的对象就是表，每一个引擎就像是插头一样的东西，其实我们可以自己开发存储引擎，像是 Facebook 这样的第三方就可以开发自己的存储引擎，满足自己的需求。 但是因为灵活和存储引擎比较多，就会存在兼容性的问题。 对于数据库产品的架构，一般可以分为应用层、逻辑层、物理层，对于MySQL，同样可以理解为如下3个层次。 其中Connectors可以理解为各种客户端、 应用服务； Connection Pool可以理解为应用层，负责和客户端、用户进行交互，需要和不同的客户端（PHP,Java,C API,.Net以及ODBC,JDBC等等）和中间服务器进行交互，这一层主要完成的是链接处理，授权认证，和安全等一些功能，连接到MySQL的客户端在其进程中，都会有一个独立的线程，连接的查询只会在这个登录线程中进行查询。 Management Services&amp;Utilities、SQL Interface、 Parser、 Optimizer、 Caches&amp;Buffers、 Pluggable Storage Engines可以理解为数据库的大脑——逻辑层。 负责具体的查询处理、事务处理、存储管理、恢复管理，以及其他附加功能。查询处理器负责查询的解析、执行。当接收到客户端的查询时，数据库会分配一个县城来处理它。先友查询处理器（优化器）生成执行计划，然后交由计划执行器来执行，执行器有时需要访问更底层的事务管理器、存储管理器来操作数据，事务管理器、存储管理器主要负责事务控制、并发控制、存储管理。在其中，将由事务管理来保证“ACID”特性，通过锁管理器来控制并发，由日志管理器来确保数据持久化，存储故那里器一般还包括一个缓冲管理器，有它来确定磁盘和缓存之间的数据传输。 根据上面的架构图，我们可以看到在逻辑层中Pluggable Storage Engines 这是MySQL服务逻辑架构中的第三层，是MySQL的存储引擎，MySQL提供出了存储引擎接口，第三方可以根据自己的业务逻辑需求开发自己的存储引擎，Innodb起初就是由Innobase Oy公司所开发，2006年5月被甲骨文公司并购。 服务器通过API与存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作，但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层和服务的请求。 注意：存储引擎是针对于表的而不是针对于库的，不同的表可以使用不同的引擎； 最下方的Files&amp;Logs可以理解为物理层，实际物理磁盘（存储）上的数据库文件，比如数据文件、日志文件等等。 MySQL 数据库与实例的关系对于没有学习过 Mysql 和 Oracle 的人可能并不清楚什么是数据库，什么是实例。 在MySQL 中一个数据库可以对应几个实例，比如说3306这个实例它对应的数据库是一对多，还是一对一的！ 一个实例对应的是一个数据库，比如说3306对应的就是一个数据库，3307对应的是一个数据库。 Oracle 的数据库对于实例的关系是可以对应多个实例。比如Oracle RAC 集群可以一对多，数据库指的的磁盘上的文件，内存上的进程我们叫做实例。 数据库其实就是磁盘上的文件或者其他形式文件类型的结合，实例是数据库后台进程/线程以及一个共享内存区组成的，共享内存可以被运行的后台进程/线程共享。 数据库在 MySQL 里面与实例关系是1：1，数据库实例才是真正用来操作数据库文件的。 如果在一台物理机上建立两个实例的话，对应的是两个数据库，多实例比如说我又两个实例3306和3307要对应的建立一个目录，3307不能使用3307的目录，这样的话3306和3307有各自的文件。 MySQL 5.6 InnoDB 架构 在红线框起来的叫实例，红线框起来的叫数据库。 内存和线程实例是由内存和进程组成的，下图就是共享内存，相当于 Oracle 的 SGA： 围绕在共享内存边上的就是后台线程。 index page（索引页） 就类似于 Oracle 中的 buffer，在磁盘里面我们叫block(块)，在 MySQL 里面叫做 page (页)，Index page 索引页这里就是放数据的，MySQL 的数据都放在 index page 里面，因为 MySQL 的存储结构是 B-Tree 结构， 数据索引都是这里面。 data dictionary（数据字典） 是放在 MySQL的 ibdata 里面，这是数据的缓存，我们需要 DDL 操作，如果我要创建表，修改表，删除表，会把数据字典里面的信息，先读到内存里面，也就是数据字典中，然后在里面。 lock info（锁信息），行锁的信息是放在 lock info 里面的，如果做DML操作需要获取所要到里面拿。需要注意的是对一个大的事务，UPDATE 了一千万行记录，就要分配一千万个行锁，每一个行锁都要有大小的，lock info就会比较大，所以在 MySQL 中有一个优化，当行锁达到一定级别的时候，就会升级为表级锁，如果不升级的话开销就很大了。 undo page和 index page 的机制是一样的，当我们每一次做 DML 操作时候， 我们要把一些前置项缓存到 undo page 当中, undo page 的信息也是放在 ibdata 当中的。 Insert buffer page中是缓存二级索引的，二级索引就是非唯一的索引就是二级索引或者是辅助索引，二级索引是非唯一的，比如说我建立一个表： 123456create table t1 ( id int, vid int, primary key(id), key idx_vid(vid)); id 是主键，vid 是一个普通索引，那我向表中插入数据的时候。 12insert into t1 values(1,123456);insert into t1 values(2,654321); 主键索引1，2在 tree 的节点上可能会很近，但是二级索引，123456，654321的节点是随机的，两个节点之间的距离相差很大，效率就比较低了，机械盘读的速度就很慢，为了减少二级索引随机读的问题，就会需要用到 Insert buffer page来缓存我们的二级索引，主要是根据 space_id 和 page_number 进行合并在写入到文件中，这样一来效率就比较高了。 也就是说，要先把我们的123456，654312先放入 insert buffer page当中，然后根据这两条不同的记录，放到不同的page 里面，然后根据 space_id 和 page_number 进行合并然后一次性写入到磁盘当中。 虽然增加了内存开销，但是提高了随机度的效率，用空间来换时间。 adaptive hash index 是用来缓存 Hash 索引，我们有一些热数据需要放到 Hash 索引中，因为 Hash 索引的查询效率是最快的，他可以直接查找到需要使用的数据，他的时间复杂度是 O(1) 。 我们可以通过show variables like &#39;%buffer%&#39;查看 innodb_buffer_pool_size，一般我们可以将其设置成物理内存的60~80%。 Additional Memory Pool这是放一些内存额外的一些东西。 redo log buffer 日志缓冲区，在我们的操作中会产生一些日志，就会放到这个位置,然后通过 redo log thread线程写入到磁盘当中，它也会有条件的触发，比如当服务器收到commit命令线程就会把它写到日志文件，其对应的是ib_logfile。 double write 双写，MySQL 在写数据的时候，首先要到磁盘中把 page 先读到 index page 里面，然后再插入数据，然后再写数据，从硬盘到内存是同步操作，从内存写到磁盘是异步的，我们的一个 page 是16k，操作系统里面 block 的大小可能是4k 也可能是2k，不同的操作系统块的大小是不一样的，扇区的大小是512btye， 如果说我的一个 page，从内存写到文件的时候，写了8k，这个时候突然宕机了没写进去，怎么办？ 当我们修改完数据会产生日志，redo 肯定是写进去了做了保护，但是这个时候 redo 是无法恢复的，因为这个时候page 已经坏了，redo 是修复不了的，因为这个 page 已经不完整了，每个 page 头部都会有一个校验和，尾部也有一个，只有一致的时候，page 才是好的，如果说写坏了，也就破坏了一致性，这个时候这个 block 就是损坏的。 因为 redo 里面没有保留 page 的完全的镜像，他只是保留了这个 page 里面修改的某条记录，当你的page 不完整的时候他是没有办法修复的。 所以在 MySQL 里面就有了 double write，首先要把 index page 先放到 double write 里面，然后 double write 里缓存的数据再写到 doublewrite segment 里面，如果没有问题的话在写到正式文件里面去。 如果 doublewrite segment 写坏了，double Write 里面不是还有吗，如果 doule write 到 doublewrite segment 再写坏了，那就再重新来一遍就好了，虽然增加了开销，但是增强了安全性。 到此，内存中的内容就介绍完了，接下来介绍 inndb 的线程。 我们可以通过 ps 命令找到进程编号 1ps -ef | grep 3306 然后在使用 psstack 查看线程 1pstack 3530 #3530是 mysql 的进程编号 user threads：用户线程 rollback clean thread：回滚线程 recv write thread：恢复线程 redo log thread： 刷日志线程，到遇到提交命令的时候会触发，或者是当达到 redo log buffer 容量二分之一的时候也会进行触发，在 MySQL 中每个一秒也会去刷，在5.6版本中还没有这个线程，patch 还没有打上去，目前还是使用用户线程去做的。 read/write thread：读写线程，写线程就是写 double write 中的赃块，写到文件中去，也是异步写的，可以通过参数进行培植innodb_write_io_threads，read 指的是预读，如果现在读取的是 page1,下一次可能读 page2，那么 inndbo 就会把 page2读进去，如果下次读的是 page2就会直接从内存中调用。 purge thread: 事务被提交后，其所使用的 undolog 可能不再需要，因此需要 Purge Thread 来回收已经使用并分配的 undo page，在 InnoDB 1.1版本之前，purge 操作仅在 InnoDB 引擎的Master Thread 中完成，1.1版本之后，purge 操作可以独立到单独的线程中进行，以此来减轻 Master Tread 的工作，从而提高 CPU 的使用率以及提升存储引擎的性能，用户可以在 MYSQL 数据库的配置文件中天骄如下命令来启用独立的 Purge Thread: 12[mysqld]innodb_purge_threads = 1 page cleaner thread：该线程通过 RLU 算法用来刷赃块，在 RLU 上面有 free page, clean page， drity page，cleaner thread 就是把赃块刷到磁盘当中去。 Master Trehad 该线程是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO 页的回收等。 buf dump thread：这个线程主要是做预热的，当我的数据库关闭的时候，我要把我的热块保存起来。可以通过innodb_buffer_pool_dump_at_shutdown 和 innodb_buffer_pool_now 来进行开启。 此时我们将 mysql 关闭后，他就会把这些数据放到 ib_buffer_pool 里面 1230,2780,279..... 这里保存的是 space_id,page_number。 数据库层在 Innodb 中也有属于自己的 redo，因为 innodb 本身也是一个数据库，就算是没有 mysql server 层，你给他一个 key，他也返回一个 value，所以他需要自己 redo 来记录自己的操作，而 MySQL 中的 binlog 日志，是所有引擎都要通过binlog 来进行封装，所有引擎的操作都要放到 binlog 之中。 user tablespace 就是我们存放数据的表空间，system tablespace 是我们的系统表空间，里面存放了undo 等信息。 MySQL 数据库里的文件在 MySQL 中又数据库配置文件，表结构定义文件，数据文件，慢查询日志，错误文件，通用日志。 数据库配置文件其实就是 MYSQL 的参数文件，我们可以通过–defaults-file 来自己指定 MySQL 启动时候加载的配置文件。 表结构定义文件：就是放在 frm 文件中，我们没有办法直接查看其中的内容，因为这是一个二进制文件，但是我们可以通过 mysql-utilities 工具中的 mysqlfrm 来查。 慢查询日志，错误日志，和通用日志，如果 MySQL 服务器有问题，我们通常是要去看错误日志的， 我们在优化 sql 时候，我们要通过慢查询日志来看，不过默认配置慢查询日志是没有开启的，我们需要使用 show_query_log进行开启，同时我们还需要对慢查询做一个定义，一个 sql 执行多长时间才是慢查询，我们可以通过 long_query_time进行设置，其基本单位是秒，但是我们可以设置到毫秒。 通用日志一般是不会开启的，因为会影响 MySQL 的性能，因为他会把所有的 SQL 操作都记录下来，如果想要研究一下 mysqldump 的一个过程，可以查看日志都进行了什么操作。 MySQL 客户机/服务器模型 TCP/IP 套接字客户端通过 TCP/IP 协议去链接 MySQL 服务器，后面就是具体的服务器。 TCP/IP 套接字方式是 MySQL 数据库在任何平台下都支持的链接方式，也是网络中使用的最多的一种方式。这种方式在 TPC/IP 上建立一个机遇网络的连接请求，一般情况下客户端在一台服务器上，而 MySQL 实例在另外一个服务器上，这两台服务器通过一个 TCP 网络链接。 例如用户可以在 Windows 服务器下请求一个远程 Linux 服务器（前提是开启了远程访问）。 命令管道和共享内存在 Windows 上，如果两个需要进程通信的进程在一台服务器上，那么可以使用命令管道，Microsoft SQL Server 数据库默认安装后的本地连接也是使用命令管道。在 MySQL 数据库中需在配置文件中开启–enable-named-pipe 选项。 在 MySQL4.1之后的版本中，MySQL 还提供了共享内存的链接方式，这是通过在配置文件中添加–shared-memory 实现的。如果想要使用共享内存的方式，在连接时， 必须使用–protocol=memory Uinx 套接字在 LInux 和 Uinx 环境下，还可以使用 Uinx 域套接字。Uinx 套接字其实不是一个玩过协议，所以只能在 MySQL 客户端和数据库实例在一台服务器上的情况下可以使用。用户可以在配置文件中指定套接字文件路径，如–socket=/tmp/mysql.scok。当数据库实例启动后，用户可以通过下列命令进行套接字路径的查找： 1SHOW VARIABLES liek &apos;socket&apos;; 知道了 Uinx 套接字文件路径后，就可以使用该方式进行连接了。 1[root@MyDB1] mysql -udavid -S /tmp/mysql.socks 我们可以通过设置 max_user_connections 来设置 MySQL 的最大连接数，这里不能设置的太大，因为每一个连接都是要消耗资源的，他会占用内存，一个连接会在服务器上最小占用512字节，最大会占用64M，如果连接一直不断，被占用的内存会越来越大，这要根据业务场景来进行配置。 比方说，在业务层有10台 Java JDBC，Java 连接池当中是50个连接，一共有10台，就占用了500个连接，如果是300个连接就是3000个连接这里，所以要根据实际的去设置。 SQL 处理过程 如果把 MySQL 里面开启了查询缓存的话，在执行 SQL 的时候，就会把 SQL 查询的结果集缓存起来，我们可以通过query_chache_type和 query_cache_wlock_invalidate进行开启，不过建议不要开，因为 bug 比较多。因为所有的修改缓存都需要更新，如果你的表结构改了或者数据改了，关联会比较多。 如果没有开启缓存，就回去解析查询，解析查询又被分为了硬解析和软解析，如果当前的 SQL 语句是第一次执行就会执行硬解析，如果语法语意、权限都没有问题的会统计信息，并且对 SQL 进行等价、切片，优化器根据 SQL 语句的一些信息生成一个执行计划在返回给用户。 如果是软解析，已经被执行过，直接找到 SQL 语句的执行计划进行操作。 内存结构服务器以三种不同的类别分配内存： 连接会话有排序、读取、临时表，这些都是私有的，每一个线程都会有，相当于 PGA。 而服务器和存储引擎相当于 Oracle 的SGA。 内存参数连接/会话 binlog_cache_size read_buffer_size read_rnd_buffer_size join_buffer_size sort_buffer_size tmp_table_size thread_cache_szie bulk_insert_buffer_size net_buffer_length thread_stack 服务器/共享 query_cache table_cache table_definition_cache 存储引擎/共享 innodb_buffer_pool_szie innodb_additional_mem_pool_szie innodb_log_buffer_size MySQL 如何使用磁盘空间 MySQL 物理存储结构 MySQL 逻辑存储结构 一个数据库实例可以创建很多数据，在 MySQL 中 Database 和 Schema 是一对一的，在 Database 或者是 Schema 下面可以拥有很多表。","categories":[{"name":"MySQL DBA","slug":"MySQL-DBA","permalink":"http://www.maksim.website/categories/MySQL-DBA/"}],"tags":[]},{"title":"MySQL DBA 学习笔记（01）：安装 MYSQL5.6 for CentOS6.6 源码编译安装","slug":"2017-01-08 MySQL DBA 学习笔记（01）：安装 MYSQL5.6 for CentOS6.6 源码编译安装","date":"2017-01-07T16:00:00.000Z","updated":"2018-07-20T11:26:50.873Z","comments":true,"path":"2017/01/08/cjlz9pr31002rabrdxdm6c06q/","link":"","permalink":"http://www.maksim.website/2017/01/08/cjlz9pr31002rabrdxdm6c06q/","excerpt":"","text":"1）关闭防火请 1[root@MyDB1 ~] service iptables status 如果看到有很多信息，就需要使用 stop 命令关闭防火墙。 1[root@MyDB1 ~] service iptables stop 如果要彻底关闭防火墙的话可以输入： 1[root@MyDB1 ~] chkconfig iptables off Linux chkconfig命令用于检查，设置系统的各种服务。 这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。 这样重启 Linux 后防火墙就会被彻底关闭。 然后还要关闭 selinux 123[root@MyDB1 ~] vim /etc/selinux/configSELINUX=disabled 2）配置 sysctl.conf 1[root@MyDB1 ~] vim /etc/sysctl.conf 在这里可以对系统做一些配置，可以根据实际情况作出调整优化。 3）检查操作系统上是否安装了 MYSQL 1[root@MyDB1 ~] rpm -qa | grep mysql 如果安装 MySQL 需要对 MySQL 进行卸载，如果在安装 Linux 时没有选择最小化安装，可能会自带 MySQL，不过版本很低。 1[root@MyDB1 ~] rpm -e mysql-xxx-xxx-xxx-xxx 或者是直接使用 1[root@MyDB1 ~] yum remove mysql* 4）下载 MySQL 源码包 123[root@MyDB1 ~] mkdir download[root@MyDB1 ~] cd download[root@MyDB1 ~] wget https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.35.tar.gz 5）添加用户和组配、 Mysql 环境变量 123456789groupadd mysql #添加用户组useradd -d /home/mysql-g mysql -m mysql # 新建 mysqlpasswd mysql #给 mysql 用户设置密码su - mysql #进入 mysql 用户，编写环境变量vim .bash_profile PATH=$PATH:$Home/bin:/u01/my3306/bin #将 mysql 的bin 目录放到环境变量中source .bash_profile #使环境变量生效 6）创建目录及授权 12345678mkdir -p /u01/my3306/data #放数据的mkdir -p /u01/my3306/log/iblog mkdir -p /u01/my3306/log/binlogmkdir -p /u01/my3306/runmkdir -p /u01/my3306/tmpchown -R mysql:mysql /u01/my3306chmod -R 755 /u01/my3306 7) 解压 mysql5.6 12cd ~/downloadtar -xzvf mysql-5.6.35.tar.gz 8) 安装 cmake 1yum -y install cmake gcc gcc-c++ bison-devel ncurses-devel bison zlib libxml openssl cmake 是一个跨平台的编译工具，需要2.8以上版本。 9）编译并安装 1cd mysql-5.6.35 1234567891011121314151617181920cmake \\-DCMAKE_INSTALL_PREFIX=/u01/my3306 \\-DINSTALL_DATADIR=/u01/my3306/data \\-DDEFAULT_CHARSET=utf8 \\-DDEFAULT_COLLATION=utf8_general_ci \\-DEXTRA_CHARSETS=all \\-DWITH_SSL=yes \\-DWITH_EMBEDDED_SERVER=1 \\-DENABLED_LOCAL_INFILE=1 \\-DWITH_MYISAM_STORAGE_ENGINE=1 \\-DWITH_INNOBASE_STORAGE_ENGINE=1 \\-DWITH_ARCHIVE_STORAGE_ENGINE=1 \\-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\-DWITH_FEDERATED_STORAGE_ENGINE=1 \\-DWITH_PARTITION_STORAGE_ENGINE=1 \\-DMYSQL_UNIX_ADDR=/u01/my3306/run/mysql.sock \\-DMYSQL_TCP_PORT=3306 \\-DENABLED_LOCAL_INFILE=1 \\-DSYSCONFDIR=/etc \\-DWITH_READLINE=on 1make &amp;&amp; make install 10）MySQL 参数配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889[client]port=3306socket=/u01/my3306/mysql.sock[mysql]pid_file=/u01/my3306/run/mysqld.pid[mysqld]autocommit=1general_log=offexplicit_defaults_for_timestamp=true# systembasedir=/u01/my3306datadir=/u01/my3306/datamax_allowed_packet=1gmax_connections=3000max_user_connections=2800open_files_limit=65535pid_file=/u01/my3306/run/mysqld.pidport=3306server_id=101skip_name_resolve=ONsocket=/u01/my3306/run/mysql.socktmpdir=/u01/my3306/tmp#binloglog_bin=/u01/my3306/log/binlog/binlogbinlog_cache_size=32768binlog_format=rowexpire_logs_days=7log_slave_updates=ONmax_binlog_cache_size=2147483648max_binlog_size=524288000sync_binlog=100#logginglog_error=/u01/my3306/log/error.logslow_query_log_file=/u01/my3306/log/slow.loglog_queries_not_using_indexes=0slow_query_log=1log_slave_updates=ONlog_slow_admin_statements=1long_query_time=1#relayrelay_log=/u01/my3306/log/relaylogrelay_log_index=/u01/my3306/log/relay.indexrelay_log_info_file=/u01/my3306/log/relay-log.info#slaveslave_load_tmpdir=/u01/my3306/tmpslave_skip_errors=OFF#innodbinnodb_data_home_dir=/u01/my3306/log/ibloginnodb_log_group_home_dir=/u01/my3306/log/ibloginnodb_adaptive_flushing=ONinnodb_adaptive_hash_index=ONinnodb_autoinc_lock_mode=1innodb_buffer_pool_instances=8#defaultinnodb_change_buffering=insertsinnodb_checksums=ONinnodb_buffer_pool_size= 128Minnodb_data_file_path=ibdata1:32M;ibdata2:16M:autoextendinnodb_doublewrite=ONinnodb_file_format=Barracudainnodb_file_per_table=ONinnodb_flush_log_at_trx_commit=1innodb_flush_method=O_DIRECTinnodb_io_capacity=1000innodb_lock_wait_timeout=10innodb_log_buffer_size=67108864innodb_log_file_size=1048576000innodb_log_files_in_group=4innodb_max_dirty_pages_pct=60innodb_open_files=60000innodb_purge_threads=1innodb_read_io_threads=4innodb_stats_on_metadata=OFFinnodb_support_xa=ONinnodb_use_native_aio=OFFinnodb_write_io_threads=10[mysqld_safe]datadir=/u01/my3306/data 10）初始化 MySQL 脚本 12[root@MyDB1 my3306]# cd /u01/my3306/scripts/ ./mysql_install_db --defaults-file=/u01/my3306/my.cnf --datadir=/u01/my3306/data --user=mysql 如果有报错的话，可以到/usr/my3306/log/error.log下进行查看 。 11）启动 mysql 我们需要到 mysql 的 bin 目录下启动 mysqld_safe，如果误操作把 mysql kill 了，mysqld 会再次将 mysql 启动。 1./mysqld_safe --defaults-file=/u01/my3306/my.cnf --user=mysql &amp; 启动后，我们可以通过 ps 命令查看 MySQL 进程 123456[root@MyDB1 my3306]# ps -ef | grep mysqlroot 1263 1254 0 18:16 pts/0 00:00:00 su mysqlmysql 1264 1263 0 18:16 pts/0 00:00:00 bashroot 1588 1346 0 18:29 pts/0 00:00:00 /bin/sh /u01/my3306/bin/mysqld_safe --defaults-file=/u01/my3306/my.cnf --user=mysqlmysql 2436 1588 0 18:29 pts/0 00:00:02 /u01/my3306/bin/mysqld --defaults-file=/u01/my3306/my.cnf --basedir=/u01/my3306 --datadir=/u01/my3306/data --plugin-dir=/u01/my3306/lib/plugin --user=mysql --log-error=/u01/my3306/log/error.log --open-files-limit=65535 --pid-file=/u01/my3306/run/mysqld.pid --socket=/u01/my3306/run/mysql.sock --port=3306root 2491 1346 0 18:38 pts/0 00:00:00 grep mysql 12) 登录 mysql 我们直接可以使用 mysql 命令进入 mysql 1234567891011121314151617181920212223[root@MyDB1 my3306]# mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 1Server version: 5.6.35-log Source distributionCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.05 sec)","categories":[{"name":"MySQL DBA","slug":"MySQL-DBA","permalink":"http://www.maksim.website/categories/MySQL-DBA/"}],"tags":[]},{"title":"使用 Vagrant 统一公司内开发环境","slug":"2016-12-13 使用 Vagrant 搭建开发环境","date":"2016-12-13T01:10:23.000Z","updated":"2018-06-20T05:12:04.600Z","comments":true,"path":"2016/12/13/cjlz9pr2u002kabrdgpuriw58/","link":"","permalink":"http://www.maksim.website/2016/12/13/cjlz9pr2u002kabrdgpuriw58/","excerpt":"","text":"Vagrant 是什么? 简单地说，Vagrant让我们可以通过代码的方式快速地、可重复地创建针对不同虚拟环境的虚拟机，包括Virtualbox、AWS、Docker等。它使得我们可以一次性地、自动创建多个环境相同的虚拟机，对于软件开发和测试尤其有用。本文我们将以Virtualbox为例，看看Vagrant的基本使用。 Vagrantd的作用? 统一开发环境。一次配置打包，统一分发给团队成员，统一团队开发环境，解决诸如“编码问题”，“缺少模块”，“配置文件不同”带来的问题； 避免重复搭建开发环境。新员工加入，不用浪费时间搭建开发环境，快速加入开发，减少时间成本的浪费； 多个相互隔离开发环境。可以在不用box里跑不同的语言，或者编译安装同一语言不同版本，搭建多个相互隔离的开发环境，卸载清除时也很快捷轻松。 Vagrant 适用范围 开发环境 项目配置比较复杂 官网：https://www.vagrantup.com/ vagrant与 VirtualBox的版本需要注意匹配，在官网有详细介绍，如果版本不匹配会出现一些错误。 常用命令 vagrant box list 查看目前已有的box vagrant box add 新增加一个box vagrant box remove 删除指定box vagrant init 初始化 vagrant up 启动虚拟机 vagrant ssh SSH 登陆虚拟机 vagrant suspend 挂起虚拟机 vagrant reload 重启虚拟机 vagrant halt 关闭虚拟机 vagrant status 查看虚拟机运行状态 vagrant destroy 销毁当前虚拟机","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://www.maksim.website/tags/工具/"}]},{"title":"使用策略模式敲开设计模式的大门(PHP语言描述)","slug":"2016-09-23 PHP设计模式系列之入门","date":"2016-09-23T14:15:16.000Z","updated":"2018-06-20T05:03:04.513Z","comments":true,"path":"2016/09/23/108/","link":"","permalink":"http://www.maksim.website/2016/09/23/108/","excerpt":"","text":"设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 前言 本系列文章不会直接上代码直接进行解释，我一直认为带着问题来学习是效率最高的学习方式。 本系列文章不会有演示截图，你为什么不敲一遍加深印象呢，另外说不定我的代码有错。 我所写的文章只是我对于编程的理解，如果有错误希望能够得到指正以免误人子弟。 怎么样才可以进行设计模式的学习步子迈大了容易扯到蛋，如果在没有熟悉 OOP 编程思想前就开始学习设计模式，我感觉会有两种可能，不是“扯蛋”，就是“拉跨”。 当然上面的话是一句玩笑话，学习设计模式可以有效的提高我们的代码质量与深入的理解 OOP 编程理念，如但是果在没有扎实的功底（至少要要理解了抽象、接口、多态）前就开始学习设计模式会越学越难，脑子越来越浑，那就真变成了从入门到放弃了，因为你的思维还没有真正的走进 OOP(单身狗表示完全无法面向对象^_^)。 对于设计模式的不理解我感觉主要分为两种，一种是不知道怎么实现的，原因就是如上所述，另外一种是不知道为什么要这么用的，其实没有必要纠结于为什么这么用，这么用了有啥作用，设计模式不过是与算法一样只是为了实现某个特定环境下可以使用的一种更好的选择。 更好一点的例子就是当我们对一些数据进行排序的时候，我们首先想到就是那几个排序算法一样，当我们打着打着代码突然灵光一闪，好像这个地方用这个设计模式写起来会轻松一点。 当碰到不懂得地方，思考一下，想不通，就出去走走，把这个东西放下来，反正就算看到第二天凌晨也也是无用的，当真正遇到问题的时候，灵光一闪这个东西可以这么写，然后去实践，这就是我的学习之道。还有就是尽量去学实例，而不是去死扣概念，当你真正用起来了，你也就差不多懂了，算法与数据结构亦是如此。 本系列文章尽量以推导的形式来进行书写，而不是以现成的代码来进行讲解，让读者知道设计模式是怎么来的也就是如何演化出来的，希望各位能够喜欢。另外本系列的文章并不会提供运行界面的截图，如果想看看结果是否正确，为什么不自己试试呢？ 设计模式尝鲜（策略模式）开头引用的话来自于百度百科，我相信很多刚刚开始接触编程的人都会犯晕，因为所有人都不喜欢被学术化的文字，我们以设计模式中较为常用的策略模式来进行演示，当我们编写一个广告模块的时候，公司给的要求是根据访问者的性别来进行显示广告以提高转化率，那我们应该怎么写呢？ 首先我们想到的是在每一个广告位上面都使用 if 判断来判断访客的性别，这样就能够解决这样的需求，那么我们的每一个广告代码的代码块可能是这个样子的： 12345判断 男 or 女&#123; 如果是男的就是男人的广告&#125;else&#123; 显示女人的广告&#125; 既然伪代码想好了，那么我们就可以着手进行开发了，然后我们在 if 代码块中添加各自的家在广告代码，于是就变成了下面的样子： 12345if ($_GET['sex'] == 'man') &#123; echo '外星人大减价现在购买立即送电竞瑞文皮肤';&#125;else&#123; echo '卡西欧美颜相机不要钱免费送！';&#125; 但是这是属于一种硬编码的编程方式，一旦我们增加了某种需求，要求其年龄大于23岁显示什么样的广告，那么我们就不得不在每一个 if 判断处再加上新的判断条件，这样的设计就是不合理的，为了提高可读性与可维护性，我们会考虑建立两个不同的类来对两个广告类来对其进行管理。于是代码变成了下面的样子。 12345678910111213141516171819202122232425//index.phpinclude 'GenderAD.php';include 'ManAD.php';if ($_GET['sex'] == 'man') &#123; $ad = new ManAD();&#125;else&#123; $ad = new GenderAD();&#125;$ad-&gt;show();//GenderAD.phpclass GenderAD&#123; public algorithm()&#123; echo '卡西欧美颜相机不要钱免费送！'; &#125;&#125;//ManAD.phpclass ManAD&#123; public algorithm()&#123; echo '外星人大减价现在购买立即送电竞瑞文皮肤'; &#125;&#125; algorithm 英[ˈælgərɪðəm] 美[ˈælɡəˌrɪðəm] n. 演算法; 运算法则; 计算程序; 其实到了这一步就已经算是一个简单的策略模式了，因为他已经具有策略的特质了，只不过还不够完善，如果说这不算什么的话我也没有办法，因为所有的设计模式其实都是思维模式与表现形式罢了，就像上面的引用中提到的一样，设计模式只不过是为了能够让代码可以重用，更容易他让人理解，因为你的代码并不是你一个人在维护，那么问题来了，只是简单的对其进行封装真的就提高代码的可维护性了么，其实并没有，我们还没有将 OOP 的设计概念发挥到极致。 经过分析我们发现其实 ManAD类和 GenderAD最终都要进行显示，他们的方法的显示方法都是 show，如果是你一个人在开发那么没有什么问题，可是若是两个人开发呢，你们可以直接可以对话的方式进行沟通，协定好都是 show方法来显示，可是为什么不用更工程化的方式来实现呢？ 我们可以使用接口来实现这一目的，如果对接口还不了解，可以去查阅一下资料，很快你就能够明白，在本文结束后我会在下方标注出参考范例。 我们可以新建一个接口来对这些策略进行控制。 12345678910111213141516interface ADinterface&#123; public function algorithm();&#125;class ManAD implements ADInterface&#123; public function algorithm()&#123; echo '外星人大减价现在购买立即送电竞瑞文皮肤'; &#125;&#125;class GenderAD implements ADInterface&#123; public function algorithm()&#123; echo '卡西欧美颜相机不要钱免费送！'; &#125;&#125; 这样一来广告策略必须遵循这个接口进行开发，就保证了所有策略类都需要实现 show 方法。 到目前为止，策略模式已经相对的完善了，但是还是不够完美，因为代码依旧并不是很 OOP，我们其实还可以更进一步，让他更 OOP，我们可以对那些策略外面套一个壳子，给外面一个选择器。 123456789101112131415class StrategySelect &#123; //具体策略对象 private $strategyInstance; //构造函数 public function __construct($instance) &#123; $this-&gt;strategyInstance = $instance; &#125; public function algorithm($strategy) &#123; return $this-&gt;strategyInstance-&gt;algorithm(); &#125;&#125; 我们通过构造函数接收到具体的执行策略，然后使用algorithm()执行相对应的策略。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpinterface ADinterface&#123; public function algorithm();&#125;class StrategySelect &#123; //具体策略对象 private $strategyInstance; //构造函数 public function __construct($instance) &#123; $this-&gt;strategyInstance = $instance; &#125; public function algorithm() &#123; return $this-&gt;strategyInstance-&gt;algorithm(); &#125;&#125;class ManAD implements ADInterface&#123; public function algorithm()&#123; echo '外星人大减价现在购买立即送电竞瑞文皮肤'; &#125;&#125;class GenderAD implements ADInterface&#123; public function algorithm()&#123; echo '卡西欧相机免费赠送啦'; &#125;&#125;header(\"Content-type:text/html;charset=utf-8\");if ($_GET['sex'] == 'man') &#123; $stratey = new StrategySelect(new ManAD()); $stratey-&gt;algorithm();&#125;else&#123; $stratey = new StrategySelect(new GenderAD()); $stratey-&gt;algorithm();&#125; Strategy其实算是一个策略选择器，当满足一定条件的时候，我们通过这个策略选测器来进行选择相对应的策略。这样一来更符合逻辑。是不是很 OOP？ 如果有什么不懂得可以在评论区进行留言，有时间我会一一答复，如果发现本文中有什么错误请指出，我也害怕误人子弟，特别是概念上的东西，在最后StrategySelect类的讲解上我依旧感觉写的很模糊，有些差强人意。 参考 《Leaning PHP Design Patterns》 William Sanders 著 苏金国 王宇飞等译 《PHP之道》 《PHP大话设计模式》 Rango(韩天峰) 录制者 慕课网视频教程","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.maksim.website/tags/设计模式/"}]},{"title":"使用 Feedly RSS阅读器订阅技术大牛的博客","slug":"2016-05-08 Rss","date":"2016-05-08T03:06:05.000Z","updated":"2018-06-20T07:17:42.054Z","comments":true,"path":"2016/05/08/cjlz9pr2n002eabrdprhhzvi1/","link":"","permalink":"http://www.maksim.website/2016/05/08/cjlz9pr2n002eabrdprhhzvi1/","excerpt":"这几天一直都在自己看书，可是书上面的东西都比较落后一点，而且没有大牛博文上的东西讲的深入，可是来回跳转各位大牛的博客又非常的麻烦，有一些公众账号虽然也会推荐一些知识内容，可是你应该有过看到多个公众号发一篇博文的经历吧。 这个时候我想起了一个叫做 RSS 订阅的一个功能，可是国产的RSS 订阅器的 UI 是一个很大的槽点，而且功能相对于臃肿，很多功能都用不到，最终选择了 Feedly 这款 APP，UI 清爽，功能简单，完全符合我的需要，而且还支持 OPML 导入。 AirCrayon 是一名 iOS 程序员，所以我订阅的大多都是 iOS 的技术大牛，大牛唐巧一直在维护一个中文博文列表的项目地：https://github.com/tangqiaoboy/iOSBlogCN","text":"这几天一直都在自己看书，可是书上面的东西都比较落后一点，而且没有大牛博文上的东西讲的深入，可是来回跳转各位大牛的博客又非常的麻烦，有一些公众账号虽然也会推荐一些知识内容，可是你应该有过看到多个公众号发一篇博文的经历吧。 这个时候我想起了一个叫做 RSS 订阅的一个功能，可是国产的RSS 订阅器的 UI 是一个很大的槽点，而且功能相对于臃肿，很多功能都用不到，最终选择了 Feedly 这款 APP，UI 清爽，功能简单，完全符合我的需要，而且还支持 OPML 导入。 AirCrayon 是一名 iOS 程序员，所以我订阅的大多都是 iOS 的技术大牛，大牛唐巧一直在维护一个中文博文列表的项目地：https://github.com/tangqiaoboy/iOSBlogCN 在其中为广大 iOS 程序员提供了一个OPML 文件，将其文件下载来进入Feedly 的官网。 没有账户的同学请先注册账户，虽然是英文的但是一般都应该能看的懂，也就不做注册介绍了。 第一步,登录后点击 AddContent 第二步，右侧栏拉倒底部点击 Import OPML 第三步，上传 OPML 文件 这样一来就已经大功告成了，进入 AppStore 或者安卓市场下载一个 Feedly 后登陆自己的账户后便可以使用手机直接查看技术大牛的最新博文了。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"内存管理 Form《Objectivce-C编程全解》&《Objectivce-C编程》","slug":"2016-05-06 基于引用计数的内存管理","date":"2016-05-06T04:31:00.000Z","updated":"2018-06-19T01:28:27.155Z","comments":true,"path":"2016/05/06/cjlz9pr2j0029abrdpz3squpz/","link":"","permalink":"http://www.maksim.website/2016/05/06/cjlz9pr2j0029abrdpz3squpz/","excerpt":"","text":"Xcode4.2之后可以使用自动引用计数（ARC,Automatic Reference Counting）的管理方式进行说明，ARC 是 Mac OS X 10.7和 iOS5引入的新特性，也是苹果公司推荐使用的内存管理方式。弃用 ARC 后，编译器会在适当的地方自动加入 retaion、release、autorelease 等语句，来简化 Objective-C 编程在内存管理方面的工作量 动态内存管理内存管理的必要性C 语言中需要手动利用 malloc()和 free()对内存进行管理。当程序运行结束时，操作系统会释放掉为其分配的内存。如果是很小、运行时间短的程序，就算是内存没有释放也没有问题，程序结束时操作系统会进行自动释放。而对于长时间运行的程序，则需要程序员释放不再使用的内存，否则程序就会崩溃。 如果程序没能妥善管理内存，运行过程中就不但不能释放不再使用的内存，而且还会不停的分配内容村，这样所占用的内存就会越来越多，程序速度也会越来越慢，最后甚至会出现内存耗尽而崩溃。 就好像滴水一样，程序未能释放已不使用的内存叫做内存泄漏(memory leak)。C 语言中要特别注意内存的动态分配和释放，以防内存泄漏。有效地管理内存，会提高程序的执行效率。 如果访问了以被释放的内存，则会造成数据错误，严重时甚至会导致程序异常终止。在指针指向已被释放或回收的情况下，该指针就称之为悬垂指针（danling pointer）或野指针。继续使用这种指针会造成程序崩溃。 Objective—C 会通过向对象发送 alloc 消息来生成实例对象，alloc 的作用就是分配内存。alloc 方法的返回值是 id 类型，我们之前介绍过 id 其实就是指针类型，而其指向的就是为实例对象分配的内存。生成的实例对象用完之后如果不被释放的话，就会发生内存泄漏。另一方面，如果给已经被释放了的实例对象发送消息，运气好的话会得到警告，告诉你已被释放的对象发送了消息，运气不好的话则会程序错误甚至异常终止，所以 Objective-C 的程序一定要注意内存管理。 在面向对象的语言中，对象是程序的核心。而对象也有生命周期，既有从头到尾一直存在的对象，也有声明起短暂的临时对象。对象之间也可能相互引用，构成结构复杂的数据结构。同面向过程的语言相比，面向对象语言的内存管理更复杂一些。 引用计数器、自动引用计数和自动垃圾回收Coca 环境的 Objective-C 提供了一种动态内存管理方式，称之为引用计数（reference counter）。这种方式会跟踪每一个对象被引用的次数，当对象的引用次数为0的时候，系统会释放掉这个对象所占用的内存。这种内存管理方式也被称之为基于引用计数器的内存管理。 比引用计数内存管理更高级一点的就是自动引用计数（Automatic Reference Counting，简写 ARC）的内存管理。自动引用计数使开发人员不需要考虑何时使用 retain、release、autorelease 来管理内存，它提供了自动评估对象生存期的工恩给你，在编译期间会自动加入何时的内存管理方法，为了同自动引用计数器进行区分，将引用计数内存管理方式称之为手动引用技术内存管理。 除了 ARC 外，Objective-C2.0还引入了另外一种自动内存管理机制——垃圾回收，使用垃圾回收时，就不需要通过引用计数来刮泥创建的对象，系统会自动识别那些对象仍在使用，那些对象可以回收。 程序员可以从手动引用计数管理、ARC 和垃圾回收中选择任意一种内存管理方式来进行开发，不过还是推荐大家使用 ARC 的方式来进行内存管理。 内存管理方式 难易度 Mac iOS 备注 手动引用计数 较难 支持 支持 自动引用计数 容易 支持 支持 现在已经默认使用此方式 垃圾回收 容易 支持 不支持 兼容方法在ARC的程序中,有一些类使用MRC实现的. 如果希望某些指定的类还是使用MRC. 那么这个时候可以在 在targets的build phases选项下Compile Sources下选择要不使用arc编译的文件，双击它，输入 -fno-objc-arc 即可 MRC工程中也可以使用ARC的类。方法如下： 在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可 手动引用计数内存管理本节将说明如何基于引用计数器来管理内存。手中引用计数是内存引用计数的基础，就算程序使用自动引用计数的内存管理，也需要了解手动引用计数的原理。 引用计数Cocoa 环境的 Objective-C 使用了一种叫做引用计数的计数来管理对象所占的内存。每个对象都有一个与之相关的整数——引用计数，当某段代码需要使用一个对象时，就将该对象的引用计数值加1。当这段代码不再使用这个对象的时候，则将对象的引用计数器减1.换而言之，引用计数就是指程序中到底有多少个地方需要访问这个对象。 使用 alloc 和初始化方法创建一个对象的时候，该对象的引用计数初始值为1.假设有一个类 A 在进行某些处理的过程中需要使用到实例 B，为了防止实例化 B被别的对象随意释放，类 A 会实现给实例 B 发送一个 retain 消息。这样，没执行一次 retain，实例 B 的引用计数就会加1。 反之，不需要某个对象时，可以发送 release 消息，使对象的引用计数减1。 实际上，释放内存的并不是 release，而是 dealloc 方法。同 alloc 不同，dealloc 不是类方法而是一个实例方法。没收到一个 release 消息，对象的引用计数器就会减一。当对象的引用计数器达到0的时候，系统就知道这个对象不需要了。这时，Objectivce—C 会自动向对象发送一条 delloc 消息来释放内存。通常允许在程序内直接调用 dealloc。 retain、release和 dealloc 的定义如下所示。retain 的返回值是接收消息的对象。 123-(void)retain;-(oneway void)release;-(void)dealloc; retain 是“保持”的意思，给一个对象发送 retain 消息，就意味着“保持”这个对象。生成对象或通过给对象发送 retain 消息来保持对象这种状态，都可以说是拥有这个对象的所有权（ownership）拥有实例所有权的对象叫做所有者（owner）。 这里需要注意的是，所有权是一个虚拟的概念。既无法通过语法标记，也无法通过这个对象的某个属性表示出来。程序在运行时没发确认某个对象的所有者是谁。所有权仅仅是人们分析阅读程序时，为了说明对象之间的关系而加上去的一个属性。 通过引用计数能够表现出一个对象有几个所有者。只要某个对象的引用计数器大于0就表示这个对象有所有者。引用计数变为0的时候，说明这个对象没有所有者，会被释放。 图1 没有使用引用计数器的例子 让我们通过例子来说明一下基于应用技术的内存管理。首先，假设图（1）中对象 A 的方法把一个新生成的一个实例对象复制给了 A 的实例变量。这个时候新生成的对象的引用计数为1，他的所有者是对象 A，然后，图（2）中把这个对象的指针付给了对象 B 的某个实例变量。因为对象鼻没有发送 retain 消息，所以并不是这个对象的所有者，这个独享的引用计数器还是1.最后图（3）中对象 A 不再使用这个对象的时候发送了一个 release 消息，于是，虽然对象 B 还在使用这个对象，但该对象也被释放了。而此时如果对象 B 给已经释放的消息在发送消息，就会发生运行错误，程序将会异常终止！ 为了防止这样的情况发生，一定要给动态生成的对象发送 retain 消息来增加它的引用计数。只要对对象的引用次数大于零，系统就不会释放它。 测试引用计数让我们通过一个例子来看引用计数到底是如何工作的。 retain 和 release 方法是类 NSObject 的实例方法，方法 retainCount 可以获得对象的引用计数的当前值。retainCount 方法并没有太大的使用价值，一般在调试程序的时候使用。 代码清单的程序显示了对象生成后收到 retain、release 消息时引用计数器的变化。retainCount 的返回值是 NSUInteger 类型，使用 printf 输出返回值的时候需要进行类型转换。 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; id obj = [[NSObject alloc]init]; NSLog(@\"init:%d\",(int)[obj retainCount]); [obj retain]; NSLog(@\"retain:%d\",(int)[obj retainCount]); [obj retain]; NSLog(@\"retain:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); return 0;&#125; 程序的输出如下所示。我们可以看出，对象刚生成的时候引用计数器的值为1，没收到一次 retain 消息，引用计数器的值就会加1；而收到 release 消息，引用计数器的值就减少1 12345672016-05-06 13:19:16.761 引用计数器学习[6574:600738] init:12016-05-06 13:19:16.762 引用计数器学习[6574:600738] retain:22016-05-06 13:19:16.762 引用计数器学习[6574:600738] retain:32016-05-06 13:19:16.762 引用计数器学习[6574:600738] release:22016-05-06 13:19:16.763 引用计数器学习[6574:600738] release:12016-05-06 13:19:16.763 引用计数器学习[6574:600738] release:1Program ended with exit code: 0 释放对象的方法在自定义类的时候，如果累的实例变量是一个对象类型，那么，在销毁类的对象的时候，也要给类的实例变量发送 release 消息。 通过给对象发送 release 消息可以放弃对这个对象的所有权，但如前所述，真正释放对象占用的内存方法是 dealloc方法。 释放一个类的实例对象时，为了彻底释放该实例对象的所有对象的所有权，需要为该类重写 dealloc 方法，在其中释放已经分配的资源，放弃实例变量的所有权。 123456- (void)dealloc&#123; //重写的是 dealloc 方法而不是 release 方法 /* 这里通过 release 方法放弃子类中所有实例变量的所有权 其他用于释放前的善后操作也都卸载这里 */&#125; 在重写 dealloc 犯法中，在释放自身之前，首先做好“善后工作”（释放所有需要释放的资源）。一般情况下，“善后工作”包括通过使用 release 放弃自身的实例变量的所有权。销毁对象的时候，不允许直接使用 dealloc，而是使用 release。release 会让引用计数减少1，只有当引用计数等于0的时候系统才会自动调用 dealloc 真正的销毁这个对象。 子类“善后工作”完成后，调用父类的 dealloc 方法来释放父类中定义的实例变量，这样，内存的释放会从子类一直向上知道 NSObject，最终这个对象就会被彻底释放掉。下面的分数计算器的例子中展示了如何重写 dealloc。 Retain计数原则当使用Objective-C编写程序时，如果没有使用 ARC，就必须遵守特定的内存管理约定，否则可以由 ARC 来自动完成相关任务。 下面为 retain 计数总结若干规则，规则中的“你”代表“当前正在使用的某个类实例”。这是一种很有用的带入形式：请读者将自己想象成是在正在编写的那个对象。例如，“如果你保留了某个 NSString 对象，那么该实例就不会被释放掉”的真是意思是“如果读者正在使用的实例保留了某个 NSString 实例，那么该实例就不会被释放。” 下面列出规则（袁阔闹中的是实现细节） 如果用来创建对象的方法，其方法名是以 alloc 或new 开头的，或者包含 copy，那么你已经得到了该对象的所有权（即可以假设新对象的 retain计数是1，而且该对象不再 NSAutoreleasePool 对象中）。你要负责不再需要使用该对象的时候释放掉他。以下是部分常见的、会“传输”所有权的方法：alloc（后面总会跟一个 init 方法）、copy 和 mutableCopy 通过任何其他途径创建的对象（例如通过便捷方法），你是没有所有权的（即可以假设新对象的 retain 计数是1，而且该对象已经在 NSAutoreleasePool 对象中。如果没有保留该对象，那么当NSAutoreleasePool被“排干”时，这个对象会被释放）。 如果你不拥有某个对象，但是要确保该对象能继续存在，那么可以通过响起发送 retain 消息来获得所有权。 当你拥有某个对象并且不再需要使用该对象的时候，可以向其方发送 release 消息或者 autorelease 消息 只要对象还有只要一个拥有方，该对象就会继续存在下去。 ##参考文献： ① Objectivce-C编程全解（第三版） [日]荻原刚志 著 唐璐 翟俊杰 译 ② Objectivce-C编程 [美]Aaron Hillegass 著 夏伟频 译","categories":[{"name":"ios","slug":"ios","permalink":"http://www.maksim.website/categories/ios/"}],"tags":[]},{"title":"读书总结之NSObject","slug":"2016-05-06 NSObject","date":"2016-05-06T03:03:16.000Z","updated":"2018-04-10T10:52:18.304Z","comments":true,"path":"2016/05/06/cjlz9pr290023abrd1hoorkg5/","link":"","permalink":"http://www.maksim.website/2016/05/06/cjlz9pr290023abrd1hoorkg5/","excerpt":"使用 Objectvice-C 进行全面对象编程时，除了需要知道语言本身的语法和面向对象的知识外，还需要了解Objectvice-C的根类 NSObject 的信息。 NSObject根类的作用作为一门动态编程语言，Objectstvice-C有很多动态的特性，因此，Objectvice-C不进需要编译环境，同时还需要一个运行时系统（runtime system）来执行编译好的代码。运行时系统扮演的角色类似于Objectvice-C的操作系统，他负责完成对象生成、释放时的内存管理、发来的消息查找对应的处理方法等工作。 通常情况下，程序无法直接使用运行时系统提供的功能。根类方法提供了运行时系统的基本工恩给你。继承了 NSObject 的所有类都可以自由的使用运行时系统的功能，也就是说，根类就想到于系统的一个借口。 根类通过哪些方式提供了哪些功能对系统有很大的影响。因此，根类不同的系统之间是无法开发出通用的程序的。 Cocoa 是以OPENSTEPDE的核心 API 为基础发展起来的。OPENSTEP的前身为 NeXTstep。在 NeXTstep 时代，根类是累 Object,而在 OPENSTEP 时代，根类则变为了 NSObject，同时类的设计也得到了大幅度的改进。","text":"使用 Objectvice-C 进行全面对象编程时，除了需要知道语言本身的语法和面向对象的知识外，还需要了解Objectvice-C的根类 NSObject 的信息。 NSObject根类的作用作为一门动态编程语言，Objectstvice-C有很多动态的特性，因此，Objectvice-C不进需要编译环境，同时还需要一个运行时系统（runtime system）来执行编译好的代码。运行时系统扮演的角色类似于Objectvice-C的操作系统，他负责完成对象生成、释放时的内存管理、发来的消息查找对应的处理方法等工作。 通常情况下，程序无法直接使用运行时系统提供的功能。根类方法提供了运行时系统的基本工恩给你。继承了 NSObject 的所有类都可以自由的使用运行时系统的功能，也就是说，根类就想到于系统的一个借口。 根类通过哪些方式提供了哪些功能对系统有很大的影响。因此，根类不同的系统之间是无法开发出通用的程序的。 Cocoa 是以OPENSTEPDE的核心 API 为基础发展起来的。OPENSTEP的前身为 NeXTstep。在 NeXTstep 时代，根类是累 Object,而在 OPENSTEP 时代，根类则变为了 NSObject，同时类的设计也得到了大幅度的改进。 NSArray,NSString 等等NS前缀类、函数归属于cocoa Fundation基础类库,其”NS”的由来据说是这样的：乔布斯被苹果开除后,创立了NeSt公司,而cocoa Fundation基础类库就是出自于NeST公司,NeST中的”NS”被作为Fundation中所有成员的前缀 类和实例NSObject 只是一个实例变量，就是 Class 类型的变量 isa。isa 用于表示实例对象属于哪个类对象。因为 isa 决定着实例变量和类的关系，非常重要，所以子类不可以修改 isa 的值。另外，也不能通过直接访问 isa 来查询实例变量到底属于哪个类，而是要通过实例方法 class 来完成查询。 在运行时的代码中我们可以查看到objc_class的定义如下： 1234567/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; 下面对类和实例变量的相关方法进行说明。NSObject 的方法与其说是为自己定义的，不如说是为了其子类和所有实例对象而定义的。 123456789101112131415161718192021222324- (class) class 返回消息接收者所属类的类对象+ (class) class 返回类型对 虽然可以使用类名作为消息的接受者来调用类方法，但类对象是其他消息的参数，或者将类对象赋值给变量的时候，需要通过这个方法来获取类的参数- (id) self 返回接受者自身。是一个无任何实际动作但很有用的方法。-(BOOL) isMemberOfClass: (Class) aClass 判断消息接受者是不是参数 aClass 类的对象 -(BOOL) isKindOfClass: (Class) aClass 判断消息接受者是否是参数 aClass 类或者 aClass 的子类的实例。这个函数和 isMemberOfClass:的区别在于当消息的接受者是 aClass 的子类的实例时也返回 YES。 - (BOOL) isSubclassOfClass: (Class) aClass 判断消息接受者是不是参数 aClass 的子类或自身，如果是则返回 YES - (Class) superclass 返回消息接受者所在类的父类的类对象。 + (Class) superclass 返回消息接收类的父类和类对象 实例对象的生成和释放1234567891011121314151617181920+ (id) alloc 生成消息接收类的实例对象。通常和 init 或者 init 开头的方法连用，生成实例化对象的同事需要对其进行初始化。子类中不润徐重写 alloc 方法+ (void) dealloc 释放实例对象。dealloc 被称之为 release 的结果调用。除了在子类中重写 dealloc 的情况之外，程序不润徐直接调用 dealloc- (oneway void)release 将消息接受者的引用计数减1.引用计数变为0时，dealloc 方法被调用，消息接受者被释放- (id)retain 为消息接收者的引用计数加1，同事返回消息接收者- (id)autorelease 把消息的接受者加入到自动释放池中，同事返回消息接受者 - (NSUinteger) retainCount 返回消息接受者的引用计数，可在调试时使用这个方法。NSUInteger 是无符号证书类型- (void)finalize 垃圾收集器在释放接受者对象之前会执行该 finalize 方法。 上面从 dealloc 到 retainCount 都是手动引用计数管理内存时使用的方法，使用 ARC 时不可用。finalize 仅供垃圾回收有效时使用。 初始化123456789- (id) init init 可对 alloc 生成的实例对象进行初始化。子类中可以重写 init 或者自定义的心的以 init 开头的初始化函数。+ (void)initialize 被用于类的初始化，也就是对类中共同使用的变量进行初始化设定等。这个方法会在类收到第一个消息之前被自动执行，不需手动调用 + (id) new new 是 alloc 和 init 的组合。new 方法返回的实例对象的所有者就是调用 new 方法的对象。但是把 alloc 和 init 组合定义为 new 没有什么优点，并不建议使用。 根据类的实现不同，new 方法并不会每次都返回一个全新的实例对象。有时new 方法会返回对象池中预先生成的对象，也有可能每次都返回同一个对象。 对象的比较12345-(BOOL) isEqual: (id) anObject 消息的接受者如果和参数 anObject 相等则返回 YES - (NSUInteger) hash 把对象放入容器的时候，返回系统内部用的散列表 原则上来讲，具有相同 id 值也就是同一个指针指向的对象被认为是相等的。而子类在这个基础上进行了扩展，把拥有相同值认为是相等。我们可以根据需求对“想通知”激进型定义，但一般都会让具备“相同值”的对象返回相同的散列表，因此就需要对散列表方法进行重新定义。而反之则并不成立，也就是说，散列值相等的两个对象不一定相等。 另外，有的累中还自定义了 compare:或者isEqualTo 之类的方法。至于到底是哪个方法或者自定义类的时候是否需要定义比较的方法，都需要根据目的和类的内容做具体分析。 对象的内容描述12345+ (NSString*) description 返回一个 NSString 类型的字符串，表示消息接受者所属类的内容。通常是这个类的名称。- (NSString*)description 返回一个 NSString 类型的字符串，表示消息接受者的实例对象的内容。通常是类名家 id 值。子类中可以重新定义 description 的返回值。例如 NSString的实例会返回字符串的内容，NSArray 的实例会对数组中的每一个元素调用 description，然后将调用结果用句号进行分割，并且一起返回。 消息发送机制选择器和 SEL 类型至今为止我们把选择器（方法名）和消息关键字放在一起进行说明。程序中的方法名（选择器）在便有被一个内部标识符所代替，这个内部标识符所对应的数据类型就是 SEL 类型。 Objective-C为了能够在程序中操作编译后的选择器，定义了@selector()指令。通过使用@selector()指令，就可以直接饮用编译后的选择器。使用方法如下： 123@selector(mutableCopy)@selector(compare:)@selector(replaceObjectAtIndex:withObject:) 也可以声明 SEL 类型的变量 选择器不同的情况下，编译器转换后生成的 SEL 类型的值也一定不同，相同的算择期对应的 SEL 类型的值一定相同。Objective-C的程序员不需要知道选择器对应的 SEL 类型的值到底是什么，具体的值是和处理器相关的。但是如果 SEL 类型的便利功能无效的话，可设其为 NULL，或者也可以使用(SEL)0这种常见的表达方式 可以使用 SEL 类型的变量来发送消息，为此，NSObject 中准备了如下方法 123456-(id)performSelector: (SEL) aSelector 向消息的接收者发送 aSelector代表的消息，返回这个消息的执行结果 -(id)performSelector: (SEL) aSelector withObject: (id) anObject 与上面的方法一直，不过可以传递参数 例如下面两个消息表达式进行的处理是相同的 12[target description][targ performSelector: @selector(description)]; 下面的例子展示了如何根据条件动态决定执行那个方法 123SEL method = (void1) ? @selector(activate:) : @selector(hide:);id obj = (cond2) ? MyDocument : defaultDocument;[target performSelector:method withObject:obj] 这种调用方式很想 C 语言中函数指针的用法，使用函数指针可以实现和上面的程序同样的功能。 函数指针是函数在内存中的地址。指针对应的函数是在编译的时候决定的，不能够执行指定之外的函数。SEL 类型就相当于方法名，根据消息接受者的不同（上例子中 target 的赋值），来动态执行不同的方法。 通过 SEL 类型来指定要中子星的方法，这就是 Objectivce-C消息发送的方式。也正是通过这种方法才实现了 Objectivce-C的动态性 消息搜索对象收到一个消息后执行哪个方法是动态决定的。 所有的实例变量都存在一个 Class 类型的 isa 变量，它就是类对象。当收到消息后，运行时系统会检查类内是否有和这个消息选择器相同的方法，如果有就执行对应的方法，如果没有就通过类对象中指向父类的指针来查找父类中是否有对应的方法。如果一直找到根类都没有找到对应的方法，就会提示执行时错误。 如果每次收到消息都需要查找对应的方法的话，消息发送过程的开销就会很大，是针对这种情况，运行时内部会缓存一个散列表，表中记录着某个类拥有和什么样的选择器相对应的方法、方法被定义在何处等信息。这样一来，当下次在收到同样的消息时，直接利用上次缓存好的信息即可。 NSObject 中定义了可以动态检查一个对象是否能够响应某个选择器的方法。 12345- (BOOL) respondsToSelector: (SEL) aSelector 查询消息的接收者中是否能够响应 aSelector 的方法，包括从父类继承来的方法，如果存在的话则返回 YES- (BOOL) instancesRespondToSelector: (SEL) aSelector 查询消息的接收者所属的类中是否能够响应 aSelector 的实例方法，如果存在的话则返回 YES 一函数的形式来调用方法类中定义的方法通常是以函数的形式来实现的，但通常在编程的时候并不会直接操作方法所对应的函数。 但如果想尽可能第让程序更快一点，或者需要按照 C 语言的管理传递函数指针的时候，可以直接调用方法对应的函数，以节省发送消息的开销。另外执行时动态加载方法的定义等时，也可以将方法作为函数调用。但是需要注意的是，如果以函数的形式来调用方法的话，将无法利用面向对象的动态绑定等功能。虽然消息发送同函数调用相比确实慢一点，但却有面向对象的动态绑定、多态等优点。同这些优点相比，速度上略微的损失是不值得一提的。而其实消息发送的速度也非常的快。 通过使用下面的方法，可以获得某个对象持有的方法的函数指针，这些方法都被定义在 NSObject 中。 1234- (IMP) methodForSelector: (SEL) aSelector 搜索和执行选择器对应的方法，并返回指向该方法实现的函数指针。实例对象和类对象都可以使用这个方法。对实例对象使用时，会返回实例方法对应的函数，对类对象使用时，会返回类对象对应的函数+ (IMP) instanceMethodForSelector: (SEL)aSelector; 搜索和制定选择器相对应的实例方法，并返回该指向实例方法实现的函数指针 IMP 是“implemention”的缩写，它是一个函数指针，指向了方法实现代码的入口 IMP 的定义为： 12345#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id (*IMP)(id, SEL, ...); #endif 这个被指向的函数包括 id(self 指针)、调用的 SEL（方法名），以及其他参数 例如： 1- (id)setBox:(id)obj1 title:(id)obj2; foo 是这个方法所属类的一个实例变量。获取指向 setBox 的函数指针，并且通过该指针进行函数调用的过程如下： 123IMP funcp;funcp = [foo methodForSelector:@selector[setBox:title]];xyz = (*funcp)(foo,@selector[setBox:title:],param1,param2) 类对象和跟对象因为累对象也是一个对象，所以累对象可以作为根类 NSObject 的某个子类的对象来使用。下面这句话看上去好像比较奇怪，但是实际上他是正确的，会返回 YES 1[NSString class] isKindOfClass:[NSObject class]] 这就说明了相当于类对象的类的对象是存在的。而类对象的类就被叫做元类(metaclass)。实例对象(instance object)所属的类是 class，类对象(class object)所属的类是 metaclass。 Objective-C 中的很多概念都来源于 Smalltalk，元类的概念就是其中之一。但现在的 Objective-C中已经不存在元类的概念了，程序中不能操作元类。用于表示对象的 id 类型和表示类的 Class 类实际上都是指向结构体的指针。被详细定义在/usr/include/objc 下面的 objc.h 头文件中。通过查看 objc.h 中 id和 Class 的定义，就会发现类和元类的关系如图所示。Objective-C2.0更新了基本的数据结构，但是没有改变类和元类的关系。 类 A 是 NSObject 的子类，类 B是 A 的子类。类对象和实例对象都存在一个成员变量 isa，它是一个 objc_class 类型的指针 图中带有 isa 的实现表明了 isa 指向的对象，带有 super_class 的虚线则表明了父类的关系。 类对象中保存的是实例方法，元对象中保存的是累方法。通过这样的定义能够统一实现实例方法和类方法的调用机制。 因为编程时不可以直接操作元类，所以并不需要完全了解图中的细节。大家只需要记住任何一个类对象都是继承了根类的元对象的一个实例即可。也就是说，类对象可以执行根类对象的实例方法。 例如，类对象可以执行 NSObject 的实例方法 performSelector:和 respondsToSelector:。当然提前是没有将这些方法作为类方法再次定义。 下面让我们总结一下。其中（1）和（2）我们已经介绍过了。（3）比较不容易理解， 所有类的实例对象都可以执行根类的实例方法 如果在派生类中重新定义了实例方法，新定义的方法会被执行 所有类的类对象都可以执行根类的类方法 如果在派生类中重新定义了类方法，新定义的方法会被执行 所有类的类对象都可以执行根类的实例方法 即使在派生类中重新定义了实例方法，根类中的方法也会被执行 如果在派生类中将实例方法作为类方法重新定义了的话，新定义的方法会被执行 参考文献① Objectivce-C编程全解（第三版） [日]荻原刚志 著 唐璐 翟俊杰 译","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"UITableView 系统 API实现滑动删除Cell","slug":"2016-04-23 UITableView API实现滑动删除Cell","date":"2016-04-23T08:05:19.000Z","updated":"2018-04-10T10:52:18.303Z","comments":true,"path":"2016/04/23/cjlz9pr230020abrdjgtdz0kf/","link":"","permalink":"http://www.maksim.website/2016/04/23/cjlz9pr230020abrdjgtdz0kf/","excerpt":"","text":"#UITableView 系统 API实现滑动删除Cell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import UIKitclass ViewController: UIViewController &#123; private lazy var tableview:UITableView = &#123; let tb = UITableView(frame: CGRectZero,style: UITableViewStyle.Plain) tb.dataSource = self tb.delegate = self tb.registerClass(UITableViewCell.self, forCellReuseIdentifier: &quot;Cell&quot;) return tb &#125;() private var dataArray = [&quot;lazy&quot;,&quot;make&quot;,&quot;help&quot;,&quot;papa&quot;] override func viewDidLoad() &#123; super.viewDidLoad() view = tableview &#125;&#125;extension ViewController:UITableViewDataSource&#123; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return dataArray.count; &#125; func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableview.dequeueReusableCellWithIdentifier(&quot;Cell&quot;, forIndexPath: indexPath) cell.textLabel?.text = dataArray[indexPath.row] return cell &#125;&#125;extension ViewController:UITableViewDelegate&#123; //1.设置Cell 可编辑 func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool &#123; return true &#125; //2.进入编辑模式，滑动初选删除按钮 func tableView(tableView: UITableView, titleForDeleteConfirmationButtonForRowAtIndexPath indexPath: NSIndexPath) -&gt; String? &#123; return &quot;删除&quot; &#125; //3.响应删除按钮事件 func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) &#123; tableview.setEditing(false, animated: true) print(&quot;删除\\(dataArray[indexPath.row])&quot;) dataArray.removeAtIndex(indexPath.row) tableview.reloadData() &#125;&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"iOS多线程","slug":"2016-03-22 多线程-nsoperation","date":"2016-03-22T08:05:19.000Z","updated":"2018-06-19T01:37:19.669Z","comments":true,"path":"2016/03/22/cjlz9pr2r002habrdjs3f6kr4/","link":"","permalink":"http://www.maksim.website/2016/03/22/cjlz9pr2r002habrdjs3f6kr4/","excerpt":"","text":"简介多线程是所有程序员都应该知道的一个概念，因为当一个程序开始运行，进程就已经开启了！ 多线程基本概念进程(process)和文件(files)是UNIX/Linux操作系统最基本的抽象。进程是处于执行期的程序和它所包含的资源的综合，也就是说一个进程就是处于执行期的程序。一个线程（thread）就是运行在一个程序上下文中的一个逻辑刘，不难看出，线程是进程中最基本的活动对象。 在软件工程中，上下文是一种属性的有序序列，它们为主流在环境内的对象定义环境，在对象的激活过程中创建上下文，对象呗配置为要求某些自动服务，如同步、事务、实时激活、安全性等等。又比如计算机技术中，对象鱼进程而言，上下文就是进程执行时候的环境，具体来就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。 在传统系统中，一个进程只包含一个线程。但是在现代系统中，润徐一个进程里面可以同时运行多个县城，这类程序被称之为多线程程序。所有的程序都有一个主线程（main thread，在iOS开发中，主线程主要用于UI呈现，要将耗时操作放到其他线程之中，否则UI界面会被卡死），主直选成是进程的控制流或者执行线程在多线程程序中，主线可以创建一个活多个对等线程（peer thread），从这个时间点开始，这些线程就开始兵法执行，主线程和对等线程的区别仅在于主线程总是进程中第一个运行的线程。从某种程度上看，线程可以看做是轻量级的进程（lightweight process）。 每个程序都拥有独立的线程上下文（thread context），线程ID（Thread ID，TID），程序计数器（PC），线程栈（stack），一组寄存器（register）和条件码，其中内核正式通过线程ID（TID）来识别线程，进行线程调度的。 上面的内容是否晦涩难懂，那么我们看一看百度百科是如何解释多线程的： 在百度百科中，多线程是指软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多余一个线程，今儿提高整体处理性能。就这样的一句话就解释了什么是线程和线程的作用，就是为了提高程序的执行效率，能够在同一时间段执行多个任务。 这样一来是否就容易理解了，其实每一个软件都是一个进程，每个进程中包含一个到多个的线程，我们在window有的时候程序卡死，我们使用任务管理器结束程序的时候就是杀死那个进程。进程也可能是整个程序或者是部分程序的动态执行，线程是一组指令的集合，或者是程序的特殊段，它可以在程序里面单独执行，也可以把它理解成为代码运行的上下文，所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。 线程是程序中一个单一的顺序控制流程，在单个程序中同时运行多个线程完成不同的工作，成为多线程。 线程和进程的主要区别在于子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其知心上下文，多线程主要是为了节省CPU时间，发挥利用，根据具体情况而定。线程的运行需要使用计算机的内存资源和CPU。 到了这里你应该已经知道了什么是多线程了，首先让我们来整理一下然后再进行进行学习。 进程:就是指在系统中运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间中 线程:一个进程要执行任务，必须得有线程（每一个进程只要有一条线程），一个进程的所有任务都是放在线程中完成的 线程的串行：一个线程中执行的任务是串行的，如果在一个线程中赤星多个任务，只能一个一个的按照顺序执行 多线程：一个进程中可以开启多条线程，每条线程可以并行（同时），执行不同的任务。 多线程的优缺点多线程的优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 多线程的缺点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 多线程在iOS开发中的应用主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”主线程的主要作用显示、刷新UI界面处理UI事件（比如点击事件、滚动事件、拖拽事件等）主线程的使用注意:别将比较耗时的操作放到主线程中。耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验 PthreadPOSIX线程（POSIX threads）简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一套API，在类Unix系统中，都是用Pthreads作为系统的线程。在这里只讲一下其基本使用，因为在日常的开发之中并不是很常用这种方式进行多线程的开发。 Pthread的基本使用由于Pthreads是使用C语言进行开发的，所以其使用都是C语法。 语法规则1pthread_create(pthread_t *thread,pthread_attr_t * attr,void*(*start_routine)(void*),void*arg); 创建线程thread:返回创建的线程ID attr:线程属性，调度策略、优先级等都在这里设置，如果为NULL则标识默认属性 start_rountine:线程入口函数，可以返回一个void*类型的返回值，该返回值可由pthread_join()捕获arg:传给start_rountine的参数，可以为NULL 设置线程属性线程属性通过attr进行设置设置与查询attr结构为pthread_attr_get()与pthread_attr_set()两个系列函数，也可以在创建时通过pthread_create参数参数，有些必须在线程创建时进行设置比如跳读策略。 调度策略POSIX定义一种优先级调度模型，此模型确定任何两个线程相对于对方的重要程度。当两个线程同时准备就绪的时候，系统就会自动选择具有最高优先级的线程。 SCHED_OTHER：非实时、正常SCHED_RR：实时、轮询法SCHED_FIFO：实时、先入先出，与vxworks的调度机制一致 例程： 123pthread_attr_t attr;pthread_attr_init(&amp;attr);pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);//sched_policy NSThread简介NSThread 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切,通过NSThread这个API我们可以实现简单的多线程编程,但需要管理线程的声明周期、同步、加锁等问题，这样会导致一定的性能开销，当我们进行多线程开发的时候，并不推荐此方法。 NSThread的初始化动态方法1- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 12345678910// 初始化线程NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];// 设置线程的优先级(0.0 - 1.0，1.0最高级)thread.threadPriority = 1;// 开启线程[thread start];参数解析：selector ：线程执行的方法，这个selector最多只能接收一个参数target ：selector消息发送的对象argument : 传给selector的唯一参数，也可以是nil 静态方法1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 12[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];// 调用完毕后，会马上创建并开启新线程 隐式创建线程的方法1[self performSelectorInBackground:@selector(run) withObject:nil]; 获取当前线程1NSThread *current = [NSThread currentThread]; 获取主线程1NSThread *main = [NSThread mainThread]; 暂停当前线程123456// 暂停2s[NSThread sleepForTimeInterval:2];// 或者NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];[NSThread sleepUntilDate:date]; 线程间的通信123456781.在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES];2.在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];3.在当前线程执行操作[self performSelector:@selector(run) withObject:nil]; 优缺点1.优点：NSThread比其他两种多线程方案较轻量级，更直观地控制线程对象2.缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销 NSOperationNSOperation的作用 配合使用NSOperation和NSOperationQueue实现多线程编程 NSOperation和NSOperationQueue实现多线程的具体步骤 先将需要执行的操作封装到一个NSOperation对象中 然后将NSOperation对象添加到NSOperationQueue中 系统会自动的将NSOperationQueue中的NSOperation中取出来 将取出的NSOperation封装的操作放到一条线程中执行 NSOperation的子类NSOperation是一个抽象的类,它并不具备封装操作的能力,当我们进行多线程编程的时候,必须使用它的子类. NSInvocationOperation NSBlockOperation 自定义子类继承NSOperation,实现内部相对应的方法 NSInvocationOperation创建NSInvocationOperation对象 1-(id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg; 调用start方法开启线程 1-(void)start; 一旦执行操作，就会调用target的sel方法默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 NSBlockOperation创建NSBlockOperation对象 1+(id)blockOperationWithBlock:(void (^)(void))block; 通过addExecutionBlock:方法添加更多的操作 1-(void)addExecutionBlock:(void (^)(void))block; 只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 NSOperationQueueNSOperationQueue可以调用start放啊来进行执行任务,但是默认是同步执行的 如果将NSOperationQueue添加到NSOperationQueue操作队列中,系统会自动异步执行. 添加操作: 12-(void)addOperation:(NSOperation *)op;-(void)addOperationWithBlock:(void (^)(void))bloc 最大并发数什么是并发数 同时执行的任务数比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 12-(NSInteger)maxConcurrentOperationCount;-(void)setMaxConcurrentOperationCount:(NSInteger)cnt; 队列的取消,暂停,回复取消队列的所有操作 1-(void)cancelAllOperations; 提示：也可以调用NSOperation的 -(void)cancel方法取消单个操作 暂停和恢复队列 12-(void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列-(BOOL)isSuspended; 操作依赖NSOperation之间可以设置依赖来保证执行顺序比如一定要让操作A执行完后，才能执行操作B，可以这么写 1[operationB addDependency:operationA]; // 操作B依赖于操作A 可以在不同queue的NSOperation之间创建依赖关系 操作监听可以监听一个操作的执行完毕 12-(void (^)(void))completionBlock;-(void)setCompletionBlock:(void (^)(void))block; 自定义NSOperation自定义NSOperation的步骤 重写-(void)main方法，在里面实现想执行的任务 重写-(void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 GCD简介GCD 是 libdispatch 的市场名称，而 libdispatch 作为 Apple 的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点： GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。 GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。 GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力 （未完待续） 参考文献： [1] fireaxe - Pthread编程基础","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"移动info.plist后无法运行","slug":"2016-03-04 移动info.plist后无法运行","date":"2016-03-04T14:29:03.000Z","updated":"2018-06-20T05:17:02.217Z","comments":true,"path":"2016/03/04/cjlz9pr1v001sabrdge7ldhwy/","link":"","permalink":"http://www.maksim.website/2016/03/04/cjlz9pr1v001sabrdge7ldhwy/","excerpt":"","text":"今天做项目的时候,不小心将info.plist移动了,再移动回项目中的时候直接报错,查了一下百度找到了解决办法. 只需要在bulid Phases中的Copy Bundle Resources重新加入info.plist即可。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"统一设置tabBarItem字体样式","slug":"2016-03-04 统一设置tabBarItem字体样式","date":"2016-03-04T12:14:36.000Z","updated":"2018-06-25T12:42:01.768Z","comments":true,"path":"2016/03/04/1/","link":"","permalink":"http://www.maksim.website/2016/03/04/1/","excerpt":"","text":"一般我们在使用tabBar的时候都需要进行自定义,统一设置其字体样式的方法如下. 在iOS开发中有两个方法:load与initialize. load是在类加载的时候会自动调用,iOS工程在运行的时候,会自动将工程内的类加载到内存之中,这个时候就是load执行的时候. initialize是在第一次使用或者调用子类的时候回自动执行,具有初始化类的功能,我们可以通过这两个方式的执行特性来对tabBarItem的样式进行设置. tabBarItem其实是一个模型(Item是苹果对模型的一种命名规范),我们并不能够对模型直接格式操作,但是我们可以对控件的格式进行设置,这样也就是使用到了文本属性(富文本)来进行设置. 代码如下: 12345678910+(void)initialize&#123; //获取所有的tabBarItem 获取所有的外观 UITabBarItem *item = [UITabBarItem appearance]; NSMutableDictionary *att = [[NSMutableDictionary alloc]init]; [att setObject:[UIColor grayColor] forKey:NSForegroundColorAttributeName]; NSMutableDictionary *selectedAtt = [[NSMutableDictionary alloc]init]; [selectedAtt setObject:[UIColor orangeColor] forKey:NSForegroundColorAttributeName]; [item setTitleTextAttributes:att forState:UIControlStateNormal]; [item setTitleTextAttributes:selectedAtt forState:UIControlStateSelected]; &#125; 这样一来我们就完成了样式的设置,appearance在英语中的意思是外观,在iOS中算是一个标记,通过这个标记,我们可以取得UITabBarItem中所有Item的外观.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"使用iOS本地通知","slug":"2016-03-03 IOS推送通知","date":"2016-03-03T07:06:05.000Z","updated":"2018-06-25T12:41:56.683Z","comments":true,"path":"2016/03/03/1/","link":"","permalink":"http://www.maksim.website/2016/03/03/1/","excerpt":"","text":"在 iOS 开发中推送通知被分为两种，本地通知与推送通知， 本地通知是应用在后台运行时，把一些消息提示给用户，一个很好的例子就是基于定位的应用，这类应用在后台运行，到他发现到达某个特殊地点是给予用户提醒，本地通知只能使用在 iOS 设备中，他可以立即发出通知也可以在计划时间后发出。 本地通知只是应用所在设备上给用户通知，而推送通知是远程通知，它是由远程服务器推送过来的。无论是哪一种，通知的形式都是一样的。 12345678910111213141516171819202122232425262728//本地推送,主要用于一些常规类的提醒 /** * 1.健康类 定时几点运动 * 2.社交类 几点约会 * 3.游戏类 到时见领取奖励 * 4.新闻类 每日早间提醒阅读 * 5.医药类 你该吃药了,药别停 */ //在iOS8下需要注册一下本地推送 [[UIApplication sharedApplication] registerUserNotificationSettings: [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge|UIUserNotificationTypeAlert|UIUserNotificationTypeSound categories:nil]]; //初始创建本地推送 UILocalNotification *local = [[UILocalNotification alloc]init]; //设置推送时间 local.fireDate = [NSDate dateWithTimeIntervalSinceNow:5]; //设置推送的内容 local.alertBody = @&quot;你该吃药了!&quot;; //设置时区 根据当前手机时区设置的 local.timeZone = [NSTimeZone defaultTimeZone]; //设置重复的间隔 local.repeatInterval = kCFCalendarUnitDay; //设置推送声音(本地需要有相对应的声音,该声音需要少于三十秒) //local.soundName = UILocalNotificationDefaultSoundName; local.soundName = @&quot;音效.caf&quot;; local.userInfo = @&#123;@&quot;name&quot;:@&quot;王花花&quot;&#125;; local.applicationIconBadgeNumber = 9999; //加入到系统级推送 [[UIApplication sharedApplication] scheduleLocalNotification:local]; 清除本地推送 1234567891011//如何取消推送//获取目前已经加入本地消息推送的有几个.NSArray *array = [[UIApplication sharedApplication]scheduledLocalNotifications];//遍历推送内容for (UILocalNotification *notification in array) &#123; NSLog(@&quot;%@&quot;,notification.userInfo); //如果遇到我们想要取消的本地推送 [[UIApplication sharedApplication] cancelLocalNotification:notification];&#125;//如果全部取消//[[UIApplication sharedApplication]cancelAllLocalNotifications];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"iOS多线程概念入门","slug":"2016-03-01 iOS多线程概念入门","date":"2016-03-01T04:11:20.000Z","updated":"2018-04-10T10:52:18.299Z","comments":true,"path":"2016/03/01/cjlz9pr1p001kabrduif4sqp6/","link":"","permalink":"http://www.maksim.website/2016/03/01/cjlz9pr1p001kabrduif4sqp6/","excerpt":"","text":"简介我们为何需要多线程呢？多线程其实是为了实现并发执行，而且线程是并发执行多个代码路径的多种技术之中比较轻量级的一种（对应较重的实现是多进程）。 在单核 CPU 时代，支持多线程的操作系统会通过分配 CPU 计算时间，来实现软件层面的多线程。创建线程，线程间切换都是有成本开销的。但由于多线程可以避免阻塞所造成的 CPU 计算时间浪费，所以多线程所带来的开销成本总体看来是值得的。任务一般都可以被拆分成多个子任务，如果一个子任务发生了阻塞，计算时间就可以分配给其他子任务。这样就提高了 CPU 的利用率。 在多核 CPU 时代，就更好理解了。由于硬件上就支持多线程技术，就可以让多个线程真正同时地运行。如果任务能够被拆分，各个子任务就能并行地在 CPU 上运行，这就能显著加快运行速度。 总结说来，多线程的目的是，通过并发执行提高 CPU 的使用效率，进而提供程序运行效率。 OS X 和 iOS 是多线程操作系统，它们追随 UNIX 系统使用了 POSIX 线程模型。OS X 和 iOS 都提供了一套底层的 C 语言 POSIX 线程 API 来创建和管理线程。但实际应用开发中，除非需要跨平台，我们并不常直接使用 POSIX 线程 API，而是使用系统或语言提供的其他一些更为简单的方案。 多线程基本概念在了解多线程之前，我们应该先搞懂几个概念，首先了解几个基本概念 进程 线程 多线程 主线程 进程进程（process），是计算机中已运行程序的实体。在面向线程设计的系统中，进程是线程的容器。程序本身只是指令、数据以及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，而且每个进程皆可以同步或者异步的方法独立运行。现代计算机系统刻在统一时间内以进程的形式将多个程序加载到存储器中，并且借由时间共享（分时复用），在一个处理器上表选出同时运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上） 线程线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程（软件多线程）多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个执行绪，进而提升整体处理性能。 软件多线程。即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。 主线程在一个 iOS 程序运行后，默认会开启1条线程。称之为主线程或者是 UI 线程。 主线程是进程的控制流或者执行线程在多线程程序中，主线可以创建一个或多个对等线程（peer thread），从这个时间点开始，这些线程就开始兵法执行，主线程和对等线程的区别仅在于主线程总是进程中第一个运行的线程。从某种程度上看，线程可以看做是轻量级的进程（lightweight process）。 每个程序都拥有独立的线程上下文（thread context），线程ID（Thread ID，TID），程序计数器（PC），线程栈（stack），一组寄存器（register）和条件码，其中内核正式通过线程ID（TID）来识别线程，进行线程调度的。 我们要知道，一条线程只能处理一个任务，如果将大规模运算放到主线程之中，就会造成 UI 界面卡顿的现象。 线程进程的主要区别线程和进程的主要区别在于子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其知心上下文，多线程主要是为了节省CPU时间，发挥利用，根据具体情况而定。线程的运行需要使用计算机的内存资源和CPU。​ 多线程的优缺点多线程的优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 多线程的缺点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 参考资料[1] 维基百科 [3] OS X 和 iOS 中的多线程技术 infoq [2] fireaxe - Pthread编程基础","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"Objective-C Block的基本使用","slug":"2016-02-17 Block的基本使用","date":"2016-02-17T08:05:19.000Z","updated":"2018-04-10T10:52:18.298Z","comments":true,"path":"2016/02/17/231/","link":"","permalink":"http://www.maksim.website/2016/02/17/231/","excerpt":"","text":"什么是BlockBlock是iOS4.0后推出的一种比较特殊的数据类型，用来保存某一段代码，可以在恰当的时间取出来再调用。，应用场景有:动画、多线程、集合遍历、网络请求回调等。 用Block替换代理可以使代码更加简洁、直观，苹果官方也更推荐使用block来进行传值等操作。 Block 的定义定义和使用Block， 123456789101112131415161718192021222324252627282930-(void)viewDidLoad &#123; [super viewDidLoad]; //1、定义无参无返回值的Block void (^printBlock)() = ^()&#123; printf(&quot;no number&quot;); &#125;; printBlock(); printBlock(9); int mutiplier = 7; //3、定义名为myBlock的代码块，返回值类型为int int (^myBlock)(int) = ^(int num)&#123; return num*mutiplier; &#125; //使用定义的myBlock int newMutiplier = myBlock(3); printf(&quot;newMutiplier is %d&quot;,myBlock(3)); &#125;&#125;//定义在-viewDidLoad方法外部//2、定义一个有参数，没有返回值的Blockvoid (^printNumBlock)(int) = ^(int num)&#123; printf(&quot;int number is %d&quot;,num)；&#125;; 定义Block变量，就相当于定义了一个函数。但是区别也很明显，因为函数肯定是在-viewDidLoad方法外面定义，而Block变量定义在了viewDidLoad方法内部。当然，我们也可以把Block定义在-viewDidLoad方法外部，例如上面的代码块printNumBlock的定义，就在-viewDidLoad外面。 再来看看上面代码运行的顺序问题，以第（3）个myBlock距离来说，在定义的地方，并不会执行Block{}内部的代码，而在myBlock(3)调用之后才会执行其中的代码，这跟函数的理解其实差不多，就是只要在调用Block（函数）的时候才会执行Block体内（函数体内）的代码。所以上面的简单代码示例，我可以作出如下的结论， 在类中，定义一个Block变量，就像定义一个函数； Block可以定义在方法内部，也可以定义在方法外部； 只有调用Block时候，才会执行其{}体内的代码； 关于第（2）条，定义在方法外部的Block，其实就是文件级别的全局变量 那么在类中定义一个Block，特别是在-viewDidLoad方法体内定义一个Block到底有什么意义呢？我表示这时候只把它当做私有函数就可以了。我之前说过，Block其实就相当于代理，那么这时候我该怎样将其与代理类比以了解呢。这时候我可以这样说：本类中的Block就相当于类自己服从某个协议，然后让自己代理自己去做某个事情。很拗口吧？看看下面的代码， 123456789//定义一个协议@protocol ViewControllerDelegate -(void)selfDelegateMethod;@end //本类实现这个协议ViewControllerDelegate@interface ViewController () @property (nonatomic, assign) id delegate;@end 接着在-viewDidLoad中的代码如下， 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view from its nib. self.delegate = self; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(selfDelegateMethod)] &#123; [self.delegate selfDelegateMethod]; &#125;&#125; #pragma mark - ViewControllerDelegate method//实现协议中的方法- (void)selfDelegateMethod&#123; NSLog(@&quot;自己委托自己实现的方法&quot;);&#125; 看出这种写法的奇葩地方了吗？自己委托自己去实现某个方法，而不是委托别的类去实现某个方法。本类中定义的一个Block其实就是闲的蛋疼，委托自己去字做某件事情，实际的意义不大，所以你很少看见别人的代码直接在类中定义Block然后使用的，Block很多的用处是跨越两个类来使用的，比如作为property属性或者作为方法的参数，这样就能跨越两个类了。 __block关键字的使用在Block的{}体内，是不可以对外面的变量进行更改的，比如下面的语句， 123456789- (void)viewDidLoad &#123; //将Block定义在方法内部 int x = 100; void (^sumXAndYBlock)(int) = ^(int y)&#123; x = x+y; printf(&quot;new x value is %d&quot;,x); &#125;; sumXAndYBlock(50);&#125; 这段代码有什么问题呢，Xcode会提示x变量错误信息：Variable is not assigning (missing__block type)，这时候给int x = 100;语句前面加上__block关键字即可，如下， 1__block int x = 100; 这样在Block的{}体内，就可以修改外部变量了。 Block作为Property属性实现页面之间传值需求：在ViewController中，点击Button，push到下一个页面NextViewController，在NextViewController的输入框TextField中输入一串字符，返回的时候，在ViewController的Label上面显示文字内容， 1、第一种方法：首先看看通过“协议/代理”是怎么实现两个页面之间传值的吧， 12345678910//NextViewController是push进入的第二个页面//NextViewController.h 文件//定义一个协议，前一个页面ViewController要服从该协议，并且实现协议中的方法@protocol NextViewControllerDelegate - (void)passTextValue:(NSString *)tfText;@end @interface NextViewController : UIViewController @property (nonatomic, assign) id delegate;@end //NextViewController.m 文件//点击Button返回前一个ViewController页面 1234567- (IBAction)popBtnClicked:(id)sender &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(passTextValue:)]) &#123; //self.inputTF是该页面中的TextField输入框 [self.delegate passTextValue:self.inputTF.text]; &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 接下来我们在看看ViewController文件中的内容， 123456789101112131415161718//ViewController.m 文件@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *nextVCInfoLabel;@end//点击Button进入下一个NextViewController页面- (IBAction)btnClicked:(id)sender&#123;NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil];nextVC.delegate = self;//设置代理[self.navigationController pushViewController:nextVC animated:YES];&#125;//实现协议NextViewControllerDelegate中的方法#pragma mark - NextViewControllerDelegate method- (void)passTextValue:(NSString *)tfText&#123;//self.nextVCInfoLabel是显示NextViewController传递过来的字符串Label对象self.nextVCInfoLabel.text = tfText;&#125; 这是通过“协议/代理”来实现的两个页面之间传值的方式。2、第二种方法：使用Block作为property，实现两个页面之间传值，先看看NextViewController文件中的内容， 1234567891011//NextViewController.h 文件@interface NextViewController : UIViewController @property (nonatomic, copy) void (^NextViewControllerBlock)(NSString *tfText);@end//NextViewContorller.m 文件- (IBAction)popBtnClicked:(id)sender &#123; if (self.NextViewControllerBlock) &#123; self.NextViewControllerBlock(self.inputTF.text); &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 再来看看ViewController文件中的内容， 1234567891011- (IBAction)btnClicked:(id)sender&#123; NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil]; nextVC.NextViewControllerBlock = ^(NSString *tfText)&#123; [self resetLabel:tfText];&#125;; [self.navigationController pushViewController:nextVC animated:YES];&#125;#pragma mark - NextViewControllerBlock method- (void)resetLabel:(NSString *)textStr &#123; self.nextVCInfoLabel.text = textStr;&#125; 好了就这么多代码，可以使用Block来实现两个页面之间传值的目的，实际上就是取代了Delegate的功能。 另外，博客中的代码Sample Code可以再Github下载，如果因为Github被墙了，可以在终端使用git clone + 完整链接，即可克隆项目到本地。 Github中的代码，可以开启两种调试模式，你需要在项目的配置文件BlockSamp-Prefix.pch中注释或者解注释下面的代码. 1#define Debug_BlcokPassValueEnable 即可开启两种调试的方式，如果注释了上面的语句就是使用Delegate进行调试；否则使用Block进行调试。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"CGFloat、CGPoint、CGSize和CGRect","slug":"2016-01-31 CGFloat、CGPoint、CGSize和CGRect","date":"2016-01-30T16:27:31.000Z","updated":"2018-04-10T10:52:18.297Z","comments":true,"path":"2016/01/31/2/","link":"","permalink":"http://www.maksim.website/2016/01/31/2/","excerpt":"","text":"CGFloat、CGPoint、CGSize和CGRect主要是用来描述UI控件的几何属性的基本类型。 CGFloat: 浮点值的基本类型 CGPoint: 表示一个二维坐标系中的点 CGSize: 表示一个矩形的宽度和高度 CGRect: 表示一个矩形的位置和大小 CGFloatCGFloat是这四种类型中最基本的类型，这是一个浮点型的数据，他就是一个数值，下面三种类型都需要使用该数值来进行赋值，当我们使用CMD键进入CGBase.h文件后，可以清楚的看到关于CGFloat的定义，映入眼帘的是一个别名定义： 1typedef CGFLOAT_TYPE CGFloat; 当我们CMD点击CGFLOAT_TYPE的时候，我们可以跳转到宏定义的代码区域，其实就在其上面 1234567891011#if defined(__LP64__) &amp;amp;&amp;amp; __LP64__# define CGFLOAT_TYPE double# define CGFLOAT_IS_DOUBLE 1# define CGFLOAT_MIN DBL_MIN# define CGFLOAT_MAX DBL_MAX#else# define CGFLOAT_TYPE float# define CGFLOAT_IS_DOUBLE 0# define CGFLOAT_MIN FLT_MIN# define CGFLOAT_MAX FLT_MAX#endif 我们可以清晰的看到这就是一段宏定义，#if defined(LP64) &amp;&amp; LP64这一段代码主要使用来判断操作系统是64位还是32位，如果是64位那么CGFloat就是double类型，如果不是那边是32位操作系统，则会被系统定义为float类型,接下来的三种类型都是基于CGFloat的结构体。 CGPointCGPoint用于表示二维坐标系中的某一个点，在IOS中以左上角（0，0）为起始坐标。CMD进入CGGeometry.h中便可以直接查看其类型的定义如下（CGSize、CGRect都在此文件中）： 12345struct CGPoint &#123; CGFloat x; CGFloat y;&#125;;typedef struct CGPoint CGPoint; CGSizeCGSize主要用于描述UI控件的宽与高 12345struct CGSize &#123; CGFloat width; CGFloat height;&#125;;typedef struct CGSize CGSize; CGRectCGRect同样也是一个结构体，通过上面的了解，我们知道了原来CGRect是由CGSize和CGPoint组成，这样一来便可以确定一个UI空间的大小与位置。 12345struct CGRect &#123; CGPoint origin; CGSize size;&#125;;typedef struct CGRect CGRect;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"懒加载与模型转换","slug":"2016-01-30 懒加载与模型转换","date":"2016-01-30T15:48:32.000Z","updated":"2018-06-20T05:11:34.153Z","comments":true,"path":"2016/01/30/219/","link":"","permalink":"http://www.maksim.website/2016/01/30/219/","excerpt":"","text":"所谓的懒加载其实就是重写getter方法，以实现实例化类的同时自动加载数据，简化代码的一个作用,代码如下 12345678//这是一个实例-(NSArray*)question&#123;if (!_question) &#123;//判断是否为空_question = [GZModelName questionList];&#125;return _question;&#125; 接下来便是模型转化,因为使用点语法写起来的方法也非常简单，只需要重新定义构造方法即可,其中用到的plist文件如下图： .h文件 123456789@interface GZQuestion : NSObject@property (nonatomic,copy) NSString *answer;@property (nonatomic,copy) NSString *icon;@property (nonatomic,copy) NSString *title;@property (nonatomic,strong) NSArray *options;-(instancetype)initWithDic:(NSDictionary *)dic;+(instancetype)questionWithDic:(NSDictionary *)dic;+(NSArray*)questionList;@end .m文件 12345678910111213141516171819202122-(instancetype)initWithDic:(NSDictionary *)dic&#123;if (self = [super init]) &#123;//KVC 直接从字典中读取对应的值，需要注意的是，定义的属性名称，要与字典的key值相对应，否则会崩溃[self setValuesForKeysWithDictionary:dic];&#125;return self;&#125;+(instancetype)questionWithDic:(NSDictionary *)dic&#123;return [[self alloc]initWithDic:dic];&#125;+(NSArray *)questionList&#123;//加载plistNSString *path = [[NSBundle mainBundle] pathForResource:@&quot;questions&quot; ofType:@&quot;plist&quot;];NSArray *dicArray = [NSArray arrayWithContentsOfFile:path];//字典转模型NSMutableArray *tempArray = [NSMutableArray array];for (NSDictionary *dic in dicArray) &#123;GZQuestion *question = [GZQuestion questionWithDic:dic];[tempArray addObject:question];&#125;return tempArray;&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://www.maksim.website/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"Objective-C 简单的数组排序","slug":"2016-01-05 OC简单数组排序","date":"2016-01-05T07:53:07.000Z","updated":"2018-06-20T05:14:30.785Z","comments":true,"path":"2016/01/05/3/","link":"","permalink":"http://www.maksim.website/2016/01/05/3/","excerpt":"","text":"123456789NSMutableArray *array = [NSMutableArray arrayWithObjects:@\"8123\",@\"456\",@\"378\", nil];NSComparator cmp = ^(id obj,id obj1) &#123; return [obj compare:obj1];&#125;;[array sortUsingComparator:cmp];NSLog(@\"%@\",array);&lt;/pre&gt;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/tags/iOS/"}]},{"title":"iOS图层树","slug":"2015-12-21 图层树","date":"2015-12-20T16:00:00.000Z","updated":"2018-04-10T11:11:00.589Z","comments":true,"path":"2015/12/21/cjlz9pr170015abrdey1ceue9/","link":"","permalink":"http://www.maksim.website/2015/12/21/cjlz9pr170015abrdey1ceue9/","excerpt":"","text":"图层树Core Animation 是一个符合引擎，塔的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分分解成独立的图层，存储在一个叫做图层数的体系中，于是这个树形成了 UIKit 以及在 iOS 10应用程序当中你所看能在屏幕上看见的一切的基础。 图层与视图如果你曾经在 iOS 10或MacOS 平台上面写过应用程序，你可能能会对视图的概念比较熟悉。一个视图就是在屏幕上显示一个矩形块（比如图片，文字或者视频），它能拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系。 图1.1一种典型的 iOS 屏幕（左边）和型城市图的层级关系（右边） 在 iOS 中，所有的视图都从一个叫做 UIview 的基类派生而来，UIView 可以处理触摸事件，可以支持基于 Core Graphics 绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。 CALayerCALayer类在概念上和 UIView 类似，同样也是一些被层级关系树管理的矩形块，同样可以包含一些内容（像图片，文本或者背景色），管理子视图的位置。它们有一些方法和尚需经用来做动画和变换。 和 UIview 最大的不同是 CALayer 不处理用户的交互。 CALayer 兵不清楚具体的响应链（iOS通过视图层级关系用来传递触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触电在图层的范围之内。 平行的层级关系每一个 UIView 都有一个 CALayer 实例的图层属性，也就是所谓的 Backing layer,视图的职责就是创建并管理这个图层，以确保子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应是在层级关系树当中有相同的操作（见图1.2） 图1.2 图层的树状结构（左边）以及对应的视图层级（右边） 实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView 仅仅是对它的一个封装，提供了一些 iOS 类似于处理触摸事件的具体功能，以及 Core Animation 底层方法的高级借口。 但是为什么 iOS 要基于 UIview 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这也是能避免很多重复代码。在 iOS 和 Mac OS两个平台上，时间和用户交互有很多地方不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么 iOS有 UIKit 和 UIView，但是 MacOS 有 APPKit 和 NSView 的元婴。他们功能上很类似，但是在实现上有着显著的区别。 绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。+ 实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[]},{"title":"iOS多线程","slug":"2015-12-10 iOS 多线程","date":"2015-12-10T08:04:12.000Z","updated":"2018-06-20T05:04:27.511Z","comments":true,"path":"2015/12/10/1/","link":"","permalink":"http://www.maksim.website/2015/12/10/1/","excerpt":"","text":"NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在制定的线程中、或者立即、延迟执行某个方法调用个。这个方法给用户实现多线程编程最简单的方法。 在当前线程中执行方法： 123- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay: (NSTimeInterval)delay inModes:(NSArray *)modes 在指定线程中执行方法： 12345- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array 在主线程中执行方法： 12345- (void)performSelectorOnMainThread: (SEL)selector withObject:(id)argument waitUntilDone:(BOOL)wait- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array 在后台线程中执行方法： 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg 这一系列方法简单易用，但只提供了有限的几个选择：指定执行的方法（但传入方法的参数数量有限制）；指定是在当前线程，还是在主线程，还是在后台线程执行；指定是否需要阻塞当前线程等待结果。 例如，以下代码使得方法 foo: 在一个新的后台线程执行，并传入了 object 参数： 12SEL selector ＝ @selector(foo:);[self performSelectorInBackground:selector withObject:object]; 以下代码使得 updateUI 方法在主线程内得到执行，并且当前线程会被阻塞，直到主线程执行完该函数： 1[self performSelectorOnMainThread:@selector(updateUI) withObject:nil waitUntilDone:YES];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://www.maksim.website/categories/iOS/"}],"tags":[{"name":"Objc,多线程","slug":"Objc-多线程","permalink":"http://www.maksim.website/tags/Objc-多线程/"}]},{"title":"","slug":"2015-12-02 PHP中的$this","date":"2015-12-01T16:00:00.000Z","updated":"2018-06-25T12:37:09.106Z","comments":true,"path":"2015/12/02/1/","link":"","permalink":"http://www.maksim.website/2015/12/02/1/","excerpt":"","text":"当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。 123456789101112&lt;?phpclass SimpleClass&#123; // property declaration public $var = 'a default value'; // method declaration public function displayVar() &#123; echo $this-&gt;var; &#125;&#125;?&gt; $this 伪变量的示例 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass A&#123; function foo() &#123; if (isset($this)) &#123; echo '$this is defined ('; echo get_class($this); echo \")\\n\"; &#125; else &#123; echo \"\\$this is not defined.\\n\"; &#125; &#125;&#125;class B&#123; function bar() &#123; // Note: the next line will issue a warning if E_STRICT is enabled. A::foo(); &#125;&#125;$a = new A();$a-&gt;foo();// Note: the next line will issue a warning if E_STRICT is enabled.A::foo();$b = new B();$b-&gt;bar();// Note: the next line will issue a warning if E_STRICT is enabled.B::bar();?&gt; 以上例程会输出： 1234567$this is defined (A)$this is not defined.$this is defined (B)$this is not defined. 由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"PHP基础教程：将Session存储到MySQL中","slug":"2015-10-20 PHP基础教程：Session入库","date":"2015-10-19T16:00:00.000Z","updated":"2018-06-29T15:41:48.343Z","comments":true,"path":"2015/10/20/1/","link":"","permalink":"http://www.maksim.website/2015/10/20/1/","excerpt":"","text":"我们知道，Session是一种会话技术，用来实现跨脚本共享数据。Session是存放在服务器端的文件里的，因此Session有可能因为文件数量过多，会在查询 Session 文件以及读取的时候产生压力。一般我们有三种解决方案 使用文件分层（缺点：I/O操作是系统的一个瓶颈，即使分层也不能避免此问题） 将session放入数据库 将session放在内存中（非关系性数据库）（缺点：对服务器内存要求教高） 将Session存入MySQL数据库，也就是我们要讲的重点（其实并不建议这么做，因为在高并发和大流量的情况下，无疑会增加MySQL的压力，建议放到缓存服务中，如Memcache、Redis）， 要实现session入库，首先我们要了解session 机制： 在PHP中，Session 可以理解为一套单独的小系统，在该系统中有很多关于 Session 的处理方法，用来解决各种问题，用户只需要在 Session 之外，调用session_start函数（session系统的一个接口） 其他操作都是session系统帮忙去处理 由图可知我们应该修改session机制中的session的读取和最终的写入。要修改session机制要借助一个系统函数session_set_save_handler():用来使用外部用户定义的函数，来取代session系统本身的函数。 1bool session_set_save_handler ( callable $open , callable $close , callable $read , callable $write , callable $destroy , callable $gc [, callable $create_sid [, callable $validate_sid [, callable $update_timestamp ]]] ) open(string $savePath, string $sessionName) open 回调函数类似于类的构造函数， 在会话打开的时候会被调用。 这是自动开始会话或者通过调用 session_start() 手动开始会话 之后第一个被调用的回调函数。 此回调函数操作成功返回 TRUE，反之返回 FALSE。 close() close 回调函数类似于类的析构函数。 在 write 回调函数调用之后调用。 当调用 session_write_close() 函数之后，也会调用 close 回调函数。 此回调函数操作成功返回 TRUE，反之返回 FALSE。 read(string $sessionId) 如果会话中有数据，read 回调函数必须返回将会话数据编码（序列化）后的字符串。 如果会话中没有数据，read 回调函数返回空字符串。 在自动开始会话或者通过调用 session_start() 函数手动开始会话之后，PHP 内部调用 read 回调函数来获取会话数据。 在调用 read 之前，PHP 会调用 open 回调函数。 read 回调返回的序列化之后的字符串格式必须与 write 回调函数保存数据时的格式完全一致。 PHP 会自动反序列化返回的字符串并填充$_SESSION 超级全局变量。 虽然数据看起来和 serialize() 函数很相似， 但是需要提醒的是，它们是不同的。 请参考：session.serialize_handler。 write(string $sessionId, string $data) 在会话保存数据时会调用 write 回调函数。 此回调函数接收当前会话 ID 以及 $_SESSION 中数据序列化之后的字符串作为参数。 序列化会话数据的过程由 PHP 根据 session.serialize_handler 设定值来完成。 序列化后的数据将和会话 ID 关联在一起进行保存。 当调用 read 回调函数获取数据时，所返回的数据必须要和 传入 write 回调函数的数据完全保持一致。 PHP 会在脚本执行完毕或调用 session_write_close() 函数之后调用此回调函数。 注意，在调用完此回调函数之后，PHP 内部会调用 close回调函数。 Note: PHP 会在输出流写入完毕并且关闭之后 才调用 write 回调函数， 所以在 write 回调函数中的调试信息不会输出到浏览器中。 如果需要在 write 回调函数中使用调试输出， 建议将调试输出写入到文件。 destroy($sessionId) 当调用 session_destroy() 函数， 或者调用 session_regenerate_id() 函数并且设置 destroy 参数为 TRUE 时， 会调用此回调函数。此回调函数操作成功返回 TRUE，反之返回 FALSE。 gc($lifetime) 为了清理会话中的旧数据，PHP 会不时的调用垃圾收集回调函数。 调用周期由 session.gc_probability 和 session.gc_divisor 参数控制。 传入到此回调函数的 lifetime 参数由 session.gc_maxlifetime 设置。 此回调函数操作成功返回 TRUE，反之返回 FALSE。 create_sid() 当需要新的会话 ID 时被调用的回调函数。 回调函数被调用时无传入参数， 其返回值应该是一个字符串格式的、有效的会话 ID。 因此我们要准备六个函数。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?php//session入库//以为修改session机制必须借助session_set_save_handler()函数，该函数需要6个可以调用的回调函数，因此需要创建6个人对应的函数//1.开启session机制function sess_open() &#123; //开启资源 //连接数据库 mysql_connect('localhost','root',''); mysql_query('set names utf8'); mysql_query('use session'); echo FUNCTION,'&lt;br/&gt;';&#125;//2.关闭sessionfunction sess_close() &#123; //关闭资源 mysql_close(); echo FUNCTION,'&lt;br/&gt;';&#125;//3.读取sessionfunction sess_read($sess_id) &#123; //从数据库读取数据 //根据sess_id（由系统提供）获取数据 //读数据时要过滤掉过期的数据 $expire=time()-ini_get('session.gc_maxlifetime'); $sql=\"selsct * from session where sess_id='&#123;$sess_id&#125;' and sess_expire&gt;='&#123;$expire&#125;'\"; res=mysql_query(sql); //得到的是一个数组 if(sess=@mysql_fetch_assoc(res)) &#123; //得到一个序列化后的字符串 //要进行反序列化，read只负责读取数据，不负责加工数据 return $sess['sess_info']; &#125; echo FUNCTION,'&lt;br/&gt;';&#125;//4.写入sessionfunction sess_write(sess_id,sess_info) &#123; //向数据库中写入数据 $time=time(); $sql=\"replace into session values('&#123;$sess_id&#125;','&#123;$sess_info&#125;','&#123;$time&#125;')\"; mysql_query($sql); echo FUNCTION,'&lt;br/&gt;';&#125;//5.销毁sessionfunction sess_destroy($sess_id) &#123; $sql=\"delete from session where sess_id='&#123;$sess_id&#125;'\"; return mysql_query($sql);&#125;//6.回收sessionfunction sess_gc() &#123; //从数据库删除过期的session数据 //判断session是否过期，过期的删除 $expire=ini_get('session.gc_maxlifetime'); //得到最迟的时间，在$expire之前的都是过期的 expire=time()-expire; $sql=\"delete from session where sess_expire &lt; '&#123;expire&#125;'\"; return mysql_query($sql);&#125;//使用session_set_save_handler()修改session机制session_set_save_handler('sess_open','sess_close','sess_read','sess_write','sess_destroy','sess_gc');//想要使用session，必须要用session_start()来开启session_start();$_SESSION['name']='wangqixing';$_SESSION['age']='23';//session_destroy();","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"Cookie和Session","slug":"2015-10-19 Cookie和Session","date":"2015-10-18T16:00:00.000Z","updated":"2018-06-14T13:27:24.131Z","comments":true,"path":"2015/10/19/1/","link":"","permalink":"http://www.maksim.website/2015/10/19/1/","excerpt":"","text":"CookieHTTP协议是无状态的，也就导致服务器无法分片是谁浏览了网页，为了解决此问题，1994年网景通讯的一名员工 Lou Montulli将 “magic cookies” 的概念应用到 Web 通讯中。他试图解决 Web 的第一个购物车应用，现在购物车成了购物网站的支柱。他的原始说明文档提供了 cookie 工作原理的基本信息，该文档后来被作为规范纳入到 RFC 2109（大多数浏览器的实现参考文档）中，最终被纳入到 RFC 2965 中。Montulli 也被授予 cookie 的美国专利。网景浏览器在它的第一个版本中就开始支持 cookie，现在所有 Web 浏览器都支持 cookie。 cookie是浏览器保存在用户电脑上的一小段文本，用来保存用户在网站上的必要的信息。Web页面或服务器告诉浏览器按照一定的规范存储这些信息，并且在以后的所有请求中，这些信息就会自动加在HTTP请求头中发送给服务器，服务器根据这些信息判断不同的用户。并且cookie本身是安全的。 创建CookieWeb 服务器通过发送一个称为 Set-Cookie 的 HTTP 消息头来创建一个 cookie，Set-Cookie消息头是一个字符串，其格式如下（中括号中的部分是可选的）： 1Set-Cookie: value; expires=date; path=path 在PHP开发过程中，我们可以使用setcookie函数来进行设置： 1bool setcookie ( string $name [, string $value = \"\" [, int $expire = 0 [, string $path = \"\" [, string $domain = \"\" [, bool $secure = false [, bool $httponly = false ]]]]]] ) 参数name： Cookie 名称。 value： Cookie 值。 这个值储存于用户的电脑里，请勿储存敏感信息。 比如 name 是 ‘cookiename’， 可通过 $_COOKIE[‘cookiename’]获取它的值。 expire： Cookie 的过期时间。 这是个 Unix 时间戳，即 Unix 纪元以来（格林威治时间 1970 年 1 月 1 日 00:00:00）的秒数。 也就是说，基本可以用time() 函数的结果加上希望过期的秒数。 或者也可以用 mktime()。 time()+60\\602430* 就是设置 Cookie 30 天后过期。 如果设置成零，或者忽略参数， Cookie 会在会话结束时过期（也就是关掉浏览器时）。 Note: 你可能注意到了，expire 使用 Unix 时间戳而非 Wdy, DD-Mon-YYYY HH:MM:SS GMT 这样的日期格式，是因为 PHP 内部作了转换。 path: Cookie 有效的服务器路径。 设置成 ‘/‘ 时，Cookie 对整个域名 domain 有效。 如果设置成 ‘/foo/‘， Cookie 仅仅对 domain 中 /foo/ 目录及其子目录有效（比如 /foo/bar/）。 默认值是设置 Cookie 时的当前目录。 domain: Cookie 的有效域名/子域名。 设置成子域名（例如 ‘www.example.com’），会使 Cookie 对这个子域名和它的三级域名有效（例如 w2.www.example.com）。 要让 Cookie 对整个域名有效（包括它的全部子域名），只要设置成域名就可以了（这个例子里是‘example.com’）。 旧版浏览器仍然在使用废弃的 » RFC 2109， 需要一个前置的点 . 来匹配所有子域名。 secure: 设置这个 Cookie 是否仅仅通过安全的 HTTPS 连接传给客户端。 设置成 TRUE 时，只有安全连接存在时才会设置 Cookie。 如果是在服务器端处理这个需求，程序员需要仅仅在安全连接上发送此类 Cookie （通过 $_SERVER[“HTTPS”] 判断）。 httponly : 设置成 TRUE，Cookie 仅可通过 HTTP 协议访问。 这意思就是 Cookie 无法通过类似 JavaScript 这样的脚本语言访问。 要有效减少 XSS 攻击时的身份窃取行为，可建议用此设置（虽然不是所有浏览器都支持），不过这个说法经常有争议。 PHP 5.2.0 中添加。 TRUE 或 FALSE JavaScript 操作 cookie 在 JavaScript 中通过 document.cookie 属性，你可以创建、维护和删除 cookie。创建 cookie 时该属性等同于 Set-Cookie 消息头，而在读取 cookie 时则等同于 Cookie 消息头。 删除cookie会话 cooke (Session cookie) 在会话结束时（浏览器关闭）会被删除。 持久化 cookie（Persistent cookie）在到达失效日期时会被删除。 如果浏览器中的 cookie 数量达到限制，那么 cookie 会被删除以为新建的 cookie 创建空间。 Sessionsession的作用和cookie差不多，也是用来解决Http协议不能维持状态的问题。但是session只存储在服务器端的，不会在网络中进行传输，所以较cookie来说，session相对安全一些。但是session是依赖cookie的，当用户访问某一站点时，服务器会为这个用户产生唯一的session_id,并把这个session_id以cookie的形式发送到客户端，以后的客户端的所有请求都会自动携带这个cookie（前提是浏览器支持并且没有禁用cookie）。 用下面这个图来了解下session的工作原理: 禁用cookie时如何使用session 有些时候,为了安全浏览器会禁用cookie,这时可以用传参的方式将session_id发送到服务器,session可以照常工作. 删除session会话关闭后，session会自动失效，如果想手动删除session，可以在服务器端编程实现。如PHP是这样做的 12$_SESSION = array();session_destory();","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"Cookie和Session","slug":"2015-10-18 Session的基本使用","date":"2015-10-18T16:00:00.000Z","updated":"2018-06-21T12:51:28.219Z","comments":true,"path":"2015/10/19/1/","link":"","permalink":"http://www.maksim.website/2015/10/19/1/","excerpt":"","text":"session技术Session基础PHP有内建的会话支持，帮助你维护所有cookie的状态来通过不同的页面和多访问提供持久的变量访问，会话可以让你简单地创建多页面表单（如购物车），页面之间的用户认证信息保存，以及在站点上存储持久的用户偏好。 每个初次访问的客户会分配到一个唯一的会话ID，默认情况下，会话ID会存储到cookie中，叫做PHPSESSID。如果浏览器不支持cookie或者关闭了 创建Session在创建Session之前，我们需要知道， 3，保存session信息 index1.php index2.php 先在网页中运行index1.php，再运行index2.php页面输出： session可以保存多种数据类型session不但保存字符串，还可以保存整型，布尔型，数组，对象等。 index1.php index2.php 先在网页中运行index1.php，再运行index2.php页面输出： 获取session信息直接获取所有session 根据key获取 直接获取某个变量 获取数组 获取对象，session在保存对象时候，没法保存类的信息，因此在获取对象，需要先声明这个类。可以把类单独作为一个文件，存储和读取session时候分别引用这个文件。 6，Session的更新，就是根据key值重新保存session的值。 Session的删除(1) 指定删除session中某个键值对 (2) 删除所有session 设置默认时间session数据默认存在时间是1440s（24分钟），可以在php.ini中修改， session.gc_maxlifetime = 1440。Session文件的存放路径是可以修改的，可以通过修改php.ini改变sesion文件存放路径，session.save_path = “tcp://127.0.0.1:11211”。 自动开启SessionSession使用前，先进行初始化，session_start();这样比较麻烦，可以在php.ini设置session自动初始化，session.auto_start = 0（此方法不推荐）。 10，浏览器访问页面a.php时候，服务器产生一个session文件，将其存放在服务器，同时将session_id发送给浏览器，浏览器将其保存到cookie，浏览器再次访问b.php时候，从cookie中获取session_id发送到服务器，服务器根据session_id获取相应session内容。 问题：如果浏览器禁用cookie，怎么使用session呢？ 使用URL重写的方式，url重写分为手动和自动。自动重写url就是配置php.ini，开启透明的SID，其他程序不变，自动重写url不安全，不建议使用。 开启透明SID，需要修改的php.ini是： session.use_trans_sid = 1 //由0改为1 session.use_only_cookies = 0 //是否只使用cookie来保存session值 该参数为1时，上述机制失效。 session.use_cookies = 0 //设置客户端是否使用cookie来保存session值 该参数的值不影响上述机制的进行。这个可改可不改 手动模式： index1.php index2.php 而自动模式，会将url后面自动添加PHPSESSID参数，所以在index1.php中去掉SID即可，index2.php不变。 index1.php 11，php.ini中关于session和cookie的配置 (1) session.use_trans_sid = 0，开启后，默认为每个url后添加了session_name=session_id。 (2) session.save_path=”c:/mysession”，save_path是session文件在服务器的存放路径。 (3) session.gc_maxlifetime = 1440,session默认最大生命周期，当session文件在1440s后没被访问的话，则该session被视为“垃圾文件”，并且等待gc(垃圾回收)进程的调用时候被清理掉；session.gc_probability=1;session.gc_divisor=1000;这两个参数根据网站规模合理设置。每当初始化一个session时候，有gc_probability/gc_divisor的概率执行一次垃圾回收。 我开启三个会话，则创建三个对应的session文件，当每个文件在30秒内都没被调用的话，就会被当成是“垃圾文件”，等到gc进程调用的时候，“垃圾文件”就会被unlink，因为之前我已经通过修改php.ini配置文件，将gc被调用的概率改成百分百，所以接下来，如果我重新使用任何一个浏览器刷新下页面的时候，三个session文件，应该只剩下一个了。 (4) session.cookie_lifetime，以秒数指定了发送到浏览器的cookie的生命周期，值为0表示“直到关闭浏览器”。默认为0。这个与程序中setCookie(“name”,”zhangsan”,time()+60);类似。 禁用cookie的session使用方案在浏览器中，有的用户会禁用掉cookie(现在基本上已经不会出现了)，但是这种情况还是会有发生。 通过URL传值，把session id附加到URL上（缺点：整个站点中不能有纯净静态页面，因为纯静态页面的session id将无法传递到下一个页面）。 通过隐藏表单，把session id放到表单的隐藏文本框中同表单一块提交过去（缺点不适用\\标签这种直接跳转的非标单情况） 直接配置php.ini，将session.use_trans_sid = 0设置为1 用文件、数据库等形式保存session id，在跨页面中手动调用。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"利用 INSERT 命令将表中字段导入到新表中","slug":"2015-09-18 利用insert命令将表中字段导入到新表中","date":"2015-09-17T16:00:00.000Z","updated":"2018-08-20T13:52:49.192Z","comments":true,"path":"2015/09/18/1/","link":"","permalink":"http://www.maksim.website/2015/09/18/1/","excerpt":"","text":"最近为公司内部系统写了一个爬虫，爬了一个问答社区的三万多条数据，由于一开始的设计不够合理，将所有记录都放入了一个表中，由于是问答系统，合理的数据库设计，应该是将问题和答案分离开来，这样的结构更加合理，也易于未来的扩展。 我刚开始做iOS 的，转到 PHP 有一年多了，大学时有自学PHP，东学学西搞搞，结果就变成了啥都快记不住了，什么也都懂一些。 到了现在MYSQL 的基础也忘了许多，你让我扯一扯大规模，主从，分表，优化，我倒是能说上一堆，但是实际操作起来，啧啧。 这么一个简单的功能一时之间竟然都没有想起来，搜索引擎的确是个好东西（当然不拿医疗盈利的话）。 现在 iOS 也快忘得差不多了，感叹 ing，Swift 4都出了··· 1INSERT INTO `new_table_name` VALUE (`c1`,`c2`) SELECT `c1`,`c2` FROM `old_table_name` 简单的一命令即可将数据导出。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.maksim.website/categories/MySQL/"}],"tags":[{"name":"INSERT","slug":"INSERT","permalink":"http://www.maksim.website/tags/INSERT/"}]},{"title":"DATA URI image封装类","slug":"2015-08-17 data-uri-image","date":"2015-08-17T12:12:44.000Z","updated":"2018-08-20T13:52:40.328Z","comments":true,"path":"2015/08/17/1/","link":"","permalink":"http://www.maksim.website/2015/08/17/1/","excerpt":"","text":"Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。 12345678910111213141516171819202122class DataBase64 &#123; public $file = ''; public function __construct($file)&#123; $this-&gt;file = $file; &#125; public function getBase64()&#123; $type = getimagesize($this-&gt;file); $fp = fopen($this-&gt;file, 'r') or die(\"Can't open file\"); $file_content= chunk_split(base64_encode(fread($fp, filesize($this-&gt;file)))) ; switch($type[2])&#123;//判读图片类型 case 1:$img_type=\"gif\";break; case 2:$img_type=\"jpg\";break; case 3:$img_type=\"png\";break; &#125; return $img='data:image/'.$img_type.';base64,'.$file_content; &#125;&#125;$data = new DataBase64('image/1.jpg');$img = $data-&gt;getBase64();","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/tags/PHP/"}]},{"title":"目录常量：PATH_SEPARATOR和DIRECTORY_SEPARATOR","slug":"2015-07-30 PATH_SEPARATOR-and-DIRECTORY_SEPARATOR","date":"2015-07-30T00:22:04.000Z","updated":"2018-06-25T12:36:49.813Z","comments":true,"path":"2015/07/30/1/","link":"","permalink":"http://www.maksim.website/2015/07/30/1/","excerpt":"","text":"DIRECTORY_SEPARATOR（string） 目录分隔符，这是PHP内置的一个常量，代表着”/“或“” 因为系统原因，目录的分隔符被分为两种，在windows中目录的分割符号可以使用‘/’或者‘’，但是在linux中目录分隔符只能使用’/‘; PATH_SEPARATOR 路径分隔符，同样是PHP内置的一个常量，在windows系统中，如果使用include包含多个路径可以使用分号（;）来进行分割，可是在linux系统中却要使用冒号（：）。 这两个常量主要就是用来解决linux与windows的兼容问题，避免因为系统差异出现的错误，可以增强移植性。 在 THINKPHP 中，将DIRECTORY_SEPARATOR定义为了一个DR 常量用来方便调用。 1define(\"DS\", DIRECTORY_SEPARATOR);","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"亿级文件静态文件爱你存储分发及分布式文件存储","slug":"2015-06-15 亿级文件","date":"2015-06-14T16:00:00.000Z","updated":"2018-08-26T09:15:05.353Z","comments":true,"path":"2015/06/15/cjlz9pr0g000gabrdlpqyoree/","link":"","permalink":"http://www.maksim.website/2015/06/15/cjlz9pr0g000gabrdlpqyoree/","excerpt":"","text":"在项目的早期，用户规模没有起来之前，其实我们并不需要有专门的存储系统。 在虚拟主机的时代，我们的程序和存储是放到一起的。最常见的像是Discuz，它的文件存储就是存储在uc_server/data目录下。 在这里需要注意的是，当我们上传文件的时候，一定要做好文件类型的检查，如果没有对文件进行筛选就上传到服务器上会对我们的站点造成毁灭性的打击，就比如说，用户上传了一个 PHP 文件，里面跑个无限递归的生成垃圾广告的脚本就已经够我们头疼的了。 当随着用户的激增，单台服务器再也无法支撑当前的业务逻辑，我们就会对服务器进行角色上的拆分，比如 Web 服务器、存储服务器、数据库服务器。 当我们对每一个角色进行拆分之后，当用户数达到一定量机的时候，这种简单的拆分必然会再度演化，变得也就更加复杂，最后存储系统可能就会用上分布式文件系统。 数据的世界不像我们想象的那么简单，不同的对象拥有不同的存储方式，数据的存储有很多种方式：结构化存储和非结构化存储。 结构化存储的有表格、字段、行、列、JSON、XML 非结构化存储，文件，但是：文件不一定是单一文件，就像数据航、数据表可以不是单一文件。","categories":[{"name":"PHP 架构","slug":"PHP-架构","permalink":"http://www.maksim.website/categories/PHP-架构/"}],"tags":[]},{"title":"deepin下安装 php的扩展","slug":"2015-05-26 deepin-install-PHP","date":"2015-05-26T01:56:08.000Z","updated":"2018-06-25T12:36:44.032Z","comments":true,"path":"2015/05/26/1/","link":"","permalink":"http://www.maksim.website/2015/05/26/1/","excerpt":"","text":"一直没用过linux开发PHP，昨天试了一下，却发现deepin下安装的php默认是不开其扩展的，可是PHP.INI中却没有开启扩展的选项，无奈之下百度了一番，却发现文章很少，但是却找到了ubuntu的命令，型号deepin的命令跟ubuntu一样，到是解决了PHP扩展的一些问题，原来只需要将所需要的扩展下载下来，重启服务器便可。 代码如下： 123sudo apt-get install php5-你所需要的扩展。sudo service apache2 restart 这样用来扩展就可以使用了。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/tags/PHP/"}]},{"title":"Smarty3封装类","slug":"2015-05-21 Smarty封装","date":"2015-05-21T14:10:59.000Z","updated":"2018-07-02T12:05:36.397Z","comments":true,"path":"2015/05/21/1/","link":"","permalink":"http://www.maksim.website/2015/05/21/1/","excerpt":"","text":"12345678910111213141516171819// load Smarty library require('Smarty.class.php'); // The setup.php file is a good place to load // required application library files, and you // can do that right here. An example: require('guestbook/guestbook.lib.php'); class Smarty_GuestBook extends Smarty &#123; function __construct() &#123; // Class Constructor. // These automatically get set with each new instance. parent::__construct(); $this-&gt;setTemplateDir('/web/www.example.com/guestbook/templates/'); $this-&gt;setCompileDir('/web/www.example.com/guestbook/templates_c/'); $this-&gt;setConfigDir('/web/www.example.com/guestbook/configs/'); $this-&gt;setCacheDir('/web/www.example.com/guestbook/cache/'); $this-&gt;caching = Smarty::CACHING_LIFETIME_CURRENT; $this-&gt;assign('app_name', 'Guest Book'); &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/tags/PHP/"}]},{"title":"PHP框架编写（二）单入口路由","slug":"2015-04-30 PHP框架编写（二）单入口路由","date":"2015-04-30T08:05:19.000Z","updated":"2018-06-25T12:36:13.297Z","comments":true,"path":"2015/04/30/1/","link":"","permalink":"http://www.maksim.website/2015/04/30/1/","excerpt":"","text":"PHP框架编写（二）单入口路由基本思路是浏览器端通过URL字符串提供控制器类的名字和方法的名字，PHP据此找到对应的类和方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/******************************************************* * * URL 路由原理展示代码 * * 浏览器访问地址: http://server/index.php?C=Controler1&amp;M=Method1 * 根据C找到控制器类，再根据M找到方法，然后执行这个方法 * * ****************************************************/ $C = isset($_GET['C']) ? $_GET['C']: null; $M = isset($_GET['M']) ? $_GET['M']: null; if($C != NULL &amp;&amp; $M != NULL &amp;&amp; class_exists($C) &amp;&amp; method_exists($C, $M)) &#123; $cObj = new $C(); $cObj-&gt;$M(); &#125;else&#123; echo '找不到控制器或方法'; exit; &#125; // 控制器1 class Controler1 &#123; public function Method1() &#123; echo 'Controler1, Method1'; &#125; public function Method2() &#123; echo 'Controler1, Method2'; &#125; &#125; // 控制器2 class Controler2 &#123; public function Method1() &#123; echo 'Controler2, Method1'; &#125; public function Method2() &#123; echo 'Controler2, Method2'; &#125; &#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"http://www.maksim.website/tags/php/"}]},{"title":"PHP框架编写（一）：框架运行流程","slug":"2015-04-29 PHP框架开发(一)MVC","date":"2015-04-29T14:02:49.000Z","updated":"2018-06-25T12:36:02.540Z","comments":true,"path":"2015/04/29/1/","link":"","permalink":"http://www.maksim.website/2015/04/29/1/","excerpt":"","text":"首先欢迎各位进入我的博客，我感觉非常荣幸，我并不是什么高手，现在的我不过是个在校的大学生，写这篇系列的博文只不过是为了加深自己对PHP的理解，以及对之前的学习做一个总结，同时也希望各位能够给我提一些意见。 PHP框架总给人以高大上的感觉，很多人学框架都学的头晕脑胀，百思不得其解，看完这篇博文后应该可以让还处于迷茫中的学习者找到一个入门的道路。 PHP框架到底是什么，框架不过是其他程序员提供的一个快速开发的一个代码而已，他帮助PHP开发者能够快速的开发，免去一些代码而已，PHP框架目前的核心就是MVC和数据库操作，更加大白话一点其实就是编程中最基础的增删改查，不过就是将他变的更加漂亮而已。 那么什么是MVC呢，M模型,V显示,C控制器。 这基本上是所有教程和书中都会提及的概念，也就不再多进行赘述模糊不清的概念了。 M是啥，字面上理解太费劲了，其实M模型我感觉表面上就是对数据库的操作，以及业务逻辑的梳理，这便是M模型，主要进行逻辑分析，将分析的结果传递给C也就是控制器，M就是一个深藏功与名的人，他默默就默默地站在幕后，干着最累的工作。 V就是显示，也就是其中最好面子的人，他们两个人忙活半天，其实都是在给我忙活，所有东西都处理完了，拿到他这里来显示。 C控制器，这个字面上就好理解了，那就是起到控制的作用，他控制着全局，属于M和C的一个中间层。（如果说错了，还请高手指正） 现在市面上的PHP框架基本上都是单一入口的文件。下面就是一个PHP框架的运行的简单流程图。 对PHP框架有了一定的了解之后，我们下一篇就开始讲PHP框架的目录结构了。 仅以此文先给刚刚入门的菜鸟，和正在努力奋斗的程序员们，祝各位早日成为攻城狮！出任CTO，赢取白富美，走向人生巅峰。 （如有转载，请注明出处，小弟感激不尽。）","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/tags/PHP/"}]},{"title":"文本输入输出与网站的安全问题","slug":"2015-04-22 文本输入输出与网站的安全问题","date":"2015-04-21T16:00:00.000Z","updated":"2018-08-20T14:54:55.779Z","comments":true,"path":"2015/04/22/1/","link":"","permalink":"http://www.maksim.website/2015/04/22/1/","excerpt":"","text":"常见的攻击在我们编码过程中，很多人都不会注意到安全问题，尤其是一些输入文本框，就算是一些较大的公司，也会存在这些问题。 网站的常见漏洞有 XSS（Cross Site Scirpt 、跨站脚本攻击） SQL 注入 CSRF（Cross-site request forgery、跨站请求伪造） 我们可以将其理解为： XSS =&gt; JS =&gt; 盗号 SQL注入 =&gt; SQL =&gt;盗取数据 CSRF =&gt; iframe =&gt; 刷粉丝 这些漏洞产生的原因主要是我们轻易相信了用户提交的数据。按照惯有的逻辑会认为用户提交了一个整数、一个字符串，但是用户可能提交的是一些拼接的内容字母或者汉字。 XSS 跨站脚本攻击上面我们提到了 XSS 的全称—— Cross Site Scirpt，那么为什么不叫 CSS 呢？ 这主要是跟层叠样式表的英文缩写冲突:Cascading Style Sheets。 最常见的用法就是利用 XSS 攻击，盗取用户的账号。 文本的输入以及输出SQL 注入CSRF攻击其他安全问题","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]},{"title":"PHP 的四种运行模式","slug":"2014-02-04 PHP的四种运行模式","date":"2014-02-03T16:00:00.000Z","updated":"2018-08-20T13:57:37.852Z","comments":true,"path":"2014/02/04/cjlz9pqzp0008abrdp2ock6td/","link":"","permalink":"http://www.maksim.website/2014/02/04/cjlz9pqzp0008abrdp2ock6td/","excerpt":"","text":"SAPIServer Application Programming Interface服务端应用编程端口。他就是PHP与其他应用交互的接口，PHP脚本要执行有很多中方式，通过Web服务器，或者直接在命令行行下，也可以嵌入其他程序中。SAPI提供了一个和外部通信的接口，常见的SAPI有：CGI、FAST-CGI、CLI、mod_php的dll等。 CGICGI即通用网关接口（common gatewag interface),它是一段程序，通俗的讲CGI就象是一座桥，把网页和WEB服务器中的执行程序连接起来，它把HTML接收的指令传递给服务器的执 行程序，再把服务器执行程序的结果返还给HTML页。CGI 的跨平台性能极佳，几乎可以在任何操作系统上实现。 CGI方式在遇到连接请求（用户 请求）先要创建cgi的子进程，激活一个CGI进程，然后处理请求，处理完后结束这个子进程。这就是fork-and-execute模式。所以用cgi 方式的服务器有多少连接请求就会有多少cgi子进程，子进程反复加载是cgi性能低下的主要原因。都会当用户请求数量非常多时，会大量挤占系统的资源如内 存，CPU时间等，造成效能低下。 FastCGIfast-cgi 是cgi的升级版本，FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一 次。PHP使用PHP-FPM(FastCGI Process Manager)，全称PHP FastCGI进程管理器进行管理。 Web Server启动时载入FastCGI进程管理器(IIS ISAPI或Apache Module)。FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。 当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。 在上述情况中，你可以想象CGI通常有多慢。每一个Web 请求PHP都必须重新解析php.ini、重新载入全部扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的 好处是，持续数据库连接(Persistent database connection)可以工作。 mod_phpPHP作为Apache模块，Apache服务器在系统启动后，预先生成多个进程副本驻留在内存中，一旦有请求出 现，就立即使用这些空余的子进程进行处理，这样就不存在生成子进程造成的延迟了。这些服务器副本在处理完一次HTTP请求之后并不立即退出，而是停留在计算机中等待下次请求。对于客户浏览器的请求反应更快，性能较高。 ## CLICLI 是 PHP 的命令行运行模式，大家经常会使用它，但是可能并没有注意到（例如：我们在linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式； PHP 执行方式对比 mod_php 稳定性不好，PHP出错 server进程也受影响 php-fpm 在 PHP 出错时启动新的 PHP进程 php-fpm 可以与 webserver 分离，能同时运行多份，甚至多个 PHP 版本 php-fpm 效率高比mod_php 高 php-fpm 的缺点是不利于调试，需要单独监控","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.maksim.website/categories/PHP/"}],"tags":[]}]}