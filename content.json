{"meta":{"title":"Maksim's Website","subtitle":null,"description":null,"author":"Maksim","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2017-07-04T03:28:00.000Z","updated":"2017-07-04T03:28:00.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"生活很艰辛，没有人是轻松的。 我可能不是很聪明，所以我在努力学习有关于如何学习的方法。 读书对于我来说可能是目前能够让我最快乐的一件事情，虽然我并不经常读书。 找到一份自己喜欢的事情不容易，请不要放弃它，坚持下去，可能你现在所从事的行业与他无关，但时间久了，你坚持说不定会会给你带来意外的惊喜。 如果可以，我想以码字为生，因为当年抓阄我抓的是个笔杆子。‘’ 偶尔也会孤独，偶尔也会迷茫，想想大学里的荒唐，也就不迷茫了、不孤独了。 ————国柱(Maksim)一名开发者的自述。"},{"title":"Categories","date":"2017-06-01T01:17:24.000Z","updated":"2017-06-01T01:17:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-01T01:17:31.000Z","updated":"2017-06-01T01:17:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在Mac上编译安装线程安全的PHP7.2","slug":"在-Mac上编译安装线程安全的-PHP7.2","date":"2017-08-05T04:04:12.000Z","updated":"2017-08-05T03:17:24.000Z","comments":true,"path":"2017/08/05/1/","link":"","permalink":"http://yoursite.com/2017/08/05/1/","excerpt":"","text":"因为项目需求后期可能会需要使用到进程守护和消息队列，于是上网查了一下，看到Netkiller PHP 手札中有介绍到PHP使用 Pthread实现优雅守护进程的方法。 可是由于我本地的 PHP 是使用brew进行安装的，在 Linux 下使用 yum或者 apt进行安装的 PHP 同样不支持线程安全。 于是开始折腾起来，将 PHP 卸载掉后使用编译进行重新安装，开启--enable-maintainer-zts 后在编译过程中遇到了 Clang 报错，经过了一番 Google、百度过后，原来是编译器在作怪。Mac 由于 Xcode 的原因，默认使用的编译器是 Clang，在编译到 pthread 的时候，就会报错。 解决方法也很简单，在./configure 命令的最后加上 CC=gcc ，告诉make 我要使用 GCC 编译器进行编译即可。 其实在日常的开发中PHP开发者，很少会接触到多线程这一块。甚至有的PHP 开发者都搞不清楚什么是线程、进程和协程。 那是因为在 Web 开发中根本使用不了多线程，因为 PHP 本身并不提供多线程API，其多线程的支持是由 Pthread 扩展提供的，而 Pthread 扩展的文档中有说明： Warning 不可以在 web 服务器环境中使用 pthreads 扩展，PHP 多线程开发仅限于命令行模式的应用。 Windows版的PHP从版本5.2.1开始有Thread Safe(线程安全)和None Thread Safe(NTS，非线程安全)之分，这两者不同在于何处？到底应该用哪种？ 从2000年 10月20日发布的第一个Windows版的PHP3.0.17开始的都是线程安全的版本，这是由于与Linux/Unix系统是采用多进程的工作方式不同的导致的。 Windows系统是采用多线程的工作方式。如果在IIS下以CGI方式运行PHP会非常慢，这是由于CGI模式是建立在多进程的基础之上的，而非多线程。一般我们会把PHP配置成以ISAPI的方式来运行，ISAPI是多线程的方式，这样就快多了。 但存在一个问题，很多常用的PHP扩展是以 Linux/Unix的多进程思想来开发的，这些扩展在ISAPI的方式运行时就会出错搞垮IIS。因此在IIS下CGI模式才是PHP运行的最安全方式，但CGI模式对于每个HTTP请求都需要重新加载和卸载整个PHP环境，其消耗是巨大的。 为了兼顾IIS下PHP的效率和安全，微软 给出了FastCGI的解决方案。FastCGI可以让PHP的进程重复利用而不是每一个新的请求就重开一个进程。同时FastCGI也可以允许几个进程同时执行。这样既解决了CGI进程模式消耗太大的问题，又利用上了CGI进程模式不存在线程安全问题的优势。 因此，如果是使用ISAPI 的方式来运行PHP就必须用Thread Safe(线程安全)的版本；而用FastCGI模式运行PHP的话就没有必要用线程安全检查了，用None Thread Safe(NTS，非线程安全)的版本能够更好的提高效率。 从上面这段描述我们可以清楚的知道，如果不是使用 ISAPI 的话，不使用多线程特性，那么基本上就用不Thread Safe。 查看自己的 PHP版本是否是线程安全你的只需要在命令行中输入 PHP -v查看 PHP 的版本即可，如下： 引用： PHP线程安全和非线程安全有什么区别 http://www.cnblogs.com/T8881/p/6397264.html PHP Internals Book（《PHP内部书》PHP 内核开发者合著) http://www.phpinternalsbook.com/index.html PHP运行模式 http://www.cnblogs.com/xia520pi/p/3914964.html Netkiller PHP 手札 http://netkiller.github.io/php/index.html","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"多线程,PHP7.2,编译安装,GCC","slug":"多线程-PHP7-2-编译安装-GCC","permalink":"http://yoursite.com/tags/多线程-PHP7-2-编译安装-GCC/"}]},{"title":"在SQL中使用变量","slug":"在SQL中使用变量","date":"2017-08-05T00:04:12.000Z","updated":"2017-08-05T01:31:44.000Z","comments":true,"path":"2017/08/05/602/","link":"","permalink":"http://yoursite.com/2017/08/05/602/","excerpt":"","text":"MySQL 李的变量可分为用户变量和系统变量 1. 用户变量 MySQL允许用户在语句中自定义变量，对于用户变量的值，可以先保存在用户变量中，然后在引用它；这样就可以将值从一个语句传到另外一个语句。 用户变量与连接有关。一个客户端定义的变量不能被其他客户端看到货使用。当客户端退出时，该客户端连接的所有变量将自动释放。这点不同于在函数或存储过程中通过 DECLAER 药监局声明的局部变量，局部变量的生存周期在它被声明的“BEGIN...END”块内。 用户变量的表现形式为：@var_name 设置用户变量的一个途径是执行 SET 语句，语法如下： 1SET @var_name= expr[, @var_name= expr] ... 对于SET，可以使用“=”或“:=”作为分配符。分配给每个变量的expr可以为整数、实数、字符串或NULL值。如: 1mysql&gt; SET @t1=0, @t2=0, @t3=0; 或 1SET @minMid=(select min(id) FROM table_name) ; 2.系统变量 MySQL服务器维护着两种系统变量: 全局变量影响MySQL服务的整体运行方式 会话变量影响具体客户端连接的操作 当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中对指定的选项进行更改。服务器启动后，通过连接服务器并执行SET GLOBAL var_name语句，可以动态更改这些全局变量。要想更改全局变量，必须具有SUPER权限。 服务器还为每个连接的客户端维护一系列的会话变量。在连接时使用相应全局变量的当前值对客户端的会话变量进行初始化。对于动态会话变量，客户端可以通过SET SESSION var_name语句更改它们。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其他客户端的会话变量。 访问全局变量的任何客户端都可以看见对全局变量所做的更改。然而，它只影响更改后连接的客户的相应会话变量，而不会影响目前已经连接的客户端的会话变量(即使客户端执行SET GLOBAL语句也不影响)。 也就是说，如果你的连接是短连接，那么修改全局变量后，客户端有重连的操作，就会立刻影响到客户端。而对于长连接、连接池来说，连接可能一直在MySQL里没有被销毁，也就不会有重连的操作，所以这种情况下对全局变量的修改一般不会影响到客户端。 可以使用如下几种语法形式来设置或检索全局变量或会话变量(下面的例子使用sort_buffer_size作为示例变量名)。 要想设置一个GLOBAL变量的值，可使用下面的语法。 12mysql&gt; SET GLOBAL sort_buffer_size=value; mysql&gt; SET @@global.sort_buffer_size=value; 要想设置一个SESSION变量的值，可使用下面的语法。 123mysql&gt; SET SESSION sort_buffer_size=value; mysql&gt; SET @@session.sort_buffer_size=value; mysql&gt; SET sort_buffer_size=value; 如果设置变量时不指定GLOBAL、SESSION或LOCAL，则默认使用SESSION。 要想检索一个GLOBAL变量的值，可使用下面的语法。 12mysql&gt; SELECT @@global.sort_buffer_size;mysql&gt; SHOW GLOBAL VARIABLES LIKE 'sort_buffer_size'; 要想检索一个SESSION变量的值，可使用下面的语法。 12mysql&gt; SELECT @@sort_buffer_size;mysql&gt; SELECT @@session.sort_buffer_size; mysql&gt; SHOW VARIABLES LIKE 'sort_buffer_size'; 当用SELECT@@var_name搜索一个变量时(也就是说，不指定GLOBAL、SESSION)，MySQL会返回SESSION值(如果存在SESSION变量的话)，否则返回GLOBAL值。 对于SHOW VARIABLES，如果不指定GLOBAL、SESSION的话，MySQL会返回SESSION值。 引用 《MySQLDBA 修炼之道》 作者：陈晓勇 MySQL 官方文档 9.4 User-Defined Variables","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"基础很重要，你真的知道什么是数据库吗？","slug":"读书笔记之什么是数据库？","date":"2017-08-04T13:04:12.000Z","updated":"2017-08-04T13:12:48.000Z","comments":true,"path":"2017/08/04/601/","link":"","permalink":"http://yoursite.com/2017/08/04/601/","excerpt":"","text":"“数据库基础”可不是一件小事。问题是，有时人们认为他们知道的很多。 例如，这个问题:什么是数据库? 我敢说大多数的人相信他们知道这个问题的答案。但其中一部分人(或者很多)都会答错。SQL Server 不是数据库，它只是一种 DBMS(数据库管理系统)。你可以使用 SQL Server 来创建数据库，但 SQL Server 本身不是一种数据库。 那么，什么是数据库?数据库是一种有组织的数据存储，其中的数据可以通过指定的数据元素(比如，字段、记录和文件)来访问(详见图 1-1)。 数据库是一种有组织的数据存储，其中的数据可以通过指定的数据元素来访问。 DBMS 是一种使终端用户或程序员能够共享数据的软件。它提供了一套操作数据库的系 统性方法:创建、更新、检索和存储信息。DBMS 通常还负责数据完整性、数据安全性、数据访问控制和优化、自动回退、重起和恢复。 对外行人来说，你可以把数据库想象成一个文件夹，把 DBMS 想象成文件柜，且所容纳的所有文件都贴有标签。DBMS 管理着数据库，通过 DBMS 来实现和访问数据库实例。所以说，DB2、Oracle 和 SQL Server 都是数据库管理系统。工资单应用使用工资单的数据库，该数据库可以使用 DB2、Oracle 或者 SQL Server 来实现。 摘自DBA 《修炼之道：数据库管理员的第一本书》","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"利用 MySQL 权限机制设置用户权限","slug":"Mysql权限控制","date":"2017-08-04T05:01:00.000Z","updated":"2017-08-04T05:09:08.000Z","comments":true,"path":"2017/08/04/600/","link":"","permalink":"http://yoursite.com/2017/08/04/600/","excerpt":"","text":"MySQL 权限控制包含如下两个阶段。 阶段1： 服务器检测是否允许你链接。 阶段2： 假定你能连接，服务器将检测你发出的每一个请求，查看你是否有足够的权限实施它。例如你从数据库表中选择（SELECT）行或从数据库中删除表，那么服务器要确定你是否对表有SELECT权限或对数据库有DROP权限。 MySQL是通过用户名、密码、IP(主机名)3个要素来验证用户的。当你想要访问MySQL服务器时，MySQL客户端程序一 般会要求你指定如下参数。 MySQL服务器的IP(主机名)， 端口 用户名 密码 以下是连接MySQL服务器的一个示例，你需要以实际的IP、端口、用户名、密码代替相应的内容。 1mysql -h host_ip_address -u user_name -pyour_password -P server_port 一般在生产环境下，程序账号有增加、删除、查询、修改这4项功能即可。 如下命令用于赋予查询、插入、修改、删除权限，并进行密码设置。 1grant select,insert,update,delete on db_name.* to user_name@ '10.%' identified by 'password'; 如下命令用于回收上面所赋予的权限。 1revoke select,insert,update,delete on db_name.* from user_name@ '10.%';","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"PHP7 微信支付不能回调，让我们的团队损失1.00CNY。","slug":"PHP7微信支付","date":"2017-07-14T06:15:20.000Z","updated":"2017-07-14T11:39:10.000Z","comments":true,"path":"2017/07/14/cj5yqarfb000oigrduqjcln8h/","link":"","permalink":"http://yoursite.com/2017/07/14/cj5yqarfb000oigrduqjcln8h/","excerpt":"","text":"公司目前正在使用一套基于 TP5的开源商城，在线上测试过程中碰到了一个问题，微信支付完成后无法进行回调更新订单状态，简单点说就是钱没了，啥也没得到。 What？这可是一个无法容忍的错误。 原本以为是微信支付配置环节出了问题，于是便去查看微信官网给出的帮助手册，又顺着流程走了一边，信心满满的又测试了一边，结果尴尬了，又损失了0.01人民币。 反复确认流程后，确认并不是配置的问题，于是便开始了百度，原来这一切都是在微信官网给出的SDK中的一段代码惹的祸，就这么一段代码让我们团队损失了接近1人民币。 12//获取通知的数据$xml = $GLOBALS['HTTP_RAW_POST_DATA']; // WxPay.Api.php 414 line 这段代码如果放在PHP7之前的版本是不会有任何问题的，但是在 PHP7版本中却已经废除了 HTTP\\_RAW\\_POST\\_DATA 。 在官方文档中给了说明： Warning This feature was DEPRECATED in PHP 5.6.0, and REMOVED as of PHP 7.0.0. 在PHP5.6.0发布的时候，就已经不推荐只用这种方法，于是在PHP 社区在开发 PHP7.0的时候直接就将其废弃掉了。 而官方也给出了替代的方案，那就是php://input php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP\\_RAW\\_POST\\_DATA，因为它不依赖于特定的php.ini指令。 而且，这样的情况下 $HTTP\\_RAW\\_POST\\_DATA 默认没有填充， 比激活 always\\_populate\\_raw\\_post\\_data潜在需要更少的内存。 enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的。 Note: 在 PHP 5.6 之前 php://input 打开的数据流只能读取一次； 数据流不支持 seek 操作。 不过，依赖于 SAPI 的实现，请求体数据被保存的时候， 它可以打开另一个 php://input 数据流并重新读取。 通常情况下，这种情况只是针对 POST 请求，而不是其他请求方式，比如 PUT 或者 PROPFIND。 于是我将这段代码改为了： 12//获取通知的数据$xml = file_get_contents(\"php://input\"); // WxPay.Api.php 414 line 最后我又以0.01人民币的代价确认修复了这个 BUG。 PHP7:&quot;怪我喽，让你经常看文档，哼！&quot;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"wechat pay, php, php7, php://input","slug":"wechat-pay-php-php7-php-input","permalink":"http://yoursite.com/tags/wechat-pay-php-php7-php-input/"}]},{"title":"","slug":"正确的使用 JOIN 从句","date":"2017-07-07T01:38:29.000Z","updated":"2017-08-04T04:54:54.000Z","comments":true,"path":"2017/07/07/cj5yqarhq003eigrdblwvebfh/","link":"","permalink":"http://yoursite.com/2017/07/07/cj5yqarhq003eigrdblwvebfh/","excerpt":"","text":"12title: 正确使用JOIN从句date: 2016-12-12 20:04:21 Join 操作的类型——Inner Join 内连接 Inner Join 基于连接谓词将两周那个表的列组合在一起，产生新的结果表。 示例如下： 我们当前有这样的两张表，其中 users表用于存储用户的基本信息，其中包括自增 id、密码和邮箱，另外一张表 address 用来储存用户的地址信息。 user_id username password email 1 maksim 098f6bcd4621d373cade4e832627b4f6 1401588099@qq.com 2 aircrayon 098f6bcd4621d373cade4e832627b4f6 aircrayon@qq.com address_id user_id province city address 1 1 黑龙江省 齐齐哈尔市 黑龙江省齐齐哈尔市龙沙区朴奎大街108号 2 2 黑龙江省 齐齐哈尔市 黑龙江省齐齐哈尔市齐齐哈尔大学 1SELECT a.`uesr_name`, a.`over`,b.`over` FORM user1 a INNER JOIN user2 b ON a.`user_name` = b.`user_name` Join 操作的","categories":[],"tags":[]},{"title":"提高 MySQL 的性能，从数据库设计规范开始","slug":"数据库设计规范实例","date":"2017-06-22T16:00:00.000Z","updated":"2017-08-04T04:41:58.000Z","comments":true,"path":"2017/06/23/2/","link":"","permalink":"http://yoursite.com/2017/06/23/2/","excerpt":"","text":"这几日一直都在看慕课网的一篇有关于数据库设计的实战教程，在其中讲述了关于数据库设计的一些相关规范，可以说是受益匪浅，于是便将学习所得记录下来，如果有想要看视频版的同学可以到慕课网查看。 点我跳转到慕课网观看视频 数据库名称规范1.所有数据库对象名称必须使用小写字母并使用下划线分割由于 MySQL数据库的对象名称默认情况下是大小写敏感的，特别是在 Linux 系统下，MySQL 的数据库和表实际上的存储方式就是 Linux 下的一个文件，由于 Linux 系统是对大小写敏感的，所以 MySQL 也就对大小写敏感，这就意味着 DbName dbname 是完全不同的两个数据库。 如果在开发过程中使用大小写混用的情况下，就会对未来的开发工作造成很多不必要的麻烦，要时刻注意数据库对象的大小写。 2.所有的数据库对象名称禁止使用 MySQL 的保留字段1select id,username from ,age from tb_user; 在上述SQL 语句中存在两个 from，由于 MySQL 并不知道这两个 from 有什么区别，若是执行这条 SQL 语句肯定会报错，但是在建表的时候却不会报错。 若是已经使用了关键字做了字段名，那就需要在字段名前后加上反引号，示例如下： 1select id,username `from` ,age from tb_user; 反引号是为了区分MySQL关键字和保留字与普通字符而引入的符号，保留字的列表请点击此网页查看 https://dev.mysql.com/doc/refman/5.7/en/keywords.html 3. 数据库对象的命名要做到见名识义，而且最好不要超过32个字符MySQL 的限制长度是64个字符，但是表名和列名一旦过长，在使用过程中将会很不方便，而且还会增加网络传输的开销。 例如： 12用户数据库： ex_userdb用户账户表： user_account 4. 所有的临时表必须以 tmp为前缀并以日期为后缀在我们的日常工作中，会在数据库中建立一些临时表或者中间表，往往无法第一时间将其清理掉，时间一长便无法分清，哪些是临时表或者是持久化表，这样一来就会造成很多的垃圾数据。 5.备份表必须以bak为前缀并以日期为后缀在日常工作中，我们会对数据库进行备份，在备份的时候，以 bak 开头可以清晰的表示出这是一个备份表，并且以时间结尾标注了这个表是在什么时间进行的备份，这样一来能够设计出更加整洁的数据库，并且结构清晰。 6.所有存储相同数据的列明和列类型必须一致。通着这这种字段都是以关联字段进行使用的，如果两个表的关联字段的数据类型不一致，在关联时MySQL 会进行隐式类型转换，造成字段索引失效，影响数据库的运行性能，导致不必要的开销。 数据库基本设计规范1. 在没有特殊要求的情况下，所有表必须使用 Innodb 存储引擎比如列存储、在5.7版本之前存储空间数据，如果还在使用MyISAM 引擎如果在升级到5.6之后应该尽快将存储引擎升级到 Innodb，因为在5.6之后的默认引擎就是 Innodb，Innodb 支持事务，行级锁，更好的恢复性，高并发下性能更好。 2.数据库和表的字符集使用 UTF8统一的字符集可以避免由于字符集转换禅城的乱码，MySQL 中 UTF8字符集汉字站3个字节，ASCII 码占用1个字节，若我们定了一个 varchar(255)的列，并且存储中文的话，255个中文字符将会占用725个字节。 3.所有的表和字段都需要添加注释使用 comment 从句添加表和列的备注，从一开始就进行数据字典维护。 4.尽量控制单表数据量的大小，建议控制在500万行以内500万并不是 MySQL数据库的限制，MySQL 的存储数据量取决于存储设置和文件系统，修改表结构，备份，恢复都会有很大问题。 可以使用历史数据归档，分库分表等手段来控制数据量的大小，历史数据归档常用语系统日志，分库分表主要应用在业务表上。 5.谨慎的使用 MySQL 分区表。分区表在物理上表现为多个文件，在逻辑上表现为一个表。谨慎的选择分区键，跨分区查询效率可能更低。 建议采用物理分表的方式管理大数据。 6.尽量做到冷热数据分离，减小表单的宽度MySQL 限制最多存储4096列，并且每一行的大小是不能超过65535个字节的。最好将经常用到的列放到一个表中，这样一来可以减少磁盘 IO，保证热数据的内存缓存命中率。利用更有效的利用缓存，避免读入无用的冷数据。 7.禁止在表中建立预留字段预留字段的命名很难做到见名识义，预留字段无法确认存储的数据类型，所以无法选择合适的类型。对预留字段类型的修改，会对表进行锁定，修改一个字段类型的成本远高于新建一个字段。 8.禁止在数据库中存储图片，文件等二进制数据这类文件都会很大，会在短时间内造成数据量的疯涨，在数据库读取的时会产生大量的 IO 操作，非常好事，影响数据库性能，常规的做法是将图片保存在对应的文件服务器上，然后在数据库中保存地址信息就可以了。 9.禁止在线上做数据库压力测试如果使用生产环境进行压力测试一方面会对正常的业务访问造成影响，另一方面也会对数据库造成影响，产生大量的垃圾数据。 8.禁止从开发环境，测试环境直接连生产环境数据库会对生产环境的数据的完整性进行破坏。 数据库索引设计规范1.限制每张表上的索引数量，建议单标索引不超过5个索引数量是和列的数量是成正比的，通常列的数量越多索引的数量也会越多，索引并不是越多越好，索引可以提高效率单同样也可以鉴定效率，索引可以增加查询效率，单同样也会降低插入和更新的效率。 由于 MySQL 优化器在选择优化查询时，会根据统计信息对每一个可以用到的索引进行评估，以生成出一个最好的执行计划，如果同时有很多索引都可以用于查询，就会增加 MySQL优化器生成优化器的时间，同样机会降低 SQL 查询的性能。 禁止给表中的每一个列都建立单独的索引。 2.每一个 Innodb表都必须有一个主键Innodb 是一种索引组织表，数据存储的逻辑顺序与索引的顺序是相同的，每一个表上上都会有很多索引，但是存储顺序只有一种，Innodb是按照主键索引进行组织表的。 如果没有主键，那么 Innodb 会优先以第一非空，唯一索引当做主键，在没有非空唯一所以的情况下，MySQL 会生成一个站位6个字节的主键，这个自动生成的主键性能并不是最好的。 在表的设计中不要使用更新频繁的列作为主键，不使用多列主键（联合索引），因为 Innodb是一个索引组织表的缘故，如果主键频繁被更新，那么久意味着，数据存储的顺序就会频繁的变动，必然会带来大量的 IO 操作。 不要使用 UUID，MD5，HASH，字符串列作为主键。因为这类数据无法保证数据的顺序增长，如果后面插入的值比已经存在的值还要小，则为了保证索引的顺序，则会把新的数据插入到前面，这样就会造成所有大于这个值的数据要想后移带来大量的 IO 操作。 建议使用自增 ID 作为主键。 3.常见索引列建议1.SELECT、UPDATE、DELETE语句的WHERE 从句中的列出现的字段中添加索引2.包含在 ORDER BY、GROUP BY、DISTINCT 中的字段3.多表JOIN的关联列 4.如何选择索引列的顺序在联合索引中索引的使用顺序是由从左到右的顺序来使用的。所以我们需要将区分度最高的列放在联合索引的最左侧，尽量把字段长度小的列房子啊联合索引的最左侧，私用最频繁的列放在联合索引的左侧。 ###避免建立冗余索引和重复索引 重复索引：1primary key(id)、index(id)、unique index(id) 冗余索引：1index(a,b,c) 、index(a,b)、index(a) 5.对于频繁的查询优先考虑使用覆盖索引覆盖索引：就是包含了所有查询字段的索引 避免 Innodb 表进行索引的二次查找， 数据库字段设计规范1.优先选择符合存储需要的最小的数据类型 将字符串转换为数字类型存储 INET_ATON(‘255.255.255.255’) = 4294967295 INET_NTOA(4294967295) = ‘255.255.255.255’ 对于非负型的数据来说，要有限选用无符号整型来存储，无符号相对于有符号可以多出一倍的存储空间 VARCHAR（N）中的 N 代表的是字符数，而不是字节数 使用 UTF8存储汉字 VARCHAR(255)=765个字节 过大的长度会消耗更多的内存，因为当数据被载入到内存时为了提高效率是按照所定义的类型长度来申请内存的。 2.避免使用 Text、BLOG 的数据类型Text列分为四种 TinyText、Text、MidumText、LongText，Text 类型可以存储下64K的数据，备注或者说明很少会使用到64K 这么庞大的数据，使用 Varchar 类型就可以了。另外由于MySQL 内存表是不支持 Text 和 Blog 的，因此我们在对这种大数据类型进行排序的时候无法使用内存表，而必须使用磁盘内置表，这类数据MySQL 在读取数据时会进行二次查询，所以会使得 SQL 的性能变的很差。 建议把 BLOG 或是 TEXT列分离到单独的扩展表中 ，并且在查询时一定不要使用 select * 的方式，而是取出必要的列，在使用 BOLOG 或者 TEXT 类型的时候就不要查询该列。 TEXT或 BLOG 类型只能使用前缀索引，并且 TEXT 的列上是不能有默认值的。 3.避免使用 ENUM 数据类型枚举类型是一个很特别的类型，在其他关系型数据库中并不存在这一类型，枚举本身是一个字符串类型，但是其本身却是以整数类型，所以能够存储65535种不同的枚举值，前面提到要将字符串类型转换成整数进行存储，从这一点看枚举是一种很好的数据类型，有助于我们很好的进行优化。 但是枚举类型也存在着很大的缺陷，修改 ENUM 值需要使用 ALTER 语句，频繁的对表结构进行修改很容易造成失误，在修改元数据的时候会生成元数据锁，在大量数据访问的时候会造成数据库系统的阻塞，对枚举数据进行操作的时候是存在一定的操作风险的。 ENUM 类型的 ORDER BY 操作效率低，需额外操作，由于是按照整型进行存储的，所以在查询的时候会对其进行字符串转化然后在进行排序，这种装换是无法使用索引的，所以枚举值排序性能比较差。 禁止使用数值作为 ENUM 的枚举值，因为枚举本身是索引顺序存储的，如果枚举值也是用整型进行存储，很容易会造成逻辑上的一种混淆，一般情况下枚举值是整型，通常建议使用整型代替。 4.尽量可能把所有列定义为 NOT NULL索引 NULL 列需要额外的空间来保存，所以需要占用更多的空间，索引空间占用的越低越好。 进行比较和计算时候对 NULL 值做特别的处理，所以可能会造成索引失效。 5.使用 TIMESTAMP 或DATETIME 类型存储时间字符串存储日期型的数据（不正确的做法） 缺点1：无法用日期函数进行计算和比较。缺点2：用字符串存储日期要占用更多的空间 TIMESTAMP 1970-01-01 00：00：01 ~ 2038-01-19 03：14：07 其实 TIMESTAMP 是以 INT 类型存储的，但是以日期格式显示，TIMESTAMP占用4字节和 INT 相同，单比 INT 可读性高， 当超出 TIMESTAMP 类型的存储范围时我们需要使用 DATETIME 类型来进行存储。 6.同财务相关的金额类数据，必须使用 decimal 类型Decimal 类型为精准浮点数，在计算时不会丢失精度，占用空间油定义的宽度决定，可用于存储比 bigint 更大的整数数据。 数据库 SQL 开发规范1.建议使用预编译语句进行数据库 只传参数，比传递 SQL 语句更高效 相同语句可以一次解析，多次使用，提高处理效率 防范 SQL 注入的风险 2.避免数据类型的隐式转换隐式转换一般发生在 Where 从句中，当列类型和参数类型不一致时就会出现隐式转换。， 隐式转换会导致索引失效 3.充分利用表上已经存在的索引尽量避免用%号的查询 例如 a like ‘%123%’ 一个 SQL 只能利用到符合索引中的一列进行范围查询 使用 left join 活 not exists 来优化 not in 操作。 4.程序链接不同的数据库使用不同的账号，禁止跨库查询。 为了数据库迁移和分库分表留出余地 降低业务耦合度 避免由于权限过大产生的安全风险 5.禁止使用 SELECT *必须使用 SELECT&lt;字段列表&gt;查询 消耗更多的 CPU 和 IO 以及网络带宽资源 无法使用覆盖索引 可减少表结构变更带来的影响 6.禁止使用不含字段列表的 insert 语句 12insert into t values (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); //不包含字段列表的 insertinsert into t(c1,c2,c3) values(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); //正确的写 可以减少表结构变更带来的影响 7.避免使用子查询，可以把子查询优化为join 并不是所有的子查询都可以使用 join进行优化，一般情况下只有子查询在 IN 子句中，并且子查询是一个简单的 SQL ，例如其中不包含 order by之类的复杂查询，才可以进行转换。 子查询的结果集无法使用索引 子查询会产生临时表操作，如果子查询数据量大则严重影响性能 临时表会消耗过多 CPU 以及 IO 资源 8.避免使用 JOIN 关联太多的表 每Join 一个表会占用一部分内存（join buffer size） 会产生临时表操作，影响查询效率 MySQL 最多允许关联61个表，建议不超过五个 9.减少同数据库的交互次数 数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率 10.使用 in 代替or in 的值不要超过500个 in 操作可以有效的利用索引 11.禁止使用 order by rand(）进行随机排序 会把表中所有符合条件的数据装载到内存中进行排序 会消耗大量的 CUP 和 IO 以及内存支援 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式 12.WHERE 从句中禁止对列进行函数转换和计算 对列进行函数转换或计算会导致无法使用索引 12wehre date(createtime) = &apos;20160901&apos;where createtime &gt;= &apos;20160901&apos; and createtime&lt; &apos;20160902&apos; 13.有明显不会重复值时使用 UNION ALL 而不是UNION UNION 会把所有数据放到临时表中然后进行去重操作 UNION ALL 不会对结果集进行去重操作 14.拆分复杂的大 SQL 为多个小 SQL MySQL 一个 SQL 只能使用一个 CPU进行计算 SQL 拆分后可以进行并行执行来提高处理效率 数据库操作行为规范1.超100万行的批量写操作，需分批多次进行操作 大批量操作可能会造成严重的主从延迟 binlog 日志为row 格式时会产生大量的日志 避免产生大事务操作 2.对大表数据结构的修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。对于大表使用 pt-online-schema-change 修改表结构，可以避免主从延时、表锁的问题。 3.禁止为程序使用的账户赋予 super 权限 当达到最大连接数贤之士，MySQL 允许1个有 super 权限的用户连接 super 权限只能留给 DBA 处理问题的账户使用 4.对于程序链接数据库账户，遵循权限最小原则 程序使用数据库账号只能在一个 DB下使用，不准夸库 程序使用账号原则上不准有 drop权限","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL 设计规范","slug":"MySQL-设计规范","permalink":"http://yoursite.com/tags/MySQL-设计规范/"}]},{"title":"利用规约设计模式（Specification）开发整洁的规格校验","slug":"理解Specification设计模式","date":"2017-05-31T16:00:00.000Z","updated":"2017-07-14T11:29:19.000Z","comments":true,"path":"2017/06/01/1/","link":"","permalink":"http://yoursite.com/2017/06/01/1/","excerpt":"","text":"规格校验是使我们在日常的开发过程中中比较常见的一种业务需求，最直观的使用是我们在开发电商类网站时我们会对商品的一些规格进行限定，例如重量大小不能超过 N（kg） 。 如果是一个刚刚加入业界的程序员，很有可能会编写出大量的if语句来进行解决此类的业务逻辑，这样编码可行吗？ 答案是可以，因为顺利的完成了业务逻辑代码的编写任务，但是却违反了类设计中的开闭原则，而且一看就是没有经过正规的训练，没有对于 OOP 编程有更深的了解。 那么有没有一种设计模式可以让我们设计出优雅而又整洁的逻辑代码呢，答案是显而易见的，要不然也就不会出现这篇文章，它就是——规模设计模式。 我们可以利用规约模式来解决这一实际问题，开发出优雅而又健全的业务逻辑代码。 规约设计模式的主要设计目的就是为了生成业务规则的明确规范，通过isSatisfiedBy方法来检测对象是否符合规范。 下图是规约模式 UML 类图（不懂的同学推荐去看由谭云杰所编写的《大象：Thinking in UML》） 即使看不懂 UML 类图也没有关系，编码能力的提高是要根据不断的实践才能有所增长的。当你顺着我的思路打完代码，你就已经可以明白规约设计模式的设计理念以及作用。 当然我还是要解释一下这个类图所代表的含义。 既然是规格校验，那么一个规格校验到底包括什么呢？ 一般而言主要有：区间、大于、小于、不等于，这几样，那么我们是不是可以将其抽象成一个类呢？ 这就是上面那张 UML 的简单含义，其中主要是用于描述其类的关系，UML 就是帮助我们对类进行抽象的一个工具。 下面让我们撸起袖子打代码。首先我们应该新建了 Goods类用于表示被规约的产品，其中包含一个 Price 价格属性，然后在建立对 Price 属性的规约，用来检验最新实例化的 Goods 是否满足约定。 123456789101112131415161718192021&lt;?php//商品类namespace DesignPatterns\\Behavioral\\Specification;class Goods&#123; /** * @var float */ private $price; public function __construct(float $price) &#123; $this-&gt;price = $price; &#125; public function getPrice(): float &#123; return $this-&gt;price; &#125;&#125; 在建立规约之前，我们需要建立一个接口，这个接口中定了了一个方法isSatisfiedBy,也就是上文提到的那个检测对象是否满足规约条件的那个方法。 12345678&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;interface SpecificationInterface&#123; public function isSatisfiedBy(Goods $goods): bool;&#125; Ok，在我们编写其余代码之前，我们需要来做一个思考，在程序语言当中，判断条件中的操作符是不是有或、与、非这三个判断条件，对应着 ||、&amp;&amp;、！。 那么我们是否可以将其抽象成一个又一个的类呢？ OrSpecification规约用来表示 Or 的关系，与我们的逻辑判断一样，表示在两个规约之间只要满足一条便返回 true。 123456789101112131415161718192021222324252627282930namespace DesignPatterns\\Behavioral\\Specification;class OrSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface[] */ private $specifications; /** * @param SpecificationInterface[] ...$specifications */ public function __construct(SpecificationInterface ...$specifications) &#123; $this-&gt;specifications = $specifications; &#125; /** * if at least one specification is true, return true, else return false */ public function isSatisfiedBy(Item $item): bool &#123; foreach ($this-&gt;specifications as $specification) &#123; if ($specification-&gt;isSatisfiedBy($item)) &#123; return true; &#125; &#125; return false; &#125;&#125; AndSpecification 用于表示 And 关系，两条以上规约时，必须都满足条件才会返回 true否则返回false. 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class AndSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface[] */ private $specifications; /** * @param SpecificationInterface[] ...$specifications */ public function __construct(SpecificationInterface ...$specifications) &#123; $this-&gt;specifications = $specifications; &#125; /** * if at least one specification is false, return false, else return true. */ public function isSatisfiedBy(Item $item): bool &#123; foreach ($this-&gt;specifications as $specification) &#123; if (!$specification-&gt;isSatisfiedBy($item)) &#123; return false; &#125; &#125; return true; &#125;&#125; NotSpecification.php 用于表示Not。 123456789101112131415161718192021&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class NotSpecification implements SpecificationInterface&#123; /** * @var SpecificationInterface */ private $specification; public function __construct(SpecificationInterface $specification) &#123; $this-&gt;specification = $specification; &#125; public function isSatisfiedBy(Item $item): bool &#123; return !$this-&gt;specification-&gt;isSatisfiedBy($item); &#125;&#125; 逻辑判断抽编码好了之后，我们就要开始真正的规约了，我们建立一个 Price 规约，其中主要设定了 Price 的范围，构造函数中包含最大值与最小值，并且实现isSatisfiedBy用来判断输入的值是否符合范围。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification;class PriceSpecification implements SpecificationInterface&#123; /** * @var float|null */ private $maxPrice; /** * @var float|null */ private $minPrice; /** * @param float $minPrice * @param float $maxPrice */ public function __construct($minPrice, $maxPrice) &#123; $this-&gt;minPrice = $minPrice; $this-&gt;maxPrice = $maxPrice; &#125; public function isSatisfiedBy(Item $item): bool &#123; if ($this-&gt;maxPrice !== null &amp;&amp; $item-&gt;getPrice() &gt; $this-&gt;maxPrice) &#123; return false; &#125; if ($this-&gt;minPrice !== null &amp;&amp; $item-&gt;getPrice() &lt; $this-&gt;minPrice) &#123; return false; &#125; return true; &#125;&#125; 下面我们进行单元测试，如果不懂单元测试的朋友，也可以直接使用上面的代码进行测试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace DesignPatterns\\Behavioral\\Specification\\Tests;use DesignPatterns\\Behavioral\\Specification\\Item;use DesignPatterns\\Behavioral\\Specification\\NotSpecification;use DesignPatterns\\Behavioral\\Specification\\OrSpecification;use DesignPatterns\\Behavioral\\Specification\\AndSpecification;use DesignPatterns\\Behavioral\\Specification\\PriceSpecification;use PHPUnit\\Framework\\TestCase;class SpecificationTest extends TestCase&#123; public function testCanOr() &#123; $spec1 = new PriceSpecification(50, 99); $spec2 = new PriceSpecification(101, 200); $orSpec = new OrSpecification($spec1, $spec2); $this-&gt;assertFalse($orSpec-&gt;isSatisfiedBy(new Item(100))); $this-&gt;assertTrue($orSpec-&gt;isSatisfiedBy(new Item(51))); $this-&gt;assertTrue($orSpec-&gt;isSatisfiedBy(new Item(150))); &#125; public function testCanAnd() &#123; $spec1 = new PriceSpecification(50, 100); $spec2 = new PriceSpecification(80, 200); $andSpec = new AndSpecification($spec1, $spec2); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(150))); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(1))); $this-&gt;assertFalse($andSpec-&gt;isSatisfiedBy(new Item(51))); $this-&gt;assertTrue($andSpec-&gt;isSatisfiedBy(new Item(100))); &#125; public function testCanNot() &#123; $spec1 = new PriceSpecification(50, 100); $notSpec = new NotSpecification($spec1); $this-&gt;assertTrue($notSpec-&gt;isSatisfiedBy(new Item(150))); $this-&gt;assertFalse($notSpec-&gt;isSatisfiedBy(new Item(50))); &#125;&#125; 这样一来，我们就设计出了优雅而又健壮的代码。 说明： 本文章代码，来自于 Github 开源项目，点击链接进入查看http://designpatternsphp.readthedocs.io/","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP设计模式","slug":"PHP设计模式","permalink":"http://yoursite.com/tags/PHP设计模式/"}]},{"title":"","slug":"单例模式 - Singleton","date":"2017-03-16T15:28:53.000Z","updated":"2017-03-16T15:28:53.000Z","comments":true,"path":"2017/03/16/cj5yqargr002digrd27256ugd/","link":"","permalink":"http://yoursite.com/2017/03/16/cj5yqargr002digrd27256ugd/","excerpt":"","text":"单例模式 - Singleton单例模式确保每一个指定的类只存在一个实例对象，并且可以全局访问那个实例。一般情况下会用延时加载的策略，指在第一次需要使用的时候初始化。 设计模式并不局限于某一个语言，他是一种编程思维 在 iOS 开发中单例模式h很常见，NSUserDefaults.standardUserDefaults()等等。 如果多于一个实例又会怎么样呢？代码和内存还没精贵到这个地步吧？ 某些场景下，保持实例对象仅有一份是很有意义的。举个例子，你的应用实例 (UIApplication)，应该只有一个吧，显然是指你的当前应用。还有一个例子：设备的屏幕 (UIScreen) 实例也是这样，所以对于这些类的情况，你只想要一个实例对象。 单例模式的应用还有另一种情况：你需要一个全局类来处理配置文件。我们很容易通过单例模式实现线程安全的实例访问，而如果有多个类可以同时访问配置文件，那可就复杂多了。 使用单例模式 这是一个日志类，有一个属性（是以单例对象）和两个方法（sharedInstance()和 init()）。 第一吊用 sharedInstance()的时候，instance 属性还没有初始化，所以我们必须创建一个新的实例并且返回。 下一次再调用 sharedInstance()的时候，instance 已经完成了初始化，直接返回即可，这个逻辑就确保了只有一个实例对象。 接下来我们继续完善单例模式，通过这个类来管理专辑数据。 注意到在我们前面的截图里，分组中有个 API 分组，这里可以放那些提供后台服务的类。在这个分组中创建一个新的文件 LibraryAPI.swift ，继承自 NSObject 类。 在 LibraryAPI 里添加下面这段代码：","categories":[],"tags":[]},{"title":"iOS多线程","slug":"Untitled","date":"2017-03-16T06:18:18.000Z","updated":"2017-07-17T05:54:48.000Z","comments":true,"path":"2017/03/16/cj5yqarfz001digrdrx4kd8un/","link":"","permalink":"http://yoursite.com/2017/03/16/cj5yqarfz001digrdrx4kd8un/","excerpt":"","text":"NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在制定的线程中、或者立即、延迟执行某个方法调用个。这个方法给用户实现多线程编程最简单的方法。 在当前线程中执行方法： 123- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay: (NSTimeInterval)delay inModes:(NSArray *)modes 在指定线程中执行方法： 12345- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array 在主线程中执行方法： 12345- (void)performSelectorOnMainThread: (SEL)selector withObject:(id)argument waitUntilDone:(BOOL)wait- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array 在后台线程中执行方法： 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg 这一系列方法简单易用，但只提供了有限的几个选择：指定执行的方法（但传入方法的参数数量有限制）；指定是在当前线程，还是在主线程，还是在后台线程执行；指定是否需要阻塞当前线程等待结果。 例如，以下代码使得方法 foo: 在一个新的后台线程执行，并传入了 object 参数： 12SEL selector ＝ @selector(foo:);[self performSelectorInBackground:selector withObject:object]; 以下代码使得 updateUI 方法在主线程内得到执行，并且当前线程会被阻塞，直到主线程执行完该函数： 1[self performSelectorOnMainThread:@selector(updateUI) withObject:nil waitUntilDone:YES];","categories":[],"tags":[]},{"title":"","slug":"图层树","date":"2017-03-16T02:36:21.000Z","updated":"2017-03-16T02:36:21.000Z","comments":true,"path":"2017/03/16/cj5yqargv002jigrd7xjdv79l/","link":"","permalink":"http://yoursite.com/2017/03/16/cj5yqargv002jigrd7xjdv79l/","excerpt":"","text":"图层树Core Animation 是一个符合引擎，塔的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分分解成独立的图层，存储在一个叫做图层数的体系中，于是这个树形成了 UIKit 以及在 iOS 10应用程序当中你所看能在屏幕上看见的一切的基础。 图层与视图如果你曾经在 iOS 10或MacOS 平台上面写过应用程序，你可能能会对视图的概念比较熟悉。一个视图就是在屏幕上显示一个矩形块（比如图片，文字或者视频），它能拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系。 图1.1一种典型的 iOS 屏幕（左边）和型城市图的层级关系（右边） 在 iOS 中，所有的视图都从一个叫做 UIview 的基类派生而来，UIView 可以处理触摸事件，可以支持基于 Core Graphics 绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。 CALayerCALayer类在概念上和 UIView 类似，同样也是一些被层级关系树管理的矩形块，同样可以包含一些内容（像图片，文本或者背景色），管理子视图的位置。它们有一些方法和尚需经用来做动画和变换。 和 UIview 最大的不同是 CALayer 不处理用户的交互。 CALayer 兵不清楚具体的响应链（iOS通过视图层级关系用来传递触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触电在图层的范围之内。 平行的层级关系每一个 UIView 都有一个 CALayer 实例的图层属性，也就是所谓的 Backing layer,视图的职责就是创建并管理这个图层，以确保子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应是在层级关系树当中有相同的操作（见图1.2） 图1.2 图层的树状结构（左边）以及对应的视图层级（右边） 实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView 仅仅是对它的一个封装，提供了一些 iOS 类似于处理触摸事件的具体功能，以及 Core Animation 底层方法的高级借口。 但是为什么 iOS 要基于 UIview 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这也是能避免很多重复代码。在 iOS 和 Mac OS两个平台上，时间和用户交互有很多地方不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么 iOS有 UIKit 和 UIView，但是 MacOS 有 APPKit 和 NSView 的元婴。他们功能上很类似，但是在实现上有着显著的区别。 绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。+ 实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，","categories":[],"tags":[]},{"title":"PHP Closures","slug":"PHP 的闭包","date":"2017-03-15T14:15:16.000Z","updated":"2017-05-31T06:39:12.000Z","comments":true,"path":"2017/03/15/cj5yqarf8000ligrdsqbrqk5j/","link":"","permalink":"http://yoursite.com/2017/03/15/cj5yqarf8000ligrdsqbrqk5j/","excerpt":"","text":"PHP 的闭包闭包函数（closures）也就做匿名函数（Anonymous functions），是指在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。 理论上，闭包和匿名函数是不同的概念，不过 PHP 将其视作相同的概念，所以闭包与匿名函数相等。 匿名函数其实就是没有名字的函数。匿名函数可以赋值给变量，还能像其他任何 PHP 对象那样传递。不过匿名函数仍然是函数，因此可以调用，还可以传入参数。匿名函数特别适合作为函数或方法的回调。 创建闭包12345$closure = function ($name) &#123; return sprintf(&apos;Hello %s&apos;, $name);&#125;;echo $closure(&apos;Maksim&apos;);//输出 Hello Maksim 创建一个闭包对象，然后将其复制给$closure 变量。闭包和普通的 PHP 函数很想：使用语句相同，也接受参数，而且能返回值。不过，匿名函数没有名称。 我们通常把 PHP 闭包当做函数和方法的回调使用。很多 PHP 函数都会用到回调函数，例如 array_map()和 preg_replace_callback()。这是使用 PHP 匿名函数的最佳时机！，记住，闭包和其他值一样，可以作为参数传入其他 PHP 函数，我们把一个闭包对象当做回调参数，传给 array_map()函数。 12345$numbersPlusOne = array_map(function ($number)&#123; return $number + 1;&#125;,[1,2,3]);print_r($numbersPlusOne);//([0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4) 在闭包出现之前，PHP 开发者只能单独创建普通函数，然后使用名称引用那个函数，这么做，代码执行的稍微慢一点，而且把回调场景和使用场景分割开了，如下： 123456$numbersPlusOne = array_map(&apos;incrementNumber&apos;,[1,2,3]);function incrementNumber($number)&#123; return $number + 1;&#125;print_r($numbersPlusOne);//([0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4) 这样的代码虽然可用，但是没有使用闭包来的间接。如果只需要使用一次回调，没有必要单独定义具名函数。把闭包当做回调使用，写出的代码更加简洁、清晰。 附加状态前面演示了如何把匿名函数当做回调使用，下面探讨如何为 PHP 闭包附加兵封装状态。JavaScript 开发者可能对 PHP 的闭包感到奇怪，因为 PHP 闭包不会像真正的 JavaScript 闭包那样自动封装应用状态。在 PHP 中，必须手动调用闭包对象的 bindTo()方法或者使用 use 关键字，把状态附加到 PHP 闭包上。 使用 use 关键字附加闭包状态常见得多，因此我们先看这种方式。使用 use 关键字把变量附加到闭包上时，附加的变量会记住附加时赋给它的值。 123456789101112function enclosePerson($name) &#123; return function ($doCommand) use ($name) &#123; return sprintf(&apos;%s, %s&apos;, $name, $doCommand); &#125;;&#125;//把字符串“Maksim”封装在闭包中$clay = enclosePerson(&apos;Clay&apos;);//掺入参数，调用闭包echo $clay(&apos;get sweet tea&apos;);// Clay, get sweet tea 使用 use 关键字可以把多个参数传入闭包，此时要像 PHP 函数或者方法的参数一样，使用逗号分割多个参数 PHP 闭包是对象。与其他 PHP 对象类似，每个闭包实例都可以使用$this 关键字获取闭包的内部状态。闭包对象的默认状态没什么用，不过有一个__invoke()魔术方法和 bindTo()方法，仅此而已。 但是，bindTo()方法为闭包增加了一些有趣的潜力。我们可以把使用这个方法把 Closure 对象的内部状态绑定到其他对象上。bindTo()方法的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的 PHP 类。因此闭包可以访问绑定闭包的对象中受保护和私有的成员变量。 你会发现，PHP 框架经常使用 bindTo()方法把路由 URL 映射到匿名回调函数上。框架会把匿名函数绑定到应用对象上，这么做可以把这个匿名函数中使用$this 关键字引用重要的应用对象。 参考 现代 PHP 官方手册","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"Closures","slug":"Closures","permalink":"http://yoursite.com/tags/Closures/"}]},{"title":"","slug":"RESTFul 是什么？","date":"2017-03-14T06:30:03.000Z","updated":"2017-07-17T05:46:24.000Z","comments":true,"path":"2017/03/14/cj5yqarfo0010igrdui8g818k/","link":"","permalink":"http://yoursite.com/2017/03/14/cj5yqarfo0010igrdui8g818k/","excerpt":"","text":"RESTFul 是什么？RESTful的本质是一种软件架构风格，核心是面向资源，主要用来解决降低开发的复杂性，提高系统的可伸缩性。随着互联网的发展，各种终端层出不穷，手机浏览器，手机 APP 为了节约成本，我们可以使用 RESTful 架构，只需要封装好一套完善的API就可以为多套终端提供服务。 设计概念和准则 网络上所有事物都可以被抽象为资源 每一个资源都有唯一的标识符，对资源的操作不会改变这些标识 所有的操作都是无状态的 所谓的资源就是网络上的一个实体，或者说是网络上一个具体的信息。 HTTP 协议 - URL HTTP 是一个属于应用层的协议，特点是简捷、快速 1schema://host[:port]/path[?query-string][#anchor] schema 指定底层使用的协议（如：http,https） host 服务器的 IP 地址或者域名 port 服务器端口 path 访问资源的路径 query-string 发送给 http 服务器的数据 anchor 锚 HTTP","categories":[],"tags":[]},{"title":"","slug":"光源色、物体色、固有色","date":"2017-03-14T06:20:11.000Z","updated":"2017-03-14T06:20:11.000Z","comments":true,"path":"2017/03/14/cj5yqargp002aigrdwwcaor6u/","link":"","permalink":"http://yoursite.com/2017/03/14/cj5yqargp002aigrdwwcaor6u/","excerpt":"","text":"光源色、物体色、固有色什么是光源色光源色指的是发光体所发出光线的颜色。例如，阳光、月光、火光和各种灯光等的光色。光源色的不同会引起物体的固有颜色的变化。例如，一块红布在白天看起来和在晚上灯光下看起来颜色是有所不同的。许多女同志都懂得这一点，她们避免晚上去商店购买衣料，因为晚上灯光下看到的黄色，和白天看到的是有些不一样的。就是同样的眼光来说，在早晨、正午和傍晚其光色也是不相同的，会引起同一景物的色调的显著变化。 物体在不同颜色的光照下会呈现出跟光颜色比较接近的色彩，这些都是收到光源色彩的影响。 什么是物体色物体色是指光源色经过物体有选择的吸收和反射，反映到人的视觉中的光色感觉。物体本身并不会发光，但都具有对各种波长的光有所选择性的吸收、反射或者投射的特性，因此形成千变万化的不相同的物体色彩。 物体可以分为透明物体和不透明物体，不透明物体呈现的色彩是由它反射的光色决定的，而透明物体呈现的色彩则是由它透过的色彩决定的。 如绿色树叶吸收太阳光除绿色光的其他色光，所以我们看到的是绿色，而蓝色玻璃只透过蓝色光吸收其他光所以看起来呈现的是蓝色。 什么是固有色固有色指的是一个物体在通常情况下给人的色彩印象（概念）例如，红旗是红色的，草地是绿色的，中国人的皮肤是黄色的等等。 从色彩的光学原理知道物体并不存在固定不变的固有颜色，物体的颜色是与光密切相关的，是在一定的条件下变化的，是具体的，而不是一种概念。讲中国人皮肤是黄色的，其实不可能指出是哪一种具体的光色。然而，物体的颜色景观是变化的、复杂的，单扔给我们一定的色彩印象。所以我们既不要受固有色概念的束缚，又不能完全故事固有色。","categories":[],"tags":[]},{"title":"色彩基础","slug":"色彩的基本构成和使用方法","date":"2017-03-11T12:40:00.000Z","updated":"2017-03-11T12:40:58.000Z","comments":true,"path":"2017/03/11/cj5yqaria003vigrdjd05oh0y/","link":"","permalink":"http://yoursite.com/2017/03/11/cj5yqaria003vigrdjd05oh0y/","excerpt":"","text":"色彩的基本构成和使用方法 色彩的定义是什么 色彩的种类 色彩3大特点 色彩的定义是什么我们平时看到的所有东西都会有自己的色彩，有难以感觉到的灰暗，也有鲜艳耀眼的成色等，其实色彩是依赖于光存在的，没有光就不会有色彩，色彩是物体对光谱的反射给人眼传达的一种视觉信息。 我们可以把颜色通过可见光的波长来划分，这有点跟 PS 软件上面的取色板上的色彩排列相似（如下图）。 光其实也是电磁波的一种，我们知道电磁波的传播速度是一样的，而决定我们看到颜色光的色彩的就是电磁波的波长，我们可以从图中看到不同颜色对应的波长范围，如红色光的波长在760纳米之间，蓝色光的波长范围在380纳米之间，所以可见光的范围在380-760之间（如下图）。 色彩种类划分我们可以看到的可见光的范围是380-760纳米波长之间的光谱，通过三棱镜折射出太阳光我们可以看到红橙光绿青蓝紫7中颜色，而实际上我们可以把颜色归类成红黄蓝三追踪原色，这3种颜色可以通过组合搭配调配处其他任意颜色。 色光三颜色 ： 红黄蓝 RGB（PS 案例）物体三颜色： 红蓝黄（水彩绘画） 色彩的三要素 色相 明度 纯度（饱和度） 色相色相其实就是指色彩，物体所呈现的颜色状态叫做色相，如红旗的颜色就是红色，天空的颜色是蓝色，荷叶的颜色是绿色，我们可以很简单的识别一种物体的色相。 在 RGB 色彩模式中，色彩用红，绿，蓝三种色彩来合成表现的，每种色彩分成255个阶，通过不同的比例调配出千变万化的色彩。 明度明度是指色彩的明暗程度，也称深浅度，是表现颜色层次感的基础。 我们知道色彩的表现是以光反射的形式表现的，比如同一个橙子的颜色是橙色的，但是在明度上的变化让我们可以看出这个橙子的立体感(如下图)。 在无彩色系中，白色明度最高，黑色明度最低，在黑白之间存在一系列灰色，靠近白色的部分称之为名灰色，靠近黑色的部分称之为暗灰色。在有色系中，黄色明度最高，紫色明度最低。任何一个有色彩，当它掺入白色时，明度提高，当掺入黑色时，明度降低。同时其混度也响应降低。 在 RGB 色彩模式中，RGB 色彩3个数值相加越大就代表色彩明度越高，我们可以简单理解为月亮的颜色明度越高，就比如R：255是红色，那么 R255，G：50，B：50就是加了亮度的红色，会显得亮而且轻(如图)。 纯度（饱和度）纯度通常是指色彩的鲜艳程度。从科学的角度看，一种颜色的鲜艳度取决于这一色相发射光的单一程度，也就是指原色在色彩中所占的百分比。人眼能识别的有单色光特征的颜色，都具有一定的鲜艳度。不同色相不仅明度不同，纯度也不相同。 通常纯色的纯度最高，也就是不加入黑白灰的颜色，同一色相的色彩，不掺杂白色或者黑色，则被称为纯色。在纯色中加入不同明度的无彩色，会出现不同的纯度。以蓝色为例，向纯蓝色中加入一点白色，纯度下降而明度上升，变为淡蓝色。继续加入白色的量，颜色会越来越淡，纯度下降，而明度持续上升。反之，加入黑色或灰色，则相应的纯度和明度同时下降。","categories":[{"name":"设计","slug":"设计","permalink":"http://yoursite.com/categories/设计/"}],"tags":[{"name":"色彩","slug":"色彩","permalink":"http://yoursite.com/tags/色彩/"}]},{"title":"使用 Vagrant 统一公司内开发环境","slug":"使用 Vagrant 搭建开发环境","date":"2016-12-13T01:10:23.000Z","updated":"2017-05-31T06:50:37.000Z","comments":true,"path":"2016/12/13/cj5yqargo0027igrdtsk2zp8c/","link":"","permalink":"http://yoursite.com/2016/12/13/cj5yqargo0027igrdtsk2zp8c/","excerpt":"","text":"使用 Vagrant 搭建开发环境Vagrant 是什么 Vagrant 是构建在虚拟化技术上的虚拟机运行环境管理工具 建立和删除虚拟机 配置虚拟机运行参数 管理虚拟机运行状态 自动化配置和安装开发环境 打包和分发虚拟机运行环境 Vagrant 的运行，需要依赖某项具体的虚拟化技术 Virtualbox WMWare Vagrantd的作用 跨平台 可移动 自动化部署无需人工参与 减少人力培训成本 统一开发环境 Vagrant 适用范围 开发环境 项目配置比较复杂 官网：https://www.vagrantup.com/vagrant与 VirtualBox的版本需要注意匹配，在官网有详细介绍，如果版本不匹配会出现一些错误。 常用命令 vagrant box list 查看目前已有的box vagrant box add 新增加一个box vagrant box remove 删除指定box vagrant init 初始化 vagrant up 启动虚拟机 vagrant ssh SSH 登陆虚拟机 vagrant suspend 挂起虚拟机 vagrant reload 重启虚拟机 vagrant halt 关闭虚拟机 vagrant status 查看虚拟机运行状态 vagrant destroy 销毁当前虚拟机","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"PHP设计模式系列之入门","slug":"PHP设计模式系列之入门","date":"2016-09-23T14:15:16.000Z","updated":"2017-03-12T04:33:28.000Z","comments":true,"path":"2016/09/23/108/","link":"","permalink":"http://yoursite.com/2016/09/23/108/","excerpt":"","text":"设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 前言 本系列文章不会直接上代码直接进行解释，我一直认为带着问题来学习是效率最高的学习方式。 本系列文章不会有演示截图，你为什么不敲一遍加深印象呢，另外说不定我的代码有错。 我所写的文章只是我对于编程的理解，如果有错误希望能够得到指正以免误人子弟。 怎么样才可以进行设计模式的学习步子迈大了容易扯到蛋，如果在没有熟悉 OOP 编程思想前就开始学习设计模式，我感觉会有两种可能，不是“扯蛋”，就是“拉跨”。 当然上面的话是一句玩笑话，学习设计模式可以有效的提高我们的代码质量与深入的理解 OOP 编程理念，如但是果在没有扎实的功底（至少要要理解了抽象、接口、多态）前就开始学习设计模式会越学越难，脑子越来越浑，那就真变成了从入门到放弃了，因为你的思维还没有真正的走进 OOP(单身狗表示完全无法面向对象^_^)。 对于设计模式的不理解我感觉主要分为两种，一种是不知道怎么实现的，原因就是如上所述，另外一种是不知道为什么要这么用的，其实没有必要纠结于为什么这么用，这么用了有啥作用，设计模式不过是与算法一样只是为了实现某个特定环境下可以使用的一种更好的选择。 更好一点的例子就是当我们对一些数据进行排序的时候，我们首先想到就是那几个排序算法一样，当我们打着打着代码突然灵光一闪，好像这个地方用这个设计模式写起来会轻松一点。 当碰到不懂得地方，思考一下，想不通，就出去走走，把这个东西放下来，反正就算看到第二天凌晨也也是无用的，当真正遇到问题的时候，灵光一闪这个东西可以这么写，然后去实践，这就是我的学习之道。还有就是尽量去学实例，而不是去死扣概念，当你真正用起来了，你也就差不多懂了，算法与数据结构亦是如此。 本系列文章尽量以推导的形式来进行书写，而不是以现成的代码来进行讲解，让读者知道设计模式是怎么来的也就是如何演化出来的，希望各位能够喜欢。另外本系列的文章并不会提供运行界面的截图，如果想看看结果是否正确，为什么不自己试试呢？ 设计模式尝鲜（策略模式）开头引用的话来自于百度百科，我相信很多刚刚开始接触编程的人都会犯晕，因为所有人都不喜欢被学术化的文字，我们以设计模式中较为常用的策略模式来进行演示，当我们编写一个广告模块的时候，公司给的要求是根据访问者的性别来进行显示广告以提高转化率，那我们应该怎么写呢？ 首先我们想到的是在每一个广告位上面都使用 if 判断来判断访客的性别，这样就能够解决这样的需求，那么我们的每一个广告代码的代码块可能是这个样子的： 12345判断 男 or 女&#123; 如果是男的就是男人的广告&#125;else&#123; 显示女人的广告&#125; 既然伪代码想好了，那么我们就可以着手进行开发了，然后我们在 if 代码块中添加各自的家在广告代码，于是就变成了下面的样子： 12345if ($_GET[&apos;sex&apos;] == &apos;man&apos;) &#123; echo &apos;外星人大减价现在购买立即送电竞瑞文皮肤&apos;;&#125;else&#123; echo &apos;卡西欧美颜相机不要钱免费送！&apos;;&#125; 但是这是属于一种硬编码的编程方式，一旦我们增加了某种需求，要求其年龄大于23岁显示什么样的广告，那么我们就不得不在每一个 if 判断处再加上新的判断条件，这样的设计就是不合理的，为了提高可读性与可维护性，我们会考虑建立两个不同的类来对两个广告类来对其进行管理。于是代码变成了下面的样子。 12345678910111213141516171819202122232425//index.phpinclude &apos;GenderAD.php&apos;;include &apos;ManAD.php&apos;;if ($_GET[&apos;sex&apos;] == &apos;man&apos;) &#123; $ad = new ManAD();&#125;else&#123; $ad = new GenderAD();&#125;$ad-&gt;show();//GenderAD.phpclass GenderAD&#123; public algorithm()&#123; echo &apos;卡西欧美颜相机不要钱免费送！&apos;; &#125;&#125;//ManAD.phpclass ManAD&#123; public algorithm()&#123; echo &apos;外星人大减价现在购买立即送电竞瑞文皮肤&apos;; &#125;&#125; algorithm 英[ˈælgərɪðəm] 美[ˈælɡəˌrɪðəm] n. 演算法; 运算法则; 计算程序; 其实到了这一步就已经算是一个简单的策略模式了，因为他已经具有策略的特质了，只不过还不够完善，如果说这不算什么的话我也没有办法，因为所有的设计模式其实都是思维模式与表现形式罢了，就像上面的引用中提到的一样，设计模式只不过是为了能够让代码可以重用，更容易他让人理解，因为你的代码并不是你一个人在维护，那么问题来了，只是简单的对其进行封装真的就提高代码的可维护性了么，其实并没有，我们还没有将 OOP 的设计概念发挥到极致。 经过分析我们发现其实 ManAD类和 GenderAD最终都要进行显示，他们的方法的显示方法都是 show，如果是你一个人在开发那么没有什么问题，可是若是两个人开发呢，你们可以直接可以对话的方式进行沟通，协定好都是 show方法来显示，可是为什么不用更工程化的方式来实现呢？ 我们可以使用接口来实现这一目的，如果对接口还不了解，可以去查阅一下资料，很快你就能够明白，在本文结束后我会在下方标注出参考范例。 我们可以新建一个接口来对这些策略进行控制。 12345678910111213141516interface ADinterface&#123; public function algorithm();&#125;class ManAD implements ADInterface&#123; public function algorithm()&#123; echo &apos;外星人大减价现在购买立即送电竞瑞文皮肤&apos;; &#125;&#125;class GenderAD implements ADInterface&#123; public function algorithm()&#123; echo &apos;卡西欧美颜相机不要钱免费送！&apos;; &#125;&#125; 这样一来广告策略必须遵循这个接口进行开发，就保证了所有策略类都需要实现 show 方法。 到目前为止，策略模式已经相对的完善了，但是还是不够完美，因为代码依旧并不是很 OOP，我们其实还可以更进一步，让他更 OOP，我们可以对那些策略外面套一个壳子，给外面一个选择器。 123456789101112131415class StrategySelect &#123; //具体策略对象 private $strategyInstance; //构造函数 public function __construct($instance) &#123; $this-&gt;strategyInstance = $instance; &#125; public function algorithm($strategy) &#123; return $this-&gt;strategyInstance-&gt;algorithm(); &#125;&#125; 我们通过构造函数接收到具体的执行策略，然后使用algorithm()执行相对应的策略。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpinterface ADinterface&#123; public function algorithm();&#125;class StrategySelect &#123; //具体策略对象 private $strategyInstance; //构造函数 public function __construct($instance) &#123; $this-&gt;strategyInstance = $instance; &#125; public function algorithm() &#123; return $this-&gt;strategyInstance-&gt;algorithm(); &#125;&#125;class ManAD implements ADInterface&#123; public function algorithm()&#123; echo &apos;外星人大减价现在购买立即送电竞瑞文皮肤&apos;; &#125;&#125;class GenderAD implements ADInterface&#123; public function algorithm()&#123; echo &apos;卡西欧相机免费赠送啦&apos;; &#125;&#125;header(&quot;Content-type:text/html;charset=utf-8&quot;);if ($_GET[&apos;sex&apos;] == &apos;man&apos;) &#123; $stratey = new StrategySelect(new ManAD()); $stratey-&gt;algorithm();&#125;else&#123; $stratey = new StrategySelect(new GenderAD()); $stratey-&gt;algorithm();&#125; Strategy其实算是一个策略选择器，当满足一定条件的时候，我们通过这个策略选测器来进行选择相对应的策略。这样一来更符合逻辑。是不是很 OOP？ 如果有什么不懂得可以在评论区进行留言，有时间我会一一答复，如果发现本文中有什么错误请指出，我也害怕误人子弟，特别是概念上的东西，在最后StrategySelect类的讲解上我依旧感觉写的很模糊，有些差强人意。 参考文档 《Leaning PHP Design Patterns》 William Sanders 著 苏金国 王宇飞等译 《PHP之道》 《PHP大话设计模式》 Rango(韩天峰) 录制者 慕课网视频教程","categories":[{"name":"PHP设计模式","slug":"PHP设计模式","permalink":"http://yoursite.com/categories/PHP设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"AV Foundation那些事系列（一）AVFunction入门了解","slug":"文字转语音","date":"2016-07-30T12:38:29.000Z","updated":"2016-07-30T13:36:40.000Z","comments":true,"path":"2016/07/30/194/","link":"","permalink":"http://yoursite.com/2016/07/30/194/","excerpt":"","text":"前言Hello，大家好，先做一个简短的自我介绍，我是AirCrayon，目前就职于齐齐哈尔的一家创业型公司，从今天开始，每周末我都将为大家带来一篇博文，今天为大家带阿里的是 AVFunction 的那些事系列博文的第一章——AV Foundation入门。 苹果公司一直以来都是一家擅长引领潮流的一家公司，不论是产品设计开始技术革新，1991年苹果公司推出了QuickTime首次将数字音频和数字视频展现在用户面前。 QuickTime不仅仅是一个媒体播放器，而且是一个完整的多媒体架构，可以用来进行多种媒体的创建、生产和分发，并为这一过程提供端到端的支持：包括媒体的实时捕捉，以编程的方式合成媒体，导入和导出现有的媒体，还有编辑和制作、压缩、分发，以及用户回放等多个环节。 在2001年苹果公司推出了iTunes和iPod，从根本上改变了用户收听音乐的方式，iTunes store的出现彻底改变了国外的传统音乐行业（多么牛的一家公司）。 AV Foundation 的含义AV Foundation是MacOS（目前还叫 OS X ，但最新版本的名字将叫做 MacOS）和 iOS 系统中用于处理基于时间的媒体数据的高级Objective-C框架。通过开发所需要的工具提供了大量的功能集，让开发者能够基于 Apple 平台创建媒体应用程序。AV Foundation 的构建考虑到了目前的硬件环境和应用程序，其设计过程高度依赖于多线程机制。充分利用了多和设备的有时并且使用了大量的 block 和 GCD 机制将复杂的计算放在后台线程中会自动提供硬件加速操作，确保在大部分设备上应用程序以最佳的性能运行。AV Foundation 的设计也充分考虑了电量效率来满足注入 iPhone 和 iPad 这类的移动设备，此外从一开始该框架就是针对于64位处理器设计，可以发挥64为处理器的所有优势。 在iOS7下的AVFoundation下增加了一个类用于文字转成语音,需要注意的是其转换的语音与你的手机语言环境有关,如果手机是英文环境,则无法读取中文字符串,但是中文环境下可以读取英文. 12AVSpeechSynthesizer *xx = [[AVSpeechSynthesizer alloc]init]; //开始播放[xx speakUtterance:[AVSpeechUtterance speechUtteranceWithString:@&quot;语音转换&quot;]];","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"对于未来的规划","slug":"plan","date":"2016-07-20T04:45:16.000Z","updated":"2016-07-20T05:10:54.000Z","comments":true,"path":"2016/07/20/cj5yqargg001wigrdkrl5n68d/","link":"","permalink":"http://yoursite.com/2016/07/20/cj5yqargg001wigrdkrl5n68d/","excerpt":"","text":"我现在在做什么很久没有写博客了，其实是不知道写什么了，目前在做一个 PHP的项目，这也算是大学没有白白浪费，至少还学了一门语言，虽然并没有一上来就做 iOS 心里有点小遗憾。我并没有回北京而是选择留在了齐齐哈尔，这是一座很美的城市，其中也有很多回忆，留下来的一个原因就是这里的回忆实在是太多了，等回忆被齐齐哈尔的大风吹散也就该是离开这里的时候了。 对于未来的规划规划这种东西规划的太久也没有用，谁都不可能预料到以后会发生什么，只能说是大致心里有一个方向，最近打算在看 swfit 的同时也看一下安卓。本身我就会 PHP，说不定在齐齐哈尔的这段时间里我会成为一个全栈工程师。 毕业了，虽然闲散的时间少了，但是这个时候我可以去做一些我喜欢做的事情，因为可以自己赚钱了，昨天在网上买了一个瑜伽垫准备开始健身，健康的身体才是未来的保障，我还买了一套美术教程，其实我还想买一个尤克里里，但是想了想还是算了，可能是在我出生的时候身上的音乐细胞就全都被消灭掉了。 我目前每天11点半睡觉，早晨五点钟起床，从五点到六点半的这个时间段我分配出了半个小时锻炼，一个小时的晨读，读的并不是技术类的书籍而是一些读物，目前正在读《百年孤独》，这样做只是希望自己能够得到精神上的满足还有活跃一下脑子，害怕有一天变成了代码脑袋。 以下是我这一年要读的书： 《百年孤独》 《摆渡人》 在齐齐哈尔这段时间要掌握的技能： 安卓开发 跨平台开发 自己的爱好： 可以画简单的插画 新书收藏超过500 这样今年简单的计划就算是完成了","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Objective-C Runtime：Class","slug":"Runtime:Class","date":"2016-05-30T16:27:31.000Z","updated":"2017-07-17T05:53:32.000Z","comments":true,"path":"2016/05/31/2/","link":"","permalink":"http://yoursite.com/2016/05/31/2/","excerpt":"","text":"Objective-C具有相当多的动态特性，表现在三个方面动态类型（Dynamic typeing）、动态绑定（ggDynamic binding）、动态加载（Dynamic loading），之所以被叫做动态，是因为必须到运行时（Runtime）才会做这些事情。 动态类型：即运行时在决定对象的类型。这类动态特性在日常生活中非常常见，简单说就是id类型。实际上静态类因为固定性与可与执行而使用得更加广泛，静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。 动态绑定：基于冬天类型，在某个实例对象呗确定后，其类型便被确定了，该对象对应的水泥管和响应的消息也将会被完全确定。 动态加载：根据需求加载所需要的资源，最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的图通屏幕设备上加载原图。 这一切的特性都是由于objective-c的Runtime。 Runtime库主要做了下面的几件事 封装：在这个库中对象可以用C语言的结构体表示，而方法可以用C函数来实现，另外再加上一些额外的特性。这些结构体和函数被runtime封装后，我们就可以在程序运行时创建、检查，修改类、对象和它们的方法了。 找出方法的最终执行代码：当程序执行[object doSometing]时，会想消息接受者（object）发送一条消息，runtime会根据消息接受者是否响应该消息而做出不同的反应。 而在我们在了解Runtime之前，我们需要清楚Runtime的数据类型 如果想要进一步的了解，我们可以到苹果开源上下载Runtime的源码来进行学习。 Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下: 1typedef struct objc_class *Class; 1234567891011121314151617struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ isa:需要注意的是在Objective-C中，所有类的自身也是一个对象这个对象的Class里面有一个isa指针，它指向metaClass（元类），下一章进行详细介绍。 super_class：指向该类的父类，如果该类已经是最顶层的根类，则它的值为NULL。 name：类的名称 info:在运行时使用的一些标识 version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。针对cache，我们用下面例子来说明其执行过程： instance_size 该类实例变量的大小 ivars 该类中所有成员变量的数组 methodLists 该类中自定义方法的数组 cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。 protocls 该类遵守协议的数组 1NSArray *array = [[NSArray alloc] init]; 其流程是： [NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。 检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。 接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。 在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。 ##参考资料 Objective-C Runtime 运行时之一：类与对象 Objective-C Runtime的数据类型 Objective-C objc_class 介绍","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[]},{"title":"使用 Feedly RSS阅读器订阅技术大牛的博客","slug":"Rss","date":"2016-05-08T03:06:05.000Z","updated":"2016-05-08T03:06:30.000Z","comments":true,"path":"2016/05/08/cj5yqarfq0014igrdezgo69bx/","link":"","permalink":"http://yoursite.com/2016/05/08/cj5yqarfq0014igrdezgo69bx/","excerpt":"这几天一直都在自己看书，可是书上面的东西都比较落后一点，而且没有大牛博文上的东西讲的深入，可是来回跳转各位大牛的博客又非常的麻烦，有一些公众账号虽然也会推荐一些知识内容，可是你应该有过看到多个公众号发一篇博文的经历吧。 这个时候我想起了一个叫做 RSS 订阅的一个功能，可是国产的RSS 订阅器的 UI 是一个很大的槽点，而且功能相对于臃肿，很多功能都用不到，最终选择了 Feedly 这款 APP，UI 清爽，功能简单，完全符合我的需要，而且还支持 OPML 导入。 AirCrayon 是一名 iOS 程序员，所以我订阅的大多都是 iOS 的技术大牛，大牛唐巧一直在维护一个中文博文列表的项目地：https://github.com/tangqiaoboy/iOSBlogCN","text":"这几天一直都在自己看书，可是书上面的东西都比较落后一点，而且没有大牛博文上的东西讲的深入，可是来回跳转各位大牛的博客又非常的麻烦，有一些公众账号虽然也会推荐一些知识内容，可是你应该有过看到多个公众号发一篇博文的经历吧。 这个时候我想起了一个叫做 RSS 订阅的一个功能，可是国产的RSS 订阅器的 UI 是一个很大的槽点，而且功能相对于臃肿，很多功能都用不到，最终选择了 Feedly 这款 APP，UI 清爽，功能简单，完全符合我的需要，而且还支持 OPML 导入。 AirCrayon 是一名 iOS 程序员，所以我订阅的大多都是 iOS 的技术大牛，大牛唐巧一直在维护一个中文博文列表的项目地：https://github.com/tangqiaoboy/iOSBlogCN 在其中为广大 iOS 程序员提供了一个OPML 文件，将其文件下载来进入Feedly 的官网。 没有账户的同学请先注册账户，虽然是英文的但是一般都应该能看的懂，也就不做注册介绍了。 第一步,登录后点击 AddContent 第二步，右侧栏拉倒底部点击 Import OPML 第三步，上传 OPML 文件 这样一来就已经大功告成了，进入 AppStore 或者安卓市场下载一个 Feedly 后登陆自己的账户后便可以使用手机直接查看技术大牛的最新博文了。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"内存管理 Form《Objectivce-C编程全解》&《Objectivce-C编程》","slug":"基于引用计数的内存管理","date":"2016-05-06T04:31:00.000Z","updated":"2017-07-14T08:44:52.000Z","comments":true,"path":"2016/05/06/cj5yqarh4002sigrdcnqr6wc2/","link":"","permalink":"http://yoursite.com/2016/05/06/cj5yqarh4002sigrdcnqr6wc2/","excerpt":"","text":"Xcode4.2之后可以使用自动引用计数（ARC,Automatic Reference Counting）的管理方式进行说明，ARC 是 Mac OS X 10.7和 iOS5引入的新特性，也是苹果公司推荐使用的内存管理方式。弃用 ARC 后，编译器会在适当的地方自动加入 retaion、release、autorelease 等语句，来简化 Objective-C 编程在内存管理方面的工作量 动态内存管理内存管理的必要性C 语言中需要手动利用 malloc()和 free()对内存进行管理。当程序运行结束时，操作系统会释放掉为其分配的内存。如果是很小、运行时间短的程序，就算是内存没有释放也没有问题，程序结束时操作系统会进行自动释放。而对于长时间运行的程序，则需要程序员释放不再使用的内存，否则程序就会崩溃。 如果程序没能妥善管理内存，运行过程中就不但不能释放不再使用的内存，而且还会不停的分配内容村，这样所占用的内存就会越来越多，程序速度也会越来越慢，最后甚至会出现内存耗尽而崩溃。 就好像滴水一样，程序未能释放已不使用的内存叫做内存泄漏(memory leak)。C 语言中要特别注意内存的动态分配和释放，以防内存泄漏。有效地管理内存，会提高程序的执行效率。 如果访问了以被释放的内存，则会造成数据错误，严重时甚至会导致程序异常终止。在指针指向已被释放或回收的情况下，该指针就称之为悬垂指针（danling pointer）或野指针。继续使用这种指针会造成程序崩溃。 Objective—C 会通过向对象发送 alloc 消息来生成实例对象，alloc 的作用就是分配内存。alloc 方法的返回值是 id 类型，我们之前介绍过 id 其实就是指针类型，而其指向的就是为实例对象分配的内存。生成的实例对象用完之后如果不被释放的话，就会发生内存泄漏。另一方面，如果给已经被释放了的实例对象发送消息，运气好的话会得到警告，告诉你已被释放的对象发送了消息，运气不好的话则会程序错误甚至异常终止，所以 Objective-C 的程序一定要注意内存管理。 在面向对象的语言中，对象是程序的核心。而对象也有生命周期，既有从头到尾一直存在的对象，也有声明起短暂的临时对象。对象之间也可能相互引用，构成结构复杂的数据结构。同面向过程的语言相比，面向对象语言的内存管理更复杂一些。 引用计数器、自动引用计数和自动垃圾回收Coca 环境的 Objective-C 提供了一种动态内存管理方式，称之为引用计数（reference counter）。这种方式会跟踪每一个对象被引用的次数，当对象的引用次数为0的时候，系统会释放掉这个对象所占用的内存。这种内存管理方式也被称之为基于引用计数器的内存管理。 比引用计数内存管理更高级一点的就是自动引用计数（Automatic Reference Counting，简写 ARC）的内存管理。自动引用计数使开发人员不需要考虑何时使用 retain、release、autorelease 来管理内存，它提供了自动评估对象生存期的工恩给你，在编译期间会自动加入何时的内存管理方法，为了同自动引用计数器进行区分，将引用计数内存管理方式称之为手动引用技术内存管理。 除了 ARC 外，Objective-C2.0还引入了另外一种自动内存管理机制——垃圾回收，使用垃圾回收时，就不需要通过引用计数来刮泥创建的对象，系统会自动识别那些对象仍在使用，那些对象可以回收。 程序员可以从手动引用计数管理、ARC 和垃圾回收中选择任意一种内存管理方式来进行开发，不过还是推荐大家使用 ARC 的方式来进行内存管理。 内存管理方式 难易度 Mac iOS 备注 手动引用计数 较难 支持 支持 自动引用计数 容易 支持 支持 现在已经默认使用此方式 垃圾回收 容易 支持 不支持 兼容方法在ARC的程序中,有一些类使用MRC实现的. 如果希望某些指定的类还是使用MRC. 那么这个时候可以在 在targets的build phases选项下Compile Sources下选择要不使用arc编译的文件，双击它，输入 -fno-objc-arc 即可 MRC工程中也可以使用ARC的类。方法如下： 在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可 手动引用计数内存管理本节将说明如何基于引用计数器来管理内存。手中引用计数是内存引用计数的基础，就算程序使用自动引用计数的内存管理，也需要了解手动引用计数的原理。 引用计数Cocoa 环境的 Objective-C 使用了一种叫做引用计数的计数来管理对象所占的内存。每个对象都有一个与之相关的整数——引用计数，当某段代码需要使用一个对象时，就将该对象的引用计数值加1。当这段代码不再使用这个对象的时候，则将对象的引用计数器减1.换而言之，引用计数就是指程序中到底有多少个地方需要访问这个对象。 使用 alloc 和初始化方法创建一个对象的时候，该对象的引用计数初始值为1.假设有一个类 A 在进行某些处理的过程中需要使用到实例 B，为了防止实例化 B被别的对象随意释放，类 A 会实现给实例 B 发送一个 retain 消息。这样，没执行一次 retain，实例 B 的引用计数就会加1。 反之，不需要某个对象时，可以发送 release 消息，使对象的引用计数减1。 实际上，释放内存的并不是 release，而是 dealloc 方法。同 alloc 不同，dealloc 不是类方法而是一个实例方法。没收到一个 release 消息，对象的引用计数器就会减一。当对象的引用计数器达到0的时候，系统就知道这个对象不需要了。这时，Objectivce—C 会自动向对象发送一条 delloc 消息来释放内存。通常允许在程序内直接调用 dealloc。 retain、release和 dealloc 的定义如下所示。retain 的返回值是接收消息的对象。 123-(void)retain;-(oneway void)release;-(void)dealloc; retain 是“保持”的意思，给一个对象发送 retain 消息，就意味着“保持”这个对象。生成对象或通过给对象发送 retain 消息来保持对象这种状态，都可以说是拥有这个对象的所有权（ownership）拥有实例所有权的对象叫做所有者（owner）。 这里需要注意的是，所有权是一个虚拟的概念。既无法通过语法标记，也无法通过这个对象的某个属性表示出来。程序在运行时没发确认某个对象的所有者是谁。所有权仅仅是人们分析阅读程序时，为了说明对象之间的关系而加上去的一个属性。 通过引用计数能够表现出一个对象有几个所有者。只要某个对象的引用计数器大于0就表示这个对象有所有者。引用计数变为0的时候，说明这个对象没有所有者，会被释放。 图1 没有使用引用计数器的例子 让我们通过例子来说明一下基于应用技术的内存管理。首先，假设图（1）中对象 A 的方法把一个新生成的一个实例对象复制给了 A 的实例变量。这个时候新生成的对象的引用计数为1，他的所有者是对象 A，然后，图（2）中把这个对象的指针付给了对象 B 的某个实例变量。因为对象鼻没有发送 retain 消息，所以并不是这个对象的所有者，这个独享的引用计数器还是1.最后图（3）中对象 A 不再使用这个对象的时候发送了一个 release 消息，于是，虽然对象 B 还在使用这个对象，但该对象也被释放了。而此时如果对象 B 给已经释放的消息在发送消息，就会发生运行错误，程序将会异常终止！ 为了防止这样的情况发生，一定要给动态生成的对象发送 retain 消息来增加它的引用计数。只要对对象的引用次数大于零，系统就不会释放它。 测试引用计数让我们通过一个例子来看引用计数到底是如何工作的。 retain 和 release 方法是类 NSObject 的实例方法，方法 retainCount 可以获得对象的引用计数的当前值。retainCount 方法并没有太大的使用价值，一般在调试程序的时候使用。 代码清单的程序显示了对象生成后收到 retain、release 消息时引用计数器的变化。retainCount 的返回值是 NSUInteger 类型，使用 printf 输出返回值的时候需要进行类型转换。 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; id obj = [[NSObject alloc]init]; NSLog(@\"init:%d\",(int)[obj retainCount]); [obj retain]; NSLog(@\"retain:%d\",(int)[obj retainCount]); [obj retain]; NSLog(@\"retain:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); [obj release]; NSLog(@\"release:%d\",(int)[obj retainCount]); return 0;&#125; 程序的输出如下所示。我们可以看出，对象刚生成的时候引用计数器的值为1，没收到一次 retain 消息，引用计数器的值就会加1；而收到 release 消息，引用计数器的值就减少1 12345672016-05-06 13:19:16.761 引用计数器学习[6574:600738] init:12016-05-06 13:19:16.762 引用计数器学习[6574:600738] retain:22016-05-06 13:19:16.762 引用计数器学习[6574:600738] retain:32016-05-06 13:19:16.762 引用计数器学习[6574:600738] release:22016-05-06 13:19:16.763 引用计数器学习[6574:600738] release:12016-05-06 13:19:16.763 引用计数器学习[6574:600738] release:1Program ended with exit code: 0 释放对象的方法在自定义类的时候，如果累的实例变量是一个对象类型，那么，在销毁类的对象的时候，也要给类的实例变量发送 release 消息。 通过给对象发送 release 消息可以放弃对这个对象的所有权，但如前所述，真正释放对象占用的内存方法是 dealloc方法。 释放一个类的实例对象时，为了彻底释放该实例对象的所有对象的所有权，需要为该类重写 dealloc 方法，在其中释放已经分配的资源，放弃实例变量的所有权。 123456- (void)dealloc&#123; //重写的是 dealloc 方法而不是 release 方法 /* 这里通过 release 方法放弃子类中所有实例变量的所有权 其他用于释放前的善后操作也都卸载这里 */&#125; 在重写 dealloc 犯法中，在释放自身之前，首先做好“善后工作”（释放所有需要释放的资源）。一般情况下，“善后工作”包括通过使用 release 放弃自身的实例变量的所有权。销毁对象的时候，不允许直接使用 dealloc，而是使用 release。release 会让引用计数减少1，只有当引用计数等于0的时候系统才会自动调用 dealloc 真正的销毁这个对象。 子类“善后工作”完成后，调用父类的 dealloc 方法来释放父类中定义的实例变量，这样，内存的释放会从子类一直向上知道 NSObject，最终这个对象就会被彻底释放掉。下面的分数计算器的例子中展示了如何重写 dealloc。 Retain计数原则当使用Objective-C编写程序时，如果没有使用 ARC，就必须遵守特定的内存管理约定，否则可以由 ARC 来自动完成相关任务。 下面为 retain 计数总结若干规则，规则中的“你”代表“当前正在使用的某个类实例”。这是一种很有用的带入形式：请读者将自己想象成是在正在编写的那个对象。例如，“如果你保留了某个 NSString 对象，那么该实例就不会被释放掉”的真是意思是“如果读者正在使用的实例保留了某个 NSString 实例，那么该实例就不会被释放。” 下面列出规则（袁阔闹中的是实现细节） 如果用来创建对象的方法，其方法名是以 alloc 或new 开头的，或者包含 copy，那么你已经得到了该对象的所有权（即可以假设新对象的 retain计数是1，而且该对象不再 NSAutoreleasePool 对象中）。你要负责不再需要使用该对象的时候释放掉他。以下是部分常见的、会“传输”所有权的方法：alloc（后面总会跟一个 init 方法）、copy 和 mutableCopy 通过任何其他途径创建的对象（例如通过便捷方法），你是没有所有权的（即可以假设新对象的 retain 计数是1，而且该对象已经在 NSAutoreleasePool 对象中。如果没有保留该对象，那么当NSAutoreleasePool被“排干”时，这个对象会被释放）。 如果你不拥有某个对象，但是要确保该对象能继续存在，那么可以通过响起发送 retain 消息来获得所有权。 当你拥有某个对象并且不再需要使用该对象的时候，可以向其方发送 release 消息或者 autorelease 消息 只要对象还有只要一个拥有方，该对象就会继续存在下去。 ##参考文献： ① Objectivce-C编程全解（第三版） [日]荻原刚志 著 唐璐 翟俊杰 译 ② Objectivce-C编程 [美]Aaron Hillegass 著 夏伟频 译","categories":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/categories/ios/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"http://yoursite.com/tags/内存管理/"}]},{"title":"读书总结之NSObject","slug":"NSObject","date":"2016-05-06T03:03:16.000Z","updated":"2016-05-06T13:29:50.000Z","comments":true,"path":"2016/05/06/cj5yqareo0008igrdlvq2xwr6/","link":"","permalink":"http://yoursite.com/2016/05/06/cj5yqareo0008igrdlvq2xwr6/","excerpt":"使用 Objectvice-C 进行全面对象编程时，除了需要知道语言本身的语法和面向对象的知识外，还需要了解Objectvice-C的根类 NSObject 的信息。 NSObject根类的作用作为一门动态编程语言，Objectstvice-C有很多动态的特性，因此，Objectvice-C不进需要编译环境，同时还需要一个运行时系统（runtime system）来执行编译好的代码。运行时系统扮演的角色类似于Objectvice-C的操作系统，他负责完成对象生成、释放时的内存管理、发来的消息查找对应的处理方法等工作。 通常情况下，程序无法直接使用运行时系统提供的功能。根类方法提供了运行时系统的基本工恩给你。继承了 NSObject 的所有类都可以自由的使用运行时系统的功能，也就是说，根类就想到于系统的一个借口。 根类通过哪些方式提供了哪些功能对系统有很大的影响。因此，根类不同的系统之间是无法开发出通用的程序的。 Cocoa 是以OPENSTEPDE的核心 API 为基础发展起来的。OPENSTEP的前身为 NeXTstep。在 NeXTstep 时代，根类是累 Object,而在 OPENSTEP 时代，根类则变为了 NSObject，同时类的设计也得到了大幅度的改进。","text":"使用 Objectvice-C 进行全面对象编程时，除了需要知道语言本身的语法和面向对象的知识外，还需要了解Objectvice-C的根类 NSObject 的信息。 NSObject根类的作用作为一门动态编程语言，Objectstvice-C有很多动态的特性，因此，Objectvice-C不进需要编译环境，同时还需要一个运行时系统（runtime system）来执行编译好的代码。运行时系统扮演的角色类似于Objectvice-C的操作系统，他负责完成对象生成、释放时的内存管理、发来的消息查找对应的处理方法等工作。 通常情况下，程序无法直接使用运行时系统提供的功能。根类方法提供了运行时系统的基本工恩给你。继承了 NSObject 的所有类都可以自由的使用运行时系统的功能，也就是说，根类就想到于系统的一个借口。 根类通过哪些方式提供了哪些功能对系统有很大的影响。因此，根类不同的系统之间是无法开发出通用的程序的。 Cocoa 是以OPENSTEPDE的核心 API 为基础发展起来的。OPENSTEP的前身为 NeXTstep。在 NeXTstep 时代，根类是累 Object,而在 OPENSTEP 时代，根类则变为了 NSObject，同时类的设计也得到了大幅度的改进。 NSArray,NSString 等等NS前缀类、函数归属于cocoa Fundation基础类库,其”NS”的由来据说是这样的：乔布斯被苹果开除后,创立了NeSt公司,而cocoa Fundation基础类库就是出自于NeST公司,NeST中的”NS”被作为Fundation中所有成员的前缀 类和实例NSObject 只是一个实例变量，就是 Class 类型的变量 isa。isa 用于表示实例对象属于哪个类对象。因为 isa 决定着实例变量和类的关系，非常重要，所以子类不可以修改 isa 的值。另外，也不能通过直接访问 isa 来查询实例变量到底属于哪个类，而是要通过实例方法 class 来完成查询。 在运行时的代码中我们可以查看到objc_class的定义如下： 1234567/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; 下面对类和实例变量的相关方法进行说明。NSObject 的方法与其说是为自己定义的，不如说是为了其子类和所有实例对象而定义的。 123456789101112131415161718192021222324- (class) class 返回消息接收者所属类的类对象+ (class) class 返回类型对 虽然可以使用类名作为消息的接受者来调用类方法，但类对象是其他消息的参数，或者将类对象赋值给变量的时候，需要通过这个方法来获取类的参数- (id) self 返回接受者自身。是一个无任何实际动作但很有用的方法。-(BOOL) isMemberOfClass: (Class) aClass 判断消息接受者是不是参数 aClass 类的对象 -(BOOL) isKindOfClass: (Class) aClass 判断消息接受者是否是参数 aClass 类或者 aClass 的子类的实例。这个函数和 isMemberOfClass:的区别在于当消息的接受者是 aClass 的子类的实例时也返回 YES。 - (BOOL) isSubclassOfClass: (Class) aClass 判断消息接受者是不是参数 aClass 的子类或自身，如果是则返回 YES - (Class) superclass 返回消息接受者所在类的父类的类对象。 + (Class) superclass 返回消息接收类的父类和类对象 实例对象的生成和释放1234567891011121314151617181920+ (id) alloc 生成消息接收类的实例对象。通常和 init 或者 init 开头的方法连用，生成实例化对象的同事需要对其进行初始化。子类中不润徐重写 alloc 方法+ (void) dealloc 释放实例对象。dealloc 被称之为 release 的结果调用。除了在子类中重写 dealloc 的情况之外，程序不润徐直接调用 dealloc- (oneway void)release 将消息接受者的引用计数减1.引用计数变为0时，dealloc 方法被调用，消息接受者被释放- (id)retain 为消息接收者的引用计数加1，同事返回消息接收者- (id)autorelease 把消息的接受者加入到自动释放池中，同事返回消息接受者 - (NSUinteger) retainCount 返回消息接受者的引用计数，可在调试时使用这个方法。NSUInteger 是无符号证书类型- (void)finalize 垃圾收集器在释放接受者对象之前会执行该 finalize 方法。 上面从 dealloc 到 retainCount 都是手动引用计数管理内存时使用的方法，使用 ARC 时不可用。finalize 仅供垃圾回收有效时使用。 初始化123456789- (id) init init 可对 alloc 生成的实例对象进行初始化。子类中可以重写 init 或者自定义的心的以 init 开头的初始化函数。+ (void)initialize 被用于类的初始化，也就是对类中共同使用的变量进行初始化设定等。这个方法会在类收到第一个消息之前被自动执行，不需手动调用 + (id) new new 是 alloc 和 init 的组合。new 方法返回的实例对象的所有者就是调用 new 方法的对象。但是把 alloc 和 init 组合定义为 new 没有什么优点，并不建议使用。 根据类的实现不同，new 方法并不会每次都返回一个全新的实例对象。有时new 方法会返回对象池中预先生成的对象，也有可能每次都返回同一个对象。 对象的比较12345-(BOOL) isEqual: (id) anObject 消息的接受者如果和参数 anObject 相等则返回 YES - (NSUInteger) hash 把对象放入容器的时候，返回系统内部用的散列表 原则上来讲，具有相同 id 值也就是同一个指针指向的对象被认为是相等的。而子类在这个基础上进行了扩展，把拥有相同值认为是相等。我们可以根据需求对“想通知”激进型定义，但一般都会让具备“相同值”的对象返回相同的散列表，因此就需要对散列表方法进行重新定义。而反之则并不成立，也就是说，散列值相等的两个对象不一定相等。 另外，有的累中还自定义了 compare:或者isEqualTo 之类的方法。至于到底是哪个方法或者自定义类的时候是否需要定义比较的方法，都需要根据目的和类的内容做具体分析。 对象的内容描述12345+ (NSString*) description 返回一个 NSString 类型的字符串，表示消息接受者所属类的内容。通常是这个类的名称。- (NSString*)description 返回一个 NSString 类型的字符串，表示消息接受者的实例对象的内容。通常是类名家 id 值。子类中可以重新定义 description 的返回值。例如 NSString的实例会返回字符串的内容，NSArray 的实例会对数组中的每一个元素调用 description，然后将调用结果用句号进行分割，并且一起返回。 消息发送机制选择器和 SEL 类型至今为止我们把选择器（方法名）和消息关键字放在一起进行说明。程序中的方法名（选择器）在便有被一个内部标识符所代替，这个内部标识符所对应的数据类型就是 SEL 类型。 Objective-C为了能够在程序中操作编译后的选择器，定义了@selector()指令。通过使用@selector()指令，就可以直接饮用编译后的选择器。使用方法如下： 123@selector(mutableCopy)@selector(compare:)@selector(replaceObjectAtIndex:withObject:) 也可以声明 SEL 类型的变量 选择器不同的情况下，编译器转换后生成的 SEL 类型的值也一定不同，相同的算择期对应的 SEL 类型的值一定相同。Objective-C的程序员不需要知道选择器对应的 SEL 类型的值到底是什么，具体的值是和处理器相关的。但是如果 SEL 类型的便利功能无效的话，可设其为 NULL，或者也可以使用(SEL)0这种常见的表达方式 可以使用 SEL 类型的变量来发送消息，为此，NSObject 中准备了如下方法 123456-(id)performSelector: (SEL) aSelector 向消息的接收者发送 aSelector代表的消息，返回这个消息的执行结果 -(id)performSelector: (SEL) aSelector withObject: (id) anObject 与上面的方法一直，不过可以传递参数 例如下面两个消息表达式进行的处理是相同的 12[target description][targ performSelector: @selector(description)]; 下面的例子展示了如何根据条件动态决定执行那个方法 123SEL method = (void1) ? @selector(activate:) : @selector(hide:);id obj = (cond2) ? MyDocument : defaultDocument;[target performSelector:method withObject:obj] 这种调用方式很想 C 语言中函数指针的用法，使用函数指针可以实现和上面的程序同样的功能。 函数指针是函数在内存中的地址。指针对应的函数是在编译的时候决定的，不能够执行指定之外的函数。SEL 类型就相当于方法名，根据消息接受者的不同（上例子中 target 的赋值），来动态执行不同的方法。 通过 SEL 类型来指定要中子星的方法，这就是 Objectivce-C消息发送的方式。也正是通过这种方法才实现了 Objectivce-C的动态性 消息搜索对象收到一个消息后执行哪个方法是动态决定的。 所有的实例变量都存在一个 Class 类型的 isa 变量，它就是类对象。当收到消息后，运行时系统会检查类内是否有和这个消息选择器相同的方法，如果有就执行对应的方法，如果没有就通过类对象中指向父类的指针来查找父类中是否有对应的方法。如果一直找到根类都没有找到对应的方法，就会提示执行时错误。 如果每次收到消息都需要查找对应的方法的话，消息发送过程的开销就会很大，是针对这种情况，运行时内部会缓存一个散列表，表中记录着某个类拥有和什么样的选择器相对应的方法、方法被定义在何处等信息。这样一来，当下次在收到同样的消息时，直接利用上次缓存好的信息即可。 NSObject 中定义了可以动态检查一个对象是否能够响应某个选择器的方法。 12345- (BOOL) respondsToSelector: (SEL) aSelector 查询消息的接收者中是否能够响应 aSelector 的方法，包括从父类继承来的方法，如果存在的话则返回 YES- (BOOL) instancesRespondToSelector: (SEL) aSelector 查询消息的接收者所属的类中是否能够响应 aSelector 的实例方法，如果存在的话则返回 YES 一函数的形式来调用方法类中定义的方法通常是以函数的形式来实现的，但通常在编程的时候并不会直接操作方法所对应的函数。 但如果想尽可能第让程序更快一点，或者需要按照 C 语言的管理传递函数指针的时候，可以直接调用方法对应的函数，以节省发送消息的开销。另外执行时动态加载方法的定义等时，也可以将方法作为函数调用。但是需要注意的是，如果以函数的形式来调用方法的话，将无法利用面向对象的动态绑定等功能。虽然消息发送同函数调用相比确实慢一点，但却有面向对象的动态绑定、多态等优点。同这些优点相比，速度上略微的损失是不值得一提的。而其实消息发送的速度也非常的快。 通过使用下面的方法，可以获得某个对象持有的方法的函数指针，这些方法都被定义在 NSObject 中。 1234- (IMP) methodForSelector: (SEL) aSelector 搜索和执行选择器对应的方法，并返回指向该方法实现的函数指针。实例对象和类对象都可以使用这个方法。对实例对象使用时，会返回实例方法对应的函数，对类对象使用时，会返回类对象对应的函数+ (IMP) instanceMethodForSelector: (SEL)aSelector; 搜索和制定选择器相对应的实例方法，并返回该指向实例方法实现的函数指针 IMP 是“implemention”的缩写，它是一个函数指针，指向了方法实现代码的入口 IMP 的定义为： 12345#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id (*IMP)(id, SEL, ...); #endif 这个被指向的函数包括 id(self 指针)、调用的 SEL（方法名），以及其他参数 例如： 1- (id)setBox:(id)obj1 title:(id)obj2; foo 是这个方法所属类的一个实例变量。获取指向 setBox 的函数指针，并且通过该指针进行函数调用的过程如下： 123IMP funcp;funcp = [foo methodForSelector:@selector[setBox:title]];xyz = (*funcp)(foo,@selector[setBox:title:],param1,param2) 类对象和跟对象因为累对象也是一个对象，所以累对象可以作为根类 NSObject 的某个子类的对象来使用。下面这句话看上去好像比较奇怪，但是实际上他是正确的，会返回 YES 1[NSString class] isKindOfClass:[NSObject class]] 这就说明了相当于类对象的类的对象是存在的。而类对象的类就被叫做元类(metaclass)。实例对象(instance object)所属的类是 class，类对象(class object)所属的类是 metaclass。 Objective-C 中的很多概念都来源于 Smalltalk，元类的概念就是其中之一。但现在的 Objective-C中已经不存在元类的概念了，程序中不能操作元类。用于表示对象的 id 类型和表示类的 Class 类实际上都是指向结构体的指针。被详细定义在/usr/include/objc 下面的 objc.h 头文件中。通过查看 objc.h 中 id和 Class 的定义，就会发现类和元类的关系如图所示。Objective-C2.0更新了基本的数据结构，但是没有改变类和元类的关系。 类 A 是 NSObject 的子类，类 B是 A 的子类。类对象和实例对象都存在一个成员变量 isa，它是一个 objc_class 类型的指针 图中带有 isa 的实现表明了 isa 指向的对象，带有 super_class 的虚线则表明了父类的关系。 类对象中保存的是实例方法，元对象中保存的是累方法。通过这样的定义能够统一实现实例方法和类方法的调用机制。 因为编程时不可以直接操作元类，所以并不需要完全了解图中的细节。大家只需要记住任何一个类对象都是继承了根类的元对象的一个实例即可。也就是说，类对象可以执行根类对象的实例方法。 例如，类对象可以执行 NSObject 的实例方法 performSelector:和 respondsToSelector:。当然提前是没有将这些方法作为类方法再次定义。 下面让我们总结一下。其中（1）和（2）我们已经介绍过了。（3）比较不容易理解， 所有类的实例对象都可以执行根类的实例方法 如果在派生类中重新定义了实例方法，新定义的方法会被执行 所有类的类对象都可以执行根类的类方法 如果在派生类中重新定义了类方法，新定义的方法会被执行 所有类的类对象都可以执行根类的实例方法 即使在派生类中重新定义了实例方法，根类中的方法也会被执行 如果在派生类中将实例方法作为类方法重新定义了的话，新定义的方法会被执行 参考文献① Objectivce-C编程全解（第三版） [日]荻原刚志 著 唐璐 翟俊杰 译","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"UITableView 系统 API实现滑动删除Cell","slug":"delete_cell","date":"2016-04-23T08:05:19.000Z","updated":"2016-07-29T08:24:31.000Z","comments":true,"path":"2016/04/23/cj5yqarg6001oigrdef120tbm/","link":"","permalink":"http://yoursite.com/2016/04/23/cj5yqarg6001oigrdef120tbm/","excerpt":"","text":"#UITableView 系统 API实现滑动删除Cell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import UIKitclass ViewController: UIViewController &#123; private lazy var tableview:UITableView = &#123; let tb = UITableView(frame: CGRectZero,style: UITableViewStyle.Plain) tb.dataSource = self tb.delegate = self tb.registerClass(UITableViewCell.self, forCellReuseIdentifier: &quot;Cell&quot;) return tb &#125;() private var dataArray = [&quot;lazy&quot;,&quot;make&quot;,&quot;help&quot;,&quot;papa&quot;] override func viewDidLoad() &#123; super.viewDidLoad() view = tableview &#125;&#125;extension ViewController:UITableViewDataSource&#123; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return dataArray.count; &#125; func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableview.dequeueReusableCellWithIdentifier(&quot;Cell&quot;, forIndexPath: indexPath) cell.textLabel?.text = dataArray[indexPath.row] return cell &#125;&#125;extension ViewController:UITableViewDelegate&#123; //1.设置Cell 可编辑 func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool &#123; return true &#125; //2.进入编辑模式，滑动初选删除按钮 func tableView(tableView: UITableView, titleForDeleteConfirmationButtonForRowAtIndexPath indexPath: NSIndexPath) -&gt; String? &#123; return &quot;删除&quot; &#125; //3.响应删除按钮事件 func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) &#123; tableview.setEditing(false, animated: true) print(&quot;删除\\(dataArray[indexPath.row])&quot;) dataArray.removeAtIndex(indexPath.row) tableview.reloadData() &#125;&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"一个新的开始","slug":"一个新的开始","date":"2016-03-27T15:28:11.000Z","updated":"2016-05-06T13:31:46.000Z","comments":true,"path":"2016/03/27/cj5yqargl0023igrdv9kdwjse/","link":"","permalink":"http://yoursite.com/2016/03/27/cj5yqargl0023igrdv9kdwjse/","excerpt":"人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。","text":"人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。 于是在不甘，与短暂的刺激后，我又开始了写作，其实也是想试一试，自己到底能不能够成功，我所谓的成功其实就是写一个完整的故事，记得小时候抓周，我抓的就是个笔，奶奶曾经说我以后是个笔杆子，可惜现在虽然现在也是在写东西，不过写的是代码，而不是小说。 记得那是还在上初中的时候，我接触到了网络文学，我记得我看的第一本网络小说应该是木子心写的《现代修罗》，可惜最后太监了，那个时候我对太监这件事当真是有些厌恶，可是没想到到最后，我也踏入了后宫那洪流之中，成为了诸多太监中的一份子。我朋友曾经对我说过一句话，要是能在我生儿子之前能看到你一本完本的小说就行了。 其实这段时间一直在思考我要不要继续写东西，我能否坚持下去，最终还是决定试一试，思前想后决定写一篇科幻类的小说，希望能够做到不落俗套，写出自己心目中的网络文学。 以后每个月我都会更新一篇关于网络文学的文章，主要是去分析曾经红极一时或者是现在当红的网络小说的写作手法。看一看那些大神是如何进行网络文学创作的，同时也是去提升自己的能力。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"我的碎片化时间都在做什么?","slug":"mytime","date":"2016-03-26T03:03:16.000Z","updated":"2017-07-17T05:45:46.000Z","comments":true,"path":"2016/03/26/cj5yqargb001sigrd208kp92j/","link":"","permalink":"http://yoursite.com/2016/03/26/cj5yqargb001sigrd208kp92j/","excerpt":"一直都没太仔细的时间管理,基本上就是想要去做什么就去做,但就算如此有的时候回想一下自己这一天都在做什么了,却发现一天过得有些苍白,可能是精神上还是没有获得太多的满足,日记现在还在坚持写,不过一般都是有什么事情发生了才会去写上那么一笔. 最近一直在想自己的时间去了哪里,现在正在处于学习状态,满脑子都是成片的代码,倒是没有更多的碎片化时间. 那么我平时大部分碎片化时间都在干什么呢.","text":"一直都没太仔细的时间管理,基本上就是想要去做什么就去做,但就算如此有的时候回想一下自己这一天都在做什么了,却发现一天过得有些苍白,可能是精神上还是没有获得太多的满足,日记现在还在坚持写,不过一般都是有什么事情发生了才会去写上那么一笔. 最近一直在想自己的时间去了哪里,现在正在处于学习状态,满脑子都是成片的代码,倒是没有更多的碎片化时间. 那么我平时大部分碎片化时间都在干什么呢. 微信朋友圈 刷微博 QQ空间 网络小说 百度各种稀奇古怪的东西 这么算下来,我的碎片化时间并没有被合理的利用起来,仔细分析一下,以上种种对我来说,除了看网络小说以外,对自己的进步没有任何实质性的帮助,当然,我看网络小说并非是只是为了爽,主要是去分析一本网络小说的具体写作手法,以及伏笔,高潮等如何去写,以提高自己网络小说写作的水平. 那么其他的几项呢,基本上对自己没有任何帮助,除了可以获得短暂的心情愉悦,可是却并有得到任何的营养,精神上只是短暂的得到了满足,但这份满足却在短暂的愉悦过后变得苍白无力,因为自己并没有因此得到知识以及改变. 那么我该如何安排自己的碎片化时间呢? ①时间：物质存在的可用钟表来量度的属性。某一过程的发生、发展、终止，既反映了过程的持续性也反映了顺序性。过程的持续性表现为时间间隔，顺序性表现为日期和时刻。 ②碎片时间：所谓的碎片时间，即指日常工作、学习之余闲散的，零碎的时间，这些时间不是很长，如等车、排队、等人等情况所用的时间，这些时间不适宜做比较有深度的事情，一般用来手机阅读，玩游戏等。来源在线 新华词典 对于碎片化的时间的定义中说道这些时间不是以做比较深度的事情,那么什么叫做比较深度的事情,我对于这句话的理解就是需要耗时非常多的事情,例如看代码,读有深度的技术文章,因为这不是短暂的时间就可以完成的. 但是却可以用这一段时间去读一些比较短效精干的文章,在互联网如此发达的年代,倒是很好可以解决这样的需求,自媒体,微信公众号等都可以进行实现.这时候还真是要感谢网络的快速发展,使得只是的传播变得廉价. 分析了这些之后,简单的做了一些事情 删除低质量的微信公众账号 取消关注了娱乐圈的大V们 关闭了微信朋友圈功能 重新梳理了一遍亚马逊电子书城 删除了手机中并不算火的网络小说 删除了无用的社交软件 并且将我的书单进行了调整,将自己兴趣的书籍进行了筛选最终选出了要读的三本书. 中国通史 塔木德 李鸿章传 经过简单的梳理过后,倒是有了一些明确的目标,也知道接下来要怎么做了.","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"iOS多线程","slug":"多线程-nsoperation","date":"2016-03-22T08:05:19.000Z","updated":"2017-07-17T05:55:20.000Z","comments":true,"path":"2016/03/22/cj5yqarh7002xigrdnuu02pw4/","link":"","permalink":"http://yoursite.com/2016/03/22/cj5yqarh7002xigrdnuu02pw4/","excerpt":"","text":"简介多线程是所有程序员都应该知道的一个概念，因为当一个程序开始运行，进程就已经开启了！ 多线程基本概念进程(process)和文件(files)是UNIX/Linux操作系统最基本的抽象。进程是处于执行期的程序和它所包含的资源的综合，也就是说一个进程就是处于执行期的程序。一个线程（thread）就是运行在一个程序上下文中的一个逻辑刘，不难看出，线程是进程中最基本的活动对象。 在软件工程中，上下文是一种属性的有序序列，它们为主流在环境内的对象定义环境，在对象的激活过程中创建上下文，对象呗配置为要求某些自动服务，如同步、事务、实时激活、安全性等等。又比如计算机技术中，对象鱼进程而言，上下文就是进程执行时候的环境，具体来就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。 在传统系统中，一个进程只包含一个线程。但是在现代系统中，润徐一个进程里面可以同时运行多个县城，这类程序被称之为多线程程序。所有的程序都有一个主线程（main thread，在iOS开发中，主线程主要用于UI呈现，要将耗时操作放到其他线程之中，否则UI界面会被卡死），主直选成是进程的控制流或者执行线程在多线程程序中，主线可以创建一个活多个对等线程（peer thread），从这个时间点开始，这些线程就开始兵法执行，主线程和对等线程的区别仅在于主线程总是进程中第一个运行的线程。从某种程度上看，线程可以看做是轻量级的进程（lightweight process）。 每个程序都拥有独立的线程上下文（thread context），线程ID（Thread ID，TID），程序计数器（PC），线程栈（stack），一组寄存器（register）和条件码，其中内核正式通过线程ID（TID）来识别线程，进行线程调度的。 上面的内容是否晦涩难懂，那么我们看一看百度百科是如何解释多线程的： 在百度百科中，多线程是指软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多余一个线程，今儿提高整体处理性能。就这样的一句话就解释了什么是线程和线程的作用，就是为了提高程序的执行效率，能够在同一时间段执行多个任务。 这样一来是否就容易理解了，其实每一个软件都是一个进程，每个进程中包含一个到多个的线程，我们在window有的时候程序卡死，我们使用任务管理器结束程序的时候就是杀死那个进程。进程也可能是整个程序或者是部分程序的动态执行，线程是一组指令的集合，或者是程序的特殊段，它可以在程序里面单独执行，也可以把它理解成为代码运行的上下文，所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。 线程是程序中一个单一的顺序控制流程，在单个程序中同时运行多个线程完成不同的工作，成为多线程。 线程和进程的主要区别在于子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其知心上下文，多线程主要是为了节省CPU时间，发挥利用，根据具体情况而定。线程的运行需要使用计算机的内存资源和CPU。 到了这里你应该已经知道了什么是多线程了，首先让我们来整理一下然后再进行进行学习。 进程:就是指在系统中运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间中 线程:一个进程要执行任务，必须得有线程（每一个进程只要有一条线程），一个进程的所有任务都是放在线程中完成的 线程的串行：一个线程中执行的任务是串行的，如果在一个线程中赤星多个任务，只能一个一个的按照顺序执行 多线程：一个进程中可以开启多条线程，每条线程可以并行（同时），执行不同的任务。 多线程的优缺点多线程的优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 多线程的缺点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 多线程在iOS开发中的应用主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”主线程的主要作用显示、刷新UI界面处理UI事件（比如点击事件、滚动事件、拖拽事件等）主线程的使用注意:别将比较耗时的操作放到主线程中。耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验 PthreadPOSIX线程（POSIX threads）简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一套API，在类Unix系统中，都是用Pthreads作为系统的线程。在这里只讲一下其基本使用，因为在日常的开发之中并不是很常用这种方式进行多线程的开发。 Pthread的基本使用由于Pthreads是使用C语言进行开发的，所以其使用都是C语法。 语法规则1pthread_create(pthread_t *thread,pthread_attr_t * attr,void*(*start_routine)(void*),void*arg); 创建线程thread:返回创建的线程ID attr:线程属性，调度策略、优先级等都在这里设置，如果为NULL则标识默认属性 start_rountine:线程入口函数，可以返回一个void*类型的返回值，该返回值可由pthread_join()捕获arg:传给start_rountine的参数，可以为NULL 设置线程属性线程属性通过attr进行设置设置与查询attr结构为pthread_attr_get()与pthread_attr_set()两个系列函数，也可以在创建时通过pthread_create参数参数，有些必须在线程创建时进行设置比如跳读策略。 调度策略POSIX定义一种优先级调度模型，此模型确定任何两个线程相对于对方的重要程度。当两个线程同时准备就绪的时候，系统就会自动选择具有最高优先级的线程。 SCHED_OTHER：非实时、正常SCHED_RR：实时、轮询法SCHED_FIFO：实时、先入先出，与vxworks的调度机制一致 例程： 123pthread_attr_t attr;pthread_attr_init(&amp;attr);pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);//sched_policy NSThread简介NSThread 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切,通过NSThread这个API我们可以实现简单的多线程编程,但需要管理线程的声明周期、同步、加锁等问题，这样会导致一定的性能开销，当我们进行多线程开发的时候，并不推荐此方法。 NSThread的初始化动态方法1- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 12345678910// 初始化线程NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];// 设置线程的优先级(0.0 - 1.0，1.0最高级)thread.threadPriority = 1;// 开启线程[thread start];参数解析：selector ：线程执行的方法，这个selector最多只能接收一个参数target ：selector消息发送的对象argument : 传给selector的唯一参数，也可以是nil 静态方法1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 12[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];// 调用完毕后，会马上创建并开启新线程 隐式创建线程的方法1[self performSelectorInBackground:@selector(run) withObject:nil]; 获取当前线程1NSThread *current = [NSThread currentThread]; 获取主线程1NSThread *main = [NSThread mainThread]; 暂停当前线程123456// 暂停2s[NSThread sleepForTimeInterval:2];// 或者NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];[NSThread sleepUntilDate:date]; 线程间的通信123456781.在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES];2.在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];3.在当前线程执行操作[self performSelector:@selector(run) withObject:nil]; 优缺点1.优点：NSThread比其他两种多线程方案较轻量级，更直观地控制线程对象2.缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销 NSOperationNSOperation的作用 配合使用NSOperation和NSOperationQueue实现多线程编程 NSOperation和NSOperationQueue实现多线程的具体步骤 先将需要执行的操作封装到一个NSOperation对象中 然后将NSOperation对象添加到NSOperationQueue中 系统会自动的将NSOperationQueue中的NSOperation中取出来 将取出的NSOperation封装的操作放到一条线程中执行 NSOperation的子类NSOperation是一个抽象的类,它并不具备封装操作的能力,当我们进行多线程编程的时候,必须使用它的子类. NSInvocationOperation NSBlockOperation 自定义子类继承NSOperation,实现内部相对应的方法 NSInvocationOperation创建NSInvocationOperation对象 1-(id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg; 调用start方法开启线程 1-(void)start; 一旦执行操作，就会调用target的sel方法默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 NSBlockOperation创建NSBlockOperation对象 1+(id)blockOperationWithBlock:(void (^)(void))block; 通过addExecutionBlock:方法添加更多的操作 1-(void)addExecutionBlock:(void (^)(void))block; 只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 NSOperationQueueNSOperationQueue可以调用start放啊来进行执行任务,但是默认是同步执行的 如果将NSOperationQueue添加到NSOperationQueue操作队列中,系统会自动异步执行. 添加操作: 12-(void)addOperation:(NSOperation *)op;-(void)addOperationWithBlock:(void (^)(void))bloc 最大并发数什么是并发数 同时执行的任务数比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 12-(NSInteger)maxConcurrentOperationCount;-(void)setMaxConcurrentOperationCount:(NSInteger)cnt; 队列的取消,暂停,回复取消队列的所有操作 1-(void)cancelAllOperations; 提示：也可以调用NSOperation的 -(void)cancel方法取消单个操作 暂停和恢复队列 12-(void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列-(BOOL)isSuspended; 操作依赖NSOperation之间可以设置依赖来保证执行顺序比如一定要让操作A执行完后，才能执行操作B，可以这么写 1[operationB addDependency:operationA]; // 操作B依赖于操作A 可以在不同queue的NSOperation之间创建依赖关系 操作监听可以监听一个操作的执行完毕 12-(void (^)(void))completionBlock;-(void)setCompletionBlock:(void (^)(void))block; 自定义NSOperation自定义NSOperation的步骤 重写-(void)main方法，在里面实现想执行的任务 重写-(void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 GCD简介GCD 是 libdispatch 的市场名称，而 libdispatch 作为 Apple 的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点： GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。 GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。 GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力 （未完待续） 参考文献： [1] fireaxe - Pthread编程基础","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"将博客迁移到了github","slug":"wordpress to hexo","date":"2016-03-08T15:00:00.000Z","updated":"2017-07-17T05:42:21.000Z","comments":true,"path":"2016/03/08/cj5yqargk0020igrdwbj7i6qc/","link":"","permalink":"http://yoursite.com/2016/03/08/cj5yqargk0020igrdwbj7i6qc/","excerpt":"","text":"折腾了一天终于将博客迁移到了github上,以前一直用的都是WordPress,这几天看一些大牛的微博发现有很多人用的都是hexo于是在好奇心的驱使下搜了一下,发现很有逼格,身为一个不折腾就会死的人我便开始了迁移之路,这篇博文并不会讲如何迁移,因为今天没有时间了,等过两天进行一下总结,熟悉一下hexo. 在用WordPress的时候,有的博文中有html标签,hexo用的markdown很多标签不兼容,这样就导致了,导入WordPress文章的时候会出现错误,要删除其中的标签,头晕了一个晚上,一激动把一些博文删掉了. 之前的博文有很多人转载的东西,我也全都删除了,就留下了一些比较有用的东西,以后的博文也我要尽量的去试着原创,毕竟那也是一种不错的挑战.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"移动info.plist后无法运行","slug":"移动info.plist后无法运行","date":"2016-03-04T14:29:03.000Z","updated":"2016-05-08T03:22:43.000Z","comments":true,"path":"2016/03/04/cj5yqarhv003ligrdreza5xn5/","link":"","permalink":"http://yoursite.com/2016/03/04/cj5yqarhv003ligrdreza5xn5/","excerpt":"今天做项目的时候,不小心将info.plist移动了,再移动回项目中的时候直接报错,查了一下百度找到了解决办法. 只需要在bulid Phases中的Copy Bundle Resources重新加入info.plist即可","text":"今天做项目的时候,不小心将info.plist移动了,再移动回项目中的时候直接报错,查了一下百度找到了解决办法. 只需要在bulid Phases中的Copy Bundle Resources重新加入info.plist即可","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"统一设置tabBarItem字体样式","slug":"统一设置tabBarItem字体样式","date":"2016-03-04T12:14:36.000Z","updated":"2017-07-17T05:46:12.000Z","comments":true,"path":"2016/03/04/cj5yqari0003sigrdd4glw6fm/","link":"","permalink":"http://yoursite.com/2016/03/04/cj5yqari0003sigrdd4glw6fm/","excerpt":"","text":"一般我们在使用tabBar的时候都需要进行自定义,统一设置其字体样式的方法如下. 在iOS开发中有两个方法:load与initialize. load是在类加载的时候会自动调用,iOS工程在运行的时候,会自动将工程内的类加载到内存之中,这个时候就是load执行的时候. initialize是在第一次使用或者调用子类的时候回自动执行,具有初始化类的功能,我们可以通过这两个方式的执行特性来对tabBarItem的样式进行设置. tabBarItem其实是一个模型(Item是苹果对模型的一种命名规范),我们并不能够对模型直接格式操作,但是我们可以对控件的格式进行设置,这样也就是使用到了文本属性(富文本)来进行设置. 代码如下: 12345678910+(void)initialize&#123; //获取所有的tabBarItem 获取所有的外观 UITabBarItem *item = [UITabBarItem appearance]; NSMutableDictionary *att = [[NSMutableDictionary alloc]init]; [att setObject:[UIColor grayColor] forKey:NSForegroundColorAttributeName]; NSMutableDictionary *selectedAtt = [[NSMutableDictionary alloc]init]; [selectedAtt setObject:[UIColor orangeColor] forKey:NSForegroundColorAttributeName]; [item setTitleTextAttributes:att forState:UIControlStateNormal]; [item setTitleTextAttributes:selectedAtt forState:UIControlStateSelected]; &#125; 这样一来我们就完成了样式的设置,appearance在英语中的意思是外观,在iOS中算是一个标记,通过这个标记,我们可以取得UITabBarItem中所有Item的外观.","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS推送通知","slug":"检查设备是否支持后台处理","date":"2016-03-03T07:06:05.000Z","updated":"2016-05-08T03:03:35.000Z","comments":true,"path":"2016/03/03/244/","link":"","permalink":"http://yoursite.com/2016/03/03/244/","excerpt":"","text":"iOS 于2008年问世时，只能有一个第三方应用处于活动状态（位于前台）。这意味着应用需要执行的任务都必须在应用位于前台时完成，佛泽任务将暂停并在应用下次启动时接着执行。iOS4退出后，向第三方应用提供了后台功能。鉴于 iOS 设备的系统资源有限，且节省电量至关重要，对后台处理有些限制，那就是不能干扰前台引用，也不能消耗太多电量。通过妥善的利用后台功能，引用能做很多事情。 iOS 支持两种后台任务处理方式 第一种方式是在后台完成耗时操作。这种方式适合用于完成大量数据下载或更新等任务，他们需要的时间超过了用户与应用交互的时间。 第二种方式是执行 iOS 润徐的后台活动，如播放音乐、蓝牙交互、监视 GPS 数据以及获取位置变化、维持永久网络连接让 VoIP应用能够正常运行。 检查设备是否支持后台处理能够运行 iOS6或者 iOS5的设备都支持在后台执行活动，这在 Apple 文档中称之为多任务，如果应用需要支持 iOS4就需要注意了，因为有些设备不支持多任务。编写使用多任务功能的代码，需要检测设备是否支持多任务。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"使用iOS本地通知","slug":"IOS推送通知","date":"2016-03-03T07:06:05.000Z","updated":"2017-07-17T05:49:19.000Z","comments":true,"path":"2016/03/03/244/","link":"","permalink":"http://yoursite.com/2016/03/03/244/","excerpt":"","text":"在 iOS 开发中推送通知被分为两种，本地通知与推送通知， 本地通知是应用在后台运行时，把一些消息提示给用户，一个很好的例子就是基于定位的应用，这类应用在后台运行，到他发现到达某个特殊地点是给予用户提醒，本地通知只能使用在 iOS 设备中，他可以立即发出通知也可以在计划时间后发出。 本地通知只是应用所在设备上给用户通知，而推送通知是远程通知，它是由远程服务器推送过来的。无论是哪一种，通知的形式都是一样的。 12345678910111213141516171819202122232425262728//本地推送,主要用于一些常规类的提醒 /** * 1.健康类 定时几点运动 * 2.社交类 几点约会 * 3.游戏类 到时见领取奖励 * 4.新闻类 每日早间提醒阅读 * 5.医药类 你该吃药了,药别停 */ //在iOS8下需要注册一下本地推送 [[UIApplication sharedApplication] registerUserNotificationSettings: [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge|UIUserNotificationTypeAlert|UIUserNotificationTypeSound categories:nil]]; //初始创建本地推送 UILocalNotification *local = [[UILocalNotification alloc]init]; //设置推送时间 local.fireDate = [NSDate dateWithTimeIntervalSinceNow:5]; //设置推送的内容 local.alertBody = @&quot;你该吃药了!&quot;; //设置时区 根据当前手机时区设置的 local.timeZone = [NSTimeZone defaultTimeZone]; //设置重复的间隔 local.repeatInterval = kCFCalendarUnitDay; //设置推送声音(本地需要有相对应的声音,该声音需要少于三十秒) //local.soundName = UILocalNotificationDefaultSoundName; local.soundName = @&quot;音效.caf&quot;; local.userInfo = @&#123;@&quot;name&quot;:@&quot;王花花&quot;&#125;; local.applicationIconBadgeNumber = 9999; //加入到系统级推送 [[UIApplication sharedApplication] scheduleLocalNotification:local]; 清除本地推送 1234567891011//如何取消推送//获取目前已经加入本地消息推送的有几个.NSArray *array = [[UIApplication sharedApplication]scheduledLocalNotifications];//遍历推送内容for (UILocalNotification *notification in array) &#123; NSLog(@&quot;%@&quot;,notification.userInfo); //如果遇到我们想要取消的本地推送 [[UIApplication sharedApplication] cancelLocalNotification:notification];&#125;//如果全部取消//[[UIApplication sharedApplication]cancelAllLocalNotifications];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS多线程.01 简介","slug":"简介","date":"2016-03-01T04:11:20.000Z","updated":"2017-07-17T05:55:56.000Z","comments":true,"path":"2016/03/01/cj5yqarhx003oigrdcahce4rq/","link":"","permalink":"http://yoursite.com/2016/03/01/cj5yqarhx003oigrdcahce4rq/","excerpt":"","text":"简介我们为何需要多线程呢？多线程其实是为了实现并发执行，而且线程是并发执行多个代码路径的多种技术之中比较轻量级的一种（对应较重的实现是多进程）。 在单核 CPU 时代，支持多线程的操作系统会通过分配 CPU 计算时间，来实现软件层面的多线程。创建线程，线程间切换都是有成本开销的。但由于多线程可以避免阻塞所造成的 CPU 计算时间浪费，所以多线程所带来的开销成本总体看来是值得的。任务一般都可以被拆分成多个子任务，如果一个子任务发生了阻塞，计算时间就可以分配给其他子任务。这样就提高了 CPU 的利用率。 在多核 CPU 时代，就更好理解了。由于硬件上就支持多线程技术，就可以让多个线程真正同时地运行。如果任务能够被拆分，各个子任务就能并行地在 CPU 上运行，这就能显著加快运行速度。 总结说来，多线程的目的是，通过并发执行提高 CPU 的使用效率，进而提供程序运行效率。 OS X 和 iOS 是多线程操作系统，它们追随 UNIX 系统使用了 POSIX 线程模型。OS X 和 iOS 都提供了一套底层的 C 语言 POSIX 线程 API 来创建和管理线程。但实际应用开发中，除非需要跨平台，我们并不常直接使用 POSIX 线程 API，而是使用系统或语言提供的其他一些更为简单的方案。 多线程基本概念在了解多线程之前，我们应该先搞懂几个概念，首先了解几个基本概念 进程 线程 多线程 主线程 进程进程（process），是计算机中已运行程序的实体。在面向线程设计的系统中，进程是线程的容器。程序本身只是指令、数据以及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。若干进程有可能与同一个程序相关系，而且每个进程皆可以同步或者异步的方法独立运行。现代计算机系统刻在统一时间内以进程的形式将多个程序加载到存储器中，并且借由时间共享（分时复用），在一个处理器上表选出同时运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机架构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上） 线程线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程（软件多线程）多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个执行绪，进而提升整体处理性能。 软件多线程。即便处理器只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象。这样的程序运行机制被称为软件多线程。 主线程在一个 iOS 程序运行后，默认会开启1条线程。称之为主线程或者是 UI 线程。 主线程是进程的控制流或者执行线程在多线程程序中，主线可以创建一个或多个对等线程（peer thread），从这个时间点开始，这些线程就开始兵法执行，主线程和对等线程的区别仅在于主线程总是进程中第一个运行的线程。从某种程度上看，线程可以看做是轻量级的进程（lightweight process）。 每个程序都拥有独立的线程上下文（thread context），线程ID（Thread ID，TID），程序计数器（PC），线程栈（stack），一组寄存器（register）和条件码，其中内核正式通过线程ID（TID）来识别线程，进行线程调度的。 我们要知道，一条线程只能处理一个任务，如果将大规模运算放到主线程之中，就会造成 UI 界面卡顿的现象。 线程进程的主要区别线程和进程的主要区别在于子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其知心上下文，多线程主要是为了节省CPU时间，发挥利用，根据具体情况而定。线程的运行需要使用计算机的内存资源和CPU。​ 多线程的优缺点多线程的优点 能适当提高程序的执行效率 能适当提高资源利用率（CPU、内存利用率） 多线程的缺点 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 参考资料[1] 维基百科 [3] OS X 和 iOS 中的多线程技术 infoq [2] fireaxe - Pthread编程基础","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Objective-C Block的基本使用","slug":"Block学习","date":"2016-02-17T08:05:19.000Z","updated":"2017-07-17T05:44:15.000Z","comments":true,"path":"2016/02/17/231/","link":"","permalink":"http://yoursite.com/2016/02/17/231/","excerpt":"","text":"一、Block 的定义定义和使用Block， 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; //（1）定义无参无返回值的Block void (^printBlock)() = ^()&#123; printf(&quot;no number&quot;); &#125;; printBlock(); printBlock(9); int mutiplier = 7; //（3）定义名为myBlock的代码块，返回值类型为int int (^myBlock)(int) = ^(int num)&#123; return num*mutiplier; &#125; //使用定义的myBlock int newMutiplier = myBlock(3); printf(&quot;newMutiplier is %d&quot;,myBlock(3)); &#125; //定义在-viewDidLoad方法外部 //（2）定义一个有参数，没有返回值的Block void (^printNumBlock)(int) = ^(int num)&#123; printf(&quot;int number is %d&quot;,num); &#125;; 定义Block变量，就相当于定义了一个函数。但是区别也很明显，因为函数肯定是在-viewDidLoad方法外面定义，而Block变量定义在了viewDidLoad方法内部。当然，我们也可以把Block定义在-viewDidLoad方法外部，例如上面的代码块printNumBlock的定义，就在-viewDidLoad外面。 再来看看上面代码运行的顺序问题，以第（3）个myBlock距离来说，在定义的地方，并不会执行Block{}内部的代码，而在myBlock(3)调用之后才会执行其中的代码，这跟函数的理解其实差不多，就是只要在调用Block（函数）的时候才会执行Block体内（函数体内）的代码。所以上面的简单代码示例，我可以作出如下的结论， 在类中，定义一个Block变量，就像定义一个函数； Block可以定义在方法内部，也可以定义在方法外部； 只有调用Block时候，才会执行其{}体内的代码； （PS：关于第（2）条，定义在方法外部的Block，其实就是文件级别的全局变量） 那么在类中定义一个Block，特别是在-viewDidLoad方法体内定义一个Block到底有什么意义呢？我表示这时候只把它当做私有函数就可以了。我之前说过，Block其实就相当于代理，那么这时候我该怎样将其与代理类比以了解呢。这时候我可以这样说：本类中的Block就相当于类自己服从某个协议，然后让自己代理自己去做某个事情。很拗口吧？看看下面的代码， 12345678//定义一个协议@protocol ViewControllerDelegate- (void)selfDelegateMethod;@end//本类实现这个协议ViewControllerDelegate@interface ViewController ()@property (nonatomic, assign) id delegate;@end 接着在-viewDidLoad中的代码如下， 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view from its nib. self.delegate = self; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(selfDelegateMethod)] &#123; [self.delegate selfDelegateMethod]; &#125;&#125; #pragma mark - ViewControllerDelegate method//实现协议中的方法- (void)selfDelegateMethod&#123; NSLog(@&quot;自己委托自己实现的方法&quot;);&#125; 看出这种写法的奇葩地方了吗？自己委托自己去实现某个方法，而不是委托别的类去实现某个方法。本类中定义的一个Block其实就是闲的蛋疼，委托自己去字做某件事情，实际的意义不大，所以你很少看见别人的代码直接在类中定义Block然后使用的，Block很多的用处是跨越两个类来使用的，比如作为property属性或者作为方法的参数，这样就能跨越两个类了。 二、__block关键字的使用在Block的{}体内，是不可以对外面的变量进行更改的，比如下面的语句， 123456789- (void)viewDidLoad &#123; //将Block定义在方法内部 int x = 100; void (^sumXAndYBlock)(int) = ^(int y)&#123; x = x+y; printf(&quot;new x value is %d&quot;,x); &#125;; sumXAndYBlock(50);&#125; 这段代码有什么问题呢，Xcode会提示x变量错误信息：Variable is not assigning (missing__block type)，这时候给int x = 100;语句前面加上__block关键字即可，如下， 1__block int x = 100; 这样在Block的{}体内，就可以修改外部变量了。 三、Block作为Property属性实现页面之间传值需求：在ViewController中，点击Button，push到下一个页面NextViewController，在NextViewController的输入框TextField中输入一串字符，返回的时候，在ViewController的Label上面显示文字内容， （1）第一种方法：首先看看通过“协议/代理”是怎么实现两个页面之间传值的吧， 12345678910//NextViewController是push进入的第二个页面//NextViewController.h 文件//定义一个协议，前一个页面ViewController要服从该协议，并且实现协议中的方法@protocol NextViewControllerDelegate - (void)passTextValue:(NSString *)tfText;@end @interface NextViewController : UIViewController @property (nonatomic, assign) id delegate;@end //NextViewController.m 文件//点击Button返回前一个ViewController页面 1234567- (IBAction)popBtnClicked:(id)sender &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(passTextValue:)]) &#123; //self.inputTF是该页面中的TextField输入框 [self.delegate passTextValue:self.inputTF.text]; &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 接下来我们在看看ViewController文件中的内容， 123456789101112131415161718//ViewController.m 文件@interface ViewController ()@property (strong, nonatomic) IBOutlet UILabel *nextVCInfoLabel;@end//点击Button进入下一个NextViewController页面- (IBAction)btnClicked:(id)sender&#123;NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil];nextVC.delegate = self;//设置代理[self.navigationController pushViewController:nextVC animated:YES];&#125;//实现协议NextViewControllerDelegate中的方法#pragma mark - NextViewControllerDelegate method- (void)passTextValue:(NSString *)tfText&#123;//self.nextVCInfoLabel是显示NextViewController传递过来的字符串Label对象self.nextVCInfoLabel.text = tfText;&#125; 这是通过“协议/代理”来实现的两个页面之间传值的方式。（2）第二种方法：使用Block作为property，实现两个页面之间传值，先看看NextViewController文件中的内容， 1234567891011//NextViewController.h 文件@interface NextViewController : UIViewController @property (nonatomic, copy) void (^NextViewControllerBlock)(NSString *tfText);@end//NextViewContorller.m 文件- (IBAction)popBtnClicked:(id)sender &#123; if (self.NextViewControllerBlock) &#123; self.NextViewControllerBlock(self.inputTF.text); &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 再来看看ViewController文件中的内容， 1234567891011- (IBAction)btnClicked:(id)sender&#123; NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil]; nextVC.NextViewControllerBlock = ^(NSString *tfText)&#123; [self resetLabel:tfText];&#125;; [self.navigationController pushViewController:nextVC animated:YES];&#125;#pragma mark - NextViewControllerBlock method- (void)resetLabel:(NSString *)textStr &#123; self.nextVCInfoLabel.text = textStr;&#125; 好了就这么多代码，可以使用Block来实现两个页面之间传值的目的，实际上就是取代了Delegate的功能。 另外，博客中的代码Sample Code可以再Github下载，如果因为Github被墙了，可以在终端使用git clone + 完整链接，即可克隆项目到本地。 Github中的代码，可以开启两种调试模式，你需要在项目的配置文件BlockSamp-Prefix.pch中注释或者解注释下面的代码. 1#define Debug_BlcokPassValueEnable 即可开启两种调试的方式，如果注释了上面的语句就是使用Delegate进行调试；否则使用Block进行调试。","categories":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/categories/ios/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"CGFloat、CGPoint、CGSize和CGRect","slug":" CGFloat、CGPoint、CGSize和CGRect","date":"2016-01-30T16:27:31.000Z","updated":"2017-07-17T05:55:11.000Z","comments":true,"path":"2016/01/31/2/","link":"","permalink":"http://yoursite.com/2016/01/31/2/","excerpt":"","text":"CGFloat、CGPoint、CGSize和CGRect主要是用来描述UI控件的几何属性的基本类型。 CGFloat: 浮点值的基本类型 CGPoint: 表示一个二维坐标系中的点 CGSize: 表示一个矩形的宽度和高度 CGRect: 表示一个矩形的位置和大小 CGFloatCGFloat是这四种类型中最基本的类型，这是一个浮点型的数据，他就是一个数值，下面三种类型都需要使用该数值来进行赋值，当我们使用CMD键进入CGBase.h文件后，可以清楚的看到关于CGFloat的定义，映入眼帘的是一个别名定义： 1typedef CGFLOAT_TYPE CGFloat; 当我们CMD点击CGFLOAT_TYPE的时候，我们可以跳转到宏定义的代码区域，其实就在其上面 1234567891011#if defined(__LP64__) &amp;amp;&amp;amp; __LP64__# define CGFLOAT_TYPE double# define CGFLOAT_IS_DOUBLE 1# define CGFLOAT_MIN DBL_MIN# define CGFLOAT_MAX DBL_MAX#else# define CGFLOAT_TYPE float# define CGFLOAT_IS_DOUBLE 0# define CGFLOAT_MIN FLT_MIN# define CGFLOAT_MAX FLT_MAX#endif 我们可以清晰的看到这就是一段宏定义，#if defined(LP64) &amp;&amp; LP64这一段代码主要使用来判断操作系统是64位还是32位，如果是64位那么CGFloat就是double类型，如果不是那边是32位操作系统，则会被系统定义为float类型,接下来的三种类型都是基于CGFloat的结构体。 CGPointCGPoint用于表示二维坐标系中的某一个点，在IOS中以左上角（0，0）为起始坐标。CMD进入CGGeometry.h中便可以直接查看其类型的定义如下（CGSize、CGRect都在此文件中）： 12345struct CGPoint &#123;CGFloat x;CGFloat y;&#125;;typedef struct CGPoint CGPoint; CGSizeCGSize主要用于描述UI控件的宽与高 12345struct CGSize &#123;CGFloat width;CGFloat height;&#125;;typedef struct CGSize CGSize; CGRectCGRect同样也是一个结构体，通过上面的了解，我们知道了原来CGRect是由CGSize和CGPoint组成，这样一来便可以确定一个UI空间的大小与位置。 12345struct CGRect &#123;CGPoint origin;CGSize size;&#125;;typedef struct CGRect CGRect;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"懒加载与模型转换","slug":"懒加载与模型转换","date":"2016-01-30T15:48:32.000Z","updated":"2016-03-09T01:06:54.000Z","comments":true,"path":"2016/01/30/219/","link":"","permalink":"http://yoursite.com/2016/01/30/219/","excerpt":"","text":"所谓的懒加载其实就是重写getter方法，以实现实例化类的同时自动加载数据，简化代码的一个作用,代码如下 12345678//这是一个实例-(NSArray*)question&#123;if (!_question) &#123;//判断是否为空_question = [GZModelName questionList];&#125;return _question;&#125; 接下来便是模型转化,因为使用点语法写起来的方法也非常简单，只需要重新定义构造方法即可,其中用到的plist文件如下图： .h文件 123456789@interface GZQuestion : NSObject@property (nonatomic,copy) NSString *answer;@property (nonatomic,copy) NSString *icon;@property (nonatomic,copy) NSString *title;@property (nonatomic,strong) NSArray *options;-(instancetype)initWithDic:(NSDictionary *)dic;+(instancetype)questionWithDic:(NSDictionary *)dic;+(NSArray*)questionList;@end .m文件 12345678910111213141516171819202122-(instancetype)initWithDic:(NSDictionary *)dic&#123;if (self = [super init]) &#123;//KVC 直接从字典中读取对应的值，需要注意的是，定义的属性名称，要与字典的key值相对应，否则会崩溃[self setValuesForKeysWithDictionary:dic];&#125;return self;&#125;+(instancetype)questionWithDic:(NSDictionary *)dic&#123;return [[self alloc]initWithDic:dic];&#125;+(NSArray *)questionList&#123;//加载plistNSString *path = [[NSBundle mainBundle] pathForResource:@&quot;questions&quot; ofType:@&quot;plist&quot;];NSArray *dicArray = [NSArray arrayWithContentsOfFile:path];//字典转模型NSMutableArray *tempArray = [NSMutableArray array];for (NSDictionary *dic in dicArray) &#123;GZQuestion *question = [GZQuestion questionWithDic:dic];[tempArray addObject:question];&#125;return tempArray;&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Objective-C 简单的数组排序","slug":"OC简单数组排序","date":"2016-01-05T07:53:07.000Z","updated":"2017-07-17T05:45:36.000Z","comments":true,"path":"2016/01/05/189/","link":"","permalink":"http://yoursite.com/2016/01/05/189/","excerpt":"","text":"12345678910111213NSMutableArray *array = [NSMutableArray arrayWithObjects:@&quot;8123&quot;,@&quot;456&quot;,@&quot;378&quot;, nil];NSComparator cmp = ^(id obj,id obj1)&#123; return [obj compare:obj1];&#125;;[array sortUsingComparator:cmp];NSLog(@&quot;%@&quot;,array);&lt;/pre&gt;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"域名即将到期了，也不打算续费了。","slug":"吐槽","date":"2015-08-27T17:03:16.000Z","updated":"2016-03-09T01:04:50.000Z","comments":true,"path":"2015/08/28/108/","link":"","permalink":"http://yoursite.com/2015/08/28/108/","excerpt":"","text":"额，以前一直没有注意，就这样的一个pw结尾的域名竟然都会被劫持，我也真是醉了。 以前DNSPOD提示我有异常登陆，我也没在意，结果今天site了一下域名，结果尴尬的发现被泛解析了，我也真是醉了，全都是博彩网站。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"DATA URI image封装类","slug":"data-uri-image","date":"2015-08-17T12:12:44.000Z","updated":"2017-03-12T05:41:51.000Z","comments":true,"path":"2015/08/17/94/","link":"","permalink":"http://yoursite.com/2015/08/17/94/","excerpt":"","text":"Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。 1234567891011121314151617181920class DataBase64&#123; public $file = &apos;&apos;; public function __construct($file)&#123; $this-&gt;file = $file; &#125; public function getBase64()&#123; $type = getimagesize($this-&gt;file); $fp = fopen($this-&gt;file, &apos;r&apos;) or die(&quot;Can&apos;t open file&quot;); $file_content= chunk_split(base64_encode(fread($fp, filesize($this-&gt;file)))) ; switch($type[2])&#123;//判读图片类型 case 1:$img_type=&quot;gif&quot;;break; case 2:$img_type=&quot;jpg&quot;;break; case 3:$img_type=&quot;png&quot;;break; &#125; return $img=&apos;data:image/&apos;.$img_type.&apos;;base64,&apos;.$file_content; &#125; &#125; $data = new DataBase64(&apos;image/1.jpg&apos;); $img = $data-&gt;getBase64();","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"目录常量：PATH_SEPARATOR和DIRECTORY_SEPARATOR","slug":"PATH_SEPARATOR-and-DIRECTORY_SEPARATOR","date":"2015-07-30T00:22:04.000Z","updated":"2017-07-17T05:47:43.000Z","comments":true,"path":"2015/07/30/46/","link":"","permalink":"http://yoursite.com/2015/07/30/46/","excerpt":"","text":"DIRECTORY_SEPARATOR（string） 目录分隔符，这是PHP内置的一个常量，代表着”/“或“” 因为系统原因，目录的分隔符被分为两种，在windows中目录的分割符号可以使用‘/’或者‘’，但是在linux中目录分隔符只能使用’/‘; PATH_SEPARATOR 路径分隔符，同样是PHP内置的一个常量，在windows系统中，如果使用include包含多个路径可以使用分号（;）来进行分割，可是在linux系统中却要使用冒号（：）。 这两个常量主要就是用来解决linux与windows的兼容问题，避免因为系统差异出现的错误，可以增强移植性。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[]},{"title":"deepin下安装 php的扩展","slug":"deepin-install-PHP","date":"2015-05-26T01:56:08.000Z","updated":"2016-03-09T01:05:44.000Z","comments":true,"path":"2015/05/26/36/","link":"","permalink":"http://yoursite.com/2015/05/26/36/","excerpt":"","text":"一直没用过linux开发PHP，昨天试了一下，却发现deepin下安装的php默认是不开其扩展的，可是PHP.INI中却没有开启扩展的选项，无奈之下百度了一番，却发现文章很少，但是却找到了ubuntu的命令，型号deepin的命令跟ubuntu一样，到是解决了PHP扩展的一些问题，原来只需要将所需要的扩展下载下来，重启服务器便可。 代码如下： 123sudo apt-get install php5-你所需要的扩展。sudo service apache2 restart 这样用来扩展就可以使用了。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"Smarty3封装类","slug":"Smarty封装","date":"2015-05-21T14:10:59.000Z","updated":"2017-07-17T05:44:54.000Z","comments":true,"path":"2015/05/21/200/","link":"","permalink":"http://yoursite.com/2015/05/21/200/","excerpt":"","text":"12345678910111213141516171819// load Smarty library require('Smarty.class.php'); // The setup.php file is a good place to load // required application library files, and you // can do that right here. An example: require('guestbook/guestbook.lib.php'); class Smarty_GuestBook extends Smarty &#123; function __construct() &#123; // Class Constructor. // These automatically get set with each new instance. parent::__construct(); $this-&gt;setTemplateDir('/web/www.example.com/guestbook/templates/'); $this-&gt;setCompileDir('/web/www.example.com/guestbook/templates_c/'); $this-&gt;setConfigDir('/web/www.example.com/guestbook/configs/'); $this-&gt;setCacheDir('/web/www.example.com/guestbook/cache/'); $this-&gt;caching = Smarty::CACHING_LIFETIME_CURRENT; $this-&gt;assign('app_name', 'Guest Book'); &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"PHP框架编写（二）单入口路由","slug":"PHP框架编写（二）单入口路由","date":"2015-04-30T08:05:19.000Z","updated":"2017-07-17T05:47:10.000Z","comments":true,"path":"2015/04/30/cj5yqarfj000uigrd2y3nwitw/","link":"","permalink":"http://yoursite.com/2015/04/30/cj5yqarfj000uigrd2y3nwitw/","excerpt":"","text":"PHP框架编写（二）单入口路由基本思路是浏览器端通过URL字符串提供控制器类的名字和方法的名字，PHP据此找到对应的类和方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/******************************************************* * * URL 路由原理展示代码 * * 浏览器访问地址: http://server/index.php?C=Controler1&amp;M=Method1 * 根据C找到控制器类，再根据M找到方法，然后执行这个方法 * * ****************************************************/ $C = isset($_GET['C']) ? $_GET['C']: null; $M = isset($_GET['M']) ? $_GET['M']: null; if($C != NULL &amp;&amp; $M != NULL &amp;&amp; class_exists($C) &amp;&amp; method_exists($C, $M)) &#123; $cObj = new $C(); $cObj-&gt;$M(); &#125;else&#123; echo '找不到控制器或方法'; exit; &#125; // 控制器1 class Controler1 &#123; public function Method1() &#123; echo 'Controler1, Method1'; &#125; public function Method2() &#123; echo 'Controler1, Method2'; &#125; &#125; // 控制器2 class Controler2 &#123; public function Method1() &#123; echo 'Controler2, Method1'; &#125; public function Method2() &#123; echo 'Controler2, Method2'; &#125; &#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"PHP框架编写（一）：框架运行流程","slug":"PHP框架开发(一)MVC","date":"2015-04-29T14:02:49.000Z","updated":"2016-03-09T01:05:50.000Z","comments":true,"path":"2015/04/29/6/","link":"","permalink":"http://yoursite.com/2015/04/29/6/","excerpt":"","text":"首先欢迎各位进入我的博客，我感觉非常荣幸，我并不是什么高手，现在的我不过是个在校的大学生，写这篇系列的博文只不过是为了加深自己对PHP的理解，以及对之前的学习做一个总结，同时也希望各位能够给我提一些意见。 PHP框架总给人以高大上的感觉，很多人学框架都学的头晕脑胀，百思不得其解，看完这篇博文后应该可以让还处于迷茫中的学习者找到一个入门的道路。 PHP框架到底是什么，框架不过是其他程序员提供的一个快速开发的一个代码而已，他帮助PHP开发者能够快速的开发，免去一些代码而已，PHP框架目前的核心就是MVC和数据库操作，更加大白话一点其实就是编程中最基础的增删改查，不过就是将他变的更加漂亮而已。 那么什么是MVC呢，M模型,V显示,C控制器。 这基本上是所有教程和书中都会提及的概念，也就不再多进行赘述模糊不清的概念了。 M是啥，字面上理解太费劲了，其实M模型我感觉表面上就是对数据库的操作，以及业务逻辑的梳理，这便是M模型，主要进行逻辑分析，将分析的结果传递给C也就是控制器，M就是一个深藏功与名的人，他默默就默默地站在幕后，干着最累的工作。 V就是显示，也就是其中最好面子的人，他们两个人忙活半天，其实都是在给我忙活，所有东西都处理完了，拿到他这里来显示。 C控制器，这个字面上就好理解了，那就是起到控制的作用，他控制着全局，属于M和C的一个中间层。（如果说错了，还请高手指正） 现在市面上的PHP框架基本上都是单一入口的文件。下面就是一个PHP框架的运行的简单流程图。 对PHP框架有了一定的了解之后，我们下一篇就开始讲PHP框架的目录结构了。 仅以此文先给刚刚入门的菜鸟，和正在努力奋斗的程序员们，祝各位早日成为攻城狮！出任CTO，赢取白富美，走向人生巅峰。 （如有转载，请注明出处，小弟感激不尽。）","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]}]}