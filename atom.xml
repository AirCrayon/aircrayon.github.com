<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maksim&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maksim.website/"/>
  <updated>2018-03-09T14:56:03.659Z</updated>
  <id>http://www.maksim.website/</id>
  
  <author>
    <name>Maksim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/03/09/cjek2dcuu005lyvrdvbc1aj26/"/>
    <id>http://www.maksim.website/2018/03/09/cjek2dcuu005lyvrdvbc1aj26/</id>
    <published>2018-03-09T14:43:55.932Z</published>
    <updated>2018-03-09T14:56:03.659Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:深入理解JavaScript系列（2）揭秘命名函数表达式<br>date:2018-3-9</p><h2 id="categories-javascript"><a href="#categories-javascript" class="headerlink" title="categories:javascript"></a>categories:javascript</h2><blockquote><p>2011-12-29 09:02 by 汤姆大叔</p><p>原地址：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上还没用发现有人对命名函数表达式进去重复深入的讨论，正因为如此，网上出现了各种各样的误解，本文将从原理和实践两个方面来探讨JavaScript关于命名函数表达式的优缺点。</p><p>简单的说，命名函数表达式只有一个用户，那就是在Debug或者Profiler分析的时候来描述函数的名称，也可以使用函数名实现递归，但很快你就会发现其实是不切实际的。当然，如果你不关注调试，那就没什么可担心的了，否则，如果你想了解兼容性方面的东西的话，你还是应该继续往下看看。</p><p>我们先开始看看，什么叫函数表达式，然后再说一下现代调试器如何处理这些表达式，如果你已经对这方面很熟悉的话，请直接跳过此小节。</p><h1 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h1><p>在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者期间的区别是有点晕，因为ECMA规范只明确了一点：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符：</p><p>　　函数声明:</p><p>　　function 函数名称 <strong>(</strong>参数：可选<strong>){</strong> 函数体<strong> }</strong></p><p>　　函数表达式：</p><p>　　function 函数名称（可选）<strong>(</strong>参数：可选<strong>){</strong> 函数体 <strong>}</strong></p><p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称的话，如何判断是函数声明还是函数表达式呢？ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;&#125; // 声明，因为它是程序的一部分</div><div class="line">var bar = function foo()&#123;&#125;; // 表达式，因为它是赋值表达式的一部分</div><div class="line"></div><div class="line">new function bar()&#123;&#125;; // 表达式，因为它是new表达式</div><div class="line"></div><div class="line">(function()&#123;</div><div class="line">  function bar()&#123;&#125; // 声明，因为它是函数体的一部分</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式，我们来看几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;&#125; // 函数声明</div><div class="line">(function foo()&#123;&#125;); // 函数表达式：包含在分组操作符内</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  (var x = 5); // 分组操作符，只能包含表达式而不能包含语句：这里的var就是语句</div><div class="line">&#125; catch(err) &#123;</div><div class="line">  // SyntaxError</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你可以会想到，在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval(‘(‘ + json + ‘)’)，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  &#123; &quot;x&quot;: 5 &#125;; // &quot;&#123;&quot; 和 &quot;&#125;&quot; 做解析成代码块</div><div class="line">&#125; catch(err) &#123;</div><div class="line">  // SyntaxError</div><div class="line">&#125;</div><div class="line"></div><div class="line">(&#123; &quot;x&quot;: 5 &#125;); // 分组操作符强制将&quot;&#123;&quot; 和 &quot;&#125;&quot;作为对象字面量来解析</div></pre></td></tr></table></figure><p>表达式和声明存在着十分微妙的差别，首先，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，参考如下例子，函数fn是在alert之后声明的，但是在alert执行的时候，fn已经有定义了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(fn());</div><div class="line"></div><div class="line">function fn() &#123;</div><div class="line">  return &apos;Hello world!&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外，还有一点需要提醒一下，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 千万别这样做！</div><div class="line">// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个</div><div class="line"></div><div class="line">if (true) &#123;</div><div class="line">  function foo() &#123;</div><div class="line">    return &apos;first&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  function foo() &#123;</div><div class="line">    return &apos;second&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line">// 相反，这样情况，我们要用函数表达式</div><div class="line">var foo;</div><div class="line">if (true) &#123;</div><div class="line">  foo = function() &#123;</div><div class="line">    return &apos;first&apos;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  foo = function() &#123;</div><div class="line">    return &apos;second&apos;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure><p>函数声明的实际规则如下：</p><p><em>函数声明</em>只能出现在<em>程序</em>或<em>函数体</em>内。从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含<em>函数声明</em>这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让<em>表达式</em>出现在Block（块）中情形，就是让它作为<em>表达式语句</em>的一部分。但是，规范明确规定了<em>表达式语句</em>不能以关键字function开头。而这实际上就是说，<em>函数表达式</em>同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 </p><h1 id="函数语句"><a href="#函数语句" class="headerlink" title="函数语句"></a>函数语句</h1><p>在ECMAScript的语法扩展中，有一个是函数语句，目前只有基于Gecko的浏览器实现了该扩展，所以对于下面的例子，我们仅是抱着学习的目的来看，一般来说不推荐使用（除非你针对Gecko浏览器进行开发）。</p><p>1.一般语句能用的地方，函数语句也能用，当然也包括Block块中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  function f()&#123; &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  function f()&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.函数语句可以像其他语句一样被解析，包含基于条件执行的情形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  function foo()&#123; return 1; &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  function foo()&#123; return 2; &#125;</div><div class="line">&#125;</div><div class="line">foo(); // 1</div><div class="line">// 注：其它客户端会将foo解析成函数声明 </div><div class="line">// 因此，第二个foo会覆盖第一个，结果返回2，而不是1</div></pre></td></tr></table></figure><p>3.函数语句不是在变量初始化期间声明的，而是在运行时声明的——与函数表达式一样。不过，函数语句的标识符一旦声明能在函数的整个作用域生效了。标识符有效性正是导致函数语句与函数表达式不同的关键所在（下一小节我们将会展示命名函数表达式的具体行为）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 此刻，foo还没用声明</div><div class="line">typeof foo; // &quot;undefined&quot;</div><div class="line">if (true) &#123;</div><div class="line">  // 进入这里以后，foo就被声明在整个作用域内了</div><div class="line">  function foo()&#123; return 1; &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  // 从来不会走到这里，所以这里的foo也不会被声明</div><div class="line">  function foo()&#123; return 2; &#125;</div><div class="line">&#125;</div><div class="line">typeof foo; // &quot;function&quot;</div></pre></td></tr></table></figure><p>不过，我们可以使用下面这样的符合标准的代码来模式上面例子中的函数语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var foo;</div><div class="line">if (true) &#123;</div><div class="line">  foo = function foo()&#123; return 1; &#125;;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  foo = function foo() &#123; return 2; &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.函数语句和函数声明（或命名函数表达式）的字符串表示类似，也包括标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  function foo()&#123; return 1; &#125;</div><div class="line">&#125;</div><div class="line">String(foo); // function foo() &#123; return 1; &#125;</div></pre></td></tr></table></figure><p>5.另外一个，早期基于Gecko的实现（Firefox 3及以前版本）中存在一个bug，即函数语句覆盖函数声明的方式不正确。在这些早期的实现中，函数语句不知何故不能覆盖函数声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 函数声明</div><div class="line">function foo()&#123; return 1; &#125;</div><div class="line">if (true) &#123;</div><div class="line">  // 用函数语句重写</div><div class="line">  function foo()&#123; return 2; &#125;</div><div class="line">&#125;</div><div class="line">foo(); // FF3以下返回1，FF3.5以上返回2</div><div class="line"></div><div class="line">// 不过，如果前面是函数表达式，则没用问题</div><div class="line">var foo = function()&#123; return 1; &#125;;</div><div class="line">if (true) &#123;</div><div class="line">  function foo()&#123; return 2; &#125;</div><div class="line">&#125;</div><div class="line">foo(); // 所有版本都返回2</div></pre></td></tr></table></figure><p>再次强调一点，上面这些例子只是在某些浏览器支持，所以推荐大家不要使用这些，除非你就在特性的浏览器上做开发。</p><h1 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h1><p>函数表达式在实际应用中还是很常见的，在web开发中友个常用的模式是基于对某种特性的测试来伪装函数定义，从而达到性能优化的目的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 该代码来自Garrett Smith的APE Javascript library库(http://dhtmlkitchen.com/ape/) </div><div class="line">var contains = (function() &#123;</div><div class="line">  var docEl = document.documentElement;</div><div class="line"></div><div class="line">  if (typeof docEl.compareDocumentPosition != &apos;undefined&apos;) &#123;</div><div class="line">    return function(el, b) &#123;</div><div class="line">      return (el.compareDocumentPosition(b) &amp; 16) !== 0;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  else if (typeof docEl.contains != &apos;undefined&apos;) &#123;</div><div class="line">    return function(el, b) &#123;</div><div class="line">      return el !== b &amp;&amp; el.contains(b);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  return function(el, b) &#123;</div><div class="line">    if (el === b) return false;</div><div class="line">    while (el != b &amp;&amp; (b = b.parentNode) != null);</div><div class="line">    return el === b;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>提到命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var f = function foo()&#123;</div><div class="line">  return typeof foo; // foo是在内部作用域内有效</div><div class="line">&#125;;</div><div class="line">// foo在外部用于是不可见的</div><div class="line">typeof foo; // &quot;undefined&quot;</div><div class="line">f(); // &quot;function&quot;</div></pre></td></tr></table></figure><p>既然，这么要求，那命名函数表达式到底有啥用啊？为啥要取名？</p><p>正如我们开头所说：给它一个名字就是可以让调试过程更方便，因为在调试的时候，如果在调用栈中的每个项都有自己的名字来描述，那么调试过程就太爽了，感受不一样嘛。</p><h1 id="调试器中的函数名"><a href="#调试器中的函数名" class="headerlink" title="调试器中的函数名"></a>调试器中的函数名</h1><p>如果一个函数有名字，那调试器在调试的时候会将它的名字显示在调用的栈上。有些调试器（Firebug）有时候还会为你们函数取名并显示，让他们和那些应用该函数的便利具有相同的角色，可是通常情况下，这些调试器只安装简单的规则来取名，所以说没有太大价格，我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return bar();</div><div class="line">&#125;</div><div class="line">function bar()&#123;</div><div class="line">  return baz();</div><div class="line">&#125;</div><div class="line">function baz()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line">// 这里我们使用了3个带名字的函数声明</div><div class="line">// 所以当调试器走到debugger语句的时候，Firebug的调用栈上看起来非常清晰明了 </div><div class="line">// 因为很明白地显示了名称</div><div class="line">baz</div><div class="line">bar</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>通过查看调用栈的信息，我们可以很明了地知道foo调用了bar, bar又调用了baz（而foo本身有在expr_test.html文档的全局作用域内被调用），不过，还有一个比较爽地方，就是刚才说的Firebug为匿名表达式取名的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return bar();</div><div class="line">&#125;</div><div class="line">var bar = function()&#123;</div><div class="line">  return baz();</div><div class="line">&#125;</div><div class="line">function baz()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line">// Call stack</div><div class="line">baz</div><div class="line">bar() //看到了么？ </div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>然后，当函数表达式稍微复杂一些的时候，调试器就不那么聪明了，我们只能在调用栈中看到问号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return bar();</div><div class="line">&#125;</div><div class="line">var bar = (function()&#123;</div><div class="line">  if (window.addEventListener) &#123;</div><div class="line">    return function()&#123;</div><div class="line">      return baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  else if (window.attachEvent) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      return baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line">function baz()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line">// Call stack</div><div class="line">baz</div><div class="line">(?)() // 这里可是问号哦</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>另外，当把函数赋值给多个变量的时候，也会出现令人郁闷的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return baz();</div><div class="line">&#125;</div><div class="line">var bar = function()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;;</div><div class="line">var baz = bar;</div><div class="line">bar = function() &#123; </div><div class="line">  alert(&apos;spoofed&apos;);</div><div class="line">&#125;;</div><div class="line">foo();</div><div class="line"></div><div class="line">// Call stack:</div><div class="line">bar()</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>这时候，调用栈显示的是foo调用了bar，但实际上并非如此，之所以有这种问题，是因为baz和另外一个包含alert(‘spoofed’)的函数做了引用交换所导致的。</p><p>归根结底，只有给函数表达式取个名字，才是最委托的办法，也就是使用<strong>命名函数表达式</strong>。我们来使用带名字的表达式来重写上面的例子（注意立即调用的表达式块里返回的2个函数的名字都是bar）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return bar();</div><div class="line">&#125;</div><div class="line">var bar = (function()&#123;</div><div class="line">  if (window.addEventListener) &#123;</div><div class="line">    return function bar()&#123;</div><div class="line">      return baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  else if (window.attachEvent) &#123;</div><div class="line">    return function bar() &#123;</div><div class="line">      return baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line">function baz()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line">// 又再次看到了清晰的调用栈信息了耶!</div><div class="line">baz</div><div class="line">bar</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>OK，又学了一招吧？不过在高兴之前，我们再看看不同寻常的JScript吧。</p><h1 id="JScript的Bug"><a href="#JScript的Bug" class="headerlink" title="JScript的Bug"></a>JScript的Bug</h1><p>比较恶的是，IE的ECMAScript实现JScript严重混淆了命名函数表达式，搞得现很多人都出来反对命名函数表达式，而且即便是最新的一版（IE8中使用的5.8版）仍然存在下列问题。<br>下面我们就来看看IE在实现中究竟犯了那些错误，俗话说知已知彼，才能百战不殆。我们来看看如下几个例子：<br><strong>例1：函数表达式的标示符泄露到外部作用域</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;&#125;;</div><div class="line">typeof g; // &quot;function&quot;</div></pre></td></tr></table></figure><p>上面我们说过，命名函数表达式的标示符在外部作用域是无效的，但JScript明显是违反了这一规范，上面例子中的标示符g被解析成函数对象，这就乱了套了，很多难以发现的bug都是因为这个原因导致的。</p><p><em>注：IE9貌似已经修复了这个问题</em><br><strong>例2：将命名函数表达式同时当作函数声明和函数表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof g; // &quot;function&quot;</div><div class="line">var f = function g()&#123;&#125;;</div></pre></td></tr></table></figure><p>特性环境下，函数声明会优先于任何表达式被解析，上面的例子展示的是JScript实际上是把命名函数表达式当成函数声明了，因为它在实际声明之前就解析了g。<br>这个例子引出了下一个例子。<br><strong>例3：命名函数表达式会创建两个截然不同的函数对象！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;&#125;;</div><div class="line">f === g; // false</div><div class="line"></div><div class="line">f.expando = &apos;foo&apos;;</div><div class="line">g.expando; // undefined</div></pre></td></tr></table></figure><p>看到这里，大家会觉得问题严重了，因为修改任何一个对象，另外一个没有什么改变，这太恶了。通过这个例子可以发现，创建2个不同的对象，也就是说如果你想修改f的属性中保存某个信息，然后想当然地通过引用相同对象的g的同名属性来使用，那问题就大了，因为根本就不可能。<br>再来看一个稍微复杂的例子：</p><p><strong>例4：仅仅顺序解析函数声明而忽略条件语句块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var f = function g() &#123;</div><div class="line">  return 1;</div><div class="line">&#125;;</div><div class="line">if (false) &#123;</div><div class="line">  f = function g()&#123;</div><div class="line">    return 2;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">g(); // 2</div></pre></td></tr></table></figure><p>这个bug查找就难多了，但导致bug的原因却非常简单。首先，g被当作函数声明解析，由于JScript中的函数声明不受条件代码块约束，所以在这个很恶的if分支中，g被当作另一个函数function g(){ return 2 }，也就是又被声明了一次。然后，所有“常规的”表达式被求值，而此时f被赋予了另一个新创建的对象的引用。由于在对表达式求值的时候，永远不会进入“这个可恶if分支，因此f就会继续引用第一个函数function g(){ return 1 }。分析到这里，问题就很清楚了：假如你不够细心，在f中调用了g，那么将会调用一个毫不相干的g函数对象。</p><p>你可能会文，将不同的对象和arguments.callee相比较时，有什么样的区别呢？我们来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;</div><div class="line">   return [</div><div class="line">     arguments.callee == f,</div><div class="line">     arguments.callee == g</div><div class="line">   ];</div><div class="line"> &#125;;</div><div class="line"> f(); // [true, false]</div><div class="line"> g(); // [false, true]</div></pre></td></tr></table></figure><p>可以看到，arguments.callee的引用一直是被调用的函数，实际上这也是好事，稍后会解释。</p><p>还有一个有趣的例子，那就是在不包含声明的赋值语句中使用命名函数表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  f = function f()&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>按照代码的分析，我们原本是想创建一个全局属性f（注意不要和一般的匿名函数混淆了，里面用的是带名字的生命），JScript在这里捣乱了一把，首先他把表达式当成函数声明解析了，所以左边的f被声明为局部变量了（和一般的匿名函数里的声明一样），然后在函数执行的时候，f已经是定义过的了，右边的function f(){}则直接就赋值给局部变量f了，所以f根本就不是全局属性。</p><p>了解了JScript这么变态以后，我们就要及时预防这些问题了，首先<strong>防范标识符泄漏带外部作用域</strong>，其次，应该永远<strong>不引用被用作函数名称的标识符</strong>；还记得前面例子中那个讨人厌的标识符g吗？——如果我们能够当g不存在，可以避免多少不必要的麻烦哪。因此，关键就在于始终要通过f或者arguments.callee来引用函数。如果你使用了命名函数表达式，那么应该只在调试的时候利用那个名字。最后，还要记住一点，一定要把<strong>命名函数表达式声明期间错误创建的函数清理干净</strong>。</p><p>对于，上面最后一点，我们还得再解释一下。</p><h1 id="JScript的内存管理"><a href="#JScript的内存管理" class="headerlink" title="JScript的内存管理"></a>JScript的内存管理</h1><p>知道了这些不符合规范的代码解析bug以后，我们如果用它的话，就会发现内存方面其实是有问题的，来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var f = (function()&#123;</div><div class="line">  if (true) &#123;</div><div class="line">    return function g()&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  return function g()&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>我们知道，这个匿名函数调用返回的函数（带有标识符g的函数），然后赋值给了外部的f。我们也知道，命名函数表达式会导致产生多余的函数对象，而该对象与返回的函数对象不是一回事。所以这个多余的g函数就死在了返回函数的闭包中了，因此内存问题就出现了。这是因为if语句内部的函数与g是在同一个作用域中被声明的。这种情况下 ，除非我们显式断开对g函数的引用，否则它一直占着内存不放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var f = (function()&#123;</div><div class="line">  var f, g;</div><div class="line">  if (true) &#123;</div><div class="line">    f = function g()&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    f = function g()&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  // 设置g为null以后它就不会再占内存了</div><div class="line">  g = null;</div><div class="line">  return f;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>通过设置g为null，垃圾回收器就把g引用的那个隐式函数给回收掉了，为了验证我们的代码，我们来做一些测试，以确保我们的内存被回收了。</p><p>测试</p><p>测试很简单，就是命名函数表达式创建10000个函数，然后把它们保存在一个数组中。等一会儿以后再看这些函数到底占用了多少内存。然后，再断开这些引用并重复这一过程。下面是测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function createFn()&#123;</div><div class="line">  return (function()&#123;</div><div class="line">    var f;</div><div class="line">    if (true) &#123;</div><div class="line">      f = function F()&#123;</div><div class="line">        return &apos;standard&apos;;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    else if (false) &#123;</div><div class="line">      f = function F()&#123;</div><div class="line">        return &apos;alternative&apos;;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">      f = function F()&#123;</div><div class="line">        return &apos;fallback&apos;;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    // var F = null;</div><div class="line">    return f;</div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = [ ];</div><div class="line">for (var i=0; i&lt;10000; i++) &#123;</div><div class="line">  arr[i] = createFn();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过运行在Windows XP SP2中的任务管理器可以看到如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">IE6:</div><div class="line"></div><div class="line">  without `null`:   7.6K -&gt; 20.3K</div><div class="line">  with `null`:      7.6K -&gt; 18K</div><div class="line"></div><div class="line">IE7:</div><div class="line"></div><div class="line">  without `null`:   14K -&gt; 29.7K</div><div class="line">  with `null`:      14K -&gt; 27K</div></pre></td></tr></table></figure><p>如我们所料，显示断开引用可以释放内存，但是释放的内存不是很多，10000个函数对象才释放大约3M的内存，这对一些小型脚本不算什么，但对于大型程序，或者长时间运行在低内存的设备里的时候，这是非常有必要的。</p><p>关于在Safari 2.x中JS的解析也有一些bug，但介于版本比较低，所以我们在这里就不介绍了，大家如果想看的话，请仔细查看英文资料。</p><h1 id="SpiderMonkey的怪癖"><a href="#SpiderMonkey的怪癖" class="headerlink" title="SpiderMonkey的怪癖"></a>SpiderMonkey的怪癖</h1><p>大家都知道，命名函数表达式的标识符只在函数的局部作用域中有效。但包含这个标识符的局部作用域又是什么样子的吗？其实非常简单。在命名函数表达式被求值时，会<strong>创建一个特殊的对象</strong>，该对象的唯一目的就是保存一个属性，而这个属性的名字对应着函数标识符，属性的值对应着那个函数。这个对象会被注入到当前作用域链的前端。然后，被“扩展”的作用域链又被用于初始化函数。</p><p>在这里，有一点十分有意思，那就是ECMA-262定义这个（保存函数标识符的）“特殊”对象的方式。标准说<strong>“像调用new Object()表达式那样”</strong>创建这个对象。如果从字面上来理解这句话，那么这个对象就应该是全局<code>Object</code>的一个实例。然而，只有一个实现是按照标准字面上的要求这么做的，这个实现就是SpiderMonkey。因此，在SpiderMonkey中，扩展<code>Object.prototype</code>有可能会干扰函数的局部作用域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = &apos;outer&apos;;</div><div class="line"></div><div class="line">(function()&#123;</div><div class="line">  </div><div class="line">  var x = &apos;inner&apos;;</div><div class="line">  </div><div class="line">  /*</div><div class="line">    函数foo的作用域链中有一个特殊的对象——用于保存函数的标识符。这个特殊的对象实际上就是&#123; foo: &lt;function object&gt; &#125;。</div><div class="line">    当通过作用域链解析x时，首先解析的是foo的局部环境。如果没有找到x，则继续搜索作用域链中的下一个对象。下一个对象</div><div class="line">    就是保存函数标识符的那个对象——&#123; foo: &lt;function object&gt; &#125;，由于该对象继承自Object.prototype，所以在此可以找到x。</div><div class="line">    而这个x的值也就是Object.prototype.x的值（outer）。结果，外部函数的作用域（包含x = &apos;inner&apos;的作用域）就不会被解析了。</div><div class="line">  */</div><div class="line">  </div><div class="line">  (function foo()&#123;</div><div class="line">    </div><div class="line">    alert(x); // 提示框中显示：outer</div><div class="line">  </div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>不过，更高版本的SpiderMonkey改变了上述行为，原因可能是认为那是一个安全漏洞。也就是说，“特殊”对象不再继承Object.prototype了。不过，如果你使用Firefox 3或者更低版本，还可以“重温”这种行为。<br>另一个把内部对象实现为全局Object对象的是黑莓（Blackberry）浏览器。目前，它的<em>活动对象</em>（Activation Object）仍然继承Object.prototype。可是，ECMA-262并没有说<em>活动对象</em>也要“像调用new Object()表达式那样”来创建（或者说像创建保存NFE标识符的对象一样创建）。 人家规范只说了<em>活动对象</em>是规范中的一种机制。<br>那我们就来看看黑莓里都发生了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = &apos;outer&apos;;</div><div class="line"></div><div class="line">(function()&#123;</div><div class="line">  </div><div class="line">  var x = &apos;inner&apos;;</div><div class="line">  </div><div class="line">  (function()&#123;</div><div class="line">    </div><div class="line">    /*</div><div class="line">    在沿着作用域链解析x的过程中，首先会搜索局部函数的活动对象。当然，在该对象中找不到x。</div><div class="line">    可是，由于活动对象继承自Object.prototype，因此搜索x的下一个目标就是Object.prototype；而</div><div class="line">    Object.prototype中又确实有x的定义。结果，x的值就被解析为——outer。跟前面的例子差不多，</div><div class="line">    包含x = &apos;inner&apos;的外部函数的作用域（活动对象）就不会被解析了。</div><div class="line">    */</div><div class="line">    </div><div class="line">    alert(x); // 显示：outer</div><div class="line">    </div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>不过神奇的还是，函数中的变量甚至会与已有的<code>Object.prototype</code>的成员发生冲突，来看看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  </div><div class="line">  var constructor = function()&#123; return 1; &#125;;</div><div class="line">  </div><div class="line">  (function()&#123;</div><div class="line">    </div><div class="line">    constructor(); // 求值结果是&#123;&#125;（即相当于调用了Object.prototype.constructor()）而不是1</div><div class="line">    </div><div class="line">    constructor === Object.prototype.constructor; // true</div><div class="line">    toString === Object.prototype.toString; // true</div><div class="line">    </div><div class="line">    // ……</div><div class="line">    </div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>要避免这个问题，要避免使用Object.prototype里的属性名称，如toString, valueOf, hasOwnProperty等等。</p><p>JScript解决方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var fn = (function()&#123;</div><div class="line"></div><div class="line">  // 声明要引用函数的变量</div><div class="line">  var f;</div><div class="line"></div><div class="line">  // 有条件地创建命名函数</div><div class="line">  // 并将其引用赋值给f</div><div class="line">  if (true) &#123;</div><div class="line">    f = function F()&#123; &#125;</div><div class="line">  &#125;</div><div class="line">  else if (false) &#123;</div><div class="line">    f = function F()&#123; &#125;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    f = function F()&#123; &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 声明一个与函数名（标识符）对应的变量，并赋值为null</div><div class="line">  // 这实际上是给相应标识符引用的函数对象作了一个标记，</div><div class="line">  // 以便垃圾回收器知道可以回收它了</div><div class="line">  var F = null;</div><div class="line"></div><div class="line">  // 返回根据条件定义的函数</div><div class="line">  return f;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>最后我们给出一个应用上述技术的应用实例，这是一个跨浏览器的addEvent函数代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 1) 使用独立的作用域包含声明</div><div class="line">var addEvent = (function()&#123;</div><div class="line"></div><div class="line">  var docEl = document.documentElement;</div><div class="line"></div><div class="line">  // 2) 声明要引用函数的变量</div><div class="line">  var fn;</div><div class="line"></div><div class="line">  if (docEl.addEventListener) &#123;</div><div class="line"></div><div class="line">    // 3) 有意给函数一个描述性的标识符</div><div class="line">    fn = function addEvent(element, eventName, callback) &#123;</div><div class="line">      element.addEventListener(eventName, callback, false);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  else if (docEl.attachEvent) &#123;</div><div class="line">    fn = function addEvent(element, eventName, callback) &#123;</div><div class="line">      element.attachEvent(&apos;on&apos; + eventName, callback);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    fn = function addEvent(element, eventName, callback) &#123;</div><div class="line">      element[&apos;on&apos; + eventName] = callback;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 4) 清除由JScript创建的addEvent函数</div><div class="line">  //    一定要保证在赋值前使用var关键字</div><div class="line">  //    除非函数顶部已经声明了addEvent</div><div class="line">  var addEvent = null;</div><div class="line"></div><div class="line">  // 5) 最后返回由fn引用的函数</div><div class="line">  return fn;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h1 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h1><p>其实，如果我们不想要这个描述性名字的话，我们就可以用最简单的形式来做，也就是在函数内部声明一个函数（而不是函数表达式），然后返回该函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var hasClassName = (function()&#123;</div><div class="line"></div><div class="line">  // 定义私有变量</div><div class="line">  var cache = &#123; &#125;;</div><div class="line"></div><div class="line">  // 使用函数声明</div><div class="line">  function hasClassName(element, className) &#123;</div><div class="line">    var _className = &apos;(?:^|\\s+)&apos; + className + &apos;(?:\\s+|$)&apos;;</div><div class="line">    var re = cache[_className] || (cache[_className] = new RegExp(_className));</div><div class="line">    return re.test(element.className);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 返回函数</div><div class="line">  return hasClassName;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>显然，当存在多个分支函数定义时，这个方案就不行了。不过有种模式貌似可以实现：那就是提前使用函数声明来定义所有函数，并分别为这些函数指定不同的标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var addEvent = (function()&#123;</div><div class="line"></div><div class="line">  var docEl = document.documentElement;</div><div class="line"></div><div class="line">  function addEventListener()&#123;</div><div class="line">    /* ... */</div><div class="line">  &#125;</div><div class="line">  function attachEvent()&#123;</div><div class="line">    /* ... */</div><div class="line">  &#125;</div><div class="line">  function addEventAsProperty()&#123;</div><div class="line">    /* ... */</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (typeof docEl.addEventListener != &apos;undefined&apos;) &#123;</div><div class="line">    return addEventListener;</div><div class="line">  &#125;</div><div class="line">  elseif (typeof docEl.attachEvent != &apos;undefined&apos;) &#123;</div><div class="line">    return attachEvent;</div><div class="line">  &#125;</div><div class="line">  return addEventAsProperty;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>虽然这个方案很优雅，但也不是没有缺点。第一，由于使用不同的标识符，导致丧失了命名的一致性。且不说这样好还是坏，最起码它不够清晰。有人喜欢使用相同的名字，但也有人根本不在乎字眼上的差别。可毕竟，不同的名字会让人联想到所用的不同实现。例如，在调试器中看到attachEvent，我们就知 道<code>addEvent</code>是基于<code>attachEvent</code>的实现。当 然，基于实现来命名的方式也不一定都行得通。假如我们要提供一个API，并按照这种方式把函数命名为inner。那么API用户的很容易就会被相应实现的 细节搞得晕头转向。</p><p>要解决这个问题，当然就得想一套更合理的命名方案了。但关键是不要再额外制造麻烦。我现在能想起来的方案大概有如下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;addEvent&apos;, &apos;altAddEvent&apos;, &apos;fallbackAddEvent&apos;</div><div class="line">// 或者</div><div class="line">&apos;addEvent&apos;, &apos;addEvent2&apos;, &apos;addEvent3&apos;</div><div class="line">// 或者</div><div class="line">&apos;addEvent_addEventListener&apos;, &apos;addEvent_attachEvent&apos;, &apos;addEvent_asProperty&apos;</div></pre></td></tr></table></figure><p>另外，这种模式还存在一个小问题，即增加内存占用。提前创建N个不同名字的函数，等于有N-1的函数是用不到的。具体来讲，如果<code>document.documentElement</code> 中包含<code>attachEvent</code>，那么<code>addEventListener</code> 和<code>addEventAsProperty</code>则根本就用不着了。可是，他们都占着内存哪；而且，这些内存将永远都得不到释放，原因跟JScript臭哄哄的命名表达式相同——这两个函数都被“截留”在返回的那个函数的闭包中了。</p><p>不过，增加内存占用这个问题确实没什么大不了的。如果某个库——例如Prototype.js——采用了这种模式，无非也就是多创建一两百个函数而已。只要不是（在运行时）重复地创建这些函数，而是只（在加载时）创建一次，那么就没有什么好担心的。</p><h1 id="WebKit的displayName"><a href="#WebKit的displayName" class="headerlink" title="WebKit的displayName"></a>WebKit的displayName</h1><p>WebKit团队在这个问题采取了有点儿另类的策略。介于匿名和命名函数如此之差的表现力，WebKit引入了一个“特殊的”<code>displayName</code>属性（本质上是一个字符串），如果开发人员为函数的这个属性赋值，则该属性的值将在调试器或性能分析器中被显示在函数“名称”的位置上。<a href="http://www.alertdebugging.com/2009/04/29/building-a-better-javascript-profiler-with-webkit/" target="_blank" rel="noopener">Francisco Tolmasky详细地解释了这个策略的原理和实现</a>。</p><h1 id="未来考虑"><a href="#未来考虑" class="headerlink" title="未来考虑"></a>未来考虑</h1><p>将来的ECMAScript-262第5版（目前还是草案）会引入所谓的<strong>严格模式（strict mode）</strong>。开启严格模式的实现会禁用语言中的那些不稳定、不可靠和不安全的特性。据说出于安全方面的考虑，<code>arguments.callee</code>属性将在严格模式下被“封杀”。因此，在处于严格模式时，访问<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><p>  // 此前，你可能会使用arguments.callee<br>  (function(x) {<br>    if (x &lt;= 1) return 1;<br>    return x * arguments.callee(x - 1);<br>  })(10);</p><p>  // 但在严格模式下，有可能就要使用命名函数表达式<br>  (function factorial(x) {<br>    if (x &lt;= 1) return 1;<br>    return x * factorial(x - 1);<br>  })(10);</p><p>  // 要么就退一步，使用没有那么灵活的函数声明<br>  function factorial(x) {<br>    if (x &lt;= 1) return 1;<br>    return x * factorial(x - 1);<br>  }<br>  factorial(10);<br>```</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><strong>理查德· 康福德（Richard Cornford）</strong>，是他率先<a href="http://groups.google.com/group/comp.lang.javascript/msg/5b508b03b004bce8" target="_blank" rel="noopener">解释了JScript中命名函数表达式所存在的bug</a>。理查德解释了我在这篇文章中提及的大多数bug，所以我强烈建议大家去看看他的解释。我还要感谢<strong>Yann-Erwan Perio</strong>和<strong>道格拉斯·克劳克佛德（Douglas Crockford）</strong>，他们早在2003年就在<a href="http://groups.google.com/group/comp.lang.javascript/msg/03d53d114d176323" target="_blank" rel="noopener">comp.lang.javascript论坛中提及并讨论NFE问题了</a>。</p><p><strong>约翰-戴维·道尔顿（John-David Dalton）</strong>对“最终解决方案”提出了很好的建议。</p><p><strong>托比·兰吉</strong>的点子被我用在了“替代方案”中。</p><p><strong>盖瑞特·史密斯（Garrett Smith）</strong>和<strong>德米特里·苏斯尼科（Dmitry Soshnikov）</strong>对本文的多方面作出了补充和修正。</p><p>英文原文：<a href="http://kangax.github.com/nfe/" target="_blank" rel="noopener">http://kangax.github.com/nfe/</a></p><p>参考译文：<a href="http://www.cn-cuckoo.com/main/wp-content/uploads/2009/12/named-function-expressions-demystified.html#jscript-memory-management" target="_blank" rel="noopener">连接访问</a> (SpiderMonkey的怪癖之后的章节参考该文)</p><h1 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h1><p>本文已同步至目录索引：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">深入理解JavaScript系列</a></p><p>深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:深入理解JavaScript系列（2）揭秘命名函数表达式&lt;br&gt;date:2018-3-9&lt;/p&gt;
&lt;h2 id=&quot;categories-javascript&quot;&gt;&lt;a href=&quot;#categories-javascript&quot; class=&quot;heade
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/03/09/cjek2dcv1005nyvrdop7oybj0/"/>
    <id>http://www.maksim.website/2018/03/09/cjek2dcv1005nyvrdop7oybj0/</id>
    <published>2018-03-09T14:42:42.933Z</published>
    <updated>2018-03-09T14:56:06.515Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:深入理解JavaScript系列（1）编写高质量JavaScript代码的基本要点<br>date:2018-3-9</p><h2 id="categories-JavaScript"><a href="#categories-JavaScript" class="headerlink" title="categories:JavaScript"></a>categories:JavaScript</h2><blockquote><p>2011-12-28 23:00 by 汤姆大叔</p><p>原地址：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html</a></p></blockquote><p>才华横溢的<a href="http://www.phpied.com/" target="_blank" rel="noopener">Stoyan Stefanov</a>，在他写的由<a href="http://oreilly.com/" target="_blank" rel="noopener">O’Reilly</a>初版的新书<a href="http://amzn.to/93szK7" target="_blank" rel="noopener">《JavaScript Patterns》</a>(JavaScript模式)中，我想要是为我们的读者贡献其摘要，那会是件很美妙的事情。具体一点就是编写高质量JavaScript的一些要素，例如避免全局变量，使用单变量声明，在循环中预缓存length(长度)，遵循代码阅读，以及更多。</p><p>此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写API文档、执行同行评审以及运行JSLint。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码，这些代码在几个月或是几年之后再回过头看看也是会觉得很自豪的。</p><h1 id="书写可维护的代码-Writing-Maintainable-Code"><a href="#书写可维护的代码-Writing-Maintainable-Code" class="headerlink" title="书写可维护的代码(Writing Maintainable Code )"></a>书写可维护的代码(Writing Maintainable Code )</h1><p>软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要：</p><ul><li>花时间学习和理解这个问题</li><li>化时间是了解应该解决的问题代码</li></ul><p>还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。</p><p>另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。</p><p>你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如：</p><ul><li>bug是暴露的</li><li>新功能被添加到应用程序</li><li>程序在新的环境下工作（例如，市场上出现新想浏览器）</li><li>代码改变用途</li><li>代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言</li></ul><p>由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。</p><p>可维护的代码意味着：</p><ul><li>可读的</li><li>一致的</li><li>可预测的</li><li>看上去就像是同一个人写的</li><li>已记录</li></ul><h1 id="最小全局变量-Minimizing-Globals"><a href="#最小全局变量-Minimizing-Globals" class="headerlink" title="最小全局变量(Minimizing Globals)"></a>最小全局变量(Minimizing Globals)</h1><p>JavaScript通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。</p><p>每个JavaScript环境有一个全局对象，当你在任意的函数外面使用this的时候可以访问到。你创建的每一个全部变量都成了这个全局对象的属 性。在浏览器中，方便起见，该全局对象有个附加属性叫做window，此window(通常)指向该全局对象本身。下面的代码片段显示了如何在浏览器环境 中创建和访问的全局变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myglobal = &quot;hello&quot;; // 不推荐写法</div><div class="line">console.log(myglobal); // &quot;hello&quot;</div><div class="line">console.log(window.myglobal); // &quot;hello&quot;</div><div class="line">console.log(window[&quot;myglobal&quot;]); // &quot;hello&quot;</div><div class="line">console.log(this.myglobal); // &quot;hello&quot;</div></pre></td></tr></table></figure><h1 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h1><p>全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p><p>web页面包含不是该页面开发者所写的代码也是比较常见的，例如：</p><ul><li>第三方的JavaScript库</li><li>广告方的脚本代码</li><li>第三方用户跟踪和分析脚本代码</li><li>不同类型的小组件，标志和按钮</li></ul><p>比方说，该第三方脚本定义了一个全局变量，叫做result；接着，在你的函数中也定义一个名为result的全局变量。其结果就是后面的变量覆盖前面的，第三方脚本就一下子嗝屁啦！</p><p>因此，要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。在书中后面提到的一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。</p><p>由于JavaScript的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sum(x, y) &#123;</div><div class="line">   // 不推荐写法: 隐式全局变量 </div><div class="line">   result = x + y;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此段代码中的<code>result</code>没有声明。代码照样运作正常，但在调用函数后你最后的结果就多一个全局命名空间，这可以是一个问题的根源。</p><p>经验法则是始终使用var声明变量，正如改进版的sum()函数所演示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sum(x, y) &#123;</div><div class="line">   var result = x + y;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另一个创建隐式全局变量的反例就是使用任务链进行部分var声明。下面的片段中，<code>a</code>是本地变量但是<code>b</code>确实全局变量，这可能不是你希望发生的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 反例，勿使用 </div><div class="line">function foo() &#123;</div><div class="line">   var a = b = 0;</div><div class="line">   // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此现象发生的原因在于这个从右到左的赋值，首先，是赋值表达式<code>b = 0</code>，此情况下b是未声明的。这个表达式的返回值是0，然后这个0就分配给了通过var定义的这个局部变量a。换句话说，就好比你输入了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a = (b = 0);</div></pre></td></tr></table></figure><p>如果你已经准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">   var a, b;</div><div class="line">   // ... a = b = 0; // 两个均局部变量</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>然而，另外一个避免全局变量的原因是可移植性。如果你想你的代码在不同的环境下（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心大胆地使用，实际上对于有些情况并不适用）。</p></blockquote><h1 id="忘记var的副作用-Side-Effects-When-Forgetting-var"><a href="#忘记var的副作用-Side-Effects-When-Forgetting-var" class="headerlink" title="忘记var的副作用(Side Effects When Forgetting var)"></a>忘记var的副作用(Side Effects When Forgetting var)</h1><p>隐式全局变量和明确定义的全局变量间有些小的差异，就是通过<code>delete</code>操作符让变量未定义的能力。</p><ul><li>通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。</li><li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。</li></ul><p>这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过<code>delete</code>操作符删除的，而变量是不能的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 定义三个全局变量</div><div class="line">var global_var = 1;</div><div class="line">global_novar = 2; // 反面教材</div><div class="line">(function () &#123;</div><div class="line">   global_fromfunc = 3; // 反面教材</div><div class="line">&#125;());</div><div class="line"></div><div class="line">// 试图删除</div><div class="line">delete global_var; // false</div><div class="line">delete global_novar; // true</div><div class="line">delete global_fromfunc; // true</div><div class="line"></div><div class="line">// 测试该删除</div><div class="line">typeof global_var; // &quot;number&quot;</div><div class="line">typeof global_novar; // &quot;undefined&quot;</div><div class="line">typeof global_fromfunc; // &quot;undefined&quot;</div></pre></td></tr></table></figure><p>在ES5严格模式下，未声明的变量（如在前面的代码片段中的两个反面教材）工作时会抛出一个错误。</p><h1 id="访问全局对象-Access-to-the-Global-Object"><a href="#访问全局对象-Access-to-the-Global-Object" class="headerlink" title="访问全局对象(Access to the Global Object)"></a>访问全局对象(Access to the Global Object)</h1><p>在浏览器中，全局对象可以通过<code>window</code>属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的<code>window</code>标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var global = (function () &#123;</div><div class="line">   return this;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p>这种方法可以随时获得全局对象，因为其在函数中被当做函数调用了（不是通过<code>new</code>构造），<code>this</code>总 是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。</p><h1 id="单var形式（Single-var-Pattern）"><a href="#单var形式（Single-var-Pattern）" class="headerlink" title="单var形式（Single var Pattern）"></a>单var形式（Single var Pattern）</h1><p>在函数顶部使用单var语句是比较有用的一种形式，其好处在于：</p><ul><li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li><li>防止变量在定义之前使用的逻辑错误</li><li>帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的…</li><li>少代码（类型啊传值啊单线完成）</li></ul><p>单var形式长得就像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">   var a = 1,</div><div class="line">       b = 2,</div><div class="line">       sum = a + b,</div><div class="line">       myobject = &#123;&#125;,</div><div class="line">       i,</div><div class="line">       j;</div><div class="line">   // function body...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>您可以使用一个var语句声明多个变量，并以逗号分隔。像这种初始化变量同时初始化值的做法是很好的。这样子可以防止逻辑错误（所有未初始化但声明的变量的初始值是<code>undefined</code>）和增加代码的可读性。在你看到代码后，你可以根据初始化的值知道这些变量大致的用途，例如是要当作对象呢还是当作整数来使。</p><p>你也可以在声明的时候做一些实际的工作，例如前面代码中的<code>sum = a + b</code>这个情况，另外一个例子就是当你使用DOM（文档对象模型）引用时，你可以使用单一的var把DOM引用一起指定为局部变量，就如下面代码所示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function updateElement() &#123;</div><div class="line">   var el = document.getElementById(&quot;result&quot;),</div><div class="line">       style = el.style;</div><div class="line">   // 使用el和style干点其他什么事...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars"><a href="#预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars" class="headerlink" title="预解析：var散布的问题(Hoisting: A Problem with Scattered vars)"></a>预解析：var散布的问题(Hoisting: A Problem with Scattered vars)</h1><p>JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 反例</div><div class="line">myname = &quot;global&quot;; // 全局变量</div><div class="line">function func() &#123;</div><div class="line">    alert(myname); // &quot;undefined&quot;</div><div class="line">    var myname = &quot;local&quot;;</div><div class="line">    alert(myname); // &quot;local&quot;</div><div class="line">&#125;</div><div class="line">func();</div></pre></td></tr></table></figure><p>在这个例子中，你可能会以为第一个alert弹出的是”global”，第二个弹出”loacl”。这种期许是可以理解的，因为在第一个alert 的时候，myname未声明，此时函数肯定很自然而然地看全局变量myname，但是，实际上并不是这么工作的。第一个alert会弹 出”undefined”是因为myname被当做了函数的局部变量（尽管是之后声明的），所有的变量声明当被悬置到函数的顶部了。因此，为了避免这种混 乱，最好是预先声明你想使用的全部变量。</p><p>上面的代码片段执行的行为可能就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myname = &quot;global&quot;; // global variable</div><div class="line">function func() &#123;</div><div class="line">   var myname; // 等同于 -&gt; var myname = undefined;</div><div class="line">   alert(myname); // &quot;undefined&quot;</div><div class="line">   myname = &quot;local&quot;;</div><div class="line">   alert(myname); // &quot;local&quot;&#125;</div><div class="line">func();</div></pre></td></tr></table></figure><blockquote><p>为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文 的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了”hoisting”这个概念， 这种ECMAScript标准中并未定义，通常用来描述行为。</p></blockquote><h1 id="for循环-for-Loops"><a href="#for循环-for-Loops" class="headerlink" title="for循环(for Loops)"></a>for循环(for Loops)</h1><p>在<code>for</code>循环中，你可以循环取得数组或是数组类似对象的值，譬如<code>arguments</code>和<code>HTMLCollection</code>对象。通常的循环形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 次佳的循环</div><div class="line">for (var i = 0; i &lt; myarray.length; i++) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当<code>myarray</code>不是数组，而是一个<code>HTMLCollection</code>对象的时候。</p><p><code>HTMLCollections</code>指的是DOM方法返回的对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.getElementsByName()</div><div class="line">document.getElementsByClassName()</div><div class="line">document.getElementsByTagName()</div></pre></td></tr></table></figure><p>还有其他一些<code>HTMLCollections</code>，这些是在DOM标准之前引进并且现在还在使用的。有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">document.images: 页面上所有的图片元素</div><div class="line">document.links : 所有a标签元素</div><div class="line">document.forms : 所有表单</div><div class="line">document.forms[0].elements : 页面上第一个表单中的所有域</div></pre></td></tr></table></figure><p>集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。</p><p>这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i = 0, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，在这个循环过程中，你只检索了一次长度值。</p><p>在所有浏览器下，循环获取内容时缓存<code>HTMLCollections</code>的长度是更快的，2倍(Safari3)到190倍(IE7)之间。//zxx:此数据貌似很老，仅供参考</p><p>注意到，当你明确想要修改循环中的集合的时候（例如，添加更多的DOM元素），你可能更喜欢长度更新而不是常量。</p><p>伴随着单var形式，你可以把变量从循环中提出来，就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function looper() &#123;</div><div class="line">   var i = 0,</div><div class="line">        max,</div><div class="line">        myarray = [];</div><div class="line">   // ...</div><div class="line">   for (i = 0, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">      // 使用myarray[i]做点什么</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种形式具有一致性的好处，因为你坚持了单一var形式。不足在于当重构代码的时候，复制和粘贴整个循环有点困难。例如，你从一个函数复制了一个循环到另一个函数，你不得不去确定你能够把<code>i</code>和<code>max</code>引入新的函数（如果在这里没有用的话，很有可能你要从原函数中把它们删掉）。</p><p>最后一个需要对循环进行调整的是使用下面表达式之一来替换<code>i++</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i = i + 1</div><div class="line">i += 1</div></pre></td></tr></table></figure><p>JSLint提示您这样做，原因是<code>++</code>和<code>–-</code>促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手<br>如果你直接无视它，JSLint的<code>plusplus</code>选项会是<code>false</code>（默认是default）。</p><p>还有两种变化的形式，其又有了些微改进，因为：</p><ul><li>少了一个变量(无max)</li><li>向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//第一种变化的形式：</div><div class="line"></div><div class="line">var i, myarray = [];</div><div class="line">for (i = myarray.length; i–-;) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div><div class="line"></div><div class="line">//第二种使用while循环：</div><div class="line"></div><div class="line">var myarray = [],</div><div class="line">    i = myarray.length;</div><div class="line">while (i–-) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些小的改进只体现在性能上，此外JSLint会对使用i–-加以抱怨。</p><h1 id="for-in循环-for-in-Loops"><a href="#for-in循环-for-in-Loops" class="headerlink" title="for-in循环(for-in Loops)"></a>for-in循环(for-in Loops)</h1><p><code>for-in</code>循环应该用在非数组对象的遍历上，使用<code>for-in</code>进行循环也被称为“枚举”。</p><p>从技术上将，你可以使用<code>for-in</code>循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。</p><p>有个很重要的<code>hasOwnProperty()</code>方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。</p><p>思考下面一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 对象</div><div class="line">var man = &#123;</div><div class="line">   hands: 2,</div><div class="line">   legs: 2,</div><div class="line">   heads: 1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 在代码的某个地方</div><div class="line">// 一个方法添加给了所有对象</div><div class="line">if (typeof Object.prototype.clone === &quot;undefined&quot;) &#123;</div><div class="line">   Object.prototype.clone = function () &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个例子中，我们有一个使用对象字面量定义的名叫man的对象。在man定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举man的时候出现clone()方法，你需要应用<code>hasOwnProperty()</code>方法过滤原型属性。如果不做过滤，会导致clone()函数显示出来，在大多数情况下这是不希望出现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1.</div><div class="line">// for-in 循环</div><div class="line">for (var i in man) &#123;</div><div class="line">   if (man.hasOwnProperty(i)) &#123; // 过滤</div><div class="line">      console.log(i, &quot;:&quot;, man[i]);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">/* 控制台显示结果</div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line">*/</div><div class="line">// 2.</div><div class="line">// 反面例子:</div><div class="line">// for-in loop without checking hasOwnProperty()</div><div class="line">for (var i in man) &#123;</div><div class="line">   console.log(i, &quot;:&quot;, man[i]);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">控制台显示结果</div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line">clone: function()</div><div class="line">*/</div></pre></td></tr></table></figure><p>另外一种使用<code>hasOwnProperty()</code>的形式是取消Object.prototype上的方法。像是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i in man) &#123;</div><div class="line">   if (Object.prototype.hasOwnProperty.call(man, i)) &#123; // 过滤</div><div class="line">      console.log(i, &quot;:&quot;, man[i]);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var i, hasOwn = Object.prototype.hasOwnProperty;</div><div class="line">for (i in man) &#123;</div><div class="line">    if (hasOwn.call(man, i)) &#123; // 过滤</div><div class="line">        console.log(i, &quot;:&quot;, man[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>严格来说，不使用<code>hasOwnProperty()</code>并不是一个错误。根据任务以及你对代码的自信程度，你可以跳过它以提高些许的循环速度。但是当你对当前对象内容（和其原型链）不确定的时候，添加<code>hasOwnProperty()</code>更加保险些。</p></blockquote><p>格式化的变化（通不过JSLint）会直接忽略掉花括号，把if语句放到同一行上。其优点在于循环语句读起来就像一个完整的想法（每个元素都有一个自己的属性”X”，使用”X”干点什么）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 警告： 通不过JSLint检测</div><div class="line">var i, hasOwn = Object.prototype.hasOwnProperty;</div><div class="line">for (i in man) if (hasOwn.call(man, i)) &#123; // 过滤</div><div class="line">    console.log(i, &quot;:&quot;, man[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes"><a href="#（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes" class="headerlink" title="（不）扩展内置原型((Not) Augmenting Built-in Prototypes)"></a>（不）扩展内置原型((Not) Augmenting Built-in Prototypes)</h1><p>扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。</p><p>增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。</p><p>另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。</p><p>因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外：</p><ul><li>可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。</li><li>如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。</li><li>你清楚地文档记录并和团队交流了变化。</li></ul><p>如果这三个条件得到满足，你可以给原型进行自定义的添加，形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (typeof Object.protoype.myMethod !== &quot;function&quot;) &#123;</div><div class="line">   Object.protoype.myMethod = function () &#123;</div><div class="line">      // 实现...</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="switch模式-switch-Pattern"><a href="#switch模式-switch-Pattern" class="headerlink" title="switch模式(switch Pattern)"></a>switch模式(switch Pattern)</h1><p>你可以通过类似下面形式的switch语句增强可读性和健壮性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var inspect_me = 0,</div><div class="line">    result = &apos;&apos;;</div><div class="line">switch (inspect_me) &#123;</div><div class="line">case 0:</div><div class="line">   result = &quot;zero&quot;;</div><div class="line">   break;</div><div class="line">case 1:</div><div class="line">   result = &quot;one&quot;;</div><div class="line">   break;</div><div class="line">default:</div><div class="line">   result = &quot;unknown&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个简单的例子中所遵循的风格约定如下：</p><ul><li>每个case和switch对齐（花括号缩进规则除外）</li><li>每个case中代码缩进</li><li>每个case以break清除结束</li><li>避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。</li><li>以default结束switch：确保总有健全的结果，即使无情况匹配。</li></ul><h1 id="避免隐式类型转换-Avoiding-Implied-Typecasting"><a href="#避免隐式类型转换-Avoiding-Implied-Typecasting" class="headerlink" title="避免隐式类型转换(Avoiding Implied Typecasting )"></a>避免隐式类型转换(Avoiding Implied Typecasting )</h1><p>JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var zero = 0;</div><div class="line">if (zero === false) &#123;</div><div class="line">   // 不执行，因为zero为0, 而不是false</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反面示例</div><div class="line">if (zero == false) &#123;</div><div class="line">   // 执行了...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有另外一种思想观点认为==就足够了===是多余的。例如，当你使用typeof你就知道它会返回一个字符串，所以没有使用严格相等的理由。然而，JSLint要求严格相等，它使代码看上去更有一致性，可以降低代码阅读时的精力消耗。（“==是故意的还是一个疏漏？”）</p><h1 id="避免-Avoiding-eval"><a href="#避免-Avoiding-eval" class="headerlink" title="避免(Avoiding) eval()"></a>避免(Avoiding) eval()</h1><p>如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">var property = &quot;name&quot;;</div><div class="line">alert(eval(&quot;obj.&quot; + property));</div><div class="line"></div><div class="line">// 更好的</div><div class="line">var property = &quot;name&quot;;</div><div class="line">alert(obj[property]);</div></pre></td></tr></table></figure><p>使用eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理Ajax请求得到的JSON 相应的时候。在这些情况下，最好使用JavaScript内置方法来解析JSON相应，以确保安全和有效。若浏览器不支持JSON.parse()，你可 以使用来自JSON.org的库。</p><p>同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。在幕后，JavaScript仍需要评估和执行你给程序传递的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">setTimeout(&quot;myFunc()&quot;, 1000);</div><div class="line">setTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);</div><div class="line"></div><div class="line">// 更好的</div><div class="line">setTimeout(myFunc, 1000);</div><div class="line">setTimeout(function () &#123;</div><div class="line">   myFunc(1, 2, 3);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure><p>使用新的Function()构造就类似于eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用eval()，你 可以考虑使用new Function()代替。有一个小的潜在好处，因为在新Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。</p><p>考虑下面这个例子，这里仅<code>un</code>作为全局变量污染了命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">console.log(typeof un);    // &quot;undefined&quot;</div><div class="line">console.log(typeof deux); // &quot;undefined&quot;</div><div class="line">console.log(typeof trois); // &quot;undefined&quot;</div><div class="line"></div><div class="line">var jsstring = &quot;var un = 1; console.log(un);&quot;;</div><div class="line">eval(jsstring); // logs &quot;1&quot;</div><div class="line"></div><div class="line">jsstring = &quot;var deux = 2; console.log(deux);&quot;;</div><div class="line">new Function(jsstring)(); // logs &quot;2&quot;</div><div class="line"></div><div class="line">jsstring = &quot;var trois = 3; console.log(trois);&quot;;</div><div class="line">(function () &#123;</div><div class="line">   eval(jsstring);</div><div class="line">&#125;()); // logs &quot;3&quot;</div><div class="line"></div><div class="line">console.log(typeof un); // number</div><div class="line">console.log(typeof deux); // &quot;undefined&quot;</div><div class="line">console.log(typeof trois); // &quot;undefined&quot;</div></pre></td></tr></table></figure><p>另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。在下面这个例子中，eval()可以访问和修改它外部作用域中的变量，这是 Function做不来的（注意到使用Function和new Function是相同的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">   var local = 1;</div><div class="line">   eval(&quot;local = 3; console.log(local)&quot;); // logs &quot;3&quot;</div><div class="line">   console.log(local); // logs &quot;3&quot;</div><div class="line">&#125;());</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line">   var local = 1;</div><div class="line">   Function(&quot;console.log(typeof local);&quot;)(); // logs undefined</div><div class="line">&#125;());</div></pre></td></tr></table></figure><h1 id="parseInt-下的数值转换-Number-Conversions-with-parseInt"><a href="#parseInt-下的数值转换-Number-Conversions-with-parseInt" class="headerlink" title="parseInt()下的数值转换(Number Conversions with parseInt())"></a>parseInt()下的数值转换(Number Conversions with parseInt())</h1><p>使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var month = &quot;06&quot;,</div><div class="line">    year = &quot;09&quot;;</div><div class="line">month = parseInt(month, 10);</div><div class="line">year = parseInt(year, 10);</div></pre></td></tr></table></figure><p>此例中，如果你忽略了基数参数，如parseInt(year)，返回的值将是0，因为“09”被当做8进制（好比执行 parseInt( year, 8 )），而09在8进制中不是个有效数字。</p><p>替换方法是将字符串转换成数字，包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+&quot;08&quot; // 结果是 8</div><div class="line">Number(&quot;08&quot;) // 8</div></pre></td></tr></table></figure><p>这些通常快于parseInt()，因为parseInt()方法，顾名思意，不是简单地解析与转换。但是，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以NaN告终。</p><h1 id="编码规范-Coding-Conventions"><a href="#编码规范-Coding-Conventions" class="headerlink" title="编码规范(Coding Conventions)"></a>编码规范(Coding Conventions)</h1><p>建立和遵循编码规范是很重要的，这让你的代码保持一致性，可预测，更易于阅读和理解。一个新的开发者加入这个团队可以通读规范，理解其它团队成员书写的代码，更快上手干活。</p><p>许多激烈的争论发生会议上或是邮件列表上，问题往往针对某些代码规范的特定方面（例如代码缩进，是Tab制表符键还是space空格键）。如果你是 你组织中建议采用规范的，准备好面对各种反对的或是听起来不同但很强烈的观点。要记住，建立和坚定不移地遵循规范要比纠结于规范的细节重要的多。</p><h1 id="缩进-Indentation"><a href="#缩进-Indentation" class="headerlink" title="缩进(Indentation)"></a>缩进(Indentation)</h1><p>代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。</p><p>一些开发人员更喜欢用tab制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，使用四个空格缩进，这也是JSLint中默认的缩进。</p><p>什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do, while, for, for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function outer(a, b) &#123;</div><div class="line">    var c = 1,</div><div class="line">        d = 2,</div><div class="line">        inner;</div><div class="line">    if (a &gt; b) &#123;</div><div class="line">        inner = function () &#123;</div><div class="line">            return &#123;</div><div class="line">                r: c - d</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125; else &#123;</div><div class="line">        inner = function () &#123;</div><div class="line">            return &#123;</div><div class="line">                r: c + d</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return inner;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="花括号-Curly-Braces"><a href="#花括号-Curly-Braces" class="headerlink" title="花括号{}(Curly Braces)"></a>花括号{}(Curly Braces)</h1><p>花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在in或是for中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。</p><p>想象下你有一个只有一条语句的for循环，你可以忽略花括号，而没有解析的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 糟糕的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1)</div><div class="line">   alert(i);</div></pre></td></tr></table></figure><p>但是，如果，后来，主体循环部分又增加了行代码？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 糟糕的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1)</div><div class="line">   alert(i);</div><div class="line">   alert(i + &quot; is &quot; + (i % 2 ? &quot;odd&quot; : &quot;even&quot;));</div></pre></td></tr></table></figure><p>第二个alert已经在循环之外，缩进可能欺骗了你。为了长远打算，最好总是使用花括号，即时值一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 好的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1) &#123;</div><div class="line">   alert(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>if条件类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 坏</div><div class="line">if (true)</div><div class="line">   alert(1);</div><div class="line">else</div><div class="line">   alert(2);</div><div class="line"></div><div class="line">// 好</div><div class="line">if (true) &#123;</div><div class="line">   alert(1);</div><div class="line">&#125; else &#123;</div><div class="line">   alert(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="左花括号的位置-Opening-Brace-Location"><a href="#左花括号的位置-Opening-Brace-Location" class="headerlink" title="左花括号的位置(Opening Brace Location)"></a>左花括号的位置(Opening Brace Location)</h1><p>开发人员对于左大括号的位置有着不同的偏好——在同一行或是下一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">   alert(&quot;It&apos;s TRUE!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//或</div><div class="line"></div><div class="line">if (true)</div><div class="line">&#123;</div><div class="line">   alert(&quot;It&apos;s TRUE!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript是不挑剔的，当你选择不使用分号结束一行代码时JavaScript会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 警告： 意外的返回值</div><div class="line">function func() &#123;</div><div class="line">   return</div><div class="line">  // 下面代码不执行</div><div class="line">   &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果你希望函数返回一个含有name属性的对象，你会惊讶。由于隐含分号，函数返回undefined。前面的代码等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 警告： 意外的返回值</div><div class="line">function func() &#123;</div><div class="line">   return undefined;</div><div class="line">  // 下面代码不执行</div><div class="line">   &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总之，总是使用花括号，并始终把在与之前的语句放在同一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">   return &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>关于分号注：就像使用花括号，你应该总是使用分号，即使他们可由JavaScript解析器隐式创建。这不仅促进更科学和更严格的代码，而且有助于解决存有疑惑的地方，就如前面的例子显示。</p></blockquote><h1 id="空格-White-Space"><a href="#空格-White-Space" class="headerlink" title="空格(White Space)"></a>空格(White Space)</h1><p>空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在JavaScript中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。</p><p>适合使用空格的地方包括：</p><ul><li>for循环分号分开后的的部分：如<code>for (var i = 0; i &lt; 10; i += 1) {...}</code></li><li>for循环中初始化的多变量(i和max)：<code>for (var i = 0, max = 10; i &lt; max; i += 1) {...}</code></li><li>分隔数组项的逗号的后面：<code>var a = [1, 2, 3];</code></li><li>对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：<code>var o = {a: 1, b: 2};</code></li><li>限定函数参数：<code>myFunc(a, b, c)</code></li><li>函数声明的花括号的前面：<code>function myFunc() {}</code></li><li>匿名函数表达式function的后面：<code>var myFunc = function () {};</code></li></ul><p>使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在<code>+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=</code>等前后都需要空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 宽松一致的间距</div><div class="line">// 使代码更易读</div><div class="line">// 使得更加“透气”</div><div class="line">var d = 0,</div><div class="line">    a = b + 1;</div><div class="line">if (a &amp;&amp; b &amp;&amp; c) &#123;</div><div class="line">    d = a % c;</div><div class="line">    a += d;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反面例子</div><div class="line">// 缺失或间距不一</div><div class="line">// 使代码变得疑惑</div><div class="line">var d = 0,</div><div class="line">    a = b + 1;</div><div class="line">if (a&amp;&amp;b&amp;&amp;c) &#123;</div><div class="line">    d=a % c;</div><div class="line">    a+= d;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后需要注意的一个空格——花括号间距。最好使用空格：</p><ul><li>函数、if-else语句、循环、对象字面量的左花括号的前面({)</li><li>else或while之间的右花括号(})</li></ul><p>空格使用的一点不足就是增加了文件的大小，但是压缩无此问题。</p><blockquote><p>有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。</p></blockquote><h3 id="命名规范-Naming-Conventions"><a href="#命名规范-Naming-Conventions" class="headerlink" title="命名规范(Naming Conventions)"></a>命名规范(Naming Conventions)</h3><p>另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。</p><p>下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。</p><h3 id="以大写字母写构造函数-Capitalizing-Constructors"><a href="#以大写字母写构造函数-Capitalizing-Constructors" class="headerlink" title="以大写字母写构造函数(Capitalizing Constructors)"></a>以大写字母写构造函数(Capitalizing Constructors)</h3><p>JavaScript并没有类，但有new调用的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var adam = new Person();</div></pre></td></tr></table></figure><p>因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。</p><p>命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function MyConstructor() &#123;...&#125;</div><div class="line">function myFunction() &#123;...&#125;</div></pre></td></tr></table></figure><h1 id="分隔单词-Separating-Words"><a href="#分隔单词-Separating-Words" class="headerlink" title="分隔单词(Separating Words)"></a>分隔单词(Separating Words)</h1><p>当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。</p><p>对于构造函数，可以使用大驼峰式命名法(upper camel case)，如<code>MyConstructor()</code>。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是<code>myFunction(), calculateArea()</code>和<code>getFirstName()</code>。</p><p>要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，<code>first_name, favorite_bands,</code>和<code>old_company_name</code>，这种标记法帮你直观地区分函数和其他标识——原型和对象。</p><p>ECMAScript的属性和方法均使用Camel标记法，尽管多字的属性名称是罕见的（正则表达式对象的lastIndex和ignoreCase属性）。</p><h1 id="其它命名形式-Other-Naming-Patterns"><a href="#其它命名形式-Other-Naming-Patterns" class="headerlink" title="其它命名形式(Other Naming Patterns)"></a>其它命名形式(Other Naming Patterns)</h1><p>有时，开发人员使用命名规范来弥补或替代语言特性。</p><p>例如，JavaScript中没有定义常量的方法（尽管有些内置的像Number, MAX_VALUE），所以开发者都采用全部单词大写的规范来命名这个程序生命周期中都不会改变的变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 珍贵常数，只可远观</div><div class="line">var PI = 3.14,</div><div class="line">    MAX_WIDTH = 800;</div></pre></td></tr></table></figure><p>还有另外一个完全大写的惯例：全局变量名字全部大写。全部大写命名全局变量可以加强减小全局变量数量的实践，同时让它们易于区分。</p><p>另外一种使用规范来模拟功能的是私有成员。虽然可以在JavaScript中实现真正的私有，但是开发者发现仅仅使用一个下划线前缀来表示一个私有属性或方法会更容易些。考虑下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    getName: function () &#123;</div><div class="line">        return this._getFirst() + &apos; &apos; + this._getLast();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    _getFirst: function () &#123;</div><div class="line">        // ...</div><div class="line">    &#125;,</div><div class="line">    _getLast: function () &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在此例中，<code>getName()</code>就表示公共方法，部分稳定的API。而<code>_getFirst()</code>和<code>_getLast()</code>则表明了私有。它们仍然是正常的公共方法，但是使用下划线前缀来警告person对象的使用者这些方法在下一个版本中时不能保证工作的，是不能直接使用的。注意，JSLint有些不鸟下划线前缀，除非你设置了noman选项为:false。</p><p>下面是一些常见的_private规范：</p><ul><li>使用尾下划线表示私有，如name<em>和getElements</em>()</li><li>使用一个下划线前缀表_protected（保护）属性，两个下划线前缀表示__private （私有）属性</li><li>Firefox中一些内置的变量属性不属于该语言的技术部分，使用两个前下划线和两个后下划线表示，如：<strong>proto</strong>和<strong>parent</strong>。</li></ul><h1 id="注释-Writing-Comments"><a href="#注释-Writing-Comments" class="headerlink" title="注释(Writing Comments)"></a>注释(Writing Comments)</h1><p>你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。</p><p>很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。</p><blockquote><p>最重要的习惯，然而也是最难遵守的，就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。</p></blockquote><h1 id="关于作者（About-the-Author-）"><a href="#关于作者（About-the-Author-）" class="headerlink" title="关于作者（About the Author ）"></a>关于作者（About the Author ）</h1><p>Stoyan Stefanov是Yahoo!web开发人员，多个O’Reilly书籍的作者、投稿者和技术评审。他经常在会议和他的博客<a href="http://www.zhangxinxu.com/wordpress/2010/10/%e7%bf%bb%e8%af%91-%e9%ab%98%e8%b4%a8%e9%87%8fjavascript%e4%bb%a3%e7%a0%81%e4%b9%a6%e5%86%99%e5%9f%ba%e6%9c%ac%e8%a6%81%e7%82%b9/www.phpied.com" target="_blank" rel="noopener">www.phpied.com</a>上发表web开发主题的演讲。Stoyan还是smush.it图片优化工具的创造者，YUI贡献者，雅虎性能优化工具YSlow 2.0的架构设计师。</p><p>本文转自：<a href="http://www.zhangxinxu.com/wordpress/?p=1173" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=1173</a></p><p>英文原文：<a href="http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/" target="_blank" rel="noopener">http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/</a></p><h1 id="同步与结束语"><a href="#同步与结束语" class="headerlink" title="同步与结束语"></a>同步与结束语</h1><p>本文已同步至目录索引：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">深入理解JavaScript系列</a></p><p>深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:深入理解JavaScript系列（1）编写高质量JavaScript代码的基本要点&lt;br&gt;date:2018-3-9&lt;/p&gt;
&lt;h2 id=&quot;categories-JavaScript&quot;&gt;&lt;a href=&quot;#categories-JavaScript&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx的安装</title>
    <link href="http://www.maksim.website/2018/02/27/cjek2dcr8001byvrdbdlms35j/"/>
    <id>http://www.maksim.website/2018/02/27/cjek2dcr8001byvrdbdlms35j/</id>
    <published>2018-02-26T16:00:00.000Z</published>
    <updated>2018-02-27T14:04:44.098Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。</p><p>在安装 Nginx 时，我们可以通过以下两种方式进行安装：</p><ol><li>使用包管理器安装 Nginx</li><li>通过源代码安装 Nginx</li></ol><h2 id="使用包管理器安装-Nginx"><a href="#使用包管理器安装-Nginx" class="headerlink" title="使用包管理器安装 Nginx"></a>使用包管理器安装 Nginx</h2><p>使用包管理器安装 Nginx 的机会，是你使用的操作系统已经提供了 Nginx 的安装包。使用包管理器安装 Nginx 的方式很简单，只需要在终端输入：</p><p>Linux(基于 deb，如 Ubunut)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure><p> Linux（基于 rpm，如 CentOS)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>FreeBSD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pkg_install -r nginx</div></pre></td></tr></table></figure><p>通过上述命令，Nginx 将会安装到操作系统的标准位置下。如果使用操作系统的安装包安装 Nginx，那么通过上面的命令来安装是最佳方式。</p><p>Nginx 核心团队也提供了稳定的二进制版本，可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 页面下载可用版本。未发布 Nginx 安装包的系统用户（例如，CentOS），可以使用下面指导来安装预测试、预编译二进制版本。</p><p>通过创建下面的文件，在系统中添加 Nginx 仓库的 yum 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/yum.repos.d/nginx.repo</div><div class="line">[nginx]</div><div class="line">name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure><p>然后，听过执行如下命令来安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>也可以按照前面介绍的 URL 下载 nginx 发行版安装。</p><h2 id="从源代码安装-Nginx"><a href="#从源代码安装-Nginx" class="headerlink" title="从源代码安装 Nginx"></a>从源代码安装 Nginx</h2><p>Nginx 代码提供了两种独立的下载分支——开发版与稳定版。开发分支是一个正处于积极开发状态的版本。在这个版本中，会有一些新功能被集成到其中，在稳定版中是找不到这些功能的。当发布一个“开发”版时，它会经历同样的 QA 和作为稳定版本的一组类似测试功能。因此无论哪一个分支都一颗用于生产环境中，两者主要的不同，在于对第三方模块的支持。在开发板中，内部的 API 可能会发生改变，而稳定版则保持不变。因此，为了与第三方模块向下兼容，在稳定版中第三方模块都可以有效使用。</p><h3 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h3><p>为了从源代码编译 Nginx，系统需要满足某些必要条件，除了编译器外，如果想分别启用 SSL 支持和使用 rewrite 模块，那么还需要提供响应的 OpenSSL 与 PCRE（Perl Compatible Regular Expressions）库及开发头文件。rewrite 模块是默认安装的。如果你还没有 PCRE 库与开发头文件，你需要在配置阶段禁用 rewrite 模块。这依赖于系统，也有可能在系统中已经默认安装了这些必要条件。如果没有安装，则需要从其安装包安装或者从源码下载并且解压安装，在 Nginx 配置脚本中指定他们在系统中的安装位置。</p><p>如果在配置文件中使用了—with-\<library\>=\<path\>选项，那么 Nginx 会视图建立一个静态依赖库。如果你想让 Nginx 不依赖于系统的任何其他部分，或是想获得些 Nginx 的二进制额外性能，那么你可能会使用构建静态库的做法。如果你使用外部库功能只能从某一个版本起有效（例如，NPN[Next Protocol Negotiation]TLS扩展从 OpenSSL1.0.1版有效），那么你就不得不将其指定到特定版本解压后的源代码路径中。</path\></library\></p><p>根据自己的喜好，你可能会提供其他的、可选安装包。你可以为这些安装包提供支持。他们包括 MD5和 SHA-1以支持散列算法、zip 压缩库、libatomic 库。在 Nginx 中，很多地方法会用到散列库，例如为了计算 URI 散列进而计算缓存 key。</p><p>zlib 压缩裤被用来投递 gzip 压缩内容。如果 atomic_ops 库有效，那么 Nginx 会用它来实现自动内存更新操作，以实现高性能的内存锁定代码。</p><h3 id="从源代码编译"><a href="#从源代码编译" class="headerlink" title="从源代码编译"></a>从源代码编译</h3><p>读者可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载 Nginx，在该页面找到.tar.gz 或者.zip 格式的源代码分支，安装如下步骤将下载的安装包解压到一个临时目录中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir ~/bulid</div><div class="line"><span class="meta">$</span> cd ~/bulid &amp;&amp; tar xzf nginx-&lt;version-number&gt;.tar.gz</div></pre></td></tr></table></figure><p>使用下面命令配置 Nginx:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cd ~/bulid/nginx-&lt;version-number&gt; &amp;&amp; ./configure</div></pre></td></tr></table></figure><p>然后，使用下面命令进行编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> make &amp;&amp; sudo make install</div></pre></td></tr></table></figure><p>在编译自己的二进制 nginx 时，你会有很大的灵活性来包含你仅使用的功能。你已经指定使用哪个用户运行 Nginx 了吗?你要使用默认的 logfile 位置，以便不用在 Nginx 的配置文件明确地说明它们吗?表 1-1 所示是配置选项列表，通过它来帮助你设计出自己的 nginx 命令。这些选项对 Nginx 都是有效的，模块可以被独立激活。</p><table><thead><tr><th>选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td>–prefix=\<path\></path\></td><td style="text-align:left">Nginx 安装的根路径，所有其他的安装路径都要依赖于该选项</td></tr><tr><td>–sbin-path=\<path\></path\></td><td style="text-align:left">指定 Nginx 二进制文件的路径。如果没有指定，那么这个路径依赖于——prefix 选项</td></tr><tr><td>–conf-path=\<path\></path\></td><td style="text-align:left">如果在命令行没有指定配置文件，那么将会通过这里指定的路径，Nginx 将会去那里寻找它的配置文件</td></tr><tr><td>–error-log-path=\<path\></path\></td><td style="text-align:left">指定错误文件的路径，Nginx 会将其中写入错误日志文件，除非有其他配置</td></tr><tr><td>–pid-path=\<path\></path\></td><td style="text-align:left">指定的文件将会写入 Nginx master 进程的pid，通常在/var/run 下</td></tr><tr><td>–lock-path=\<path\></path\></td><td style="text-align:left">共享存储器互斥锁文件的路径</td></tr><tr><td>–user=\<user\></user\></td><td style="text-align:left">worker 进程运行的用户</td></tr><tr><td>–group=\<group\></group\></td><td style="text-align:left">worker 进程运行的组</td></tr><tr><td>–with-file-aio</td><td style="text-align:left">为 FreeBSD4.3+和 Linux2.6.22+系统启用异步 I/O</td></tr><tr><td>–with-debug</td><td style="text-align:left">这个选项用于启用调试日志。在生产环境中不推荐使用该选项。</td></tr></tbody></table><p>你可以使用优化编译，单但是如果使用包管理工具进行安装将无法获得这些优化，如下表：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–with-cc=\<path\></path\></td><td>如果想设置一个不再默认 Path 下的编译器</td></tr><tr><td>–with-cpp=\<path\></path\></td><td>设置 C 预处理器的响应路径</td></tr><tr><td>–with-cc-opt=\<options></options></td><td>指定必要的 include 文件路径，可能（-I\<path\>）指出，也可能是优化(-O4)并指定64位构建</path\></td></tr><tr><td>–with-ld-opt=\<options\></options\></td><td>包含连接器库的路径(-L\<path\>)和运行路径(-R\<path\>)</path\></path\></td></tr><tr><td>—with-cpu-opt=\<cpu\></cpu\></td><td>通过该选项为特定的 CPU 构建 Nginx</td></tr></tbody></table><h2 id="配置-SSL-支持"><a href="#配置-SSL-支持" class="headerlink" title="配置 SSL 支持"></a>配置 SSL 支持</h2><p>对于 TLS/SSL 协议，Nginx 使用 OpenSSL 项目。有关此开源工具包的更多信息，请访问 <a href="https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对" target="_blank" rel="noopener">https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对</a> SSL 的支持。如果使用不带–with-ssl 选项的–with-http_ssl_module 或者–with-mail_ssl_module，你正在使用执行了 configure 命令的、安装在计算机上的 OpenSSL 库。如果你想要针对特定版本的 OpenSSL 进行编译，请下载该分发包，将其解压缩到一个目录中，然后将该目录的路径指定为–with-openssl 的参数。使用–with-openssl-opt 选项为 OpenSSL本身指定额外的构建选项。</p><p>例如，为了使用具有优化椭圆曲线的 OpenSSL 来构建 Nginx，您将使用如下的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ./configure --with-http_ssl_module --with-openssl=$&#123;BUILD_DIR&#125;/openssl-1.0.1p --with-openssl-opt=enable-ec_nistp_64_gcc_128</div></pre></td></tr></table></figure><h2 id="查找并安装第三方模块"><a href="#查找并安装第三方模块" class="headerlink" title="查找并安装第三方模块"></a>查找并安装第三方模块</h2><p>由于有多个开源项目，所以在 Nginx 周围就会有一个活跃的开发社区。由于 Nginx 的模块化特性，这个社区能够开发和发布模块，从而为 Nginx 提供额外的功能。它们涵盖了广泛的应用，所以着手开发自己的模块之前应该看看有什么可用模块。</p><p>安装第三方模块的过程相当简单，步骤如下。</p><p>1.定位你想要使用的模块(在 <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 或者是 <a href="http://wiki.nginx.org/3rdPartyModules查找)。" target="_blank" rel="noopener">http://wiki.nginx.org/3rdPartyModules查找)。</a></p><p>2.下载该模块。</p><p>3.解压缩源代码安装包。</p><p>4.如果有 README 文件，那么阅读 README 文件，查看在安装中是否有依赖安装。</p><p>5.通过./configure–add-module=\<path\>选项配置使用该模块。</path\></p><p>这个过程会给你的 nginx 二进制文件与模块附加这个功能。</p><p>需要注意的是，很多第三方模块是实验性质的。因此，在将这些模块用于生产系统之前，首先要测试使用这些模块。另外请记住，Nginx 的开发版本中可能会有 API 的变化，会导致第三方模块出现问题。</p><h2 id="添加对-Lua-的支持"><a href="#添加对-Lua-的支持" class="headerlink" title="添加对 Lua 的支持"></a>添加对 Lua 的支持</h2><p>特别应该提到的是 ngx_lua 这个第三方模块，ngx_lua 模块提供了启用 Lua 的功能，而不是像 Perl 一样在配置时嵌入式脚本语言。该模块对于 perl 模块来说最大的优点就是它的无阻塞性，并与其他第三方模块紧密集成。对于它的安装说明的完整描述详见:<a href="https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过编译你自己的二进制文件，你可以定制 Nginx能够为你提供哪些功能。对于你来说，构建和安装软件应该不会陌生。所以，创造一个构建环境或者确保所有依赖关系都存在，这并不会花费你很多的时间。一个 Nginx 的安装应该是按照你的需要，能随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。</p><p>参考资料：</p><p>《精通 Nginx》第二版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。&lt;/p&gt;
&lt;p&gt;在安装 Nginx 时，我们可
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>function与感叹号</title>
    <link href="http://www.maksim.website/2018/02/01/cjek2dcso0030yvrdq24ai47x/"/>
    <id>http://www.maksim.website/2018/02/01/cjek2dcso0030yvrdq24ai47x/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-03-09T13:33:02.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="function与感叹号"><a href="#function与感叹号" class="headerlink" title="function与感叹号"></a>function与感叹号</h1><p>最近有空可以让我静下心来看看各种代码，function与感叹号的频繁出现，让我回想起2个月前我回杭州最后参加团队会议的时候，<a href="http://weibo.com/exqy" target="_blank" rel="noopener">@西子剑影</a>抛出的一样的问题：<strong>如果在function之前加上感叹号 (!) 会怎么样</strong>？比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？</p><p>平时我们可能对添加括号来调用匿名函数的方式更为习惯：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>虽然上述两者括号的位置不同，不过效果完全一样。</p><p>那么，是什么好处使得为数不少的人对这种叹号的方式情有独钟？如果只是为了节约一个字符未免太没有必要了，这样算来即使一个100K的库恐怕也节省不了多少空间。既然不是空间，那么就是说也许还有时间上的考量，事实很难说清，文章的最后有提到性能。</p><p>回到核心问题，为什么能这么做？甚至更为核心的问题是，为什么必须这么做？</p><p>其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是<strong>让一个函数声明语句变成了一个表达式</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// SyntaxError: unexpected_token</span></div></pre></td></tr></table></figure><p>因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 <code>a</code>，就应该以 <code>a();</code> 的方式调用。</p><p>但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。</p><p>所以，<strong>任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别</strong>。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">10</span>&#125;();        <span class="comment">// undefined</span></div><div class="line"><span class="number">1</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;();        <span class="comment">// true</span></div><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;();        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些<strong>一元运算都是有效的</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// -1</span></div></pre></td></tr></table></figure><p>甚至下面这些关键字，都能很好的工作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// undefined</span></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// Object</span></div><div class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// undefined</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。</p><p>最后讨论下性能。我在jsperf上简单建立了一个测试：<a href="http://jsperf.com/js-funcion-expression-speed" target="_blank" rel="noopener">http://jsperf.com/js-funcion-expression-speed</a> ，可以用不同浏览器访问，运行测试查看结果。我也同时将结果罗列如下表所示（由于我比较穷，测试配置有点丢人不过那也没办法：奔腾双核1.4G，2G内存，win7企业版）：</p><table><thead><tr><th>Option</th><th>Code</th><th>Ops/sec</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Chrome 13</td><td>Firefox 6</td><td>IE9</td><td>Safari 5</td><td></td><td></td></tr><tr><td>!</td><td>!function(){;}()</td><td>3,773,196</td><td>10,975,198</td><td>572,694</td><td>2,810,197</td></tr><tr><td>+</td><td>+function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,812,238</td></tr><tr><td>-</td><td>-function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,864,155</td></tr><tr><td>~</td><td>~function(){;}()</td><td>3,551,136</td><td>3,651,652</td><td>572,694</td><td>1,876,002</td></tr><tr><td>(1)</td><td>(function(){;})()</td><td>3,914,953</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>(2)</td><td>(function(){;}())</td><td>4,075,201</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>void</td><td>void function(){;}()</td><td>4,030,756</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>new</td><td>new function(){;}()</td><td>619,606</td><td>299,100</td><td>407,104</td><td>816,903</td></tr><tr><td>delete</td><td>delete function(){;}()</td><td>4,816,225</td><td>12,135,960</td><td>572,694</td><td>2,693,524</td></tr><tr><td>=</td><td>var i = function(){;}()</td><td>4,984,774</td><td>12,135,960</td><td>565,982</td><td>2,602,630</td></tr><tr><td>&amp;&amp;</td><td>1 &amp;&amp; function(){;}()</td><td>5,307,200</td><td>4,393,486</td><td>572,694</td><td>2,565,645</td></tr><tr><td>\</td><td>\</td><td></td><td>0 \</td><td>\</td><td>function(){;}()</td><td>5,000,000</td><td>4,406,035</td><td>572,694</td><td>2,490,128</td></tr><tr><td>&amp;</td><td>1 &amp; function(){;}()</td><td>4,918,209</td><td>12,135,960</td><td>572,694</td><td>1,705,551</td></tr><tr><td>\</td><td></td><td>1 \</td><td>function(){;}()</td><td>4,859,802</td><td>12,135,960</td><td>572,694</td><td>1,612,372</td></tr><tr><td>^</td><td>1 ^ function(){;}()</td><td>4,654,916</td><td>12,135,960</td><td>572,694</td><td>1,579,778</td></tr><tr><td>,</td><td>1, function(){;}()</td><td>4,878,193</td><td>12,135,960</td><td>572,694</td><td>2,281,186</td></tr></tbody></table><p>可见不同的方式产生的结果并不相同，而且，差别很大，因浏览器而异。</p><p>但我们还是可以从中找出很多共性：<strong>new方法永远最慢</strong>——这也是理所当然的。其它方面很多差距其实不大，但有一点可以肯定的是，感叹号并非最为理想的选择。反观<strong>传统的括号，在测试里表现始终很快</strong>，在大多数情况下比感叹号更快——所以平时我们常用的方式毫无问题，甚至可以说是最优的。<strong>加减号在chrome表现惊人</strong>，而且在其他浏览器下也普遍很快，相比感叹号效果更好。</p><p>当然这只是个简单测试，不能说明问题。但有些结论是有意义的：括号和加减号最优。</p><p>但是为什么这么多开发者钟情于感叹号？我觉得这只是一个习惯问题，它们之间的优劣完全可以忽略。一旦习惯了一种代码风格，那么这种约定会使得程序从混乱变得可读。如果习惯了感叹号，我不得不承认，它比括号有更好的可读性。我不用在阅读时留意括号的匹配，也不用在编写时粗心遗忘——</p><p>当我也这么干然后嚷嚷着这居然又节省了一个字符而沾沾自喜的时候，却忘了自己仓皇翻出一本卷边的C语言教科书的窘迫和荒唐……任何人都有忘记的时候，当再捡起来的时候，捡起的就已经不单单是忘掉的东西了。</p><p>2011-10-31更新：如果你使用aptana，那么在使用（!+-）时要注意一点，它们会让aptana的解析失效，导致Outline窗口没有任何显示。但是就代码本身而言，其运行没有任何问题。</p><blockquote><p>本文转自扩葵中剑的博客</p><p>原文地址：<a href="https://swordair.com/function-and-exclamation-mark/" target="_blank" rel="noopener">https://swordair.com/function-and-exclamation-mark/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;function与感叹号&quot;&gt;&lt;a href=&quot;#function与感叹号&quot; class=&quot;headerlink&quot; title=&quot;function与感叹号&quot;&gt;&lt;/a&gt;function与感叹号&lt;/h1&gt;&lt;p&gt;最近有空可以让我静下心来看看各种代码，function与感叹
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.maksim.website/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>创建型设计模式之抽象工厂</title>
    <link href="http://www.maksim.website/2018/01/10/cjek2dcue004zyvrd6djbqjmr/"/>
    <id>http://www.maksim.website/2018/01/10/cjek2dcue004zyvrd6djbqjmr/</id>
    <published>2018-01-10T12:44:02.000Z</published>
    <updated>2018-03-09T14:29:03.542Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://designpatternsphp.readthedocs.io" target="_blank" rel="noopener">http://designpatternsphp.readthedocs.io</a></p><p>在软件工程中，创建型设计模式承担着对象创建的职责，尝试创建适合程序上下文的对象，对象创建设计模式的产生是由于软件工程设计的问题，具体说是向设计中增加复杂度，创建型设计模式解决了程序设计中对象创建的问题。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>创建一系列互相关联或依赖的对象时不需要指定将要创建的对象对应的类，因为这些将被创建的对象对应的类都实现了同一个接口。抽象工厂的使用者不需要关心对象的创建过程，它只需要知道这些对象是如何协调工作的。</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="http://designpatternsphp.readthedocs.io/zh_CN/latest/_images/uml12.png" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在 <a href="https://github.com/domnikl/DesignPatternsPHP/tree/master/Creational/AbstractFactory" target="_blank" rel="noopener">GitHub</a> 上查看代码</p><p>AbstractFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * In this case, the abstract factory is a contract for creating some components</div><div class="line"> * for the web. There are two ways of rendering text: HTML and JSON</div><div class="line"> */</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JsonFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonText($content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HtmlFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HtmlText($content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Text.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> string</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> $text;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $text)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;text = $text;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JsonText.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonText</span> <span class="keyword">extends</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// do something here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HtmlText.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlText</span> <span class="keyword">extends</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// do something here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">Tests</span>;</div><div class="line"></div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">HtmlFactory</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">HtmlText</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">JsonFactory</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">JsonText</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanCreateHtmlText</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $factory = <span class="keyword">new</span> HtmlFactory();</div><div class="line">        $text = $factory-&gt;createText(<span class="string">'foobar'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertInstanceOf(HtmlText::class, $text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanCreateJsonText</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $factory = <span class="keyword">new</span> JsonFactory();</div><div class="line">        $text = $factory-&gt;createText(<span class="string">'foobar'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertInstanceOf(JsonText::class, $text);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;http://designpatternsphp.readthedocs.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://designpatternsphp.readthedocs.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>cookie, sessionStorage和localStorage的区别</title>
    <link href="http://www.maksim.website/2018/01/05/3/"/>
    <id>http://www.maksim.website/2018/01/05/3/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-01-07T10:42:39.757Z</updated>
    
    <content type="html"><![CDATA[<p>在HTML5出来之前，只有cookie作为本地存储的一个方法（JavaScript Web API）。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li>本身用于客户端和服务器端通信的，</li><li>但是它有本地存储的功能， 于是被“借用”</li><li>使用document.cookie = … 获取和修改即可，用起来特别麻烦</li></ul><p>缺点：</p><ul><li>存储量太小，只有4kb</li><li>所有http请求都带着，会影响获取资源的效率，所以cookie只适合保存很小的数据，如会话标识</li><li>API简单，需要封装才能用document.cookie = …</li><li><p>有效时长根据设定的过期时间而定。</p><p>​</p></li></ul><h2 id="sessionStorage-和localStorage"><a href="#sessionStorage-和localStorage" class="headerlink" title="sessionStorage 和localStorage"></a>sessionStorage 和localStorage</h2><ul><li>HTML5专门为存储而设计，因为不需要像服务端发送数据，所以最大容量5M</li><li>API简单易用：</li><li>localStorage.setItem(key, value); localStorage.getItem(key)</li><li>sessionStorage当关闭浏览器后便会被清除，localStorage则不会，即使关闭浏览器localStorage也会一直存在，直到删除</li><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的</li><li>在iOS Safari 隐匿模式下，localStorage.getItem会报错，建议同一使用try-catch</li><li>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在HTML5出来之前，只有cookie作为本地存储的一个方法（JavaScript Web API）。&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.maksim.website/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>DOM本质</title>
    <link href="http://www.maksim.website/2018/01/05/1/"/>
    <id>http://www.maksim.website/2018/01/05/1/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-01-07T10:42:36.852Z</updated>
    
    <content type="html"><![CDATA[<p>抛出问题!</p><ul><li>DOM是那种基本的数据结构？</li><li>DOM操作的常用API都有哪些？</li><li>DOM节点的attr和property有何区别？</li></ul><p>解答问题:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">other</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">other</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="DOM本质"><a href="#DOM本质" class="headerlink" title="DOM本质"></a>DOM本质</h2><p>上面的代码是一段XML，这是一个结构化语言，跟它其同样作用的还有JSON，他们可以用于描述一切可以结构化的数据。</p><p>这段代码快描述了一封信，to收件人，from 来源，title标题，body内容。</p><p>DOM本质上是一个树形结构。我们可以将其理解为，浏览器把拿到的HTML代码，结构化成一个浏览器能够识别且能被js操作的一个模型。</p><p>我们知道HTML本质上就是字符串，计算机处理字符串是一件相当头疼的一件事情，通过DOM，我们就可以将HTML文件抽象成一个树形结构，只要是结构化的数据，计算机处理起来，无论你的逻辑结构有多复杂，他都能够轻松的进行处理。</p><h2 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>) <span class="comment">//元素 </span></div><div class="line"><span class="keyword">var</span> divList = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>) <span class="comment">//集合</span></div><div class="line"><span class="built_in">console</span>.log(divList.length)</div><div class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="keyword">var</span> containerList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'.container'</span>);  <span class="comment">//集合</span></div><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>) <span class="comment">//集合</span></div></pre></td></tr></table></figure><p>上面的代码都是JavaScript的基础API，有的人可能用jQuery或其他的的库时间长了，就把基础API给忘了，或者是基础并不是很牢，一直都在用库，这样的话最好将基础补齐，因为在面试的时候，大多数的面试题都是问的基础。</p><p>在面试的时候有个技巧，不要轻易的撩起用的熟，但是不知道实现原理的东西，比如说你会用jQuery的绑定事件，面试官肯定会问你实现原理。</p><h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</div><div class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</div><div class="line"><span class="built_in">console</span>.log(p.style.width) <span class="comment">//获取样式</span></div><div class="line">p.style.width = <span class="string">'100px;'</span></div><div class="line"><span class="built_in">console</span>.log(p.className)</div><div class="line">p.className = <span class="string">'p1'</span></div><div class="line"></div><div class="line"><span class="comment">//获取nodeName 和 nodeType</span></div><div class="line"><span class="built_in">console</span>.log(p.nodeName)</div><div class="line"><span class="built_in">console</span>.log(p.nodeType)</div></pre></td></tr></table></figure><p>在这里我们需要知道P是个什么东西，它不就是个DOM节点吗？</p><p>其实它本质上就是一个JS对象。上面我们说过DOM的本质是一个JS可识别可操作的。既然本质上是一个对象，我们就可以操作他的属性，那这些属性都是怎么进去的？</p><p>这是浏览器规定的，W3C就是这么规定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj &#123;<span class="attr">x</span>:<span class="number">100</span>, <span class="attr">y</span>:<span class="number">200</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj.x) <span class="comment">// 100</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>]</div><div class="line">cosnole.log(p.nodeName); <span class="comment">//p</span></div></pre></td></tr></table></figure><h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</div><div class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</div><div class="line">p.getAttribute(<span class="string">'data-name'</span>)</div><div class="line">p.setAttribute(<span class="string">'data-name'</span>, <span class="string">'maksim'</span>)</div><div class="line">p.getAttribute(<span class="string">'style'</span>)</div><div class="line">p.setAttribute(<span class="string">'style'</span>, <span class="string">'font-size:30px;'</span>)</div></pre></td></tr></table></figure><p>我们在上述代码中该的 <code>data-name</code> 和 <code>style</code> 到底是什么呢？</p><p>其实就是HTML文档里的标签，并不是JavaScript里的对象。这也是两者之间的区别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;抛出问题!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM是那种基本的数据结构？&lt;/li&gt;
&lt;li&gt;DOM操作的常用API都有哪些？&lt;/li&gt;
&lt;li&gt;DOM节点的attr和property有何区别？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解答问题:&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.maksim.website/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP基础手札的引用</title>
    <link href="http://www.maksim.website/2017/10/21/cjek2dcrm001syvrdskjl042c/"/>
    <id>http://www.maksim.website/2017/10/21/cjek2dcrm001syvrdskjl042c/</id>
    <published>2017-10-21T10:06:24.000Z</published>
    <updated>2017-10-21T10:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。</p><p>PHP 的指针域这些语言机制相同，即可以用一个变量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。&lt;/p&gt;
&lt;p&gt;PHP 的指针域这些语言机制相同，即可以用一个变量&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2017/10/21/cjek2dcqc0008yvrd7jhyzqbr/"/>
    <id>http://www.maksim.website/2017/10/21/cjek2dcqc0008yvrd7jhyzqbr/</id>
    <published>2017-10-21T09:59:26.000Z</published>
    <updated>2018-01-07T10:50:24.324Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:C语言中的内存<br>categories:C/C++<br>date:2017-10-21</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p> C 程序在编译后，会以三种形式使用内存。</p><ul><li><p>静态变量/全局内存</p><p>静态声明的变量分配在这里，全局变量也会使用这部分内存。这些内存在程序开始运行时分配，直到程序终止才会消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。</p></li><li><p>自动内存</p><p>这些变量在函数内部声明，并且在函数被调用时才能创建。它们的作用域局限于函数内部，而且在函数被调用才创建。它们的作用域局限于函数内部，热切声明周期限制在函数的执行时间内。</p></li><li><p>动态内存</p><p>内存分派在堆上，可以根据需要存放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:C语言中的内存&lt;br&gt;categories:C/C++&lt;br&gt;date:2017-10-21&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP常见的经典面试题</title>
    <link href="http://www.maksim.website/2017/10/21/2/"/>
    <id>http://www.maksim.website/2017/10/21/2/</id>
    <published>2017-10-20T16:00:00.000Z</published>
    <updated>2017-10-22T04:14:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>常见经典面试题</p><ol><li>什么是引用变量？在 PHP 当中用什么符号定义引用变量？</li><li>要求写出JQuery 中，可以处理AJAX的几种方法。</li><li>写出尽可能多的Linux 命令</li><li>写出三种以上 MySQL数据存储引擎的名字</li><li>编写在线留言本，实现用户的在线留言功能</li><li>谈谈你对 MVC 的认识，介绍几中目前比较流行的MVC 框架</li><li>请写出常见的排序算法</li><li>PHP 如何解决网站大流量与高并发</li></ol><p>1.什么是引用变量？在 PHP 当中用什么符号定义引用变量。</p><ul><li>考官考点： PHP 的引用变量的概念以及定义方式</li><li><strong>延伸：PHP 引用变量的原理</strong></li></ul><p><strong>概念</strong>： 在 PHP 中引用意味着用不同的名字访问同一个变量内容。</p><p><strong>定义方式</strong> ： 使用&amp;符号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见经典面试题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是引用变量？在 PHP 当中用什么符号定义引用变量？&lt;/li&gt;
&lt;li&gt;要求写出JQuery 中，可以处理AJAX的几种方法。&lt;/li&gt;
&lt;li&gt;写出尽可能多的Linux 命令&lt;/li&gt;
&lt;li&gt;写出三种以上 MySQL数据存储
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="面试" scheme="http://www.maksim.website/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP 控制反转、依赖注入、依赖查找服务容器？</title>
    <link href="http://www.maksim.website/2017/10/19/cjek2dcrp001vyvrdog7eufr7/"/>
    <id>http://www.maksim.website/2017/10/19/cjek2dcrp001vyvrdog7eufr7/</id>
    <published>2017-10-18T16:00:00.000Z</published>
    <updated>2017-10-22T04:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>控制反转（Inversion of Control，英文缩写为IoC）是框架的重要特征，并非面向对象编程的专用术语。它与依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）并没有关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;控制反转（Inversion of Control，英文缩写为IoC）是框架的重要特征，并非面向对象编程的专用术语。它与依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）并没有关系。&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="服务容器" scheme="http://www.maksim.website/tags/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>《PHP internals Book》 一本深入PHP 扩展开发的书籍</title>
    <link href="http://www.maksim.website/2017/10/18/10/"/>
    <id>http://www.maksim.website/2017/10/18/10/</id>
    <published>2017-10-17T16:00:00.000Z</published>
    <updated>2018-01-07T10:45:32.198Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家介绍一本 PHP 扩展开发相关的书籍<a href="http://www.phpinternalsbook.com/" target="_blank" rel="noopener">《PHP internals Book》</a>，这本书是几个PHP开发人员之间的协作努力，可以更好地记录和描述PHP内部的工作原理。</p><p>《PHP internals Book》 有三个主要目标：</p><ul><li>记录和描述PHP内部工作原理。</li><li>记录并描述如何使用扩展扩展语言。</li><li>记录并描述如何与社区进行交互以开发PHP本身。</li></ul><p>《PHP internals Book》 主要面向具有C编程语言经验的开发人员。然而，尽管如此，我们将尝试提炼信息并对其进行总结，以便不了解C的开发人员仍然能够理解内容。</p><p>但是，让我们坚持。如果您不知道C语言，您将无法实现高效，稳定（任何平台下的崩溃），性能和实用性。以下是有关C语言本身，生态系统和构建工具以及操作系统API的一些非常好的在线资源：</p><ul><li><a href="http://www.tenouk.com/" target="_blank" rel="noopener">http://www.tenouk.com/</a></li><li><a href="https://en.wikibooks.org/wiki/C_Programming" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/C_Programming</a></li><li><a href="http://c-faq.com/" target="_blank" rel="noopener">http://c-faq.com/</a></li><li><a href="https://www.gnu.org/software/libc/" target="_blank" rel="noopener">https://www.gnu.org/software/libc/</a></li><li><a href="http://www.faqs.org/docs/Linux-HOWTO/Program-Library-HOWTO.html" target="_blank" rel="noopener">http://www.faqs.org/docs/Linux-HOWTO/Program-Library-HOWTO.html</a></li><li><a href="http://www.iecc.com/linker/linker10.html" target="_blank" rel="noopener">http://www.iecc.com/linker/linker10.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天给大家介绍一本 PHP 扩展开发相关的书籍&lt;a href=&quot;http://www.phpinternalsbook.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《PHP internals Book》&lt;/a&gt;，这本书是几个PHP开发人员之间
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP基础解惑： =与==、===的区别</title>
    <link href="http://www.maksim.website/2017/10/18/1/"/>
    <id>http://www.maksim.website/2017/10/18/1/</id>
    <published>2017-10-17T16:00:00.000Z</published>
    <updated>2017-10-18T13:19:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先等于号（=）在大多数语言中都是赋值操作；</p><p><code>==</code>和<code>===</code>都是比较运算符，用来比较两个变量间的关系，他们两个都有“等于”的含义，不过<code>===</code>是恒等计算符。两侧数据类型不一致时会返回 false，在官方文档中给出如下：</p><p><code>==</code>如果两侧的变量类型不同时，会转化类型后在进行比较。</p><table><thead><tr><th>例子</th><th>名称</th><th>结果</th></tr></thead><tbody><tr><td>$a == $b</td><td>等于</td><td><strong>TRUE</strong>，如果类型转换后 $a 等于 $b。</td></tr><tr><td>$a === $b</td><td>全等</td><td><strong>TRUE</strong>，如果 $a 等于 $b，并且它们的类型也相同。</td></tr></tbody></table><p>上表摘自 PHP 手册。下面来看一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">   $age = <span class="number">18</span>;</div><div class="line">   var_dump($age == <span class="number">18</span>)l    <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age === <span class="number">18</span>);   <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age == <span class="string">'18'</span>);  <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age === <span class="string">'18'</span>); <span class="comment">//bool(false)</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先等于号（=）在大多数语言中都是赋值操作；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;===&lt;/code&gt;都是比较运算符，用来比较两个变量间的关系，他们两个都有“等于”的含义，不过&lt;code&gt;===&lt;/code&gt;是恒等计算符。两侧数据类型不一致时会返回 f
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="PHP基础" scheme="http://www.maksim.website/tags/PHP%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP页面静态化</title>
    <link href="http://www.maksim.website/2017/10/16/cjek2dcry0027yvrdckr6t5y4/"/>
    <id>http://www.maksim.website/2017/10/16/cjek2dcry0027yvrdckr6t5y4/</id>
    <published>2017-10-16T11:17:47.000Z</published>
    <updated>2017-10-16T11:30:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h1><p>要了解静态化页面，首先我们就要知道什么是页面？</p><p>一、静态web页面：</p><p>1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。</p><p>2、为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。</p><p>3、静态web无法连接数据库；</p><p>4、静态web资源开发技术：HTML；</p><p>5、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。</p><p>二、动态web页面：</p><p>动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。</p><p>如果客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</p><p>如果客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</p><p>#静态化</p><p>PHP静态化分为：纯静态化 和 伪静态化；纯静态化又分为：局部静态化 和 完全静态化</p><p>纯静态化：是把PHP生成的动态页面保存成静态的html文件，用户访问该静态页面，而不是用户每一次访问都重新生成一张相同的网页，优点就是减小服务器开销，</p><ul><li>局部静态化：是生成的静态文件中，有局部的数据还是通过ajax技术动态获取的；</li><li>完全静态化：即不存在动态获取数据的情况，所以内容都来自静态的html页面</li></ul><p>伪静态化：其实还是动态访问，其实质是动态生成数据，你访问的网址类似于”<a href="http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化" target="_blank" rel="noopener">http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化</a></p><p>　　伪静态的优点：美观；便于搜索引擎收录</p><p>buffer 概括</p><p>buffer 其实就是缓冲区，一个内存地址空间，主要是用于存储数据的区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于页面&quot;&gt;&lt;a href=&quot;#关于页面&quot; class=&quot;headerlink&quot; title=&quot;关于页面&quot;&gt;&lt;/a&gt;关于页面&lt;/h1&gt;&lt;p&gt;要了解静态化页面，首先我们就要知道什么是页面？&lt;/p&gt;
&lt;p&gt;一、静态web页面：&lt;/p&gt;
&lt;p&gt;1、在静态Web程序中，客
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP基础解惑：省略结束标签</title>
    <link href="http://www.maksim.website/2017/10/16/1/"/>
    <id>http://www.maksim.website/2017/10/16/1/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2018-03-09T13:13:44.475Z</updated>
    
    <content type="html"><![CDATA[<p>对于PHP编译器来说，脚本的结束标签<code>?&gt;</code>是可选的，在写程序时你可以忽略它。你或许碰见过：在使用include()、require()或输入输出缓冲函数时，页面顶部有时会多空行或者出现<code>“header had send”</code>之类的错误信息，这类问题与结束标签有关。</p><p>省略结束标签适合纯PHP文件。如果是PHP与HTML混合开发，则不可省略。</p><p>忽略结束标签不仅能少些两个字符，而且可以使得我们开发的过程更加顺利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于PHP编译器来说，脚本的结束标签&lt;code&gt;?&amp;gt;&lt;/code&gt;是可选的，在写程序时你可以忽略它。你或许碰见过：在使用include()、require()或输入输出缓冲函数时，页面顶部有时会多空行或者出现&lt;code&gt;“header had send”&lt;/code&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="PHP基础" scheme="http://www.maksim.website/tags/PHP%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP基础手札之emtpy、isset、is_null的区别</title>
    <link href="http://www.maksim.website/2017/10/16/2/"/>
    <id>http://www.maksim.website/2017/10/16/2/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-10-16T01:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>PHP提供了3个用于测试变量值的函数，分别是isset()、empty()、is_null（从这里就可以看出PHP系统函数变量名命名的混乱，这也是一直被人诟病的地方）.这几个函数均返回布尔值，有时使用不当会造成意想不到的结果。</p><p>比如，用isset()和empty()返回的结果是相反的，但却并非一直如此。</p><p>isset()用来检测一个变量是否已声明且值不为null。只能在变量不是null时返回真。</p><p>empty()用来检测一个变量是否为空，也就是说有如下情况时返回真值：变量是一个空字符串，false，空数组,null,’’,以及被unset删除后的变量。</p><blockquote><p>在PHP5.5之后，empty()函数可以接受任意类型的表达式</p></blockquote><p>is_null()函数用来判断变量内容是否是null，即返回真值的条件仅为变量值是null，值得一提的是，is_null() 是 isset() 的反函数，区别是isset()函数可以应用到未知变量，但is_null()只能针对以声明的变量。</p><table><thead><tr><th>对比项</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>变量值($var)</td><td>isset($var)</td><td>empty($var)</td><td>is_null($var)</td></tr><tr><td>“”（空字符串）</td><td>bool(true)</td><td>bool(true)</td><td>bool(false)</td></tr><tr><td>“ “(空格)</td><td>bool(true)</td><td>bool(false)</td><td>bool(false)</td></tr><tr><td>false</td><td>bool(true)</td><td>bool(true)</td><td>bool(false)</td></tr><tr><td>true</td><td>bool(true)</td><td>bool(false)</td><td>bool(false)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PHP提供了3个用于测试变量值的函数，分别是isset()、empty()、is_null（从这里就可以看出PHP系统函数变量名命名的混乱，这也是一直被人诟病的地方）.这几个函数均返回布尔值，有时使用不当会造成意想不到的结果。&lt;/p&gt;
&lt;p&gt;比如，用isset()和empt
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2017/10/15/cjek2dcqs000ryvrdozp28jdn/"/>
    <id>http://www.maksim.website/2017/10/15/cjek2dcqs000ryvrdozp28jdn/</id>
    <published>2017-10-15T11:24:45.000Z</published>
    <updated>2017-10-15T11:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL常用存储引擎之Innodb"><a href="#MySQL常用存储引擎之Innodb" class="headerlink" title="MySQL常用存储引擎之Innodb"></a>MySQL常用存储引擎之Innodb</h1><p>Mysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。</p><p>和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。</p><p>特点：</p><ul><li>灾难恢复性好</li><li>支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的</li><li>使用行级锁</li><li>对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的</li><li>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引</li><li>支持外键</li><li>支持热备份</li></ul><p>Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由<code>innodb_file_per_table</code>这个参数决定。</p><p>如果值为 <code>ON</code>,会为每个 innodb 表建立一个<code>tablename.ibd</code>的系统文件，如果该参数为<code>OFF</code>时会把数据存储到系统的表空间<code>ibdataX</code></p><p>引用</p><p>《打造扛得住的 MySQL》 慕课网</p><p>《高性能 MySQL》</p><p>《My》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;a href=&quot;#MySQL常用存储引擎之Innodb&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;/a&gt;MySQL常用存储引擎之Innodb&lt;/h1&gt;&lt;p&gt;Mysql5
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2017/10/13/cjek2dcqv000wyvrdpu60p7hf/"/>
    <id>http://www.maksim.website/2017/10/13/cjek2dcqv000wyvrdpu60p7hf/</id>
    <published>2017-10-13T08:56:28.000Z</published>
    <updated>2018-02-27T13:04:29.467Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:MySQL服务器参数介绍<br>categories:MySQL<br>date:2017-10-18</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p>人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。</p><p>MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。</p><p>从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。</p><p>##　MySQl获取配置信息路径</p><ul><li>命令行参数 <code>mysqld_safe --datadir=/data/sql_data</code></li><li>配置文件 <code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code></li></ul><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171013153125.png" alt=""></p><p>MySQL会先从<code>/etc/my.cnf</code>文件下读取配置信息，然后是<code>/etc/mysql/my.cnf</code>。</p><p>MySQL配置参数的作用域</p><ul><li>全局参数 <ul><li><code>set global 参数名 = 参数值;</code></li><li><code>set @@global。参数名:=参数值;</code></li></ul></li><li>会话参数<ul><li><code>set [session] 参数名=参数值;</code></li><li><code>set @@session.参数名:=参数值;</code></li></ul></li></ul><p>会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。</p><p>在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。</p><h2 id="内存配置相关参数"><a href="#内存配置相关参数" class="headerlink" title="内存配置相关参数"></a>内存配置相关参数</h2><p>MySQL对于内存的使用我们可以分为两个类来看。</p><ul><li>无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存</li><li>可以通过参数配置控制的，各类的缓冲池所需要的内存。</li></ul><p>对内存参数配置之前，我们需要进行考虑：</p><ul><li>确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。</li><li>确定MySQL的每个连接使用的内存，例如排序缓冲和临时表</li><li><p>把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。</p><ul><li><p>sort_buffer_size</p><ul><li>join_buufer_szie</li><li>read_buffer_size</li><li>read_rnd_buffer_size  </li></ul></li></ul></li></ul><h3 id="确定需要为操作系统保留多少内存"><a href="#确定需要为操作系统保留多少内存" class="headerlink" title="确定需要为操作系统保留多少内存"></a>确定需要为操作系统保留多少内存</h3><p>给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。</p><p>数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。</p><p>另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。</p><h3 id="如何为缓冲池分配内存"><a href="#如何为缓冲池分配内存" class="headerlink" title="如何为缓冲池分配内存"></a>如何为缓冲池分配内存</h3><p>Innodb_buffer_pool_size，Innodb缓冲区</p><p>总内存-（每个线程所需要的内存*连接数）- 系统保留内存</p><p>手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。</p><h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos;</div></pre></td></tr></table></figure><h2 id="I-O相关配置参数"><a href="#I-O相关配置参数" class="headerlink" title="I/O相关配置参数"></a>I/O相关配置参数</h2><p>Innodb I/O相关配置</p><h2 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h2><p><code>expire_logs_days</code> 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:MySQL服务器参数介绍&lt;br&gt;categories:MySQL&lt;br&gt;date:2017-10-18&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2017/10/13/cjek2dctg003yyvrdu41jzbr9/"/>
    <id>http://www.maksim.website/2017/10/13/cjek2dctg003yyvrdu41jzbr9/</id>
    <published>2017-10-13T05:41:58.000Z</published>
    <updated>2017-10-13T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务评估"><a href="#业务评估" class="headerlink" title="业务评估"></a>业务评估</h1><h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ul><li>响应时间（request time）</li><li>数据总量</li><li>每秒请求量</li><li>读写比</li><li>重要程度</li></ul><p><strong>响应时间</strong>是与整个数据库的状态有关，不仅与CPU、数据总量、每秒请求量、读写比以及各种场景都是有关系的。所以说相应时间是一个综合指标。</p><p>对于DBA来说最关心的就是业务的相应时间能不能够满足，在满足的情况下再去优化以下的这些点，才是有意义的。</p><p>数据总量往往需要业务方提供一个一到两年的数据总量，这是因为如果没有数据总量，前期是没有办法规划我们的数据库实例的。当然也有很多的不确定因素，比如互联网行业，比如有的业务会爆发性的增长，这些规划可能是不合理的，但是在我们也要有一个大概的评估，因为这是前期资源申请和资源分配的策略。</p><p>每秒请求量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务评估&quot;&gt;&lt;a href=&quot;#业务评估&quot; class=&quot;headerlink&quot; title=&quot;业务评估&quot;&gt;&lt;/a&gt;业务评估&lt;/h1&gt;&lt;h2 id=&quot;业务需求&quot;&gt;&lt;a href=&quot;#业务需求&quot; class=&quot;headerlink&quot; title=&quot;业务需求&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL体系结构</title>
    <link href="http://www.maksim.website/2017/10/13/1/"/>
    <id>http://www.maksim.website/2017/10/13/1/</id>
    <published>2017-10-12T16:00:00.000Z</published>
    <updated>2017-10-13T11:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库产品的架构一般可以分为应用层、逻辑层、物理层，对于MySQL，同样可以理解为如下3个层次。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/http://images2015.cnblogs.com/blog/676456/201707/676456-20170722164214340-166686649.jpg210050572965263.gif" alt="img"></p><p>其中<code>Connectors</code>可以理解为各种客户端、 应用服务； <code>Connection Pool</code>可以理解为<strong>应用层</strong>，负责和客户端、用户进行交互，需要和不同的客户端（<code>PHP</code>,<code>Java</code>,<code>C API</code>,<code>.Net</code>以及<code>ODBC</code>,<code>JDBC</code>等等）和中间服务器进行交互，这一层主要完成的是链接处理，授权认证，和安全等一些功能，连接到<code>MySQL</code>的客户端在其进程中，都会有一个独立的线程，连接的查询只会在这个登录线程中进行查询。</p><p><code>Management Services&amp;Utilities</code>、<code>SQL Interface</code>、 <code>Parser</code>、 <code>Optimizer</code>、 <code>Caches&amp;Buffers</code>、 <code>Pluggable Storage Engines</code>可以理解为数据库的大脑——<strong>逻辑层</strong>。</p><p>负责具体的查询处理、事务处理、存储管理、恢复管理，以及其他附加功能。查询处理器负责查询的解析、执行。当接收到客户端的查询时，数据库会分配一个县城来处理它。先友查询处理器（优化器）生成执行计划，然后交由计划执行器来执行，执行器有时需要访问更底层的事务管理器、存储管理器来操作数据，事务管理器、存储管理器主要负责事务控制、并发控制、存储管理。在其中，将由事务管理来保证“<code>ACID</code>”特性，通过锁管理器来控制并发，由日志管理器来确保数据持久化，存储故那里器一般还包括一个缓冲管理器，有它来确定磁盘和缓存之间的数据传输。</p><p>根据上面的架构图，我们可以看到在逻辑层中<code>Pluggable Storage Engines</code></p><p>这是MySQL服务逻辑架构中的第三层，是MySQL的存储引擎，MySQL提供出了存储引擎接口，第三方可以根据自己的业务逻辑需求开发自己的存储引擎，Innodb起初就是由Innobase Oy公司所开发，2006年5月被甲骨文公司并购。</p><p>服务器通过API与存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作，但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层和服务的请求。</p><blockquote><p>注意：存储引擎是针对于表的而不是针对于库的，不同的表可以使用不同的引擎；</p></blockquote><p> 最下方的Files&amp;Logs可以理解为物理层，实际物理磁盘（存储）上的数据库文件，比如数据文件、日志文件等等。</p><p>引用：</p><p>《MySQL DBA修炼之道》 作者陈晓勇  出版社：华章图书</p><p>《打造扛得住的MySQL》 电子工业出版社</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库产品的架构一般可以分为应用层、逻辑层、物理层，对于MySQL，同样可以理解为如下3个层次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ogxeww23n.bkt.clouddn.com/http://images2015.cnblogs.com/blog/676
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.maksim.website/categories/MySQL/"/>
    
    
  </entry>
  
</feed>
