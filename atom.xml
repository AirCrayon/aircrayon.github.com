<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maksim&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maksim.website/"/>
  <updated>2018-07-19T00:27:49.921Z</updated>
  <id>http://www.maksim.website/</id>
  
  <author>
    <name>Maksim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 的持久化方案</title>
    <link href="http://www.maksim.website/2018/07/18/cjjthvl4a007uq1rdyt4bvbak/"/>
    <id>http://www.maksim.website/2018/07/18/cjjthvl4a007uq1rdyt4bvbak/</id>
    <published>2018-07-18T14:21:03.590Z</published>
    <updated>2018-07-19T00:27:49.921Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 支持 RDB 和 AOF 两种持久化机制，持久化功能有效地避免因为进程退出造成数据丢失的问题，当下次重启时利用之前持久化的文件即可实现数据恢复。</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB 可以指定时间间隔保存数据快照，这有些类似于数据库表快照性质的，也就是说他隔一段时间就会把数据拍个照片然后保存下来，这也是数据库常用的备份方式，在某一个时间点执行备份 sql 或者是备份目录之类的，出发 RDB 持久化过程分为手动出发和自动触发。</p><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><p>手动出发分别对应 save 和 bgsave 命令：</p><p><strong>save 命令：</strong>阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间堵塞，线上环境不建议使用。运行 save 命令对应的 Redis 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DB saved on disk</div></pre></td></tr></table></figure><p><strong>bgsave 命令：</strong>Redis 执行 fork 进程操作创建子进程，RDB 持久化过程由紫禁城负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。运行 bgsave 命令对应的 Redis 日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Backgroud saving stated by pid 3151</div><div class="line">DB saved on disk</div><div class="line">RDB: 0 MB of memory used by copy-on-write</div><div class="line">Background saving terminated with success</div></pre></td></tr></table></figure><p>显然bgsave 命令是针对 save 阻塞问题做的优化，因此Redis 内部所有涉及 RDB 的操作都采用 bgsave 的方式，而 save 命令已经被废弃了。</p><p>除了手动触发，之外，Redis 内部还存在自动触发 RDB 的持久化机制：</p><ol><li>使用 save 相关配置，如“save m n”表示 m 秒内数据集存在n 此修改时，自动触发bgsave。</li><li>如果从节点执行全量赋值操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点</li><li>执行 debug reload 命令重新加载 Redis 时，也会自动触发 save 操作。</li><li>默认情况下执行 shotdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave</li></ol><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol><li>执行 bgsave 命令，Redis 父进程判断当前是否存在正在执行的子进程，如 RDB/AOF 子进程，如果存在 bgsave 命令则直接返回。</li><li>父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞，通过 info stats 命令查看 latest_fork_usec 选项，可以获取最近一个 fork 操作的耗时，单位为微秒。</li><li>父进程 fork 完成后，bgsave 命令返回“Background saveing started”信息并不再阻塞父进程，可以继续响应其他命令。</li><li>子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行 lastsave 命令可以获取最后一次生成 RDB 的时间，对应 info 统计的 rdb_last_save_time 选项。</li><li>进程发送信号告诉父进程表示完成，父进程更新统计信息，具体见 info Persistence 下的 rdb_*相关选项。</li></ol><p>RDB 文件保存在 dir 配置指定的目录下，文件通过dbfilename 配置指定。可以公国执行 config set dir {newDir}和 config set dbfilename {newFilename} 运行期间动态执行，当下次运行 RDB 文件会保存到新目录上。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>RDB 模式的优点</strong></p><ul><li>适用于进行备份</li><li>fork 出子进程进行备份，主进程没有任何 IO 操作</li><li>恢复大数据集时的速度快</li></ul><p><strong>RDB 模式的优点：</strong></p><ul><li>特定条件下进行一次持久化，易丢失数据</li><li>庞大数据时，保存时会出现性能问题</li></ul><p>相比之下，RDB 模式将时间设置的相对密集了，频繁的备份就会占用较多的资源，但是如果把时间拉的比较远了，万一出问题，就会恢复到上一个时间点，很可能会丢失数据。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF 以独立日志的方式保存所有历史操作命令，当需要回复的时候，会按照之前输入的命令挨个都执行一次，主要作用是解决了数据持久化的实时性，目前已经是 Redis 持久化的主流方式。</p><p>配置方式；</p><blockquote><p> redis.confg: appendonly yes</p></blockquote><p>AOF 默认不开启，AOF 文件名通过 appendfilename 进行培植，默认文件名是 appendonly.aof，保存路径与 RDB 一样，需要通过 dir 配置指定。</p><p>AOF 工作流程：命令写入（append）、文件同步（sync）、文件重写（Write）、重启加载（load）</p><p>在命令写入命令时候，Redis 会将命令追加到 aof_buf(缓冲区中)，然后再根据对应的策略向硬盘做同步操作，随着AOF 文件越来越大，需要定期对 AOF 文件进行重写达到压缩的目的。</p><p>当 Redis 重启时候，可以加载 AOF 文件进行恢复。</p><p>AOF 命令的写入的内容直接是文本协议格式，例如 set hello world 这套命令，在 AOF 缓冲区会追加如下文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*3\r\n$3\rnset\r\n$5\r]nhello\r\n$5\r\nworld\r\n</div></pre></td></tr></table></figure><p>这样有一个好处，文本协议具有可读性，方便直接修改和处理，而且直接采用协议格式，可以避免了二次处理的开销。</p><p>缓冲区同步文件策略：</p><table><thead><tr><th>可配置值</th><th>说明</th></tr></thead><tbody><tr><td>always</td><td>命令写入 aof_buf 后调用系统 fsync 操作同步到 AOF 文件，fsync 完成后线程返回</td></tr><tr><td>everysec</td><td>命令写入 aof_buf 后调用系统 Write 操作，Write 操作完成后县城返回。fsync 同步文件操作由专门线程每秒调用一次。</td></tr><tr><td>no</td><td>命令写入 aof_buf 后调用系统 Write 操作，不对 AOF 文件做 fsync 同步，同步硬盘操作系统由操作系统负责，通常同步周期最长30秒</td></tr></tbody></table><p>系统调用 Write 和 fsync 说明：</p><p>Write 操作会触发延迟写机制，Linux 在内核提供页缓冲区来提高硬盘 IO 性能。Write 操操作在写入系统缓冲区后直接返回，同步硬盘操作依赖于系统调度机制不过同步文件之前，如果此时系统故障宕机，缓冲区内数据将丢失。</p><p>fsync 针对单个文件操作，做强制硬盘同步，fsyn 将阻塞直接写到硬盘完成后返回，保证了数据持久化。</p><h2 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h2><h1 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h1><p><strong>AOF模式的优点</strong></p><ul><li>数据非常完整，故障恢复丢失数据少</li><li>可对历史记录进行处理</li></ul><p><strong>AOF模式的缺点</strong></p><ul><li>把整个操作都记录下来，这也就导致了文件体积较大</li><li>速度低于 RDB 且故障恢复速度慢，如果几十万次或者上百万条记录，要比 RDB 慢上很多。</li></ul><p>这两种模式可以同时开启，但是会优先加载 AOF。但是需要注意，如果想要同时开启，尤其 AOF 模式最好 Redis 比较干净的时候就开启，刚开始的时候，我们用的 RDB 模式进行的备份，而 AOF 模式会从 AOF 的那个时间点开始计算，如果在之前有数据，恢复的时候就会出问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 支持 RDB 和 AOF 两种持久化机制，持久化功能有效地避免因为进程退出造成数据丢失的问题，当下次重启时利用之前持久化的文件即可实现数据恢复。&lt;/p&gt;
&lt;h1 id=&quot;RDB&quot;&gt;&lt;a href=&quot;#RDB&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从简单的示例中入门 Redis 五种常用数据结构</title>
    <link href="http://www.maksim.website/2018/07/17/1/"/>
    <id>http://www.maksim.website/2018/07/17/1/</id>
    <published>2018-07-16T16:00:00.000Z</published>
    <updated>2018-07-19T00:27:53.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><ul><li>简单的 key-value 存储，性能极高</li><li>Redis 拥有更多的数据结构和支持更丰富的数据操作</li><li>Redis 支持数据持久化和数据恢复</li><li>Redis 的所有操作都是原子性的</li><li>服务器支持 AUTH 密码验证</li></ul><h1 id="Redis-和-PHP-组件的依赖关系"><a href="#Redis-和-PHP-组件的依赖关系" class="headerlink" title="Redis 和 PHP 组件的依赖关系"></a>Redis 和 PHP 组件的依赖关系</h1><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180717191043.png" alt=""></p><p>在 Redis 的安装时，有一个配置文件，可以在安装的时候进行详细的配置，安装之后会带一个 cli 命令行的工具，相对而言 Memcached 并没与这样的工具，我们在使用memcached需要使用 telnet，所以 Redis 的命令行要比 Memcache 要好用很多。</p><p>连接方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-cli -h host -p port -a password</div></pre></td></tr></table></figure><p>PHP 如果想要连接 Redis 就必须安装 Redis 扩展。</p><p>在这里就不赘述如何进行安装了，我们可以使用包管理工具或者是编译安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">redis-server</div><div class="line">redis-cli</div><div class="line">set user_1 maksim</div></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$redis = <span class="keyword">new</span> Redis();</div><div class="line">$redis-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>);</div><div class="line"><span class="keyword">echo</span> $redis-&gt;get(<span class="string">'user_1'</span>).PHP_EOL;</div></pre></td></tr></table></figure><p>安装完成后，我们可以测试一下，看看能否正常取到值。</p><h1 id="Redis-常用命令"><a href="#Redis-常用命令" class="headerlink" title="Redis 常用命令"></a>Redis 常用命令</h1><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>DEL</td><td>删除 key</td><td>DEL KEY_NAME</td></tr><tr><td>EXISTS</td><td>检查给定 Key 是否存在</td><td>EXISTS KEY_NAME</td></tr><tr><td>KEYS</td><td>查找所有符合给定模式 pattren 的 key</td><td>KEYS PATTERN</td></tr><tr><td>TYPE</td><td>返回 key 所春初的值的类型</td><td>TYPE KEY_NAME</td></tr><tr><td>EXPIRE</td><td>设置 key 的过期时间</td><td>EXPIRE KEY_NAME TIME_IN_SECONDS</td></tr><tr><td>TTL</td><td>返回 Key 的剩余过期时间</td><td>TTL KEY_NAME</td></tr><tr><td>SAVE</td><td>RDB 持久化</td><td>SAVE</td></tr><tr><td>INFO</td><td>Reids 服务器的各种信息和统计数值</td><td>INFO [section]</td></tr><tr><td>SHUTDOWN</td><td>保存并停止所有客户端</td><td>SHUTDOWN [NOSAVE \</td><td>SAVE]</td></tr></tbody></table><h1 id="Redis-常用字段类型"><a href="#Redis-常用字段类型" class="headerlink" title="Redis 常用字段类型"></a>Redis 常用字段类型</h1><ul><li>String 字符串</li><li>Hash  散列表</li><li>List     列表</li><li>Set      无序集合</li><li>Zset    可排序结合</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>最常见的数据类型，可以是任何类型的字符串比如 JSON、XML、数字、甚至是二进制，最大容量是512M。</p><p>典型的使用场景包括：缓存功能、计数器、共享 Session、限速</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>说明</th><th>Cli 命令</th><th>PHP</th></tr></thead><tbody><tr><td>SET</td><td>赋值</td><td>SET key value</td><td>$redis-&gt;set(‘key’, ‘value’);</td></tr><tr><td>SETEX</td><td>赋值并添加过期时间</td><td>SETEX key expire value</td><td>$redis-&gt;setex(‘key’, ‘expire’, ‘value’);</td></tr><tr><td>GET</td><td>取值</td><td>GET key</td><td>$redis-&gt;get(‘key’);</td></tr><tr><td>INCR</td><td>递增数字</td><td>INCR key</td><td>$redis-&gt;incr(‘int_key’);</td></tr><tr><td>INCRBY</td><td>增加指定的数字</td><td>INCRBY key increment</td><td>$redis-&gt;incrBy(‘int_key’, number);</td></tr><tr><td>DECR</td><td>递减数字</td><td>DECR key</td><td>$redis-&gt;decr(‘key1’);</td></tr><tr><td>DECRBY</td><td>减少指定的数字</td><td>DECRBY key decrement</td><td>$redis-&gt;decrBy(‘key1’, number);</td></tr><tr><td>INCRBYFLOAT</td><td>增加指定浮点型数</td><td>INCRBYFLOAT key increment</td><td>$redis-&gt;incrByFloat(‘key1’, 1.5);</td></tr><tr><td>APPEND</td><td>向稳步追加值</td><td>APPEND key value</td><td>$redis-&gt;append(‘key’, ‘value2’);</td></tr><tr><td>STRLEN</td><td>获取字符串长度</td><td>STRLEN key value</td><td>$redis-&gt;strlen(‘key’);</td></tr><tr><td>MSET</td><td>同时设置多个 key 的值</td><td>MSET key1 [key2 value2 …]</td><td>$redis-&gt;mSet([‘key0’=&gt;’value0’]);</td></tr><tr><td>MGET</td><td>同时获取多个 key 的值</td><td>MGET key1 [key2 …]</td><td>$redis-&gt;mGet([‘key1’,’key2’]);</td></tr></tbody></table><h3 id="示例：使用-String-记录用户登录次数"><a href="#示例：使用-String-记录用户登录次数" class="headerlink" title="示例：使用 String 记录用户登录次数"></a>示例：使用 String 记录用户登录次数</h3><p>有关于文章篇幅有限，所以只是简单实现，首先我们在 redis 中设置一个 user和他的点击次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set username_1 maksim</div><div class="line">set views_1 0</div></pre></td></tr></table></figure><p>我们可以通过业务名加上 id 的形式来对 key 进行命名。</p><p>然后编写模拟登录 login.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">session_start();</div><div class="line">$_SESSION[<span class="string">'uid'</span>] = <span class="number">1</span>;</div></pre></td></tr></table></figure><p>再然后进行显示</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$session = session_start();</div><div class="line">$redis = <span class="keyword">new</span> Redis();</div><div class="line">$redis-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>);</div><div class="line"></div><div class="line">$data = [</div><div class="line">    <span class="string">'uid'</span> =&gt; $_SESSION[<span class="string">'uid'</span>],</div><div class="line">    <span class="string">'views'</span> =&gt; <span class="number">0</span>,</div><div class="line">    <span class="string">'username'</span> =&gt; <span class="string">'游客'</span>,</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($data[<span class="string">'uid'</span>])) &#123;</div><div class="line">    $data[<span class="string">'username'</span>] = $redis-&gt;get(<span class="string">'username_'</span>.$data[<span class="string">'uid'</span>]);</div><div class="line">    $data[<span class="string">'views'</span>] = $redis-&gt;get(<span class="string">'views_'</span>.$data[<span class="string">'uid'</span>]);</div><div class="line">&#125;</div><div class="line">$message =  <span class="string">'你当前的用户为：'</span>. $data[<span class="string">'username'</span>].<span class="string">'   这是你第'</span>.$data[<span class="string">'views'</span>].<span class="string">'浏览该内容'</span>;</div><div class="line"></div><div class="line">$redis-&gt;incr(<span class="string">'views_'</span>.$data[<span class="string">'uid'</span>]);</div><div class="line"><span class="keyword">echo</span> $message;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h2 id="Hash-类型"><a href="#Hash-类型" class="headerlink" title="Hash 类型"></a>Hash 类型</h2><p>Hash 类型与 PHP 的数组类似，可以保存多个 key-value 对，每个k-v 都是字符串类型，最多2^32-1字段。</p><p>该类型适用于一个属性之中具有多个子属性，比如我们的用户信息。</p><table><thead><tr><th>命令</th><th>说明</th><th>Cli 命令示例</th><th>PHP 写法</th></tr></thead><tbody><tr><td>HSET</td><td>赋值</td><td>HSET key field value</td><td>$redis-&gt;hSet(key, field, value);</td></tr><tr><td>HMSET</td><td>赋值多个字段</td><td>HMSET key filed1 value1 [field2 values]</td><td>$redis-&gt;hMset(key, [‘filed1’=&gt; ‘value1’]);</td></tr><tr><td>HGET</td><td>取值</td><td>HGET key field</td><td>$redis-&gt;hGET(KEY, [‘filed’,’filed2’])</td></tr><tr><td>HMGET</td><td>获取多个字段的值</td><td>HMGET key field1 [field2]</td><td>$redis-&gt;hmGet(key,[‘filed’,’filed2’])</td></tr><tr><td>HGETALL</td><td>获取所有的字段的值</td><td>HGETALL key</td><td>$redis-&gt;hGetAll(key);</td></tr><tr><td>HLEN</td><td>获取字段的数量</td><td>HLEN key</td><td>$redis-&gt;hLen(key);</td></tr></tbody></table><h3 id="示例：-存储用户信息"><a href="#示例：-存储用户信息" class="headerlink" title="示例： 存储用户信息"></a>示例： 存储用户信息</h3><p>在 redis 中存入用户信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hmset userinfo_1 real_name 张三 email 1401588099@qq.com</div></pre></td></tr></table></figure><p>继续在index.php 中编写代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$realName = $redis-&gt;hGet(<span class="string">'userinfo_'</span>.$data[<span class="string">'uid'</span>],<span class="string">'real_name'</span>);</div><div class="line">$email = $redis-&gt;hGet(<span class="string">'userinfo_'</span>.$data[<span class="string">'uid'</span>],<span class="string">'email'</span>);</div><div class="line">$message .= <span class="string">'&lt;br&gt;'</span>. <span class="string">'真实姓名：'</span>.$realName.<span class="string">'&lt;br&gt;'</span>.<span class="string">'邮箱：'</span>.$email;</div></pre></td></tr></table></figure><h2 id="List-类型"><a href="#List-类型" class="headerlink" title="List 类型"></a>List 类型</h2><p>Redis 的 List 类型实现其实就是一个双向链表用于存储一个有序的字符串列表，从队列两端添加和弹出元素，拥有开发经验的同学听到双向列表就应该知道 List 的作用了，他可是当做消息队列来使用，这也是最常见的应用。</p><p>使用场景：消息队列，文章列表</p><table><thead><tr><th>命令</th><th>说明</th><th>cli 命令</th><th>PHP</th></tr></thead><tbody><tr><td>LPUSH</td><td>向列表左端添加元素</td><td>LPUSH key value</td><td>$redis-&gt;lPush(key, value);</td></tr><tr><td>RPUSH</td><td>向列表右端添加元素</td><td>RPUSH key value</td><td>$redis-&gt;rPush(key, value);</td></tr><tr><td>LPOP</td><td>从列表左端弹出元素</td><td>LOPO key</td><td>$redis-&gt;lPop(key);</td></tr><tr><td>RPOP</td><td>从队列右端弹出元素</td><td>RPOP key</td><td>$redis-&gt;rPop(value);</td></tr><tr><td>LLEN</td><td>获取列表中元素个数</td><td>LLEN key</td><td>$redis-&gt;lSize(key);</td></tr><tr><td>LRANGE</td><td>获取列表中某一片段的元素</td><td>LRANGE key start stop</td><td>$redis-&gt;lRange(key, start, end);</td></tr><tr><td>LREM</td><td>删除列表中指定的值</td><td>LREM key count value</td><td>$redis-&gt;lRem(key, value, count)l</td></tr><tr><td>LINDEX</td><td>获取指定索引的元素值</td><td>LINDEX key index</td><td>$redis-&gt;lGet(key, index);</td></tr><tr><td>LSET</td><td>设置指定索引的元素值</td><td>LSET key index value</td><td>$redis-&gt;lSet(key, index, value);</td></tr><tr><td>LTRIM</td><td>只保留列表指定的片段</td><td>LTRIM key start stop</td><td>$redis-&gt;lTrim(key, start, end);</td></tr><tr><td>LINSERT</td><td>向列表中插入元素</td><td>LINSERT key BEFORE/AFTER existing_value value</td><td>$redis-&gt;linsert(key, Redis::BEFORE, existing_value, value)</td></tr></tbody></table><h3 id="示例：秒杀"><a href="#示例：秒杀" class="headerlink" title="示例：秒杀"></a>示例：秒杀</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="comment">//ms_status_3 0 结束 1已经</span></div><div class="line"><span class="comment">//在redis-cli 中输入 set cache_ms_status 1</span></div><div class="line"><span class="comment">//ms_list 秒杀队列</span></div><div class="line"></div><div class="line">$redis = <span class="keyword">new</span> Redis();</div><div class="line">$redis-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[<span class="string">'uid'</span>])) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'参数不合法'</span>;<span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$uid = $_GET[<span class="string">'uid'</span>];</div><div class="line"><span class="keyword">if</span> (!$uid) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'参数不合法'</span>;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line">$limit = <span class="number">2</span>; <span class="comment">//设置秒杀数</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ($redis-&gt;lSize(<span class="string">'cache_ms_uids'</span>) &gt;= $limit) &#123;</div><div class="line">    $redis-&gt;set(<span class="string">'cache_ms_status'</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">echo</span> <span class="string">'已经被抢光了，下次再来！'</span>;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ($redis-&gt;get(<span class="string">'cache_ms_status'</span>) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'已经结束了'</span>;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$redis-&gt;lPush(<span class="string">'cache_ms_uids'</span>, $uid);</div><div class="line"><span class="keyword">echo</span> <span class="string">'秒杀成功'</span>;</div></pre></td></tr></table></figure><p>安装上面的代码，我们就建立了一个简单的秒杀队列，其业务逻辑基础就是如此，不过请不要将其代码用于实际项目中，因为中间还缺少很多操作，最典型的就是防止黄牛等等一系列业务逻辑。</p><h2 id="Set-类型"><a href="#Set-类型" class="headerlink" title="Set 类型"></a>Set 类型</h2><p>Set 类型类似于集合，其中可以存储不同的类型元素，需要注意的是，Set 集合是禁止重复的，所以一般都用来实现去重，元素最多为2^32 -1 ，其中元素没有顺序，</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>说明</th><th>cli 命令示例</th><th>PHP</th></tr></thead><tbody><tr><td>SADD</td><td>添加元素</td><td>SADD key value [value1 value2 …]</td><td>$redis-&gt;sAdd(‘key’, ‘set’);</td></tr><tr><td>SREM</td><td>删除元素</td><td>SREM key value [value1 value3 …]</td><td>$redis-&gt;sRem(‘key’, ‘set’);</td></tr><tr><td>SMEMBERS</td><td>获取集合中所有元素</td><td>SMEMBERS key</td><td>$redis-&gt;sMembers(‘key’);</td></tr><tr><td>SISMEMBER</td><td>判断元素是否在集合中</td><td>SISMEMBER key value</td><td>$redis-&gt;slsMember(‘key’, ‘value’);</td></tr><tr><td>SDIFF</td><td>对集合做差集运算</td><td>SDIFF key1 key2 [key3 …]</td><td>$redis-&gt;sDiff(‘key1’, ‘key2’, ‘key3’);</td></tr><tr><td>SINTER</td><td>对集合做交集运算</td><td>SINTER key1 key2 [key3 …]</td><td>$redis-&gt;sInter(‘key1’, ‘key2’, ‘key3’);</td></tr><tr><td>SUNION</td><td>对集合做并集运算</td><td>SUNION key1 key2 [key3 …]</td><td>$redis-&gt;sUnion(‘key1’, ‘key2’, ‘key3’);</td></tr><tr><td>SCARD</td><td>获得集合中元素的个数</td><td>SCARD key</td><td>$redis-&gt;sCard(‘key1’);</td></tr><tr><td>SDIFFSTORE</td><td>对集合做差集运算并将结果存储</td><td>SDIFFSTORE destination key1 key2 [key3]</td><td>$redis-&gt;sDiffStore(‘output’, ‘key1’, ‘key2’);</td></tr><tr><td>SINTERSTORE</td><td>对集合做交集运算并将结果存储</td><td>SINTERSTORE destination key1 key2 [key3]</td><td>$redis-&gt;sInterStore(‘output’, ‘key1’, ‘key2’);</td></tr><tr><td>SUNIONSTORE</td><td>对集合做并集运算并将结果存储</td><td>SUNIONSTORE destination key1 key2 [key3]</td><td>$redis-&gt;sUnionStore(‘output’, ‘key1’, ‘key2’);</td></tr><tr><td>SRANDMEMBER</td><td>随机获取集合中的元素</td><td>SRANDMEMBER key [count]</td><td>$redis-&gt;sRandMember(‘key1’, 2);</td></tr><tr><td>SPOP</td><td>随机弹出一个元素</td><td>SPOP key</td><td>$redis-&gt;sPop(‘key1’);</td></tr></tbody></table><h3 id="示例：查并集"><a href="#示例：查并集" class="headerlink" title="示例：查并集"></a>示例：查并集</h3><p>在 Redis 中添加南北方拥有的商品，然后在 PHP 中进行显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SADD cache_bei apple peach pear</div><div class="line">SADD cache_nan apple banana avocado</div></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"></div><div class="line">$redis = <span class="keyword">new</span> Redis();</div><div class="line">$redis-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>);</div><div class="line"></div><div class="line">$bei = $redis-&gt;sMembers(<span class="string">'cache_bei'</span>);</div><div class="line">$nan = $redis-&gt;sMembers(<span class="string">'cache_nan'</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">'北方有的商品：&lt;br&gt;'</span>;</div><div class="line">print_r($bei);</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">'南方有的商品：&lt;br&gt;'</span>;</div><div class="line">print_r($nan);</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">'两个地方都有的商品：&lt;br&gt;'</span>;</div><div class="line">print_r($redis-&gt;sInter(<span class="string">'cache_bei'</span>, <span class="string">'cache_nan'</span>));</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">'两个地域所有的商品：&lt;br&gt;'</span>;</div><div class="line">print_r($redis-&gt;sUnion(<span class="string">'cache_bei'</span>, <span class="string">'cache_nan'</span>));</div></pre></td></tr></table></figure><p><img src="http://ogxeww23n.bkt.clouddn.com/Jietu20180718-194727.jpg" alt=""></p><h2 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h2><p>看名字我们就会知道和上面的集合用法是类似的，不过它是有序的，有序也就意味着每一个元素在插入的时候系统都会给他指定一个分数，然后根据分数高低进行排序，跟集合一样，它也是禁止重复的，分数是可以相同的，有序集合是使用散列表和跳跃表来进行实现的，这也就意味着，如果要去读写中间的数据时非常快的，</p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>说明</th><th>cli 命令示例</th><th>PHP</th></tr></thead><tbody><tr><td>ZADD</td><td>添加元素</td><td>ZADD key score value[ score2 value2 …]</td><td>$redis-&gt;zAdd(‘key’,1,’val1’);</td></tr><tr><td>ZSCORE</td><td>设置元素的分数</td><td>ZSCORE key value</td><td>$redis-&gt;zScore(‘key’, val2);</td></tr><tr><td>ZRANGE</td><td>获取正序排名在某范围的元素</td><td>ZRANGE key start stop [WITHSCORE]</td><td>$redis-&gt;zRange(‘key1’, 0, -1);</td></tr><tr><td>ZREVRANGE</td><td>获取倒序排名在某范围的元素</td><td>ZREVRANGE key start stop [WITHSCORE]</td><td>$redis-&gt;zRevRange(‘key’, 0, -1);</td></tr><tr><td>ZRANGEBYSCORE</td><td>获取指定分数范围内的元素</td><td>ZRANGEBYSCORE key min max</td><td>$redis-&gt;zRangeByScore(key, start,end, [withscores, limit]);</td></tr><tr><td>ZINCRBY</td><td>增加某个元素的分数</td><td>ZINCRBY key increment value</td><td>$redis-&gt;zIncrBy(‘key’, increment, ‘member’);</td></tr><tr><td>ZCARD</td><td>获取集合中元素的个数</td><td>ZCARD key</td><td>$redis-&gt;zSize(‘key’);</td></tr><tr><td>ZCOUNT</td><td>获取指定分数范围内的元素个数</td><td>ZCOUNT key min max</td><td>$redis-&gt;zCount(key, start ,end);</td></tr><tr><td>ZREM</td><td>删除一个或多个元素</td><td>ZREM key value1 [value2]</td><td>$redis-&gt;zDelete(‘key’, ‘val’);</td></tr><tr><td>ZREMRANGEBYRANK</td><td>按照排名范围删除元素</td><td>ZREMRANGEBYRANK key start stop</td><td>$redis-&gt;zRemRangeByRank(‘key’, 0, 1);</td></tr><tr><td>ZREMRANGEBYSCORE</td><td>按照分数范围删除元素</td><td>ZREMRANGEBYSCORE key start stop</td><td>$redis-&gt;zRemRangeByScore(‘key’, 0, 3);</td></tr><tr><td>ZRANK</td><td>获取正序排序的元素的排名</td><td>ZRANK key value</td><td>$redis-&gt;zRank(key, val);</td></tr><tr><td>ZREVRANK</td><td>获取逆序排序的元素的排名</td><td>ZREVRANK key value</td><td>$redis-&gt;zRevRank(key, val);</td></tr></tbody></table><h3 id="案例：按照评分给小说排名"><a href="#案例：按照评分给小说排名" class="headerlink" title="案例：按照评分给小说排名"></a>案例：按照评分给小说排名</h3><p>首先还是模拟评分直接在 cli 中添加数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ZADD book_rank 1 冰火魔厨</div><div class="line">ZADD book_rank 2 琴魔</div><div class="line">ZADD book_rank 3 酒神</div><div class="line">ZADD book_rank 3 天火大道</div><div class="line">ZADD book_rank 5 斗罗大陆</div><div class="line">ZADD book_rank 5 惟我独仙</div></pre></td></tr></table></figure><p>然后在 PHP 中使用倒序排列输出排名为前五的小说</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">$redis = <span class="keyword">new</span> Redis();</div><div class="line">$redis-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>);</div><div class="line"></div><div class="line">$books = $redis-&gt;zRevRange(<span class="string">'book_rank'</span>, <span class="number">0</span> ,<span class="number">4</span>, <span class="keyword">true</span>);</div><div class="line">$count = $redis-&gt;zSize(<span class="string">'book_rank'</span>);</div><div class="line"><span class="keyword">echo</span> <span class="string">'当前一共有'</span>.$count.<span class="string">'本书，显示排名前五的书籍&lt;br&gt;'</span>;</div><div class="line"><span class="keyword">foreach</span> ($books <span class="keyword">as</span> $key =&gt; $value) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">'《'</span>.$key.<span class="string">'》的评分为:'</span>.$value.<span class="string">'星&lt;br&gt;'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ogxeww23n.bkt.clouddn.com/Jietu20180718-203012.jpg" alt=""></p><h1 id="合理的使用-Redis"><a href="#合理的使用-Redis" class="headerlink" title="合理的使用 Redis"></a>合理的使用 Redis</h1><ul><li><p>防止内存站满：</p><ul><li>设置超时时间，如果把 redis 定位成一个缓存使用，键值一定要设置一个超时时间，如果不设置的话 key 会一直占着内存，造成非常大的浪费，而且随着时间的推移，内存的占用率越来越大，如果有一天达到内存上限，Redis 就会不断的进行持久化，另外一个 key 的时长进行综合评估，也不是越长越好，太长了其实跟没有超时时间没有太大区别。</li><li>不存方过大文件，一般来说 Redis 每一个键在存储数据的时候不要超过500字节，要是超过的话一定要想办法先压缩一下然后在进行储存，Redis 是将数据放到内存中的，如果把太大的东西丢进 Redis 里面肯定会浪费一定的内存的。还有就是数据是需要来回传递的，当访问量非常高的时候，你里面还带了一个非常大的文件，来回的传输，很有可能就把带宽占用满了，其他的服务就不可用。</li><li>不存不常用数据，Redis 比较适合存放一些热数据，所以我们要把冷热数据进行分离，冷数据比较适合放在 Mysql 之中，在 Redis 应该存一些比较高频的数据，把一些不长用的数据放在 Redis 中就太有点浪费资源了。Redis 存储数据量小的时候，速度肯定要快一些。不同的业务数据最好分开存储，不要把一些不相关的业务数据都放到一个 Redis 实例里面。</li></ul></li><li><p>提高使用效率</p><ul><li>合理使用不同的数据类型：Redis 支持的类型非常的多，根据不同业务的业务场景，来使用不同的数据结构，不同的字段类型适用场景是不一样的。</li><li>慎用正则处理或批量操作 Hash、Set 等：这是一个非常恐怖的操作，Hash 和 Set 本身就是一个很大的数据，然后在批量操作的话很要命的，因为 Redis 是单线程的，如果线上 Key 非常多的时候，如果再进行正则匹配效率会非常的低，效率一旦低下来，就会堵塞其他命令的运行。如果在批量操作 Hash 的时候，是需要把 feild 也进行一次操作的，</li></ul><p>所以说不要以为 Redis 是万能的，最终他还是要消耗 CPU 的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单的 key-v
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>利用 tail 命令监控文件变化</title>
    <link href="http://www.maksim.website/2018/07/17/2/"/>
    <id>http://www.maksim.website/2018/07/17/2/</id>
    <published>2018-07-16T16:00:00.000Z</published>
    <updated>2018-07-17T13:47:36.478Z</updated>
    
    <content type="html"><![CDATA[<p>tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. </p><h1 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail(选项)(参数)</div></pre></td></tr></table></figure><p>选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">--retry：即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；</div><div class="line">-c&lt;N&gt;或——bytes=&lt;N&gt;：输出文件尾部的N（N为整数）个字节内容；</div><div class="line">-f&lt;name/descriptor&gt;或；--follow&lt;nameldescript&gt;：显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；</div><div class="line">-F：与选项“-follow=name”和“--retry&quot;连用时功能相同；</div><div class="line">-n&lt;N&gt;或——line=&lt;N&gt;：输出文件的尾部N（N位数字）行内容。</div><div class="line">--pid=&lt;进程号&gt;：与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；</div><div class="line">-q或——quiet或——silent：当有多个文件参数时，不输出各个文件名；</div><div class="line">-s&lt;秒数&gt;或——sleep-interal=&lt;秒数&gt;：与“-f”选项连用，指定监视文件变化时间隔的秒数；</div><div class="line">-v或——verbose：当有多个文件参数时，总是输出各个文件名；</div><div class="line">--help：显示指令的帮助信息；</div><div class="line">--version：显示指令的版本信息。</div></pre></td></tr></table></figure><p><strong>2．**</strong>命令功能：**</p><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p><p><strong>3．**</strong>命令参数：**</p><p>-f 循环读取</p><p>-q 不显示处理信息</p><p>-v 显示详细的处理信息</p><p>-c&lt;数目&gt; 显示的字节数</p><p>-n&lt;行数&gt; 显示行数</p><p>–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. </p><p>-q, –quiet, –silent 从不输出给出文件名的首部 </p><p>-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 </p><p><strong>4．**</strong>使用实例：**</p><p><strong>实例1：显示文件末尾内容</strong></p><p><strong>命令：</strong></p><p>tail -n 5 log2014.log</p><p><strong>输出：</strong></p><p>[root@localhost test]# tail -n 5 log2014.log </p><p>2014-09</p><p>2014-10</p><p>2014-11</p><p>2014-12</p><p>==============================[root@localhost test]#</p><p><strong>说明：</strong></p><p>显示文件最后5行内容</p><p><strong>实例2：循环查看文件内容</strong></p><p><strong>命令：</strong></p><p>tail -f test.log</p><p><strong>输出：</strong></p><p>[root@localhost ~]# ping 192.168.120.204 &gt; test.log &amp;</p><p>[1] 11891[root@localhost ~]# tail -f test.log </p><p>PING 192.168.120.204 (192.168.120.204) 56(84) bytes of data.</p><p>64 bytes from 192.168.120.204: icmp_seq=1 ttl=64 time=0.038 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=2 ttl=64 time=0.036 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=3 ttl=64 time=0.033 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=4 ttl=64 time=0.027 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=5 ttl=64 time=0.032 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=6 ttl=64 time=0.026 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=7 ttl=64 time=0.030 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=8 ttl=64 time=0.029 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=9 ttl=64 time=0.044 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=10 ttl=64 time=0.033 ms</p><p>64 bytes from 192.168.120.204: icmp_seq=11 ttl=64 time=0.027 ms</p><p>[root@localhost ~]#</p><p><strong>说明：</strong></p><p>ping 192.168.120.204 &gt; test.log &amp; //在后台ping远程主机。并输出文件到test.log；这种做法也使用于一个以上的档案监视。用Ctrl＋c来终止。 </p><p><strong>实例3：从第5行开始显示文件</strong></p><p><strong>命令：</strong></p><p>tail -n +5 log2014.log</p><p><strong>输出：</strong></p><p>[root@localhost test]# cat log2014.log </p><p>2014-01</p><p>2014-02</p><p>2014-03</p><p>2014-04</p><p>2014-05</p><p>2014-06</p><p>2014-07</p><p>2014-08</p><p>2014-09</p><p>2014-10</p><p>2014-11</p><p>2014-12</p><p>==============================</p><p>[root@localhost test]# tail -n +5 log2014.log</p><p>2014-05</p><p>2014-06</p><p>2014-07</p><p>2014-08</p><p>2014-09</p><p>2014-10</p><p>2014-11</p><p>2014-12</p><p>==============================</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. &lt;/p&gt;
&lt;h1 id=&quot;命令格式&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/07/02/cjjthvkva0001q1rd4gi62ifr/"/>
    <id>http://www.maksim.website/2018/07/02/cjjthvkva0001q1rd4gi62ifr/</id>
    <published>2018-07-02T13:52:36.919Z</published>
    <updated>2018-07-02T13:52:36.919Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/07/02/cjjthvl1x004sq1rdl8eizoi9/"/>
    <id>http://www.maksim.website/2018/07/02/cjjthvl1x004sq1rdl8eizoi9/</id>
    <published>2018-07-02T12:11:33.990Z</published>
    <updated>2018-07-02T13:58:19.299Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><p>索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构，索引对于良好的性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响越发重要，不过在数据量较小而且负载较低时，不恰当的索引对性能的影响可能还不明显，担当数据量组件增大时，性能则会几急剧下降。</p><p>而且当表中的数据比较少时，查询的频率比较低的情况下，索引的作用可能不太明显，因为这个时候表中的数据差不多都可以缓存到内存中。所以就算是进行全表扫描，效率也不会太慢。</p><p>但是当数据量越来越庞大，查询频率也越来越高，内存无法缓存所有数据的时候，索引的作用就会显得越来越重要。</p><p>在日常工作中，人们总是忽略或者过分的强调索引的作用，有的时候甚至是会出现两个极端。</p><ul><li>表中除了主键之外一条索引都没有</li><li>表中的每一列都建立索引</li></ul><p>既然是两个极端，那么也就意味着，这两种方法都不正确太少或者太多的索引都会对系统带来一定的影响。只有在正确的列上，建立正确的索引的情况下，才能提升数据库的索引能力。</p><p>为了能够正确的使用索引，我们先来看看MySQL所支持的索引类型。</p><p>在开头，我们说过，索引的作用是告诉存储引擎如何快速的找到所需要的数据，所以索引是在引擎层上实现的，而不是    在 MySQL 服务器层上实现的，所以也就导致不同存储引擎之间实现的方式是不同的，同时的也不是所有的引擎支持所有的索引类型。</p><p>#B-Tree索引</p><p><strong>B-Tree索引</strong>是MySQL中最常见的索引类型，当人们谈论索引的时候，如果没有特别指明类型，那么多半说的就是B-tree索引，它使用B-Tree的结构存储数据，在B-Tree种，每一个叶子节点都会包含一个指向下一个节点的指针。这样可以方便叶子节点之间的遍历。</p><h2 id="B-tree结构存储数据"><a href="#B-tree结构存储数据" class="headerlink" title="B-tree结构存储数据"></a>B-tree结构存储数据</h2><p>通过简单的图例，讲解讲解一下B-tree的存储结构。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180702111251.png" alt=""></p><p>从图中，我们可以看到B+树是一种平衡的查找树，每一个叶子到根部的距离都是相同的，所有的记录节点都是按照键值的大小顺序排列的在同一个节点上的。</p><p>并且每个节点之间是使用指针连接的这就时一个典型的B树存储结构，对于不同的存储引擎的实现可能会有所不同，比如说 MyISAM 索引在叶子节点上是通过物理位置来引用行的，InnoDB则是通过主键来引用行的。</p><ul><li>B-tree索引能够加快数据的查询速度。</li></ul><p>通常情况下，索引的大小远小于表中数据的大小，使用了B-tree索引，存储引擎就不需要进行全表扫描，取而代之的是从索引的根节点进行搜索，根节点存储了指向下一层节点的指针，存储引擎根据这些指针向下层查找。</p><p>通过比较接节点页的值和要查找的值，找到合适的指针进入下一层的子节点，而这些指针实际上是定义了子节点值得上限和下限，所以最终存储引擎要找到对应的值或者是不存在的。</p><p>最终存储引擎通过b-tree查找到子节点，子节点的指针指向的是数据。</p><ul><li>B-tree更适合范围查找</li></ul><p>因为B-tree是顺序存储</p><p>什么情况下可以使用B树索引。</p><ul><li>全值匹配的查询 <code>order_sn = &#39;201723010222&#39;</code></li><li>匹配最左侧前缀的查询</li><li>匹配列前缀查询  <code>order_sn like &#39;9876%&#39;</code></li><li>匹配范围值得查询 <code>order_sn &gt; &#39;201723010222&#39; AND order_sn &lt; &#39;201723010333&#39;</code></li><li>精确匹配左前列并范围匹配另外一列 </li><li>只访问索引的查询 </li></ul><h2 id="B-tree索引的使用限制"><a href="#B-tree索引的使用限制" class="headerlink" title="B-tree索引的使用限制"></a>B-tree索引的使用限制</h2><p>使用索引命中了表中大部分数据时，MySQL查询优化器，使用全表扫描的方式性能可能更好，所以就不适用索引查询了。</p><p>此外在使用B-tree索引的时候还会受一些限制。</p><ul><li>如果偶不是按照索引最左列开始找茬，则无法使用索引</li><li>使用索引时不能跳过索引中的列</li><li>Not in 和 &lt; &gt;操作无法使用索引</li><li>如果查询中有某个列的范围查询，则其右侧所有列都无法使用索引</li></ul><h1 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h1><p>在MySQL的一些存储引擎中还有支持Hash索引的存储引擎，MyISAM 就是同时支持Hash和B-tree，默认情况下使用的是Hash索引，InnoDB支持Hash索引，不过它的Hash索引不是我们来建立的，而是根据B-tree的使用情况自行建立的，也成为自适应Hash索引。</p><ul><li>Hash索引时基于Hash表实现的，只有查询条件精确匹配Hash索引的所有列时，才能使用Hash索引，也就是说Hash索引只能用于等值查询上，如果要进行范围或者模糊查询就无法使用Hash索引。</li><li>对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构，索引对于良好的性能非常关键，尤其是当表中的数据量越来越大的时候，索引对性能的影响越发重要，不过在数据量较小而且负载较低时，不恰当的索引对性能的影响可能还不明显，担当数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序算法图解</title>
    <link href="http://www.maksim.website/2018/06/30/1/"/>
    <id>http://www.maksim.website/2018/06/30/1/</id>
    <published>2018-06-29T16:00:00.000Z</published>
    <updated>2018-07-18T23:32:34.294Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文是来自 <code>https://www.awaimai.com/1980.html</code>，但是都是基于面向过程的代码编写，我用面向对象的方式重新实现了一边，并且按照自己的写作习惯进行了重新编辑。</p><p>在 PHP 日常开发过程中，接触算法的机会并不多，大多数PHP 程序员都是在进行 CURD 的操作，甚至连数据结构的接触也很局限，并且大多数培训班很少回去讲解数据结构与算法，这也导致了 PHP 程序员的水平参差不齐，但是无论是进阶，还是跳槽到 BAT 这样的大公司算法都是一道绕不过去的坎，光是在算法上躺下的程序员就不在少数。</p><p>这也是一道程序员的分水岭之一，掌握算法能够利于我们开发出更加高效的软件，毕竟程序=数据结构+算法。这是每一个科班出身的人第一天上数据结构与算法这门课要学习的第一句话，排序算法是程序员必须掌握的基础内容。</p><p>（未完成，编写工作还在进行）</p><h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1 快速排序"></a>1 快速排序</h2><p><strong>快速排序</strong>是由<strong>东尼·霍尔</strong>发展的一种排序算法。</p><p>在平均状况下，排序<code>n</code>个项目要<code>Ο(nlog n)</code>次比较。</p><p>在最坏状况下则需要<code>Ο(n2)</code>次比较，但这种状况并不常见。</p><p>事实上，快速排序通常明显比其他<code>Ο(nlog n)</code>算法更快，因为它的内部循环可以在大部分的架构上，很有效率地被实现出来。</p><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/Sorting_quicksort_anim.gif" alt="img"></p><p>快速排序采用分治法实现排序，具体步骤：</p><ol><li>从数列中挑出一个数作为<strong>基准元素</strong>。通常选择第一个或最后一个元素。</li><li>扫描数列，<strong>以基准元素为比较对象，把数列分成两个区</strong>。规则是：小的移动到基准元素前面，大的移到后面，相等的前后都可以。分区完成之后，基准元素就处于数列的中间位置。</li><li>然后再用同样的方法，<strong>递归地排序划分的两部分</strong>。</li></ol><p>递归的结束条件是数列的大小是<code>0</code>或<code>1</code>，也就是永远都已经被排序好了。</p><p>PHP代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function quickSort($arr) &#123;</div><div class="line">    // 先设定结束条件，判断是否需要继续进行</div><div class="line">    if(count($arr) &lt;= 1) &#123;</div><div class="line">        return $arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 选择第一个元素作为基准元素</div><div class="line">    $baseValue = $arr[0];</div><div class="line"></div><div class="line">    // 初始化小于基准元素的左数组</div><div class="line">    $leftArray = array();</div><div class="line"></div><div class="line">    // 初始化大于基准元素的右数组</div><div class="line">    $rightArray = array();</div><div class="line"></div><div class="line">    // 遍历除基准元素外的所有元素，按照大小关系放入左右数组内</div><div class="line">    array_shift($arr);</div><div class="line">    foreach ($arr as $value) &#123;</div><div class="line">        if ($value &lt; $baseValue) &#123;</div><div class="line">            $leftArray[] = $value;</div><div class="line">        &#125; else &#123;</div><div class="line">            $rightArray[] = $value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 再分别对左右数组进行相同的排序</div><div class="line">    $leftArray = quickSort($leftArray);</div><div class="line">    $rightArray = quickSort($rightArray);</div><div class="line"></div><div class="line">    // 合并基准元素和左右数组</div><div class="line">    return array_merge($leftArray, array($baseValue), $rightArray);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2 冒泡排序"></a>2 冒泡排序</h2><p>冒泡排序是一种简单的排序算法。</p><p>算法重复地走访过要排序的数列，一次<strong>比较两个元素</strong>，如果他们的顺序错误就把他们交换过来。</p><p>走访数列的工作重复地进行，直到没有再需要交换，也就是说该数列已经排序完成。</p><p>因为排序过程让<strong>较大的数往下沉，较小的往上冒</strong>，故而叫冒泡法。</p><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/Bubble_sort_animation.gif" alt="img"></p><p>算法步骤：</p><ol><li>从第一个元素开始，比较相邻的元素，如果第一个比第二个大，就交换他们两个。</li><li>从开始第一对到结尾的最后一对，对每一对相邻元素作同样的工作。比较结束后，最后的元素应该会是最大的数。</li><li>对所有的元素重复以上的步骤，除了最后一个。</li><li>重复上面的步骤，每次比较的对数会越来越少，直到没有任何一对数字需要比较。</li></ol><p>PHP代码实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span><span class="params">($arr)</span></span></div><div class="line">&#123;</div><div class="line">    $len = count($arr);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>($i = <span class="number">1</span>; $i &lt; $len; $i++) &#123;</div><div class="line">        <span class="keyword">for</span>($k = <span class="number">0</span>; $k &lt; $len - $i; $k++) &#123;</div><div class="line">            <span class="keyword">if</span>($arr[$k] &gt; $arr[$k + <span class="number">1</span>]) &#123;</div><div class="line">                $tmp = $arr[$k + <span class="number">1</span>];</div><div class="line">                $arr[$k + <span class="number">1</span>] = $arr[$k];</div><div class="line">                $arr[$k] = $tmp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> $arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h2><p>插入排序是一种简单直观的排序算法。</p><p>插入排序的工作原理是：<strong>将需要排序的数，与前面已经排好序的数据从后往前进行比较，使其插入到相应的位置。</strong></p><p>插入排序在实现上，通常采用in-place排序，即只需用到<code>O(1)</code>的额外空间的排序。</p><p>因而，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/insert-sort.gif" alt="img"></p><p>算法步骤：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果以排序的元素大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置中；</li><li>重复步骤2。</li></ol><p>PHP代码实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">sort</span><span class="params">(array &amp;$arr)</span> </span>&#123;</div><div class="line">        $count = count($arr);</div><div class="line"><span class="keyword">if</span> ($arr == <span class="keyword">null</span> || $count &lt; <span class="number">2</span>) &#123;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $count ; $i++) &#123;</div><div class="line"><span class="keyword">for</span> ($j = $i - <span class="number">1</span>; $j &gt;= <span class="number">0</span> &amp;&amp; $arr[$j] &gt; $arr[$j + <span class="number">1</span>]; $j--) &#123;</div><div class="line"><span class="keyword">self</span>::swap($arr, $j, $j + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(array &amp;$arr, $i, $j)</span> </span>&#123;</div><div class="line">$arr[$i] = $arr[$i] ^ $arr[$j];</div><div class="line">$arr[$j] = $arr[$i] ^ $arr[$j];</div><div class="line">$arr[$i] = $arr[$i] ^ $arr[$j];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4 选择排序"></a>4 选择排序</h2><p>选择排序是一种简单直观的排序算法。</p><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/Selection_sort_animation.gif" alt="img"></p><p>算法步骤：</p><ol><li>首先，在序列中找到最小元素，存放到排序序列的起始位置；</li><li>接着，从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><p>PHP代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function selectSort($arr)</div><div class="line">&#123;</div><div class="line">    $len = count($arr);</div><div class="line"></div><div class="line">    for ($i = 0; $i &lt; $len; $i++) &#123;</div><div class="line">        $p = $i;</div><div class="line"></div><div class="line">        for ($j = $i + 1; $j &lt; $len; $j++) &#123;</div><div class="line">            if ($arr[$p] &gt; $arr[$j]) &#123;</div><div class="line">                $p = $j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $tmp = $arr[$p];</div><div class="line">        $arr[$p] = $arr[$i];</div><div class="line">        $arr[$i] = $tmp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return $arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5 归并排序"></a>5 归并排序</h2><p><strong>归并排序</strong>是建立在归并操作上的一种有效的排序算法。</p><p>归并排序将待排序的序列分成若干组，保证每组都有序，然后再进行合并排序，最终使整个序列有序。</p><p>该算法是采用分治法的一个非常典型的应用。</p><p>算法步骤：</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针达到序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><p>排序效果：</p><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/Merge_sort_animation2.gif" alt="img"></p><p>PHP实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 归并排序</div><div class="line"> *</div><div class="line"> * @param array $lists</div><div class="line"> * @return array</div><div class="line"> */</div><div class="line">function merge_sort(array $lists)</div><div class="line">&#123;</div><div class="line">    $n = count($lists);</div><div class="line">    if ($n &lt;= 1) &#123;</div><div class="line">        return $lists;</div><div class="line">    &#125;</div><div class="line">    $left = merge_sort(array_slice($lists, 0, floor($n / 2)));</div><div class="line">    $right = merge_sort(array_slice($lists, floor($n / 2)));</div><div class="line">    $lists = merge($left, $right);</div><div class="line">    return $lists;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function merge(array $left, array $right)</div><div class="line">&#123;</div><div class="line">    $lists = [];</div><div class="line">    $i = $j = 0;</div><div class="line">    while ($i &lt; count($left) &amp;&amp; $j &lt; count($right)) &#123;</div><div class="line">        if ($left[$i] &lt; $right[$j]) &#123;</div><div class="line">            $lists[] = $left[$i];</div><div class="line">            $i++;</div><div class="line">        &#125; else &#123;</div><div class="line">            $lists[] = $right[$j];</div><div class="line">            $j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    $lists = array_merge($lists, array_slice($left, $i));</div><div class="line">    $lists = array_merge($lists, array_slice($right, $j));</div><div class="line">    return $lists;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6 堆排序"></a>6 堆排序</h2><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。</p><p>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>堆排序的平均时间复杂度为<code>Ο(nlogn)</code> 。</p><p>算法步骤：</p><ol><li>创建一个堆<code>H[0..n-1]</code>；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小<code>1</code>，并调用<code>shift_down(0)</code>，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤<code>2</code>，直到堆的尺寸为<code>1</code>。</li></ol><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/Sorting_heapsort_anim.gif" alt="img"></p><p>PHP实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 堆排序</div><div class="line"> *</div><div class="line"> * @param array $lists</div><div class="line"> * @return array</div><div class="line"> */</div><div class="line">function heap_sort(array $lists)</div><div class="line">&#123;</div><div class="line">    $n = count($lists);</div><div class="line">    build_heap($lists);</div><div class="line">    while (--$n) &#123;</div><div class="line">        $val = $lists[0];</div><div class="line">        $lists[0] = $lists[$n];</div><div class="line">        $lists[$n] = $val;</div><div class="line">        heap_adjust($lists, 0, $n);</div><div class="line">        //echo &quot;sort: &quot; . $n . &quot;\t&quot; . implode(&apos;, &apos;, $lists) . PHP_EOL;</div><div class="line">    &#125;</div><div class="line">    return $lists;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function build_heap(array &amp;$lists)</div><div class="line">&#123;</div><div class="line">    $n = count($lists) - 1;</div><div class="line">    for ($i = floor(($n - 1) / 2); $i &gt;= 0; $i--) &#123;</div><div class="line">        heap_adjust($lists, $i, $n + 1);</div><div class="line">        //echo &quot;build: &quot; . $i . &quot;\t&quot; . implode(&apos;, &apos;, $lists) . PHP_EOL;</div><div class="line">    &#125;</div><div class="line">    //echo &quot;build ok: &quot; . implode(&apos;, &apos;, $lists) . PHP_EOL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function heap_adjust(array &amp;$lists, $i, $num)</div><div class="line">&#123;</div><div class="line">    if ($i &gt; $num / 2) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    $key = $i;</div><div class="line">    $leftChild = $i * 2 + 1;</div><div class="line">    $rightChild = $i * 2 + 2;</div><div class="line"></div><div class="line">    if ($leftChild &lt; $num &amp;&amp; $lists[$leftChild] &gt; $lists[$key]) &#123;</div><div class="line">        $key = $leftChild;</div><div class="line">    &#125;</div><div class="line">    if ($rightChild &lt; $num &amp;&amp; $lists[$rightChild] &gt; $lists[$key]) &#123;</div><div class="line">        $key = $rightChild;</div><div class="line">    &#125;</div><div class="line">    if ($key != $i) &#123;</div><div class="line">        $val = $lists[$i];</div><div class="line">        $lists[$i] = $lists[$key];</div><div class="line">        $lists[$key] = $val;</div><div class="line">        heap_adjust($lists, $key, $num);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7 希尔排序"></a>7 希尔排序</h2><p>希尔排序，也称<strong>递减增量</strong>排序算法，是插入排序的一种更高效的改进版本。</p><p>但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li></ul><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/Sorting_shellsort_anim.gif" alt="img"></p><p>算法步骤：</p><ol><li>先将整个待排序的记录序列分割成为若干子序列，分别进行直接插入排序</li><li>待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</li></ol><p>PHP实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 希尔排序 标准</div><div class="line"> *</div><div class="line"> * @param array $lists</div><div class="line"> * @return array</div><div class="line"> */</div><div class="line">function shell_sort(array $lists)</div><div class="line">&#123;</div><div class="line">    $n = count($lists);</div><div class="line">    $step = 2;</div><div class="line">    $gap = intval($n / $step);</div><div class="line">    while ($gap &gt; 0) &#123;</div><div class="line">        for ($gi = 0; $gi &lt; $gap; $gi++) &#123;</div><div class="line">            for ($i = $gi; $i &lt; $n; $i += $gap) &#123;</div><div class="line">                $key = $lists[$i];</div><div class="line">                for ($j = $i - $gap; $j &gt;= 0 &amp;&amp; $lists[$j] &gt; $key; $j -= $gap) &#123;</div><div class="line">                    $lists[$j + $gap] = $lists[$j];</div><div class="line">                    $lists[$j] = $key;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        $gap = intval($gap / $step);</div><div class="line">    &#125;</div><div class="line">    return $lists;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8 基数排序"></a>8 基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/unnamed-file.gif" alt="img"></p><p>说基数排序之前，我们简单介绍桶排序：</p><p>桶排序是将阵列分到有限数量的桶子里。</p><p>每个桶子再个别排序，有可能再使用别的排序算法，或是以递回方式继续使用桶排序进行排序。</p><p>桶排序是鸽巢排序的一种归纳结果。</p><p>当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间<code>O(n)</code>。</p><p>但桶排序并不是 比较排序，他不受到 <code>O(n log n)</code> 下限的影响。</p><p>简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。</p><p>例如，要对大小为<code>[1..1000]</code>范围内的<code>n</code>个整数<code>A[1..n]</code>排序</p><p>首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储   (10..20]的整数，……集合B[i]存储(   (i-1)<em>10,   i</em>10]的整数，i   =   1,2,..100。总共有  100个桶。</p><p>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。  再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任  何排序法都可以。</p><p>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这  样就得到所有数字排好序的一个序列了。</p><p>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。</p><p>如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是</p><p>O(n   +   m   <em>   n/m</em>log(n/m))   =   O(n   +   nlogn   –   nlogm)</p><p>从上式看出，当m接近n的时候，桶排序复杂度接近O(n)</p><p>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的  ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。</p><p>前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：</p><p>1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</p><p>2）其次待排序的元素都要在一定的范围内等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 基数排序</div><div class="line"> *</div><div class="line"> * @param array $lists</div><div class="line"> * @return array</div><div class="line"> */</div><div class="line">function radix_sort(array $lists)</div><div class="line">&#123;</div><div class="line">    $radix = 10;</div><div class="line">    $max = max($lists);</div><div class="line">    $k = ceil(log($max, $radix));</div><div class="line">    if ($max == pow($radix, $k)) &#123;</div><div class="line">        $k++;</div><div class="line">    &#125;</div><div class="line">    for ($i = 1; $i &lt;= $k; $i++) &#123;</div><div class="line">        $newLists = array_fill(0, $radix, []);</div><div class="line">        for ($j = 0; $j &lt; count($lists); $j++) &#123;</div><div class="line">            $key = $lists[$j] / pow($radix, $i - 1) % $radix;</div><div class="line">            $newLists[$key][] = $lists[$j];</div><div class="line">        &#125;</div><div class="line">        $lists = [];</div><div class="line">        for ($j = 0; $j &lt; $radix; $j++) &#123;</div><div class="line">            $lists = array_merge($lists, $newLists[$j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $lists;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>各种排序的稳定性，时间复杂度、空间复杂度、稳定性总结如下图：</p><p><img src="https://www.awaimai.com/wp-content/uploads/2017/12/sort_table.jpg" alt="img"></p><p>关于时间复杂度：</p><p>(1)平方阶(O(n2))排序<br> 各类简单排序:直接插入、直接选择和冒泡排序；</p><p>(2)线性对数阶(O(nlog2n))排序<br> 　　快速排序、堆排序和归并排序；<br> (3)O(n1+§))排序,§是介于0和1之间的常数。</p><p>希尔排序</p><p>(4)线性阶(O(n))排序</p><p>基数排序，此外还有桶、箱排序。</p><p>关于稳定性：</p><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博文是来自 &lt;code&gt;https://www.awaimai.com/1980.html&lt;/code&gt;，但是都是基于面向过程的代码编写，我用面向对象的方式重新实现了一边，并且按照自己的写作习惯进行了重新编辑。&lt;/p&gt;
&lt;p&gt;在 PHP 日常开发过程中，接触算法的机会并
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP基础教程：Memcache</title>
    <link href="http://www.maksim.website/2018/06/29/1/"/>
    <id>http://www.maksim.website/2018/06/29/1/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2018-06-29T15:43:57.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Memcache"><a href="#什么是Memcache" class="headerlink" title="什么是Memcache"></a>什么是Memcache</h1><p>Memcache是一个自由、源码开放、高性能、分布式的分布式内存对象缓存系统 ，用于动态Web应用以减轻数据库的负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高了网站访问的速度。Memcache是一个存储键值对的HashMap，在内存中对任意的数据（比如字符串、对象等）所使用的key-value存储，数据可以来自数据库调用、API调用，或者页面渲染的结果。MemCache设计理念就是小而强大，它简单的设计促进了快速部署、易于开发并解决面对大规模的数据缓存的许多难题，而所开放的API使得MemCache能用于Java、C/C++/C#、Perl、Python、PHP、Ruby等大部分流行的程序语言。 </p><p><strong>MemCache 和 MemCached：</strong></p><p>MemCache是这个项目的名称，而MemCached是服务器端的主程序名称。</p><h1 id="Memcache使用场景"><a href="#Memcache使用场景" class="headerlink" title="Memcache使用场景"></a>Memcache使用场景</h1><p>通常，我们会在访问量高的Web网站和应用中使用Memcache，用来缓解数据库的压力，并且提升网站和应用的响应速度。</p><p><strong>在应用程序中，我们通常在以下节点来使用MemCached：</strong></p><ol><li>访问频繁的数据库数据（身份token、首页动态）</li><li>访问频繁的查询条件和结果</li><li>作为Session的存储方式（提升Session存取性能）</li><li>页面缓存</li><li>更新频繁的非重要数据（访客量、点击次数）</li><li>大量的hot数据</li></ol><h1 id="安装Memcache"><a href="#安装Memcache" class="headerlink" title="安装Memcache"></a>安装Memcache</h1><p>我们在Linux上安装软件一般会采取两种方案，一种是编译安装，另外一种是使用Linux系统为我们提供的包管理工具。</p><p>在安装Memcache之前，我们需要提前安装Libevent，因为Memcache的实现依赖于这个库。</p><p>编译安装的好处是我们可以自定义一些设置，比如说安装到指定的目录下，相对而言假如你在编译时发生一些错误，而你对Linux又不是特别了解的话，可能处理错误时比较困难。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y memcached</div></pre></td></tr></table></figure><p>启动memcache</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">memcached -d -l 127.0.0.1 -p 11211 -m 150 -u root</div></pre></td></tr></table></figure><ul><li>-d 守护进程</li><li>-l IP地址</li><li>-p 端口号</li><li>-m 分配内存</li><li>-u 以什么用户进行运行（在线上不建议使用 root）</li></ul><h1 id="客户端的安装过程"><a href="#客户端的安装过程" class="headerlink" title="客户端的安装过程"></a>客户端的安装过程</h1><p>安装PHP的memcahed扩展需要<a href="http://libmemcached.org/libMemcached.html" target="_blank" rel="noopener">» libmemcached</a>客户端库（版本大于等于 1.0.0）。链接 memcached 服务器时使用SASL认证，需要libmemcached 必须开启SASL选项。</p><p>Memcached从0.2.0开始，要求PHP版本大于等于5.2.0。</p><p>如果libmemcached被安装在一个非标准路径，使用<strong>–with-libmemcached-dir=DIR</strong> 来指定路径，DIR就是libmemcached安装时的prefix参数。这个路径需要包含文件include/libmemcached/memcached.h。</p><p>如果要支持压缩就需要zlib。对于非标准安装的zlib库，使用<strong>–with-zlib-dir=DIR</strong> 来指定zlib安装路径，DIR就是zib安装时的prefix参数。</p><p>session处理器的支持默认是开启的。如果要关闭它，使用选项<strong>–disable-memcached-session</strong> 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Memcache&quot;&gt;&lt;a href=&quot;#什么是Memcache&quot; class=&quot;headerlink&quot; title=&quot;什么是Memcache&quot;&gt;&lt;/a&gt;什么是Memcache&lt;/h1&gt;&lt;p&gt;Memcache是一个自由、源码开放、高性能、分布式的分布式内存对象
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>Swoole 基础（二）：创建 TCP 服务器</title>
    <link href="http://www.maksim.website/2018/06/13/1/"/>
    <id>http://www.maksim.website/2018/06/13/1/</id>
    <published>2018-06-12T16:00:00.000Z</published>
    <updated>2018-07-05T15:02:13.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建TCP服务器"><a href="#创建TCP服务器" class="headerlink" title="创建TCP服务器"></a>创建TCP服务器</h1><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>server.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//创建Server对象，监听 127.0.0.1:9501端口</div><div class="line">$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501); </div><div class="line"></div><div class="line">//监听连接进入事件</div><div class="line">$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123;  </div><div class="line">    echo &quot;Client: Connect.\n&quot;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//监听数据接收事件</div><div class="line">$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123;</div><div class="line">    $serv-&gt;send($fd, &quot;Server: &quot;.$data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//监听连接关闭事件</div><div class="line">$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123;</div><div class="line">    echo &quot;Client: Close.\n&quot;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//启动服务器</div><div class="line">$serv-&gt;start();</div></pre></td></tr></table></figure><p>这里就创建了一个TCP服务器，监听本机9501端口。它的逻辑很简单，当客户端Socket通过网络发送一个 <code>hello</code> 字符串时，服务器会回复一个 <code>Server: hello</code> 字符串。</p><p>swoole_server是异步服务器，所以是通过监听事件的方式来编写程序的。当对应的事件发生时底层会主动回调指定的PHP函数。如当有新的TCP连接进入时会执行onConnect事件回调，当某个连接向服务器发送数据时会回调onReceive函数。</p><ul><li>服务器可以同时被成千上万个客户端连接，$fd就是客户端连接的唯一标识符</li><li>调用 <code>$server-&gt;send()</code> 方法向客户端连接发送数据，参数就是$fd客户端标识符</li><li>调用 <code>$server-&gt;close()</code> 方法可以强制关闭某个客户端连接</li><li>客户端可能会主动断开连接，此时会触发onClose事件回调</li></ul><h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php server.php</div></pre></td></tr></table></figure><p>在命令行下运行server.php程序，启动成功后可以使用 <code>netstat</code> 工具看到，已经在监听9501端口。这时就可以使用telnet/netcat工具连接服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">telnet 127.0.0.1 9501</div><div class="line">hello</div><div class="line">Server: hello</div></pre></td></tr></table></figure><h2 id="无法连接到服务器的简单检测手段"><a href="#无法连接到服务器的简单检测手段" class="headerlink" title="无法连接到服务器的简单检测手段"></a>无法连接到服务器的简单检测手段</h2><ul><li>在<code>Linux</code>下，使用<code>netstat -an | grep 端口</code>，查看端口是否已经被打开处于<code>Listening</code>状态</li><li>上一步确认后，检查防火墙问题</li><li>注意服务器所使用的IP地址，如果是<code>127.0.0.1</code>回环地址，则客户端只能使用<code>127.0.0.1</code>才能连接上</li></ul><h1 id="创建TCP-客户端"><a href="#创建TCP-客户端" class="headerlink" title="创建TCP 客户端"></a>创建TCP 客户端</h1><p>client.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">//连接 swoole tcp 服务</span></div><div class="line">$client = <span class="keyword">new</span> swoole_client(SWOOLE_SOCK_TCP);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!$client-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">9501</span>)) &#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"连接失败"</span>;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//PHP CLI 常量，swoole大部分功能都是在 CLI 模式下运作的。</span></div><div class="line">fwrite(STDOUT, <span class="string">"请输入消息："</span>);</div><div class="line">$msg = trim(fgets(STDIN));</div><div class="line"></div><div class="line"><span class="comment">//发送给 TCP Server</span></div><div class="line">$client-&gt;send($msg);</div><div class="line"></div><div class="line"><span class="comment">//接受来自 server 的数据</span></div><div class="line">$result = $client-&gt;recv();</div><div class="line"></div><div class="line"><span class="keyword">echo</span> $result.<span class="string">"\n"</span>;</div></pre></td></tr></table></figure><p>Swoole 的 UDP 实现和 TCP 的实现基本一致，下一章就不再讲解如何搭建 UDP 服务了，而是 HTTP 服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创建TCP服务器&quot;&gt;&lt;a href=&quot;#创建TCP服务器&quot; class=&quot;headerlink&quot; title=&quot;创建TCP服务器&quot;&gt;&lt;/a&gt;创建TCP服务器&lt;/h1&gt;&lt;h2 id=&quot;程序代码&quot;&gt;&lt;a href=&quot;#程序代码&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="php" scheme="http://www.maksim.website/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>Swoole 基础（二）：创建 TCP 服务器</title>
    <link href="http://www.maksim.website/2018/06/13/1/"/>
    <id>http://www.maksim.website/2018/06/13/1/</id>
    <published>2018-06-12T16:00:00.000Z</published>
    <updated>2018-07-05T15:08:17.817Z</updated>
    
    <content type="html"><![CDATA[<p>swoole-1.7.7增加了内置Http服务器的支持，通过几行代码即可写出一个异步非阻塞多进程的Http服务器。swoole_http_server对Http协议的支持并不完整，建议仅作为应用服务器。并且在前端增加Nginx作为代理</p><p>通过使用apache bench工具进行压力测试，在Inter Core-I5 4核 + 8G内存的普通PC机器上，swoole_http_server可以达到近11万QPS。远远超过php-fpm，golang自带http服务器，node.js自带http服务器。性能几乎接近与Nginx的静态文件处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ab -c 200 -n 200000 -k http://127.0.0.1:9501</div></pre></td></tr></table></figure><h1 id="创建Web服务器"><a href="#创建Web服务器" class="headerlink" title="创建Web服务器"></a>创建Web服务器</h1><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>http_server.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$http = <span class="keyword">new</span> swoole_http_server(<span class="string">"0.0.0.0"</span>, <span class="number">9501</span>);</div><div class="line"></div><div class="line">$http-&gt;on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($request, $response)</span> </span>&#123;</div><div class="line">    var_dump($request-&gt;get, $request-&gt;post);</div><div class="line">    $response-&gt;header(<span class="string">"Content-Type"</span>, <span class="string">"text/html; charset=utf-8"</span>);</div><div class="line">    $response-&gt;end(<span class="string">"&lt;h1&gt;Hello Swoole. #"</span>.rand(<span class="number">1000</span>, <span class="number">9999</span>).<span class="string">"&lt;/h1&gt;"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$http-&gt;start();</div></pre></td></tr></table></figure><p>Http服务器只需要关注请求响应即可，所以只需要监听一个<code>onRequest</code>事件。当有新的Http请求进入就会触发此事件。事件回调函数有2个参数，一个是$request对象，包含了请求的相关信息，如GET/POST请求的数据。</p><p>另外一个是response对象，对request的响应可以通过操作response对象来完成。$response-&gt;end()方法表示输出一段HTML内容，并结束此请求。</p><ul><li><code>0.0.0.0</code> 表示监听所有IP地址，一台服务器可能同时有多个IP，如<code>127.0.0.1</code>本地回环IP、<code>192.168.1.100</code>局域网IP、<code>210.127.20.2</code> 外网IP，这里也可以单独指定监听一个IP</li><li><code>9501</code> 监听的端口，如果被占用程序会抛出致命错误，中断执行。</li></ul><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php http_server.php</div></pre></td></tr></table></figure><ul><li>可以打开浏览器，访问<code>http://127.0.0.1:9501</code>查看程序的结果。</li><li>也可以使用apache <code>ab</code>工具对服务器进行压力测试</li></ul><h2 id="使用Http2协议"><a href="#使用Http2协议" class="headerlink" title="使用Http2协议"></a>使用Http2协议</h2><ul><li>需要依赖<code>nghttp2</code>库，<a href="https://github.com/tatsuhiro-t/nghttp2" target="_blank" rel="noopener">下载nghttp2</a>后编译安装</li><li>使用<code>Http2</code>协议必须开启<code>openssl</code></li><li>需要高版本<code>openssl</code>必须支持<code>TLS1.2</code>、<code>ALPN</code>、<code>NPN</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --enable-openssl --enable-http2</div></pre></td></tr></table></figure><p>设置http服务器的<code>open_http2_protocol</code>为<code>true</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$serv = <span class="keyword">new</span> swoole_http_server(<span class="string">"127.0.0.1"</span>, <span class="number">9501</span>, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);</div><div class="line">$serv-&gt;set([</div><div class="line">    <span class="string">'ssl_cert_file'</span> =&gt; $ssl_dir . <span class="string">'/ssl.crt'</span>,</div><div class="line">    <span class="string">'ssl_key_file'</span> =&gt; $ssl_dir . <span class="string">'/ssl.key'</span>,</div><div class="line">    <span class="string">'open_http2_protocol'</span> =&gt; <span class="keyword">true</span>,</div><div class="line">]);</div></pre></td></tr></table></figure><h2 id="nginx-swoole配置"><a href="#nginx-swoole配置" class="headerlink" title="nginx+swoole配置"></a>nginx+swoole配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">root</span> /data/wwwroot/;</div><div class="line">    <span class="attribute">server_name</span> local.swoole.com;</div><div class="line"></div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">"keep-alive"</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">        <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</div><div class="line">             <span class="attribute">proxy_pass</span> http://127.0.0.1:9501;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;swoole-1.7.7增加了内置Http服务器的支持，通过几行代码即可写出一个异步非阻塞多进程的Http服务器。swoole_http_server对Http协议的支持并不完整，建议仅作为应用服务器。并且在前端增加Nginx作为代理&lt;/p&gt;
&lt;p&gt;通过使用apache b
      
    
    </summary>
    
      <category term="php" scheme="http://www.maksim.website/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>Swoole 基础（一）：起步</title>
    <link href="http://www.maksim.website/2018/06/12/1/"/>
    <id>http://www.maksim.website/2018/06/12/1/</id>
    <published>2018-06-11T16:00:00.000Z</published>
    <updated>2018-06-25T12:37:34.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>Swoole 是使用纯 C 语言编写，提供了 PHP 语言的异步多线程服务器，异步 TCP/UDP 网络客户端，异步 MySQL，异步 Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询。 Swoole内置了Http/WebSocket服务器端/客户端、Http2.0服务器端。</p><p>除了异步 IO 的支持之外，Swoole 为 PHP 多进程的模式设计了多个并发数据结构和IPC通信机制，可以大大简化多进程并发编程的工作。其中包括了并发原子计数器，并发 HashTable，Channel，Lock，进程间通信IPC等丰富的功能特性。</p><p>Swoole2.0 支持了类似 Go 语言的协程，可以使用完全同步的代码实现异步程序。PHP 代码无需额外增加任何关键词，底层自动进行协程调度，实现异步。</p><p>Swoole 的官网是 <a href="http://www.swoole.com" target="_blank" rel="noopener">http://www.swoole.com</a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>移动互联网 API 服务器</li><li>物联网（IOT）</li><li>微服务（Micro Service）</li><li>高性能 Web 服务器</li><li>游戏服务器</li><li>在线聊天室</li></ul><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>安装扩展的方法有很多，那么我们为什么要学习编译安装呢，因为大公司基本上都是以编译进行安装。</p><p>在 PHP 内核书中也提到过，建议开发者以编译形式进行安装，这样可以根据业务要求进行定制安装，例如线程安全等功能，而且对 PHP 的运行速度也会有稍微提升。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Linux 环境下</li><li>PHP7  Swoole 2.1 redis</li><li>源码安装 PHP7、Swoole</li></ul><h2 id="获取-PHP-源代码"><a href="#获取-PHP-源代码" class="headerlink" title="获取 PHP 源代码"></a>获取 PHP 源代码</h2><p>我们可以到 PHP 官网下载，我们的生产环境都不会使用集成环境，比如 PHPStudy，WAMP，在生产环境我们都是使用编译安装 PHP 源代码。</p><p>我们最好选择最新的 PHP 版本，到本博文截止，最新的版本是7.2.6。</p><p>下载好后我们将其解压，然后按照如下步骤进行安装：</p><ol><li>configure</li><li>make</li><li>make install </li></ol><p>configure 可以对即将安装的软件进行配置与依赖检测，在这里需要注意，编译安装 PHP 需要用到 GCC、autoconfig，如果没有这两个依赖，请进行安装，configure 会给出提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/home/work/stduy/soft/php</div></pre></td></tr></table></figure><ul><li>–prefix 安装目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make </div><div class="line">make test //对编译结果进行测试</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make install</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /home/work/stduy/soft/php/bin</div><div class="line">./php -v</div></pre></td></tr></table></figure><p>我们可以看到PHP 的版本信息记大功搞成。</p><p>这样 PHP7.2.6 就已经安装完毕了。</p><p>但是每一次都要进入该目录是在是太麻烦了，我们可以直接修改系统的环境变量，也就是 profile。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo vim ~/.bash_profile</div><div class="line">alias /home/work/stduy/soft/php/bin/php</div><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure><h2 id="编译安装-Swoole"><a href="#编译安装-Swoole" class="headerlink" title="编译安装 Swoole"></a>编译安装 Swoole</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><ul><li>仅支持 <code>Linux</code>、<code>FreeBSD</code>、<code>MacOS</code> 三种操作系统</li><li>在<code>Windows</code>平台，可使用<code>CygWin</code>或<code>WSL(Windows Subsystem for Linux)</code></li><li><code>Linux</code> 内核版本 <code>2.3.32</code> 以上</li><li><code>gcc4.4</code> 以上版本或者<code>clang</code></li><li><code>4.x</code>版本起需要<code>gcc-4.8</code>或更高版本</li><li>编译为 <code>libswoole.so</code> 作为 <code>C/C++</code> 库时需要使用 <code>cmake-2.4</code> 或更高版本</li></ul><blockquote><p> 建议使用 <code>Ubuntu14</code>、<code>CentOS7</code> 或更高版本的操作系统</p></blockquote><h3 id="PHP版本依赖"><a href="#PHP版本依赖" class="headerlink" title="PHP版本依赖"></a>PHP版本依赖</h3><ul><li><code>Swoole-1.x</code>需要<code>PHP-5.3.10</code>或更高版本</li><li><code>Swoole-2.x</code>需要<code>PHP-7.0.0</code>或更高版本</li><li>依赖不<code>PHP</code>的<code>stream</code>，<code>sockets</code>，<code>pcntl</code>，<code>posix</code>，<code>sysvmsg</code>等扩展。<code>PHP</code>只需安装最基本的扩展即可</li></ul><h3 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h3><p>安装swoole前必须保证系统已经安装了下列软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">php-5.3.10 或更高版本</div><div class="line">gcc-4.4 或更高版本</div><div class="line">make</div><div class="line">autoconf</div><div class="line">pcre (centos系统可以执行命令：yum install pcre-devel)</div></pre></td></tr></table></figure><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><ul><li><a href="https://github.com/swoole/swoole-src/releases" target="_blank" rel="noopener">https://github.com/swoole/swoole-src/releases</a></li><li><a href="http://pecl.php.net/package/swoole" target="_blank" rel="noopener">http://pecl.php.net/package/swoole</a></li><li><a href="http://git.oschina.net/swoole/swoole" target="_blank" rel="noopener">http://git.oschina.net/swoole/swoole</a></li></ul><p>下载源代码包后，在终端进入源码目录，执行下面的命令进行编译和安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd swoole</div><div class="line">phpize</div><div class="line">./configure</div><div class="line">make </div><div class="line">sudo make install</div></pre></td></tr></table></figure><h3 id="完整编译示例"><a href="#完整编译示例" class="headerlink" title="完整编译示例"></a>完整编译示例</h3><p>以下脚本会下载并编译主分支的swoole源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mkdir -p ~/build &amp;&amp; \</div><div class="line">cd ~/build &amp;&amp; \</div><div class="line">rm -rf ./swoole-src &amp;&amp; \</div><div class="line">curl -o ./tmp/swoole.tar.gz https://github.com/swoole/swoole-src/archive/master.tar.gz -L &amp;&amp; \</div><div class="line">tar zxvf ./tmp/swoole.tar.gz &amp;&amp; \</div><div class="line">mv swoole-src* swoole-src &amp;&amp; \</div><div class="line">cd swoole-src &amp;&amp; \</div><div class="line">phpize &amp;&amp; \</div><div class="line">./configure \</div><div class="line">--enable-coroutine \</div><div class="line">--enable-openssl  \</div><div class="line">--enable-http2  \</div><div class="line">--enable-async-redis \</div><div class="line">--enable-sockets \</div><div class="line">--enable-mysqlnd &amp;&amp; \</div><div class="line">make clean &amp;&amp; make &amp;&amp; sudo make install</div></pre></td></tr></table></figure><p>详细参数详解请到swoole 官方文档进行查看——<a href="https://wiki.swoole.com/wiki/page/437.html" target="_blank" rel="noopener">传送门</a>。</p><h3 id="PECL"><a href="#PECL" class="headerlink" title="PECL"></a>PECL</h3><p>swoole项目已收录到PHP官方扩展库，除了手工下载编译外，还可以通过PHP官方提供的PECL命令，一键下载安装swoole</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pecl install swoole</div></pre></td></tr></table></figure><h2 id="配置的php-ini"><a href="#配置的php-ini" class="headerlink" title="配置的php.ini"></a>配置的php.ini</h2><p>编译安装成功后，修改php.ini中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension=swoole.so</div></pre></td></tr></table></figure><p>通过<code>php -m</code>或<code>phpinfo()</code>来查看是否成功加载了swoole，如果可能没有的英文<code>php.ini</code>的路径不对，使用可以<code>php --ini</code>来定位到<code>php.ini</code>的绝对路径</p><p>这样我们进入下载的 swoole 目录下，进入 <code>[examples]</code>目录运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php echo.php</div></pre></td></tr></table></figure><p>如果没有报错便是安装成功了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h1&gt;&lt;p&gt;Swoole 是使用纯 C 语言编写，提供了 PHP 语言的异步多线程服务器，异步 TCP/UDP 网络客户端，异步 MySQL，异步 Re
      
    
    </summary>
    
      <category term="php" scheme="http://www.maksim.website/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构入门（03）： 队列</title>
    <link href="http://www.maksim.website/2018/05/04/1/"/>
    <id>http://www.maksim.website/2018/05/04/1/</id>
    <published>2018-05-03T16:00:00.000Z</published>
    <updated>2018-07-04T14:35:55.777Z</updated>
    
    <content type="html"><![CDATA[<p>队列 Queue 本身也是一种线性结构，依然是排成一排，相比数组，队列对应的操作也是数组的子集，不过和栈不同，我们只能从一端（队尾）添加元素，只能从另一端（队首）取出元素。我们可以将其想象成我们现实生活中的排队，第一个来的，要第一个出去。也就是说队列是一种先进先出（First In First Out[FIFO]）的数据结构。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/1243953170-57245f3329084_articlex.png" alt=""></p><h1 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h1><p>队列我们只要要实现以下方法</p><p>Queue\<e\></e\></p><ul><li>void enqueue(E)</li><li>E dequeue()</li><li>E getFornt()</li><li>int getSize()</li><li>boolean isEmpty()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Array;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">private</span> Array&lt;T&gt; array;</div><div class="line"><span class="function"><span class="keyword">public</span>  <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">array = <span class="keyword">new</span> Array&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> array.getSize();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> array.isEmpty();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.getCapacity();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">array.addLast(e);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.removeFirst();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getFront</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.getFirst();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">res.append(String.format(<span class="string">"Queue: "</span>));</div><div class="line">res.append(<span class="string">"front ["</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.getSize(); i++) &#123;</div><div class="line">res.append(array.get(i));</div><div class="line"><span class="keyword">if</span> (i != array.getSize() -<span class="number">1</span>) &#123;</div><div class="line">res.append(<span class="string">","</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">res.append(<span class="string">']'</span>);</div><div class="line"><span class="keyword">return</span> res.toString();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Queue: front [0] tail</div><div class="line">Queue: front [0,1] tail</div><div class="line">Queue: front [0,1,2] tail</div><div class="line">Queue: front [1,2] tail</div><div class="line">Queue: front [1,2,3] tail</div><div class="line">Queue: front [1,2,3,4] tail</div><div class="line">Queue: front [1,2,3,4,5] tail</div><div class="line">Queue: front [2,3,4,5] tail</div><div class="line">Queue: front [2,3,4,5,6] tail</div><div class="line">Queue: front [2,3,4,5,6,7] tail</div><div class="line">Queue: front [2,3,4,5,6,7,8] tail</div><div class="line">Queue: front [3,4,5,6,7,8] tail</div><div class="line">Queue: front [3,4,5,6,7,8,9] tail</div></pre></td></tr></table></figure><h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p>数组队列是有局限性的，主要是在于出队这个操作，他的时间复杂度是 O(N) ，当我们删除队首时候，后面的元素都要向前移动一位，这是数组实现队列删除元素走的这样的一个过程，所以他的时间复杂度是O(N)。</p><p>如果我们删除首位后，其他位置不向前移动，因为这样后面的元素，还是保持着队列的样子，所以可以在数组中记录队首是谁 (front)，如果删除了队首[0]，那么就将队首的位置设置成[1]。</p><p>这种数据结构也就是循环队列。</p><p>当队列中一个内容都没有的时候，front(队首)和 tail 队尾指向是在一起的。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/Jietu20180704-210707.jpg" alt=""></p><p>也就是说，当front == tail 的时候，就说明队列为空，只要数组内容不为空，tail 和 front 就不可能相等，当有内容入队了，我们只需要维护 tail 将其指向下一个元素要入队时的位置就可以了，也就是 tail++。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/Jietu20180704-211137.jpg" alt=""></p><p>如果此时队列中已经拥有五个元素了，当我们要进行出队时，只需要将front 指向的元素出队，并且维护 front 向后移动一位。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/Jietu20180704-211545.jpg" alt=""></p><p>我们可以看出循环队列不再要求所有的元素进行移动了，只需要维护 front 的指向改变就可以了。</p><p>现在结构相对简单，但是并不能体现出循环，当入队的元素达到了容量的上限时，tail 就不能再向后移动了。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/Jietu20180704-212058.jpg" alt=""></p><p>从上图我们可以看到，由于队首的元素移出数组之后余下的空间，没有被后面的数据占用，所以前面也许还有可以利用的空间，这就是循环队列的来由。</p><p>其实我们就是把我们的数组看成一个环，现在的数组一共可以容纳8个元素，索引是0到7，7之后的索引其实是0，而此时我们就可以判断数组空间已经被沾满了，</p><p>上面我们说过维护 tail 就是 ++ 运算，但是如果是循环队列就不准确了，应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">（当前索引 + 1） % 数组的长度</div></pre></td></tr></table></figure><p>从7计算到0，就是 <code>(7 + 1) % 8 = 0</code>。0这位置还能放心的元素，如果再次加入元素，新的元素就会被放置到0这个位置上。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/Jietu20180704-212959.jpg" alt="">\</p><p>现在到了这种情况，1这个位置是空的，那么是否还能在向其中插入元素呢？</p><p>需要注意的是，我们之前提到过 front == tail 队列为空，如果再有一个新的元素入队了，放到[1]这个位置上，我们的 tail 就会与 front 相等，这个时候，我们的队列其实并不为空，如果还让新的元素可以进来的话，front == tail 既可以表示队列为空，又可以便是队列为满了，这并不是我们希望看到的条件。</p><p>队列满我们应该用 <strong><code>（tail + 1） % capacity == 0</code></strong>。</p><p>当我们在进行入队操作时，发现队列以满之后就可以扩容了，也就是说这样会被浪费掉一个空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;队列 Queue 本身也是一种线性结构，依然是排成一排，相比数组，队列对应的操作也是数组的子集，不过和栈不同，我们只能从一端（队尾）添加元素，只能从另一端（队首）取出元素。我们可以将其想象成我们现实生活中的排队，第一个来的，要第一个出去。也就是说队列是一种先进先出（Firs
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.maksim.website/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构入门（03）：栈</title>
    <link href="http://www.maksim.website/2018/05/03/1/"/>
    <id>http://www.maksim.website/2018/05/03/1/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-07-03T14:22:57.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><p>今天给大家讲解一个全新的线性结构分别是栈和队列，在这一篇文章的前半部分我会首先讲解栈。</p><p>栈也是一种线性结构，比起数组，栈对应的操作是数组的子集。</p><p>栈只能从一端添加元素，也只能从一端取出元素，这一端也被称为<strong>栈顶</strong>。</p><p>向栈添加数据我们将其称之为入栈，如下图：</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180702091057.png" alt=""></p><p>当我们想要取出数据时候，我们只能从栈顶取出数据，也就是说，我们首先取出的是3，然后才是2，1这样的一个顺序。</p><p>按照这个顺序执行，所以栈被称之为<strong>后进先出（Last In First Out [LIFO]）</strong>的数据结构。3其实是最后一个被放到栈中的数据，却是第一个被取出的数据。</p><p>在计算机世界里，栈拥有者不可思议的作用，事实上，在别的数据结构中还会看到栈的作用，甚至我们在学习经典算法或者算法设计的时候都将不可避免的看到栈，看起来很简单，但是应用起来非常广泛的数据结构。</p><ul><li><p>无处不在的Undo操作（撤销）</p></li><li><p>程序调用所使用的系统栈</p></li></ul><p>撤销操作其实很好理解，当我们在编辑器中输入内容时候，比如我们输入XXX、我、喜欢你，这一组数据的时候，其实就是一次入栈操作，依次将XXX、我、喜欢你、压入栈中。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180702095131.png" alt=""></p><p>当我们，感觉喜欢你，不如我爱你贴切的时候，可以执行撤销操作，将喜欢你从栈中取出来，然后输入爱你。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180702095415.png" alt=""></p><p>在我们系统执行中，总会碰到先终止，然后到另外的一个逻辑去执行，所谓的子函数的调用就是这个过程。这个时候，系统就会使用被称之为系统栈的数据结构，来记录程序调用的过程。我们同样通过画图的形式来带领大家理解。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180702101428.png" alt=""></p><p>通过上图中的业务逻辑，我们其实同时也可以很好的理解递归调用的原理，我们在上学时候，或者是在一些文章中总能看到说递归其实就是自己调用自己，这么说是为了让大家方便理解，但是其实真正的原理，就是系统帮助我们进行压栈。</p><h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><p>Stack\<e\></e\></p><ul><li>void push(E)  入栈</li><li>E pop()           出栈</li><li>E peek()         查看栈顶(top)</li><li>int getSize()   获取栈的大小</li><li>boolean isEmpty();   判断栈是否为空</li></ul><p>从用户的角度来看，我们只需要支持这些操作就完全可以了。具体底层实现，用户是不关心的，实际上底层的实现有多重实现方法。</p><p>在这一篇文章中，我只介绍一种使用动态数组实现ArrayStack的栈，在后续文章中再去介绍另外一种实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Array;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">T</span>&gt;  </span>&#123;</div><div class="line">Array&lt;T&gt; array;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">array = <span class="keyword">new</span> Array&lt;&gt;(capacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span> </span>&#123;</div><div class="line">array = <span class="keyword">new</span> Array&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.getSize();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.isEmpty();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.getCapacity();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span> <span class="params">(T e)</span> </span>&#123;</div><div class="line">array.addLast(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.removeLast();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.getLast();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">res.append(<span class="string">"Stack: ["</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.getSize(); i++) &#123;</div><div class="line">res.append(array.get(i));</div><div class="line"><span class="keyword">if</span> (i != array.getSize() - <span class="number">1</span>) &#123;</div><div class="line">res.append(<span class="string">", "</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">res.append(<span class="string">"] top"</span>);</div><div class="line"><span class="keyword">return</span> res.toString();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意其中的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> array.getLast(); </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里，我们复用来我们自己所编写的动态数组Array 类，但是并不完善，并没有提供 getLast 这个功能，其实这个很简单，只需要我们自己实现以下就好了，根据  <code>Array.get</code> 方法就可以轻松实现。</p><p>我们可以看得出来，整个栈的编写非常简单，没有任何复杂的代码，完全是使用我们自己所编写的 Array 类便可以轻松的实现。</p><h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><p>在我们编程的时候，编译器会自动匹配{}、[]、()，编译器其实也是使用栈结构来进行括号匹配的。</p><p>这是在 LeetCode 上的一道题，编号是20：<a href="https://leetcode-cn.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/description/</a></p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: &quot;()&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: &quot;()[]&#123;&#125;&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: &quot;(]&quot;</div><div class="line">输出: false</div></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: &quot;([)]&quot;</div><div class="line">输出: false</div></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: &quot;&#123;[]&#125;&quot;</div><div class="line">输出: true</div></pre></td></tr></table></figure><p>如果当前我们有这样一串字符<code>{[()]}</code></p><p>我们可以声明一个栈，然后遍历栈中的每一个字符，如果字符是一个左括号，我们就将他压入栈，第一个是<code>{</code>我们将其压栈，然后是<code>[</code>压栈，然后<code>(</code>压栈，这样左括号就全部压入了栈中，往后将是右括号，当走到<code>）</code>的时候，我们查看栈顶的括号是否可以和<code>)</code>匹配。</p><p>如果匹配，则表示通过了验证，然后出栈，然后在向右验证，直到栈中没有数据。其实就是栈顶元素反映了在嵌套层次关系中，最近的需要匹配的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() ; i++) &#123;</div><div class="line"><span class="keyword">char</span> c = s.charAt(i);</div><div class="line"><span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>) &#123;</div><div class="line">stack.push(c);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">if</span> (stack.isEmpty()) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">char</span> topChar = stack.pop();</div><div class="line"><span class="keyword">if</span> (c == <span class="string">')'</span> &amp;&amp; topChar != <span class="string">'('</span>) </div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="keyword">if</span> (c == <span class="string">']'</span> &amp;&amp; topChar != <span class="string">'['</span>)</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="keyword">if</span> (c == <span class="string">'&#125;'</span> &amp;&amp; topChar != <span class="string">'&#123;'</span>) </div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//判断是否还有数据，如果还有数据则证明不完整，只有为空的时候则全都匹配上了。</span></div><div class="line"><span class="keyword">return</span> stack.isEmpty();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈的应用&quot;&gt;&lt;a href=&quot;#栈的应用&quot; class=&quot;headerlink&quot; title=&quot;栈的应用&quot;&gt;&lt;/a&gt;栈的应用&lt;/h1&gt;&lt;p&gt;今天给大家讲解一个全新的线性结构分别是栈和队列，在这一篇文章的前半部分我会首先讲解栈。&lt;/p&gt;
&lt;p&gt;栈也是一种线性结构，比
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.maksim.website/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构入门（02）：算法复杂度的分析</title>
    <link href="http://www.maksim.website/2018/05/02/1/"/>
    <id>http://www.maksim.website/2018/05/02/1/</id>
    <published>2018-05-01T16:00:00.000Z</published>
    <updated>2018-06-30T09:15:30.390Z</updated>
    
    <content type="html"><![CDATA[<p>算法这一个词汇这两年异常的火爆，就算不是计算机从业人员也对算法如雷贯耳，<em>Alpha</em>Go狂虐各国高手，算法多么多么牛*。</p><p>但是身为计算机从业人员，我们要知道对于一个给定的算法，我们要做两项分析。第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。</p><p>而在证明算法是正确的基础上，第二部就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。因此，作为程序员，掌握基本的算法时间复杂度分析方法是很有必要的。</p><p>算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。</p><ol><li>事后统计的方法</li><li>事前分析估算</li></ol><p>这种方法可行，但不是一个好的方法。该方法有两个缺陷：一是要想对设计的算法的运行性能进行评测，必须先依据算法编制相应的程序并实际运行；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优势。</p><p>因事后统计方法更多的依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。<strong>因此人们常常采用事前分析估算的方法。</strong></p><p>在编写程序前，依据统计方法对算法进行估算。一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p><ol><li>算法采用的策略、方法；</li><li>编译产生的代码质量；</li><li>问题的输入规模；</li><li>机器执行指令的速度。</li></ol><p>一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h2><p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p><p> 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，<strong>T(n)/f(n)</strong>的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作<strong>T(n)=Ｏ(f(n)),</strong>称<strong>Ｏ(f(n))</strong> 为算法的渐进时间复杂度，简称时间复杂度</p><p>另外，上面公式中用到的 Landau符号其实是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。</p><p><strong>Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界</strong>。在计算算法复杂度时一般只用到大<strong>O</strong>符号，Landau符号体系中的小<strong>o</strong>符号、<strong>Θ</strong>符号等等比较不常用。这里的<strong>O</strong>，最初是用大写希腊字母，但现在都用大写英语字母<strong>O</strong>；小<strong>o</strong>符号也是用小写英语字母<strong>o</strong>，<strong>Θ</strong>符号则维持大写希腊字母<strong>Θ</strong>。</p><p> <strong>T (n) = Ο(f (n))</strong> 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C <em> f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时<strong>T (n)</strong>的上界是**C \</em> f(n)。<strong>其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2<em>n</em>2+n +1) = O (3<em>n</em>2+n+3) = O (7<em>n</em>2 + n) = </strong>O ( n2 )<strong> ，一般都只用</strong>O(n2)**表示就可以了。</p><p>注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。</p><p>在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=<em>n</em>2+3n+4与T(n)=4<em>n</em>2+2n+1它们的频度不同，但时间复杂度相同，都为O(<em>n</em>2)。</p><p>按数量级递增排列，常见的时间复杂度有：常数阶<strong>O(1)</strong>,对数阶<strong>O(log2n),</strong>线性阶<strong>O(n),</strong> 线性对数阶<strong>O(nlog2n),</strong>平方阶<strong>O(n2)，</strong>立方阶<strong>O(n3)</strong>,…， k次方阶<strong>O(nk),</strong>指数阶<strong>O(2n)。</strong>随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p><p><img src="http://img.blog.csdn.net/20130920210031796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvem9sYWxhZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><strong>从图中可见，我们应该尽可能选用多项式阶O(nk)的算法，而不希望用指数阶的算法。</strong></p><p>常见的算法时间复杂度由小到大依次为：<strong>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)</strong></p><p>一般情况下，对一个问题（或一类算法）只需选择一种基本操作来讨论算法的时间复杂度即可，有时也需要同时考虑几种基本操作，甚至可以对不同的操作赋予不同的权值，以反映执行不同操作所需的相对时间，这种做法便于综合比较解决同一问题的两种完全不同的算法。</p><h2 id="求解算法的时间复杂度的具体步骤是"><a href="#求解算法的时间复杂度的具体步骤是" class="headerlink" title="求解算法的时间复杂度的具体步骤是"></a>求解算法的时间复杂度的具体步骤是</h2><p>⑴ 找出算法中的基本语句；</p><p>算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。</p><p>⑵ 计算基本语句的执行次数的数量级；</p><p>只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。</p><p>⑶ 用大Ο记号表示算法的时间性能。</p><p>将基本语句执行次数的数量级放入大Ο记号中。</p><p>如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)  &#123;</div><div class="line">     x++; </div><div class="line">&#125;</div><div class="line">        </div><div class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)  &#123;</div><div class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=n; j++) &#123;</div><div class="line">          x++; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(<em>n</em>2)，则整个算法的时间复杂度为Ο(n+<em>n</em>2)=Ο(<em>n</em>2)。</p><p>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中<strong>Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)</strong>称为多项式时间，<strong>而Ο(2n)和Ο(n!)称为指数时间</strong>。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为<strong>P（Polynomial,多项式）类问题</strong>，而把后者（即指数时间复杂度的算法）称为<strong>NP（Non-Deterministic Polynomial, 非确定多项式）问题</strong>。</p><p>一般来说多项式级的复杂度是可以接受的，很多问题都有多项式级的解——也就是说，这样的问题，对于一个规模是n的输入，在n^k的时间内得到结果，称为P问题。有些问题要复杂些，没有多项式时间的解，但是可以在多项式时间里验证某个猜测是不是正确。比如问4294967297是不是质数？如果要直接入手的话，那么要把小于4294967297的平方根的所有素数都拿出来，看看能不能整除。还好欧拉告诉我们，这个数等于641和6700417的乘积，不是素数，很好验证的，顺便麻烦转告费马他的猜想不成立。大数分解、Hamilton回路之类的问题，都是可以多项式时间内验证一个“解”是否正确，这类问题叫做NP问题。</p><h2 id="在计算算法时间复杂度时有以下几个简单的程序分析法则"><a href="#在计算算法时间复杂度时有以下几个简单的程序分析法则" class="headerlink" title="在计算算法时间复杂度时有以下几个简单的程序分析法则"></a>在计算算法时间复杂度时有以下几个简单的程序分析法则</h2><p>(1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间</p><p>(2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下”求和法则”</p><p><strong>求和法则</strong>:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))</p><p>特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))</p><p>(3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间</p><p>(4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下”乘法法则”</p><p><strong>乘法法则</strong>: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1<em>T2=O(f(n)</em>g(n))</p><p>(5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度</p><p>另外还有以下2个运算法则:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数</p><h2 id="常见的时间复杂度进行示例说明"><a href="#常见的时间复杂度进行示例说明" class="headerlink" title="常见的时间复杂度进行示例说明"></a>常见的时间复杂度进行示例说明</h2><p><strong>(1)、O(1)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Temp=i; i=j; j=temp;</div></pre></td></tr></table></figure><p>以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。</p><p><strong>注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</strong></p><p><strong>(2)、O(n2)</strong></p><p>2.1. 交换i和j的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum=<span class="number">0</span>；               （一次）  </div><div class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)     （n+<span class="number">1</span>次）  </div><div class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)     （n2次）  </div><div class="line">sum++；               （n2次）</div></pre></td></tr></table></figure><p>解：<strong>因为Θ(2n2+n+1)=n2（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n2)；</strong></p><p>2.2.   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)    &#123;   </div><div class="line">y=y+<span class="number">1</span>;         ①     </div><div class="line"><span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=(<span class="number">2</span>*n);j++)   &#123;</div><div class="line">x++;       ②  </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解： </p><p>语句1的频度是n-1</p><p>语句2的频度是(n-1)<em>(2n+1)=2<em>*n2</em></em>-n-1</p><p>f(n)=2<strong>n2</strong>-n-1+(n-1)=2<strong>n2</strong>-2；</p><p>又<strong>Θ(2n2-2)=n2</strong><br>该程序的时间复杂度T(n)=O(<strong>n2</strong>).  </p><p>一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。     </p><p><strong>(3)、O(n)</strong>                      </p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a=<span class="number">0</span>;  </div><div class="line">b=<span class="number">1</span>;                      ①  </div><div class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;      ② </div><div class="line">s=a+b;　　　　③  </div><div class="line">b=a;　　　　　④    </div><div class="line">a=s;　　　　　⑤  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解： </p><p>语句1的频度：2,        </p><p>语句2的频度： n,        </p><p>语句3的频度： n-1,        </p><p>语句4的频度：n-1,    </p><p>语句5的频度：n-1,                                  </p><p>T(n)=2+n+3(n-1)=4n-1=O(n).</p><p><strong>(4)、O(log2n)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i=<span class="number">1</span>;       ①  </div><div class="line"><span class="keyword">while</span> (i&lt;=n)  </div><div class="line">i=i*<span class="number">2</span>;      ②</div></pre></td></tr></table></figure><p>解： 语句1的频度是1,<br>          设语句2的频度是f(n),   则：2^f(n)&lt;=n;f(n)&lt;=<strong>log2n</strong><br>          取最大值f(n)=<strong>log2n</strong>,<br>          T(n)=O(<strong>log2n</strong> )</p><p><strong>(5)、O(n3)</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;    </div><div class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;i;j++) &#123;  </div><div class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;j;k++)  </div><div class="line">             x=x+<span class="number">2</span>;    </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,…,m-1 , 所以这里最内循环共进行了0+1+…+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)<em>1/2+…+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(<em>*n3</em></em>).</p><h2 id="常用的算法的时间复杂度和空间复杂度"><a href="#常用的算法的时间复杂度和空间复杂度" class="headerlink" title="常用的算法的时间复杂度和空间复杂度"></a>常用的算法的时间复杂度和空间复杂度</h2><p><img src="http://img.blog.csdn.net/20130920172327687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvem9sYWxhZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><strong>一个经验规则：</strong>其中c是一个常量，如果一个算法的复杂度为c 、 <strong>log2n</strong> 、n 、 n<strong>*log2n</strong> ,那么这个算法时间效率比较高 ，如果是<strong>2n</strong> ,<strong>3n</strong> ,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。</p><p>算法时间复杂度分析是一个很重要的问题，任何一个程序员都应该熟练掌握其概念和基本方法，而且要善于从数学层面上探寻其本质，才能准确理解其内涵。</p><h1 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h1><p>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。</p><p>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。</p><p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。</p><p>如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。</p><p>【1】如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x=<span class="number">91</span>; y=<span class="number">100</span>;</div><div class="line"><span class="keyword">while</span>(y&gt;<span class="number">0</span>) <span class="keyword">if</span>(x&gt;<span class="number">100</span>) &#123;x=x<span class="number">-10</span>;y--;&#125; <span class="keyword">else</span> x++;</div></pre></td></tr></table></figure><p>解答： T(n)=O(1)，<br>这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?<br>没。这段程序的运行是和n无关的，<br>就算它再循环一万年，我们也不管他，只是一个常数阶的函数</p><p>【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x=<span class="number">1</span>; </div><div class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) </div><div class="line"></div><div class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</div><div class="line"></div><div class="line">           <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=j;k++)</div><div class="line"></div><div class="line">               x++;</div></pre></td></tr></table></figure><p>该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数：  则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3)</p><p>【3】算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。</p><p>在数值A[0..n-1]中查找给定值K的算法大致如下：   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i=n<span class="number">-1</span>;            </div><div class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;(A[i]!=k))       </div><div class="line">i--;        </div><div class="line"><span class="keyword">return</span> i;</div></pre></td></tr></table></figure><p>此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。</p><h1 id="时间复杂度评价性能"><a href="#时间复杂度评价性能" class="headerlink" title="时间复杂度评价性能"></a>时间复杂度评价性能</h1><p>有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。</p><ol><li>当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。</li><li>随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;算法这一个词汇这两年异常的火爆，就算不是计算机从业人员也对算法如雷贯耳，&lt;em&gt;Alpha&lt;/em&gt;Go狂虐各国高手，算法多么多么牛*。&lt;/p&gt;
&lt;p&gt;但是身为计算机从业人员，我们要知道对于一个给定的算法，我们要做两项分析。第一是从数学上证明算法的正确性，这一步主要用到形式
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.maksim.website/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构入门（01）：数组</title>
    <link href="http://www.maksim.website/2018/05/01/1/"/>
    <id>http://www.maksim.website/2018/05/01/1/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-06-29T16:02:18.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h1><p>数组其实就是把所有数据码成一排进行存放，数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。 在Java中数组所存放的类型是固定的，在 PHP 中数组是可以存储不同类型数据的。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180626161609.png" alt=""></p><p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 length - 1。</p><p>在这里我们需要<strong>注意</strong>，<strong>索引可以有语意；也可以没有语意</strong>。如上图，scores[2]这个索引2可以有实际的意义，上面的8个索引，可以代表八名学生的成绩，而索引可以代表他们的学号，那么scores[2]就是取2号学员的分数。</p><p>当我调用scores[2]的时候，我看的就是学号为2这个同学得了多少分，2是由实际的语意。当然也可以没有语意，这个0、1、2、3、4、5、6、7，只是简单的它存放在第几个元素而已，不代表学生的学号，就是恰好在2这个位置存了一个分，比如说是66分，存在任何索引的位置都可以，因为这个索引是没有语意的，我们只是想将分数存在数组中而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="comment">// 数组大小</span></div><div class="line">      <span class="keyword">int</span> size = <span class="number">8</span>;</div><div class="line">      <span class="comment">// 定义数组</span></div><div class="line">      <span class="keyword">double</span>[] scores = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">8</span>];</div><div class="line">      scores[<span class="number">0</span>] = <span class="number">55.6</span>;</div><div class="line">      scores[<span class="number">1</span>] = <span class="number">60.5</span>;</div><div class="line">      scores[<span class="number">2</span>] = <span class="number">30.3</span>;</div><div class="line">      scores[<span class="number">3</span>] = <span class="number">18.2</span>;</div><div class="line">      scores[<span class="number">4</span>] = <span class="number">43.0</span>;</div><div class="line">      scores[<span class="number">5</span>] = <span class="number">34.33</span>;</div><div class="line">      scores[<span class="number">6</span>] = <span class="number">34.0</span>;</div><div class="line">      scores[<span class="number">7</span>] = <span class="number">45.45</span>;</div><div class="line">      <span class="comment">// 计算所有元素的总和</span></div><div class="line">      <span class="keyword">double</span> total = <span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">         total += scores[i];</div><div class="line">      &#125;</div><div class="line">      System.out.println(<span class="string">"总和为： "</span> + total);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面这段代码就是数组的操作，这里不再介绍其他语法，因为本文主要侧重于讲述数据结构，而不是Java的基础语法和使用。</p><p>数组最大的优点是快速查找，myList[2]，数组最好应用于“索引有语意”的情况。如果索引没有语义建议使用其他数据结构。</p><p>虽然如此，有很多场景即使我们可以给索引定义出语言，但是它可能并不适用使用数组，比如说身份证号，可以设计一个数组，存放一个人对应的工资情况，我想索引到不同的人，可能使用身份证号就是一个很好的方式。</p><p>身份证号：110103198512166666</p><p>但是我们不能使用身份证号做索引，因为这个数字太大了，我们要想使用这个数字当索引，我们至少要开辟身份证号那么大的空间，对于一般的计算机来说，开辟这么大的空间是不值当的，甚至是不可能的，更重要的是，我们就算开辟了这么大的空间，对于很多空间都是浪费的。</p><p>我们现在就要考察一个工作小组，里面只有十个人，为了十个人开辟这么大的空间显然是不合理的，很多空间明显是被浪费的，没有一个合法的身份证号是6666。</p><p>如果数组没有语意，又会产生很多新的问题。</p><p>在此时，数组只是一个待存放我们我们考察元素的一个空间，比如我们开辟了一个有八个元素的数组，但是可能我们只考察三个元素，此时就有问题了，剩下的空间就没有元素，当我们访问其余空间时就是非法的，因为从用户的角度来看，是没有3，4，5，6，7这些元素的，只有0、1、3，此时我们该如何表示没有的元素呢？</p><p>与此同时我们还会向数组中提那家元素和删除元素，这些操作要如何做呢？</p><p>还会有很多问题，最典型的就是我们的数组大小，在我们创建的时候就已经固定了，如果我们添加的元素，超过了八个我们要怎么做呢？</p><p>这篇文章就会解决这些问题，但是我们要知道 Java 并没有提供这些功能，我们必须编写属于自己的方法，来为数组添加元素或者删除元素。</p><p>所以我们要基于 Java 的数组，二次封装一个属于我们自己的数组类。</p><h1 id="封装属于我们自己的数组"><a href="#封装属于我们自己的数组" class="headerlink" title="封装属于我们自己的数组"></a>封装属于我们自己的数组</h1><p>原本的数组属于静态数组，而我们要制作的是动态数组。</p><p>创建一个 Array 类，在其中封装一个 Java 的数组 data，针对data 进行增删改查，其实对于对于数据结构跟数据库是一样的，也是存储数据，之后在进行高效的操作，只不过我们设计的数据结构是把这些数据存储在内存中，针对这些数据结构添加的的操作，在大的类别上也是增删改查。</p><p>不过针对不同的数据结构，增删改查的方式是截然不同的，有的数据结构会忽略其中的某一个动作。</p><p>由于数组本身是静态的，也就是在我们创建的时候，就必须指定大小，将其称之为容量（capactiy）也就是数组空间最多装多少个元素。</p><p>但是要注意，我们的数组最多装多少个元素，和我们实际的装了多少个元素是没有关系的，我们数组中实际装了多少个元素，在 Array 类中用 size 变量控制。</p><p>当没有元素时，size 为0，也相当于指向了第一个没有盛放元素的相应的索引也就是0这个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Array;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] data;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造函数，传入数组的容量 capactiy 构造 Array</div><div class="line"> * <span class="doctag">@param</span> capactiy</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capactiy)</span> </span>&#123;</div><div class="line">data = <span class="keyword">new</span> <span class="keyword">int</span>[capactiy];</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 无参数构造函数，默认数组的容量10</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取数组中元素的个数</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取数组的容量</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> data.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回数组是否为空</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将 data 和 size 封装成了私有成员，因为不希望用户从外部直接获得这些数据的信息，否则就是危险的，data和 size 就会产生不一致的情况，比如说 data 中实际有三个有效的元素，size 本来也是三，但是 size 是公有的，用户就可以随意更改，这就破坏了类的封装性，这样在写程序的过程中有可能会产生更多 bug。</p><h2 id="向数组添加元素"><a href="#向数组添加元素" class="headerlink" title="向数组添加元素"></a>向数组添加元素</h2><p>向数组添加元素，最简单的形式就是向数组的末尾添加一个元素。向数组末尾添加元素，就等同于向 size 添加元素。因为 size 指向的是第一个没有盛放元素所对应的索引，添加完成后我们需要维护 size，此时多了一个元素所以 size 应该++。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 向数组末尾添加元素</div><div class="line"> * <span class="doctag">@param</span> e</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == data.length) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"AddLast falid. Array is full"</span>);</div><div class="line">    &#125;</div><div class="line">data[size] = e;</div><div class="line">size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在添加元素时候，我们需要检查一下数组的容量，当 size 和 data 容量相等时，表明开辟的数组已经被沾满了，应该给予提示，不过在之后的章节中，我们会对其进行改写，让其实现动态的特性。</p><h2 id="向指定位置添加元素"><a href="#向指定位置添加元素" class="headerlink" title="向指定位置添加元素"></a>向指定位置添加元素</h2><p>我们希望能够维护数组中的元素，让着个数组中的元素都是有序排列的，在这样的情况下，我们就不能将每一个元素都放到最后，我们需要将元素插入到指定的位置。</p><p>如果我们希望将一个元素插入到1的位置上，我们只需要将数组中的元素都向后挪一个位置。</p><p>再具体操作之后，我们需要从最后面的元素开始移动，否则的话，我们就会将其后面的元素覆盖掉了。</p><p>操作完成后，不要忘了维护 size，我们需要++。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 向指定位置插入元素</div><div class="line">* <span class="doctag">@param</span> index 位置</div><div class="line">* <span class="doctag">@param</span> e   元素</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == data.length) </div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"AddLast falid. Array is full"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//index 必须为合法的</span></div><div class="line"><span class="comment">//如果 index 最大是取 size, 在这样的情况下，就相当于向所有的元素后面再添加一个元素</span></div><div class="line"><span class="comment">//如果 index 比 size 还大，说明元素不是紧密排列的，中间存在一些不是合法的元素</span></div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"AddLast falid. Require index &gt;= - and index &lt;= size"</span>);  &#125;</div><div class="line"></div><div class="line"><span class="comment">//后移元素</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</div><div class="line">data [i + <span class="number">1</span>] = data[i];</div><div class="line">&#125;</div><div class="line">data[index] = e;</div><div class="line">size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当我们编写好INSERT方法后，其实 addlast 可以复用insert 方法，并且通过该方法，还可以写出向首位添加元素的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 向数组末尾添加元素</div><div class="line">* <span class="doctag">@param</span> e</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(<span class="keyword">int</span> e)</span></span></div><div class="line">&#123;</div><div class="line">    insert(size, e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 想数组首位置添加元素</div><div class="line">* <span class="doctag">@param</span> e</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">    insert(<span class="number">0</span> ,e);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="在数组中查询和修改元素"><a href="#在数组中查询和修改元素" class="headerlink" title="在数组中查询和修改元素"></a>在数组中查询和修改元素</h2><p>对于我们封装的数组而言，真正的数组是存储在我们静态数组data 中，我们可以非常方便的在<code>[]</code>中插入索引的方式直接取值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取index 索引的元素</div><div class="line"> * <span class="doctag">@param</span> index</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> int get(int index) &#123;</div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Get failed, Index is illegal."</span>);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> data[index];</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 修改 index 位置的元素</div><div class="line">* <span class="doctag">@param</span> index</div><div class="line">* <span class="doctag">@param</span> e</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> void set(int index, int e) &#123;</div><div class="line">    <span class="comment">//确保了用户永远无法查询没有使用的空间。</span></div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Get failed, Index is illegal."</span>);</div><div class="line">&#125;</div><div class="line">    data[index] = e;</div><div class="line"> &#125;</div><div class="line">@Override</div><div class="line"><span class="keyword">public</span> String toString() &#123;</div><div class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">    res.append(String.format(<span class="string">"Array Szie = %d, capactiy = %d"</span>, size, data.length));</div><div class="line">res.append(<span class="string">'['</span>);</div><div class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        res.append(data[i]);</div><div class="line">        <span class="keyword">if</span> (i != size <span class="number">-1</span>) &#123;</div><div class="line">            res.append(<span class="string">","</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">    res.append(<span class="string">']'</span>);</div><div class="line"><span class="keyword">return</span> re;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="包含、搜索和删除"><a href="#包含、搜索和删除" class="headerlink" title="包含、搜索和删除"></a>包含、搜索和删除</h2><p>检测是否包含很简单，只需要遍历我们的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检测是否包含元素</div><div class="line"> * <span class="doctag">@param</span> e</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contians</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">         <span class="keyword">if</span> (data[i] == e) &#123;</div><div class="line"> <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 查找数组元素e 所在的索引，如果不存在元素e,则返回-1</div><div class="line"> * <span class="doctag">@param</span> e</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (data[i] == e) &#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>删除索引很简单，与我们插入相反，他是从后向前移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从数组删除元素，并且返回删除的元素</div><div class="line"> * <span class="doctag">@param</span> index</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Remove failed, Index is illegal."</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> ret = data[index];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++ ) &#123;</div><div class="line">data[i - <span class="number">1</span>] = data[i];</div><div class="line">    &#125;</div><div class="line">size--;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同时我们可以添加删除首位置和末尾的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除第一个元素，并且返回被删除的元素</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ret = remove(<span class="number">0</span>);</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除最后一个元素，并且返回被删除的元素</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ret = remove(size-<span class="number">1</span>);</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从数组中删除元素e</div><div class="line"> * <span class="doctag">@param</span> e</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> index = find(e);</div><div class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</div><div class="line">remove(index);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="使用泛型优化数组"><a href="#使用泛型优化数组" class="headerlink" title="使用泛型优化数组"></a>使用泛型优化数组</h2><p>现在对于我们的数组，存在最大的问题就是只支持 Int 类型，但是实际上数组类作为存放数据的容器，应该盛放任意类型的数据。</p><p>泛型不可以是基本类型，只能是类的对象。</p><p>Java 的基本类型：</p><ul><li>boolean</li><li>byte</li><li>char</li><li>short</li><li>int </li><li>long </li><li>float</li><li>double</li></ul><p>如果将我们的数组设置为泛型，就不能放置这些基本类型了。Java 为每个基础类型都有对应的包装类。</p><ul><li>Boolean</li><li>Byte</li><li>Char</li><li>Short</li><li>Int</li><li>Long</li><li>Float</li><li>Double</li></ul><p>其实就是 Java 对基本类型的封装，两者之间可以无缝的进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Array;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> T[] data;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造函数，传入数组的容量 capactiy 构造 Array</div><div class="line"> * <span class="doctag">@param</span> capactiy</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capactiy)</span> </span>&#123;</div><div class="line">data = (T[])<span class="keyword">new</span> Object[capactiy];</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 无参数构造函数，默认数组的容量10</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取数组中元素的个数</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取数组的容量</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> data.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回数组是否为空</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 向数组末尾添加元素</div><div class="line"> * <span class="doctag">@param</span> e</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T e)</span></span></div><div class="line">&#123;</div><div class="line">insert(size, e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 想数组首位置添加元素</div><div class="line"> * <span class="doctag">@param</span> e</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">insert(<span class="number">0</span> ,e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 向指定位置插入元素</div><div class="line"> * <span class="doctag">@param</span> index 位置</div><div class="line"> * <span class="doctag">@param</span> e元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,  T e)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (size == data.length) </div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"AddLast falid. Array is full"</span>);</div><div class="line"></div><div class="line"><span class="comment">//index 必须为合法的</span></div><div class="line"><span class="comment">//如果 index 最大是取 size, 在这样的情况下，就相当于向所有的元素后面再添加一个元素</span></div><div class="line"><span class="comment">//如果 index 比 size 还大，说明元素不是紧密排列的，中间存在一些不是合法的元素</span></div><div class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"AddLast falid. Require index &gt;= 0 and index &lt;= size"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//后移元素</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</div><div class="line">data [i + <span class="number">1</span>] = data[i];</div><div class="line">&#125;</div><div class="line">data[index] = e;</div><div class="line">size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 获取index 索引的元素</div><div class="line">  * <span class="doctag">@param</span> index</div><div class="line">  * <span class="doctag">@return</span></div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Get failed, Index is illegal."</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> data[index];</div><div class="line">&#125;</div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 修改 index 位置的元素</div><div class="line">  * <span class="doctag">@param</span> index</div><div class="line">  * <span class="doctag">@param</span> e</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, T e)</span></span></div><div class="line"> &#123;</div><div class="line"> <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Get failed, Index is illegal."</span>);</div><div class="line"> &#125;</div><div class="line"> data[index] = e;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 检测是否包含元素</div><div class="line">  * <span class="doctag">@param</span> e</div><div class="line">  * <span class="doctag">@return</span></div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contians</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">   <span class="keyword">if</span> (data[i].equals(e)) &#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 查找数组元素e 所在的索引，如果不存在元素e,则返回-1</div><div class="line">  * <span class="doctag">@param</span> e</div><div class="line">  * <span class="doctag">@return</span></div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">   <span class="keyword">if</span> (data[i].equals(e)) &#123;</div><div class="line">   <span class="keyword">return</span> i;</div><div class="line">   &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">/**</span></div><div class="line">  * 从数组删除元素，并且返回删除的元素</div><div class="line">  * <span class="doctag">@param</span> index</div><div class="line">  * <span class="doctag">@return</span></div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Remove failed, Index is illegal."</span>);</div><div class="line">&#125;</div><div class="line">T ret = data[index];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++ ) &#123;</div><div class="line">data[i - <span class="number">1</span>] = data[i];</div><div class="line">&#125;</div><div class="line">size--;</div><div class="line">         data[size] == <span class="keyword">null</span>;</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除第一个元素，并且返回被删除的元素</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">removeFirst</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">T ret = remove(<span class="number">0</span>);</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除最后一个元素，并且返回被删除的元素</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">T ret = remove(size-<span class="number">1</span>);</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从数组中删除元素e</div><div class="line"> * <span class="doctag">@param</span> e</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(T e)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> index = find(e);</div><div class="line"><span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</div><div class="line">remove(index);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/***</span></div><div class="line"> * 打印输出数组</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">res.append(String.format(<span class="string">"Array Szie = %d, capactiy = %d"</span>, size, data.length));</div><div class="line">res.append(<span class="string">'['</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">res.append(data[i]);</div><div class="line"><span class="keyword">if</span> (i != size -<span class="number">1</span>) &#123;</div><div class="line">res.append(<span class="string">","</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">res.append(<span class="string">']'</span>);</div><div class="line"><span class="keyword">return</span> res.toString();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里需要注意的是，比较==运算进行了替换<code>equals</code>，那是因为<code>==</code>是值比较，而现在泛型比较的是对象，所以需要引用比较。</p><p>在 remove 代码中，可以看到最后有一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data[size] == <span class="keyword">null</span>;</div></pre></td></tr></table></figure><p>当我们使用泛型时，data 数组中存储的都是对象的引用，在这种情况下，删除了一个元素之后，此时的 data[size]还指着一个引用，在 Java中有一个垃圾回收技术，不过如果我们的 data[‘size’] 还存在引用的话，就不会被回收，将其值设置成 NULL 后对象就没有引用了，就会被自动回收。</p><p>其实在我们使用这个数组的时候，再添加一个新的元素，那么 data[size]指向的对象就会换成一个新的引用，原来的值就会被清理掉，对于这种对象有一个术语<code>loitering objects</code>，这个时候这个对象还在我们的系统中游荡，垃圾回收机制并不能把它回收，但是他已经没有用了，但是需要注意<code>loitering objects</code>的存在并不等于内存泄漏，只是为了程序的优化，如果能手动的把<code>loitering objects</code>给去除更好。</p><p>如果不写这段代码也是没有问题的。</p><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>现在我们实现的数组内部使用的还是 Java 为我们提供的静态数组，容量是有限的，可是很多时候，我们使用的数组类无法实现预估，不知道要放入多少个元素进我们的数组，在这种情况下，容量开的太大的话就会浪费很多空间，如果太小最后空间不够用，这种情况下，我们需要一种方案解决数组的容量是可伸缩的，也就是所谓的动态数组。</p><p>假设现在数组只有4个元素，并且现在4个元素已经装满了，现在向数组中再添加一个元素的话，显然是做不到的，会抛出异常。</p><p>我们首先再开创一个新的数组newData，newData 的空间要比原来的数组空间大一些，比如之前数组是4个元素，那么 newData 就开辟8个空间，然后将 data 中的数据放置到 newData 中。</p><p>其实就是使用 newData 取代 data。</p><p>在程序实现过程中，data 是一个引用，我们改变 data 的引用指向newData。</p><p>对于 newData 而言，在函数执行完成之后就会失效，但是 data 是成员变量，它的生命周期和类是一样的，只要类还在使用 data 的指向就是 newData 的空间。</p><p>只有4个元素的数组，由于没有变量指向它，就会被回收掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 向指定位置插入元素</div><div class="line"> * <span class="doctag">@param</span> index 位置</div><div class="line"> * <span class="doctag">@param</span> e元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,  T e)</span></span>&#123;</div><div class="line">    <span class="comment">//index 必须为合法的</span></div><div class="line"><span class="comment">//如果 index 最大是取 size, 在这样的情况下，就相当于向所有的元素后面再添加一个元素</span></div><div class="line">    <span class="comment">//如果 index 比 size 还大，说明元素不是紧密排列的，中间存在一些不是合法的元素</span></div><div class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"AddLast falid. Require index &gt;= 0 and index &lt;= size"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (size == data.length) </div><div class="line">        resize(<span class="number">2</span> * data.length);</div><div class="line"><span class="comment">//后移元素</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</div><div class="line">        data [i + <span class="number">1</span>] = data[i];</div><div class="line">&#125;</div><div class="line">data[index] = e;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capactiy)</span> </span>&#123;</div><div class="line">    T[] newData = (T[])<span class="keyword">new</span> Object[capactiy];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        newData[i] = data[i];</div><div class="line">&#125;</div><div class="line">    data = newData;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resize(<span class="number">2</span> * data.length);</div></pre></td></tr></table></figure><p>在扩容时候，我将其设置成了原有数组的二倍，在这里主要是不希望比原来的 data.length 再加上一个常数，扩容的大小到底取多少，其实很难判断，如果每一次只扩容十个空间，假设当前数组有一个10000元素了，然后我们扩容成10010个，很有可能我们的这个扩容是比较低效的，因为现在的数组装10000个数组已经装满了，又有新的元素来了，很有可能还会来新的元素，如果我们再次加入1000个元素，那么就需要扩容100次，这样的性能消耗实在是太大了。</p><p>如果每次都扩容1000个容量，但是这样做也有问题，如果当前整个数组只有10个的话，一次性扩容1000个空间，那么很大的概率大部分空间会被浪费掉。</p><p>现在2 * data.length 就是根据当前数组有多少容量是相关的，扩容的量是跟当前数组已经有用的容量是在一个数量级的，那么我当前有100元素，就给他扩容到200。</p><p>其实将其设置成2或者是3都是完全可以的，这只是一个参数选择上的问题，在 Java 中 ArrayList 的实现中这个参数选择的是1.5。</p><p>相对于扩容来说，同理在我们从元素中删除元素的时候，为了节省空间，我们也可以设置当删除到一定程度的时候，我们整个数组的容量进行一下缩小。</p><p>我们可以通过 resize 函数实现这个功能，对 remove 函数进行修改，如果是数组容积的二分之一的时候，我们就可以 resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从数组删除元素，并且返回删除的元素</div><div class="line"> * <span class="doctag">@param</span> index</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Remove failed, Index is illegal."</span>);</div><div class="line">&#125;</div><div class="line">     T ret = data[index];</div><div class="line">     </div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++ ) &#123;</div><div class="line">     data[i - <span class="number">1</span>] = data[i];</div><div class="line">     &#125;</div><div class="line">     size--;</div><div class="line">     data[size] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (size == data.length / <span class="number">2</span>) &#123;</div><div class="line">resize(data.length /<span class="number">2</span>);</div><div class="line">     &#125;</div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此时，我们就实现了一个真正意义上的动态数组。不过在真正意义上还不够完善，因为在删除元素时候，存在一个问题，如果我们要删除数组中的 ‘E’，当找到第一个 ‘E’的时候，程序删除掉就会停止执行，这个时候在后面的元素中也有可能会存在’E’，所以为了程序更加完善可以在添加一个删除所有，同时查找元素也存在这一问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组基础&quot;&gt;&lt;a href=&quot;#数组基础&quot; class=&quot;headerlink&quot; title=&quot;数组基础&quot;&gt;&lt;/a&gt;数组基础&lt;/h1&gt;&lt;p&gt;数组其实就是把所有数据码成一排进行存放，数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.maksim.website/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux典型应用实践：NFS共享文件</title>
    <link href="http://www.maksim.website/2018/04/12/2/"/>
    <id>http://www.maksim.website/2018/04/12/2/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-06-27T13:37:51.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用NFS"><a href="#为什么要用NFS" class="headerlink" title="为什么要用NFS"></a>为什么要用NFS</h1><p>NFS（Network File System）网络文件系统，由 SUN 公司开发，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</p><p>简单的来说：它就是是可以透过网络，让不同的主机、不同的操作系统可以共享存储。</p><p>以下是NFS最显而易见的好处：</p><ol><li>节省本地存储空间，将常用的数据存放在一台NFS服务器上且可以通过网络访问，那么本地终端将可以减少自身存储空间的使用。</li><li>用户不需要在网络中的每个机器上都建有Home目录，Home目录可以放在NFS服务器上且可以在网络上被访问使用。</li><li>一些存储设备CDROM和Zip（一种高储存密度的磁盘驱动器与磁盘）等都可以在网络上被别的机器使用。这可以减少整个网络上可移动介质设备的数量。</li></ol><p>NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，容许不同硬件及操作系统的系统共同进行文件的分享。</p><p>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。</p><p>可以说NFS本身就是使用RPC的一个程序。或者说NFS也是一个RPC SERVER。所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。</p><h1 id="NSF-的工作流程"><a href="#NSF-的工作流程" class="headerlink" title="NSF 的工作流程"></a>NSF 的工作流程</h1><ol><li>由程序在NFS客户端发起存取文件的请求，客户端本地的RPC(rpcbind)服务会通过网络向NFS服务端的RPC的111端口发出文件存取功能的请求。</li><li>NFS服务端的RPC找到对应已注册的NFS端口，通知客户端RPC服务。</li><li>客户端获取正确的端口，并与NFS daemon联机存取数据。</li><li>存取数据成功后，返回前端访问程序，完成一次存取操作。</li></ol><h1 id="CentOS-7搭建NFS服务器实例"><a href="#CentOS-7搭建NFS服务器实例" class="headerlink" title="CentOS 7搭建NFS服务器实例"></a>CentOS 7搭建NFS服务器实例</h1><table><thead><tr><th style="text-align:center">服务器系统</th><th style="text-align:center">角色</th><th style="text-align:center">IP</th></tr></thead><tbody><tr><td style="text-align:center">CentOS 7</td><td style="text-align:center">Server</td><td style="text-align:center">192.168.0.100</td></tr><tr><td style="text-align:center">CentOS 7</td><td style="text-align:center">Client</td><td style="text-align:center">192.168.0.101</td></tr></tbody></table><p><strong>1、因是测试环境，先关闭selinux和firewalld</strong></p><p>关闭selinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# sed -i s#SELINUX=enforcing#SELINUX=disabled#g /etc/selinux/config</div></pre></td></tr></table></figure><p>停止防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# systemctl stop firewalld.service</div></pre></td></tr></table></figure><p><strong>2、服务器部署</strong></p><p>1）检查系统版本及NFS服务nfs-utils 和rpcbind有没有安装 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# cat /etc/redhat-release #查看系统版本</div><div class="line">CentOS Linux release 7.5.1804 (Core)</div><div class="line">[root@service ~]# uname -r #查看系统内核版本</div><div class="line">3.10.0-862.el7.x86_64</div><div class="line">[root@servicer ~]# uname -m #查看系统是否64位</div><div class="line">x86_64</div><div class="line">[root@service ~]# rpm -qa nfs-utils rpcbind #检查安装的软件包</div><div class="line">rpcbind-0.2.0-44.el7.x86_64</div><div class="line">nfs-utils-1.3.0-0.54.el7.x86_64</div></pre></td></tr></table></figure><p>2）如果没有安装在系统中通过yum 命令进行安装以上两个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# yum install -y nfs-utils rpcbind #安装上述所需的两个软件包</div></pre></td></tr></table></figure><p>3）启动rpcbind服务（<strong>一定要先启动rpcbind服务再启动nfs服务</strong>,由于在NFS服务过程中，必须先启动rpcbind，再启动nfs，这样才能让NFS在rpcbind上注册成功) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@service ~]#  systemctl start rpcbind  #启动</div><div class="line">[root@service ~]#  systemctl status rpcbind  #查看状态</div><div class="line">● rpcbind.service - RPC bind service</div><div class="line">   Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; enabled; vendor preset: enabled)</div><div class="line">   Active: active (running) since 三 2018-06-27 16:02:27 CST; 29s ago</div><div class="line">  Process: 1577 ExecStart=/sbin/rpcbind -w $RPCBIND_ARGS (code=exited, status=0/SUCCESS)</div><div class="line"> Main PID: 1578 (rpcbind)</div><div class="line">   CGroup: /system.slice/rpcbind.service</div><div class="line">           └─1578 /sbin/rpcbind -w</div><div class="line"></div><div class="line">6月 27 16:02:27 bogon systemd[1]: Starting RPC bind service...</div><div class="line">6月 27 16:02:27 bogon systemd[1]: Started RPC bind service.</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# lsof -i :111  #查询rpcbind监听状态 (111是rpcbind的主端口)</div><div class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</div><div class="line">rpcbind 1578  rpc    6u  IPv4  19786      0t0  UDP *:sunrpc</div><div class="line">rpcbind 1578  rpc    8u  IPv4  19788      0t0  TCP *:sunrpc (LISTEN)</div><div class="line">rpcbind 1578  rpc    9u  IPv6  19789      0t0  UDP *:sunrpc</div><div class="line">rpcbind 1578  rpc   11u  IPv6  19791      0t0  TCP *:sunrpc (LISTEN)</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# netstat -lntup |grep rpcbind #查询rpcbind服务启动状态 (同lsof查询端口效果一样)</div><div class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1578/rpcbind</div><div class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1578/rpcbind</div><div class="line">udp        0      0 0.0.0.0:905             0.0.0.0:*                           1578/rpcbind</div><div class="line">udp        0      0 0.0.0.0:111             0.0.0.0:*                           1578/rpcbind</div><div class="line">udp6       0      0 :::905                  :::*                                1578/rpcbind</div><div class="line">udp6       0      0 :::111                  :::*                                1578/rpcbind</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# rpcinfo -p localhost#查看nfs服务向rpc注册的端 口信息</div><div class="line">program vers proto   port  service</div><div class="line">    100000    4   tcp    111  portmapper</div><div class="line">    100000    3   tcp    111  portmapper</div><div class="line">    100000    2   tcp    111  portmapper</div><div class="line">    100000    4   udp    111  portmapper</div><div class="line">    100000    3   udp    111  portmapper</div><div class="line">    100000    2   udp    111  portmapper</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# systemctl list-unit-files | grep rpcbind #检查rpcbind自启动情况</div><div class="line">rpcbind.service                               enabled</div><div class="line">rpcbind.socket                                enabled</div><div class="line">rpcbind.target                                static</div></pre></td></tr></table></figure><p>如果rpcbind.service不是enable将其加入自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# systemctl enable rpcbind.service</div></pre></td></tr></table></figure><p>4）启动NFS服务并查看其状态 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# systemctl start nfs #启动NFS</div><div class="line">[root@service ~]# systemctl status nfs #查看NFS</div><div class="line">● nfs-server.service - NFS server and services</div><div class="line">   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; disabled; vendor preset: disabled)</div><div class="line">   Active: active (exited) since 三 2018-06-27 16:15:44 CST; 30s ago</div><div class="line">  Process: 9397 ExecStart=/usr/sbin/rpc.nfsd $RPCNFSDARGS (code=exited, status=0/SUCCESS)</div><div class="line">  Process: 9392 ExecStartPre=/bin/sh -c /bin/kill -HUP `cat /run/gssproxy.pid` (code=exited, status=0/SUCCESS)</div><div class="line">  Process: 9391 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=0/SUCCESS)</div><div class="line"> Main PID: 9397 (code=exited, status=0/SUCCESS)</div><div class="line">   CGroup: /system.slice/nfs-server.service</div><div class="line"></div><div class="line">6月 27 16:15:44 bogon systemd[1]: Starting NFS server and services...</div><div class="line">6月 27 16:15:44 bogon systemd[1]: Started NFS server and services.</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@NFS-server ~]# netstat -lntup|grep nfs #查看NFS端口启动(FNS默认端口为2049)</div><div class="line">[root@NFS-server ~]# lsof -i :2049 #查看NFS端口启动(FNS默认端口为2049)</div><div class="line">[root@NFS-server ~]# netstat -lntup|grep 2049 #查看NFS端口启动(FNS默认端口为2049)</div><div class="line">tcp        0      0 0.0.0.0:2049            0.0.0.0:*               LISTEN      -</div><div class="line">tcp6       0      0 :::2049                 :::*                    LISTEN      -</div><div class="line">udp        0      0 0.0.0.0:2049            0.0.0.0:*                           -</div><div class="line">udp6       0      0 :::2049                 :::*                                -</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@NFS-server ~]# rpcinfo -p localhost #启动NFS过后rpcbind服务已经启用了对FNS的端口映射</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@NFS-server ~]# systemctl list-unit-files | grep nfs  #查看nfs的开机自启动情况</div><div class="line">proc-fs-nfsd.mount                            static</div><div class="line">var-lib-nfs-rpc_pipefs.mount                  static</div><div class="line">nfs-blkmap.service                            disabled</div><div class="line">nfs-config.service                            static</div><div class="line">nfs-idmap.service                             static</div><div class="line">nfs-idmapd.service                            static</div><div class="line">nfs-lock.service                              static</div><div class="line">nfs-mountd.service                            static</div><div class="line">nfs-rquotad.service                           disabled</div><div class="line">nfs-secure.service                            static</div><div class="line">nfs-server.service                            disabled</div><div class="line">nfs-utils.service                             static</div><div class="line">nfs.service                                   disabled</div><div class="line">nfslock.service                               static</div><div class="line">nfs-client.target                             enabled</div><div class="line">[root@NFS-server ~]# systemctl enable nfs #让FNS开机自启动</div></pre></td></tr></table></figure><p>5）授权nfsnobody于/data/bbs让客户端挂载后可写可读</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service /]# chown nfsnobody:nfsnobody /data/bbs</div></pre></td></tr></table></figure><p>6）创建测试目录及文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# mkdir /data/bbs -p</div><div class="line">[root@service ~]# mkdir /data/bbs/test.txt</div></pre></td></tr></table></figure><p>7）配置NFS服务的export文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# echo "/data/bbs/ 192.168.0.0/24(rw,sync,root_squash)"&gt;&gt;/etc/exports</div></pre></td></tr></table></figure><p>重新加载nfs配置文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# exportfs -rv</div><div class="line">exporting 192.168.0.0/24:/data/bbs</div></pre></td></tr></table></figure><p>exportfs：NFS服务端发布共享控制命令。 </p><ul><li>-r：表示重新刷新共享</li><li>-a：表示将配置文件/etc/exports中的所有定义共享发布出去。</li><li>-v：显示确认共享设置</li><li>-u：表示不发布共享</li></ul><p>查看nfs服务器挂载情况 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# showmount -e localhost</div><div class="line">Export list for localhost:</div><div class="line">/data/bbs 192.168.10.1/24</div></pre></td></tr></table></figure><ul><li>ro：目录只读</li><li>rw：目录读写</li><li>sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性</li><li>async：将数据先保存在内存缓冲区中，必要时才写入磁盘</li><li>all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组(nfsnobody)</li><li>no_all_squash：与all_squash取反(默认设置)</li><li>root_squash：将root用户及所属组都映射为匿名用户或用户组(默认设置)</li><li>no_root_squash：与rootsquash取反</li><li>anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户(UID=xxx)</li><li>anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户</li></ul><p><strong>3、客户端配置</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# yum install nfs-utils rpcbind</div></pre></td></tr></table></figure><p>把rpcbind加入开机自启动 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# systemctl enable rpcbind.service</div></pre></td></tr></table></figure><p>创建测试目录文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# mkdir /data/bbs/ -p</div></pre></td></tr></table></figure><p>扫描NFS服务器的文件共享列表 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# showmount -e 192.168.0.100</div><div class="line">Export list for 192.168.0.100:</div><div class="line">/data/bbs 192.168.0.100/24</div></pre></td></tr></table></figure><p>把服务器的目录挂载到客户端 的目录下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div><div class="line">[root@localhost ~]# df -h</div><div class="line">文件系统                 容量  已用  可用 已用% 挂载点</div><div class="line">/dev/mapper/centos-root  6.2G  1.1G  5.1G   18% /</div><div class="line">devtmpfs                 485M     0  485M    0% /dev</div><div class="line">tmpfs                    496M     0  496M    0% /dev/shm</div><div class="line">tmpfs                    496M  6.8M  490M    2% /run</div><div class="line">tmpfs                    496M     0  496M    0% /sys/fs/cgroup</div><div class="line">/dev/sda1               1014M  129M  886M   13% /boot</div><div class="line">tmpfs                    100M     0  100M    0% /run/user/0</div><div class="line">192.168.0.100:/data/bbs  6.2G  1.1G  5.1G   18% /data/bbs</div></pre></td></tr></table></figure><h1 id="数据测试"><a href="#数据测试" class="headerlink" title="数据测试"></a>数据测试</h1><p>Service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@service /]# cd /data/bbs</div><div class="line">[root@service bbs]# touch a.txt</div></pre></td></tr></table></figure><p>Client</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ls /data/bbsa.txt</div></pre></td></tr></table></figure><p>提示:  </p><ol><li>配置NFS服务端后，不用重启NFS服务，只要使用exportfs -rv           </li><li>rpc主程序Centos5.8下为portmap 、Centos6.4和Centos7下为rpcbind          </li><li>NFS共享目录不要授权于777权限，可以改所属主和组为nfsnobody，因为nfsnobody权限不是很大，也不能登陆 </li></ol><h1 id="配置客户端-开机自动挂载NFS共享目录"><a href="#配置客户端-开机自动挂载NFS共享目录" class="headerlink" title="配置客户端 开机自动挂载NFS共享目录"></a>配置客户端 开机自动挂载NFS共享目录</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# chmod +x /etc/rc.d/rc.local     #centos7需要给rc.local赋予执行权限后，rc.local文件才能生效</div><div class="line">[root@localhost ~]# echo "mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs"&gt;&gt;/etc/rc.local</div><div class="line">[root@localhost ~]# cat /etc/rc.local</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES#</div><div class="line"><span class="meta">#</span> It is highly advisable to create own systemd services or udev rules</div><div class="line"><span class="meta">#</span> to run scripts during boot instead of using this file.#</div><div class="line"><span class="meta">#</span> In contrast to previous versions due to parallel execution during boot</div><div class="line"><span class="meta">#</span> this script will NOT be run after all other services.#</div><div class="line"><span class="meta">#</span> Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure</div><div class="line"><span class="meta">#</span> that this script will be executed during boot.</div><div class="line"> </div><div class="line">mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><h1 id="客户端mount挂载优化"><a href="#客户端mount挂载优化" class="headerlink" title="客户端mount挂载优化"></a>客户端mount挂载优化</h1><p>在企业生产环境中，NFS客户端挂载的参数有noexec、nosuid、nodev、noatime、rsize、wsize、nodiratime等，</p><p> 一般来说，NFS服务器共享的只是普通静态数据（图片、附件、视频），不需要执行suid、exec等权限，挂载的这个文件系统只能作为数据存取之用，无法执行程序，对于客户端来讲增加了安全性，例如：很多<em>*</em>修改站点文件都是由上传入口上传的程序存储目录，然后执行，因此在挂载时，用下面的命令是有必要的，</p><p>普遍安全挂载参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t nfs -o nosuid,noexec,nodev,rw 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p>挂载的读写缓存</p><p>wsize和rsize写和读缓存</p><p>wsize和rsize的最大值</p><p>NFSV2   rsize=8192 wsize=8192</p><p>NFSV3   rsize=32768 wsize=32768</p><p>NFSV4   rsize=65536 wsize=65536</p><p>现在一般centos5.8以上的系统都己经增加了读写缓存，如需修改可以加以上参数</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p>mount的一些常用挂载优化参数：</p><ul><li><p>wsize和rsize写和读缓存</p></li><li><p>async     数据不同步写到磁盘，提高性参，但降低数据安全，不推荐使用</p></li><li>noatime和nodiratime  这两个选是说在读写磁盘时，不更新文件和目录的时间戳，而更新文件时间戳对于工作数据必要性不大，增加了磁盘IO的次数，拖慢系统性参，</li><li>defaults   这个缺省值包括rw,suid,dev,exec,auto,nouser,and async  cat /etc/fstab的结果默认大部人都是缺省值</li><li>noauto    不会自动挂载文件系统</li><li>noexec    不允许安装的直接执行任何二进制文件</li><li>ro         挂载一个只读文件系统</li><li>rw        挂载一个可写的文件系统</li><li>sync       把数据同步写入硬盘</li><li>nosuid     不允许设置用户标识或设置组标识符位</li><li>nodev      不解释字符或文件块特殊设备</li><li><p>intr       表示可以中断</p><p>企业生产环境中nfs性参优化挂载例子：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mount -t nfs -o noatime,nodiratime 192.168.10.150:/data/bbs /data/bbs</div><div class="line">mount -t nfs -o nosuid,noexec,nodev,noatime,nodiratime,intr,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p>如果是本地系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -o defaults,async,noatime,data=writeback,barrier=0 /dev/sdb1 /mnt</div></pre></td></tr></table></figure><p>data=writeback,barrier=0 是日志文件系统的优化</p><p>提示：本地文件系统挂载如果加nodiratime会报错，</p><h1 id="加优化参数和不加的数据写入测试"><a href="#加优化参数和不加的数据写入测试" class="headerlink" title="加优化参数和不加的数据写入测试"></a>加优化参数和不加的数据写入测试</h1><p><strong>使用普通挂载</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# mount -t nfs 192.168.0.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p> 测试单个文件写入速度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cd /data/bbs</div><div class="line">[root@localhost bbs]# time dd if=/dev/zero of=/data/bbs/dingjianfile bs=9k count=2000</div><div class="line">2000+0 records in</div><div class="line">2000+0 records out</div><div class="line">18432000 bytes (18 MB) copied, 0.114592 s, 161 MB/s</div><div class="line">real    0m0.125s</div><div class="line">user    0m0.000s</div><div class="line">sys     0m0.021s</div></pre></td></tr></table></figure><p>测试批量创建文件的写入速度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# time for ((i=1;i&lt;10000;i++));do /bin/cp /bin/touch /data/bbs/test$i;done</div><div class="line">real    2m2.877s</div><div class="line">user    0m10.242s</div><div class="line">sys     0m33.882s</div></pre></td></tr></table></figure><p><strong>加优化参数挂载:</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]#mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p>测试单个文件写入速度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]#  time dd if=/dev/zero of=/data/bbs/dingjianfile bs=9k count=2000</div><div class="line">2000+0 records in</div><div class="line">2000+0 records out</div><div class="line">18432000 bytes (18 MB) copied, 0.10043 s, 184 MB/s</div><div class="line">real    0m0.107s</div><div class="line">user    0m0.001s</div><div class="line">sys     0m0.017s</div></pre></td></tr></table></figure><p>测试批量创建文件的写入速度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# time for ((i=1;i&lt;10000;i++));do /bin/cp /bin/touch /data/bbs/test$i;done</div><div class="line">real    1m38.526s</div><div class="line">user    0m9.989s</div><div class="line">sys     0m32.788s</div></pre></td></tr></table></figure><h1 id="配置fstab文件令开机自动加载网络文件系统和本地的文件系统-和rc-local效果一样"><a href="#配置fstab文件令开机自动加载网络文件系统和本地的文件系统-和rc-local效果一样" class="headerlink" title="配置fstab文件令开机自动加载网络文件系统和本地的文件系统(和rc.local效果一样)"></a>配置fstab文件令开机自动加载网络文件系统和本地的文件系统(和rc.local效果一样)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# vi /etc/fstab</div><div class="line"><span class="meta">#</span> /etc/fstab</div><div class="line"><span class="meta">#</span> Created by anaconda on Wed Jun 27 15:39:33 2018</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> Accessible filesystems, by reference, are maintained under '/dev/disk'</div><div class="line"><span class="meta">#</span> See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</div><div class="line"><span class="meta">#</span></div><div class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</div><div class="line">UUID=cbf5711b-4a2b-44ca-a6da-69d181f03617 /boot xfs     defaults        0 0</div><div class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</div><div class="line"></div><div class="line">192.168.0.100:/data/bbs /data/bbs   nfs defaults,nosuid,noatime,nodiratime,noexec,nodev,intr,rsize=65536,wsize=65536     0 0</div><div class="line">~</div></pre></td></tr></table></figure><p>参考资料：</p><ol><li>《centos7下NFS使用与配置》 <a href="http://blog.51cto.com/mrxiong2017/2087001" target="_blank" rel="noopener">http://blog.51cto.com/mrxiong2017/2087001</a></li><li>《详细讲解NFS配置过程》<a href="https://www.cnblogs.com/alonones/p/6105586.html" target="_blank" rel="noopener">https://www.cnblogs.com/alonones/p/6105586.html</a></li><li>百度百科 <a href="https://baike.baidu.com/item/NFS/812203?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/NFS/812203?fr=aladdin</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要用NFS&quot;&gt;&lt;a href=&quot;#为什么要用NFS&quot; class=&quot;headerlink&quot; title=&quot;为什么要用NFS&quot;&gt;&lt;/a&gt;为什么要用NFS&lt;/h1&gt;&lt;p&gt;NFS（Network File System）网络文件系统，由 SUN 公司开发，是Fre
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>写作的准备-读《完全写作指南》</title>
    <link href="http://www.maksim.website/2018/04/08/1/"/>
    <id>http://www.maksim.website/2018/04/08/1/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-06-25T12:39:07.539Z</updated>
    
    <content type="html"><![CDATA[<p>写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：</p><p>目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改</p><p>从理论上讲，按照这个顺序操作，你就能得到一篇组织得当、逻辑严谨的完美稿件。这个方法对一部分人是有用的，但是如果你和大多数人一样，那么他可能就不适合你。在现实生活中，大部分都不是线性思维的写作者。</p><p>这六个步骤没错，错的是这个强制性的顺序。当遵循渐进编程了因循守旧，它可能会阻碍你写作能力的发挥。</p><p>你可以以这个步骤中任意一步作为起点，头脑风暴、提纲或者是写初稿。</p><h2 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h2><p>当要写作时，首先我们要确定自己的目标是什么，你希望达到什么目的。</p><p>仔细思考写作目的能帮你搞清楚该说什么，以及怎么说。又去的是，这样一来你的读者也会更加轻松，如果你也有过收到大量简历的经理，你就会知道一封周到、工整且有针对性的求职信会让你干到多么轻松。</p><h2 id="了解你的读者"><a href="#了解你的读者" class="headerlink" title="了解你的读者"></a>了解你的读者</h2><p>除了私人日记之外，所有的作品都是有读者的，你的作品需要指向这些特定的读者。</p><p>站在读者的角度进行思考，有两个关键问题：</p><ul><li>信息</li><li>态度</li></ul><p>选择信息的黄金法则是：<strong>要有足量的有效信息，让你的读者行动起来。</strong></p><p>了解读者潜在的态度也是成功的关键。</p><ul><li>你的读者会有什么样的反应？</li><li>他们很容易接受你的信息吗?</li><li>还是会有抵触情绪？</li><li>他们是否怀有敌意。</li></ul><blockquote><p>笔者说：</p><p>在这里，可以读《美国航空航天局科学家给赞比亚修女的一封信》，这是一封大师级的回信，在本文结束处。</p></blockquote><h2 id="用他头脑风暴锁定你想表达的内容"><a href="#用他头脑风暴锁定你想表达的内容" class="headerlink" title="用他头脑风暴锁定你想表达的内容"></a>用他头脑风暴锁定你想表达的内容</h2><p>头脑风暴有一些规则。如果你在学校或者工作的地方参加过头脑风暴式的讨论，那么你很可能看到过这些规则：</p><ol><li>相处的点子越多越好。如果你能把注意力放在数量而非质量上，那么提出有用的点子概率就会更大，点子都多多益善。</li><li>不要审查，不要评论。头脑风暴时，让你的思绪自由发散。这并不是对点子进行评论的时候，不要说这个点子不太好，那个点子不合适。把脑袋里评论的声音关掉，把所有想到的东西都写出来。你可以之后再删除。</li><li>接受不同寻常的想法。不要考虑你的想法靠不靠谱。你的这些想法可能完全超出预料，但它们当中可能会有一个非常有用，或至少能为你的思考指引方向的点子。充分发挥自己的想象力。</li><li>合并改进你的点子。如果你任由思绪自由发散，那么点子很可能会有一些重合。观察它们的相似之处，并加以合并调整。</li></ol><p>当写完初稿后，发现内容不够完整，不够有说服力时候甚至可以重新进行头脑风暴。</p><h1 id="美国航空航天局科学家给赞比亚修女的一封信"><a href="#美国航空航天局科学家给赞比亚修女的一封信" class="headerlink" title="美国航空航天局科学家给赞比亚修女的一封信"></a>美国航空航天局科学家给赞比亚修女的一封信</h1><p>背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。</p><p>1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ernst Stuhlinger）博士写了一封信。施图林格因在火星之旅工程中的原创性研究，成为NASA（美国航空航天局）马绍尔太空航行中心的科学副总监。信中，玛丽·尤肯达修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。施图林格很快给尤肯达修女回了信，同时还附带了一张题为“升起的地球”的照片，这张标志性的照片是宇航员威廉·安德斯于1968年在月球轨道上拍摄的（照片中可以看到月球的地面）。他这封真挚的回信随后由NASA以《为什么要探索宇宙》为标题发表。</p><p>1970年5月6日</p><p>亲爱的玛丽·尤肯达修女：每天，我都会收到很多类似的来信，但这封对我的触动最深，因为它来自一颗慈悲的饱含探求精神的心灵。我会尽自己所能来回答你这个问题。首先，请允许我向你以及你勇敢的姐妹们表达深深的敬意，你们献身于人类最崇高的事业：帮助身处困境的同胞。</p><p>在来信中，你问我在目前地球上还有儿童由于饥饿面临死亡威胁的情况下，为什么还要花费数十亿美元来进行飞向火星的航行。 我清楚你肯定不希望这样的答案：“哦，我之前不知道还有小孩子快饿死了，好吧，从现在开始，暂停所有的太空项目，直到孩子们都吃上饭再说。”事实上，早在了解火星之旅的技术之前，我已经对儿童的饥荒问题有所了解。而且，同我很多朋友的看法一样，我认为此时此刻，我们就应该开始通往月球、火星乃至其他行星的伟大探险。从长远来看，相对于那些要么只有年复一年的辩论和争吵，要么连妥协之后也迟迟无法落实的各种援助计划来说，我甚至觉得探索太空的工程给更有助于解决人类目前所面临的种种危机。</p><p>在详细说明我们的太空项目如何帮助解决地面上的危机之前，我想先简短讲一个真实的故事。那是在400年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。</p><p>然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气，“我们还在受瘟疫的苦”，他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！”伯爵听到后不为所动，“我会尽可能地接济大家”，他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。”</p><p>果不其然，他的工作赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。</p><p>伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。</p><p>我们目前面临类似的问题。美国总统的年度预算共有2000亿美元，这些钱将用于医疗、教育、福利、城市建设、高速公路、交通运输、海外援助、国防、环保、科技、农业以及其他多项国内外的工程。今年，预算中的1.6%将用于探索宇宙，这些花销将用于阿波罗以计划、其他一些涵盖了天体物理学、深空天文学、空间生物学、行星探测工程、地球资源工程的小项目以及空间工程技术。为担负这些太空项目的支出，平均每个年收入10,000美元的美国纳税人需要支付约30美元给太空，剩下的9,970美元则可用于一般生活开支、休闲娱乐、储蓄、别的税项等花销。</p><p>也许你会问：“为什么不从纳税人为太空支付的30美元里抽出5美元或3美元或是1美元来救济饥饿的儿童呢？”为了回答这个问题，我需要先简单解释一下我们国家的经济是如何运行的，其他国家也是类似的情形。政府由几个部门（如内政部、司法部、卫生部与公众福利部、教育部、运输部、国防部等）和几个机构（国家科学基金会、国家航空航天局等）组成，这些部门和机构根据自己的职能制定相应的年度预算，并严格执行以应对国务委员会的监督，同时还要应付来自预算部门和总统对于其经济效益的压力。当资金最终由国会拨出后，将严格用于经预算批准的计划中的项目。</p><p>显然，NASA的预算中所包含的项目都是和航空航天有关的。未经国会批准的预算项目，是不会得到资金支持的，自然也不会被课税，除非有其他部门的预算涵盖了该项目，借此花掉没有分配给太空项目的资金。由这段简短的说明可以看出，要想援助饥饿的儿童，或在美国已有的对外援助项目上增加援助金额，需要首先由相关部门提出预算，然后由国会批准才行。</p><p>要问是否同意政府实施类似的政策，我个人的意见是绝对赞成。我完全不介意每年多付出一点点税款来帮助饥饿的儿童，无论他们身在何处。</p><p>我相信我的朋友们也会持相同的态度。然而，事情并不是仅靠把去往火星航行的计划取消就能轻易实现的。相对的，我甚至认为可以通过太空项目，来为缓解乃至最终解决地球上的贫穷和饥饿问题作出贡献。解决饥饿问题的关键有两部分：食物的生产和食物的发放。食物的生产所涉及的农业、畜牧业、渔业及其他大规模生产活动在世界上的一些地区高效高产，而在有的地区则产量严重不足。通过高科技手段，如灌溉管理，肥料的使用，天气预报，产量评估，程序化种植，农田优选，作物的习性与耕作时间选择，农作物调查及收割计划，可以显著提高土地的生产效率。</p><p>人造地球卫星无疑是改进这两个关键问题最有力的工具。在远离地面的运行轨道上，卫星能够在很短的时间里扫描大片的陆地，可以同时观察计算农作物生长所需要的多项指标，土壤、旱情、雨雪天气等等，并且可以将这些信息广播至地面接收站以便做进一步处理。事实证明，配备有土地资源传感器及相应的农业程序的人造卫星系统，即便是最简单的型号，也能给农作物的年产量带来数以十亿美元计的提升。</p><p>如何将食品发放给需要的人则是另外一个全新的问题，关键不在于轮船的容量，而在于国际间的合作。小国统治者对于来自大国的大量食品的输入很难做出准确的判断，他们害怕伴随着食物一同而来的还有外国势力对其统治地位的影响。恐怕在国与国之间消除隔阂之前，饥饿问题无法得以高效解决了。我不认为太空计划能一夜之间创造奇迹，然而，探索宇宙有助于促使问题向着良好的方向发展。</p><p>以最近发生的阿波罗13号事故为例。当宇航员处于关键的大气层再入期时，为了保证通讯畅通，苏联关闭了境内与阿波罗飞船所用频带相同的所有广播通信。同时派出舰艇到太平洋和大西洋海域以备第一时间进行搜救工作。如果宇航员的救生舱降落到俄方舰船附近，俄方人员会像对待从太空返回的本国宇航员一样对他们进行救助。同样，如果俄方的宇宙飞船遇到了类似的紧急情况，美国也一定会毫不犹豫地提供援助。 </p><p>通过卫星进行监测与分析来提高食品产量，以及通过改善国际关系提高食品发放的效率，只是通过太空项目提高人类生活质量的两个方面。下面我想介绍另外两个重要作用：促进科学技术的发展和提高一代人的科学素养。</p><p>登月工程需要历史上前所未有的高精度和高可靠性。面对如此严苛的要求，我们要寻找新材料，新方法；开发出更好的工程系统；用更可靠的制作流程；让仪器的工作寿命更长久；甚至需要探索全新的自然规律。</p><p>这些为登月发明的新技术同样可以用于地面上的工程项目。每年，都有大概一千项从太空项目中发展出来的新技术被用于日常生活中，这些技术打造出更好的厨房用具和农场设备，更好的缝纫机和收音机，更好的轮船和飞机，更精确的天气预报和风暴预警，更好的通讯设施，更好的医疗设备，乃至更好的日常小工具。你可能会问为什么先设计出宇航员登月舱的维生系统，而不是先为听力障碍患者造出有声阅读设备呢。答案很简单：解决工程问题时，重要的技术突破往往并不是按部就班直接得到的，而是来自能够激发出强大创新精神，能够燃起的想象力和坚定的行动力，以及能够整合好所有资源的充满挑战的目标。</p><p>太空旅行无可置疑地是一项充满挑战的事业。通往火星的航行并不能直接提供食物解决饥荒问题。然而，它所带来大量的新技术和新方法可以用在火星项目之外，这将产生数倍于原始花费的收益。若希望人类生活得越来越好，除了需要新的技术，我们还需要基础科学不断有新的进展。包括物理学和化学，生物学和生理学，特别是医学，用来照看人类的健康，应对饥饿、疾病、食物和水的污染以及环境污染等问题。</p><p>我们需要更多的年轻人投入到科学事业中来，我们需要给予那些投身科研事业的有天分的科学家更多的帮助。随时要有富于挑战的研究项目，同时要保证对项目给予充分的资源支持。在此我要重申，太空项目是科技进步的催化剂，它为学术研究工作提供了绝佳和实践机会，包括对月球和其他行星的眼睛、物理学和天文学、生物学和医学科学等学科，有它，科学界源源不断出现令人激动不已研究课题，人类得以窥见宇宙无比瑰丽的景象；为了它，新技术新方法不断涌现。</p><p>由美国政府控制并提供资金支持的所有活动中，太空项目无疑最引人瞩目也最容易引起争议，尽管其仅占全部预算的1.6%，不到全民生产总值的千分之三。作为新技术的驱动者和催化剂，太空项目开展了多项基础科学的研究，它的地位注定不同于其他活动。从某种意义上来说，以太空项目的对社会的影响，其地位相当于3-4千年前的战争活动。</p><p>如果国家之间不再比拼轰炸机和远程导弹，取而代之比拼月球飞船的性能，那将避免多少战乱之苦！聪慧的胜利者将满怀希望，失败者也不用饱尝痛苦，不再埋下仇恨的种子，不再带来复仇的战争。</p><p>尽管我们开展的太空项目研究的东西离地球很遥远，已经将人类的视野延伸至月亮、至太阳、至星球、直至那遥远的星辰，但天文学家对地球的关注，超过以上所有天外之物。太空项目带来的不仅有那些新技术所所提供的生活品质的提升，随着对宇宙研究的深入，我们对地球，对生命，对人类自身的感激之情将越深。太空探索让地球更美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：&lt;/p&gt;
&lt;p&gt;目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改&lt;/p&gt;
&lt;p&gt;从理论上讲，按照这个顺序操作，你就能得到一篇组
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.maksim.website/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 安全系列之删除特殊的用户和用户组</title>
    <link href="http://www.maksim.website/2018/04/02/1/"/>
    <id>http://www.maksim.website/2018/04/02/1/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-06-20T05:07:51.210Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。</p><p>Linux 系统中可以删除的默认用户和用户组大致如下：</p><ul><li>可删除的用户，如 adm、lp、sync、shutdown、halt、news、uucp、operator、games、gopher 等。</li><li>可删除的用户组，如 adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers 等。</li></ul><p>删除的方法很简单，下面以删除 games 用户和用户组为例介绍具体的操作。</p><p>删除用户所使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">userdel games</div></pre></td></tr></table></figure><p>删除用户组使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupdel games</div></pre></td></tr></table></figure><p>有些时候，某些用户仅仅作为进程调度或者用户组调用，并不需要登录功能，此时可以禁止这些用户登录系统的功能，例如要禁止 nagios 用户的登录功能，可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -s /sbin/nologin nagios</div></pre></td></tr></table></figure><p>其实要删除哪些用户和用户组，并没有固定要求，可以根据服务器的用途来决定，如果服务器用于 Web 应用的，那么系统默认的 Apache 用户和用户组就无需删除；如果服务器用于数据库应用，那么建议删除系统默认的 Apache 用户和用户组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。&lt;/p&gt;
&lt;p&gt;Linux 系统中可以删除的默认用户和用户组大
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>AndroidStudio解决一直处于Building gradle project info的问题</title>
    <link href="http://www.maksim.website/2018/03/10/1/"/>
    <id>http://www.maksim.website/2018/03/10/1/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-06-25T12:39:00.687Z</updated>
    
    <content type="html"><![CDATA[<p>问题的原因是gradle包（即gradle-wrapper.properties里的gradle压缩文件）本地没有需要下载，因为墙的原因，一直卡在下载的环节。 </p><p>有三个解决方案：（选其一，推荐第三个方案） </p><ol><li>科学#上网，不多说，必备。加载多久看你网速了。（但即使是如此速度依旧很慢）</li><li>将 gradle-wrapper.properties中的版本改为已经存在的版本，找一个可以编译的项目复制 gradle 版本号即可。</li><li>下载对应离线包放到本地（如：C:\Users\Administrator.gradle\wrapper\dists\gradle-4.0.1-all\26awvqv6f41r14q9x72t4n0s，不解压，重启as），离线包地址：services.gradle.org/distributions/或者<a href="http://download.csdn.net/album/detail/2265" target="_blank" rel="noopener">http://download.csdn.net/album/detail/2265</a>；然后打开File-&gt;Settings-&gt;Build, Exectution, Deployment-&gt;Gradle ，设置 “Gradle home” 为解压目录即可.</li></ol><blockquote><p>原文地址：<a href="http://blog.csdn.net/nifanggge/article/details/53397942" target="_blank" rel="noopener">http://blog.csdn.net/nifanggge/article/details/53397942</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题的原因是gradle包（即gradle-wrapper.properties里的gradle压缩文件）本地没有需要下载，因为墙的原因，一直卡在下载的环节。 &lt;/p&gt;
&lt;p&gt;有三个解决方案：（选其一，推荐第三个方案） &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;科学#上网，不多说，必备。
      
    
    </summary>
    
      <category term="Andriod" scheme="http://www.maksim.website/categories/Andriod/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx的安装</title>
    <link href="http://www.maksim.website/2018/02/27/1/"/>
    <id>http://www.maksim.website/2018/02/27/1/</id>
    <published>2018-02-26T16:00:00.000Z</published>
    <updated>2018-06-25T12:39:20.550Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。</p><p>在安装 Nginx 时，我们可以通过以下两种方式进行安装：</p><ol><li>使用包管理器安装 Nginx</li><li>通过源代码安装 Nginx</li></ol><h2 id="使用包管理器安装-Nginx"><a href="#使用包管理器安装-Nginx" class="headerlink" title="使用包管理器安装 Nginx"></a>使用包管理器安装 Nginx</h2><p>使用包管理器安装 Nginx 的机会，是你使用的操作系统已经提供了 Nginx 的安装包。使用包管理器安装 Nginx 的方式很简单，只需要在终端输入：</p><p>Linux(基于 deb，如 Ubunut)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure><p> Linux（基于 rpm，如 CentOS)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>FreeBSD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pkg_install -r nginx</div></pre></td></tr></table></figure><p>通过上述命令，Nginx 将会安装到操作系统的标准位置下。如果使用操作系统的安装包安装 Nginx，那么通过上面的命令来安装是最佳方式。</p><p>Nginx 核心团队也提供了稳定的二进制版本，可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 页面下载可用版本。未发布 Nginx 安装包的系统用户（例如，CentOS），可以使用下面指导来安装预测试、预编译二进制版本。</p><p>通过创建下面的文件，在系统中添加 Nginx 仓库的 yum 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/yum.repos.d/nginx.repo</div><div class="line">[nginx]</div><div class="line">name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure><p>然后，听过执行如下命令来安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>也可以按照前面介绍的 URL 下载 nginx 发行版安装。</p><h2 id="从源代码安装-Nginx"><a href="#从源代码安装-Nginx" class="headerlink" title="从源代码安装 Nginx"></a>从源代码安装 Nginx</h2><p>Nginx 代码提供了两种独立的下载分支——开发版与稳定版。开发分支是一个正处于积极开发状态的版本。在这个版本中，会有一些新功能被集成到其中，在稳定版中是找不到这些功能的。当发布一个“开发”版时，它会经历同样的 QA 和作为稳定版本的一组类似测试功能。因此无论哪一个分支都一颗用于生产环境中，两者主要的不同，在于对第三方模块的支持。在开发板中，内部的 API 可能会发生改变，而稳定版则保持不变。因此，为了与第三方模块向下兼容，在稳定版中第三方模块都可以有效使用。</p><h3 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h3><p>为了从源代码编译 Nginx，系统需要满足某些必要条件，除了编译器外，如果想分别启用 SSL 支持和使用 rewrite 模块，那么还需要提供响应的 OpenSSL 与 PCRE（Perl Compatible Regular Expressions）库及开发头文件。rewrite 模块是默认安装的。如果你还没有 PCRE 库与开发头文件，你需要在配置阶段禁用 rewrite 模块。这依赖于系统，也有可能在系统中已经默认安装了这些必要条件。如果没有安装，则需要从其安装包安装或者从源码下载并且解压安装，在 Nginx 配置脚本中指定他们在系统中的安装位置。</p><p>如果在配置文件中使用了—with-\<library\>=\<path\>选项，那么 Nginx 会视图建立一个静态依赖库。如果你想让 Nginx 不依赖于系统的任何其他部分，或是想获得些 Nginx 的二进制额外性能，那么你可能会使用构建静态库的做法。如果你使用外部库功能只能从某一个版本起有效（例如，NPN[Next Protocol Negotiation]TLS扩展从 OpenSSL1.0.1版有效），那么你就不得不将其指定到特定版本解压后的源代码路径中。</path\></library\></p><p>根据自己的喜好，你可能会提供其他的、可选安装包。你可以为这些安装包提供支持。他们包括 MD5和 SHA-1以支持散列算法、zip 压缩库、libatomic 库。在 Nginx 中，很多地方法会用到散列库，例如为了计算 URI 散列进而计算缓存 key。</p><p>zlib 压缩裤被用来投递 gzip 压缩内容。如果 atomic_ops 库有效，那么 Nginx 会用它来实现自动内存更新操作，以实现高性能的内存锁定代码。</p><h3 id="从源代码编译"><a href="#从源代码编译" class="headerlink" title="从源代码编译"></a>从源代码编译</h3><p>读者可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载 Nginx，在该页面找到.tar.gz 或者.zip 格式的源代码分支，安装如下步骤将下载的安装包解压到一个临时目录中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir ~/bulid</div><div class="line"><span class="meta">$</span> cd ~/bulid &amp;&amp; tar xzf nginx-&lt;version-number&gt;.tar.gz</div></pre></td></tr></table></figure><p>使用下面命令配置 Nginx:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cd ~/bulid/nginx-&lt;version-number&gt; &amp;&amp; ./configure</div></pre></td></tr></table></figure><p>然后，使用下面命令进行编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> make &amp;&amp; sudo make install</div></pre></td></tr></table></figure><p>在编译自己的二进制 nginx 时，你会有很大的灵活性来包含你仅使用的功能。你已经指定使用哪个用户运行 Nginx 了吗?你要使用默认的 logfile 位置，以便不用在 Nginx 的配置文件明确地说明它们吗?表 1-1 所示是配置选项列表，通过它来帮助你设计出自己的 nginx 命令。这些选项对 Nginx 都是有效的，模块可以被独立激活。</p><table><thead><tr><th>选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td>–prefix=\<path\></path\></td><td style="text-align:left">Nginx 安装的根路径，所有其他的安装路径都要依赖于该选项</td></tr><tr><td>–sbin-path=\<path\></path\></td><td style="text-align:left">指定 Nginx 二进制文件的路径。如果没有指定，那么这个路径依赖于——prefix 选项</td></tr><tr><td>–conf-path=\<path\></path\></td><td style="text-align:left">如果在命令行没有指定配置文件，那么将会通过这里指定的路径，Nginx 将会去那里寻找它的配置文件</td></tr><tr><td>–error-log-path=\<path\></path\></td><td style="text-align:left">指定错误文件的路径，Nginx 会将其中写入错误日志文件，除非有其他配置</td></tr><tr><td>–pid-path=\<path\></path\></td><td style="text-align:left">指定的文件将会写入 Nginx master 进程的pid，通常在/var/run 下</td></tr><tr><td>–lock-path=\<path\></path\></td><td style="text-align:left">共享存储器互斥锁文件的路径</td></tr><tr><td>–user=\<user\></user\></td><td style="text-align:left">worker 进程运行的用户</td></tr><tr><td>–group=\<group\></group\></td><td style="text-align:left">worker 进程运行的组</td></tr><tr><td>–with-file-aio</td><td style="text-align:left">为 FreeBSD4.3+和 Linux2.6.22+系统启用异步 I/O</td></tr><tr><td>–with-debug</td><td style="text-align:left">这个选项用于启用调试日志。在生产环境中不推荐使用该选项。</td></tr></tbody></table><p>你可以使用优化编译，单但是如果使用包管理工具进行安装将无法获得这些优化，如下表：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–with-cc=\<path\></path\></td><td>如果想设置一个不再默认 Path 下的编译器</td></tr><tr><td>–with-cpp=\<path\></path\></td><td>设置 C 预处理器的响应路径</td></tr><tr><td>–with-cc-opt=\<options></options></td><td>指定必要的 include 文件路径，可能（-I\<path\>）指出，也可能是优化(-O4)并指定64位构建</path\></td></tr><tr><td>–with-ld-opt=\<options\></options\></td><td>包含连接器库的路径(-L\<path\>)和运行路径(-R\<path\>)</path\></path\></td></tr><tr><td>—with-cpu-opt=\<cpu\></cpu\></td><td>通过该选项为特定的 CPU 构建 Nginx</td></tr></tbody></table><h2 id="配置-SSL-支持"><a href="#配置-SSL-支持" class="headerlink" title="配置 SSL 支持"></a>配置 SSL 支持</h2><p>对于 TLS/SSL 协议，Nginx 使用 OpenSSL 项目。有关此开源工具包的更多信息，请访问 <a href="https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对" target="_blank" rel="noopener">https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对</a> SSL 的支持。如果使用不带–with-ssl 选项的–with-http_ssl_module 或者–with-mail_ssl_module，你正在使用执行了 configure 命令的、安装在计算机上的 OpenSSL 库。如果你想要针对特定版本的 OpenSSL 进行编译，请下载该分发包，将其解压缩到一个目录中，然后将该目录的路径指定为–with-openssl 的参数。使用–with-openssl-opt 选项为 OpenSSL本身指定额外的构建选项。</p><p>例如，为了使用具有优化椭圆曲线的 OpenSSL 来构建 Nginx，您将使用如下的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ./configure --with-http_ssl_module --with-openssl=$&#123;BUILD_DIR&#125;/openssl-1.0.1p --with-openssl-opt=enable-ec_nistp_64_gcc_128</div></pre></td></tr></table></figure><h2 id="查找并安装第三方模块"><a href="#查找并安装第三方模块" class="headerlink" title="查找并安装第三方模块"></a>查找并安装第三方模块</h2><p>由于有多个开源项目，所以在 Nginx 周围就会有一个活跃的开发社区。由于 Nginx 的模块化特性，这个社区能够开发和发布模块，从而为 Nginx 提供额外的功能。它们涵盖了广泛的应用，所以着手开发自己的模块之前应该看看有什么可用模块。</p><p>安装第三方模块的过程相当简单，步骤如下。</p><p>1.定位你想要使用的模块(在 <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 或者是 <a href="http://wiki.nginx.org/3rdPartyModules查找)。" target="_blank" rel="noopener">http://wiki.nginx.org/3rdPartyModules查找)。</a></p><p>2.下载该模块。</p><p>3.解压缩源代码安装包。</p><p>4.如果有 README 文件，那么阅读 README 文件，查看在安装中是否有依赖安装。</p><p>5.通过./configure–add-module=\<path\>选项配置使用该模块。</path\></p><p>这个过程会给你的 nginx 二进制文件与模块附加这个功能。</p><p>需要注意的是，很多第三方模块是实验性质的。因此，在将这些模块用于生产系统之前，首先要测试使用这些模块。另外请记住，Nginx 的开发版本中可能会有 API 的变化，会导致第三方模块出现问题。</p><h2 id="添加对-Lua-的支持"><a href="#添加对-Lua-的支持" class="headerlink" title="添加对 Lua 的支持"></a>添加对 Lua 的支持</h2><p>特别应该提到的是 ngx_lua 这个第三方模块，ngx_lua 模块提供了启用 Lua 的功能，而不是像 Perl 一样在配置时嵌入式脚本语言。该模块对于 perl 模块来说最大的优点就是它的无阻塞性，并与其他第三方模块紧密集成。对于它的安装说明的完整描述详见:<a href="https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过编译你自己的二进制文件，你可以定制 Nginx能够为你提供哪些功能。对于你来说，构建和安装软件应该不会陌生。所以，创造一个构建环境或者确保所有依赖关系都存在，这并不会花费你很多的时间。一个 Nginx 的安装应该是按照你的需要，能随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。</p><p>参考资料：</p><p>《精通 Nginx》第二版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。&lt;/p&gt;
&lt;p&gt;在安装 Nginx 时，我们可
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Pathogen安装VIM插件</title>
    <link href="http://www.maksim.website/2018/02/23/1/"/>
    <id>http://www.maksim.website/2018/02/23/1/</id>
    <published>2018-02-22T16:00:00.000Z</published>
    <updated>2018-06-20T03:25:08.862Z</updated>
    
    <content type="html"><![CDATA[<p>pathogen的安装其实非常简单。git上有非常全面的介绍和文档，<a href="http://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">http://github.com/tpope/vim-pathogen</a>。简单的几条命令即可搞定pathogen的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p ~/.vim/autoload ~/.vim/bundle   </div><div class="line">curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</div></pre></td></tr></table></figure><p>也就是在 ~/.vim目录下（如果没有，则新建）新建目录autoload、bundle（插件会放在这个目录），然后将pathogen放在autoload目录下即可</p><p>安装完成之后，这时候，pathogen还没有生效，需要在~/.vimrc添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execute pathogen#infect()</div></pre></td></tr></table></figure><p>如果没有~/.vimrc则需要新建文件，并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">execute pathogen#infect()  </div><div class="line">syntax on  </div><div class="line">filetype plugin indent on</div></pre></td></tr></table></figure><p>完成之后，就可以使用pathogen管理vim插件了，只需要将插件放在~/.vim/bundle目录下即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;pathogen的安装其实非常简单。git上有非常全面的介绍和文档，&lt;a href=&quot;http://github.com/tpope/vim-pathogen&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/tpope/v
      
    
    </summary>
    
      <category term="工具" scheme="http://www.maksim.website/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
