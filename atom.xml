<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maksim&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maksim.website/"/>
  <updated>2018-04-08T14:25:32.113Z</updated>
  <id>http://www.maksim.website/</id>
  
  <author>
    <name>Maksim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP中的$this</title>
    <link href="http://www.maksim.website/2018/04/08/cjfqx80i60022h7rdjx21vdkw/"/>
    <id>http://www.maksim.website/2018/04/08/cjfqx80i60022h7rdjx21vdkw/</id>
    <published>2018-04-08T14:25:32.113Z</published>
    <updated>2018-04-08T14:25:32.113Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// property declaration</span></div><div class="line">    <span class="keyword">public</span> $var = <span class="string">'a default value'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// method declaration</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">displayVar</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;var;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>当一个方法在类定义内部被调用时，有一个可用的伪变量 \$this。\$this 是<strong>一个到主叫对象的引用</strong>（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。</p><p><strong>$this 伪变量的示例</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>)) &#123;</div><div class="line">            <span class="keyword">echo</span> <span class="string">'$this is defined ('</span>;</div><div class="line">            <span class="keyword">echo</span> get_class(<span class="keyword">$this</span>);</div><div class="line">            <span class="keyword">echo</span> <span class="string">")\n"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">echo</span> <span class="string">"\$this is not defined.\n"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">        A::foo();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$a = <span class="keyword">new</span> A();</div><div class="line">$a-&gt;foo();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">A::foo();</div><div class="line">$b = <span class="keyword">new</span> B();</div><div class="line">$b-&gt;bar();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">B::bar();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>以上例程会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>this is defined (A)</div><div class="line"><span class="meta"></span></div><div class="line">$this is not defined.</div><div class="line"><span class="meta"></span></div><div class="line">$this is defined (B)</div><div class="line"><span class="meta"></span></div><div class="line">$this is not defined.</div></pre></td></tr></table></figure><p>由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。用静态方式调用一个非静态方法会导致一个 <strong>E_STRICT</strong> 级别的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>美国航空航天局科学家给赞比亚修女的一封信</title>
    <link href="http://www.maksim.website/2018/04/08/3/"/>
    <id>http://www.maksim.website/2018/04/08/3/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-08T14:42:41.635Z</updated>
    
    <content type="html"><![CDATA[<p>背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。</p><p>1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ernst Stuhlinger）博士写了一封信。施图林格因在火星之旅工程中的原创性研究，成为NASA（美国航空航天局）马绍尔太空航行中心的科学副总监。信中，玛丽·尤肯达修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。施图林格很快给尤肯达修女回了信，同时还附带了一张题为“升起的地球”的照片，这张标志性的照片是宇航员威廉·安德斯于1968年在月球轨道上拍摄的（照片中可以看到月球的地面）。他这封真挚的回信随后由NASA以《为什么要探索宇宙》为标题发表。</p><p>1970年5月6日</p><p>亲爱的玛丽·尤肯达修女：每天，我都会收到很多类似的来信，但这封对我的触动最深，因为它来自一颗慈悲的饱含探求精神的心灵。我会尽自己所能来回答你这个问题。首先，请允许我向你以及你勇敢的姐妹们表达深深的敬意，你们献身于人类最崇高的事业：帮助身处困境的同胞。</p><p>在来信中，你问我在目前地球上还有儿童由于饥饿面临死亡威胁的情况下，为什么还要花费数十亿美元来进行飞向火星的航行。 我清楚你肯定不希望这样的答案：“哦，我之前不知道还有小孩子快饿死了，好吧，从现在开始，暂停所有的太空项目，直到孩子们都吃上饭再说。”事实上，早在了解火星之旅的技术之前，我已经对儿童的饥荒问题有所了解。而且，同我很多朋友的看法一样，我认为此时此刻，我们就应该开始通往月球、火星乃至其他行星的伟大探险。从长远来看，相对于那些要么只有年复一年的辩论和争吵，要么连妥协之后也迟迟无法落实的各种援助计划来说，我甚至觉得探索太空的工程给更有助于解决人类目前所面临的种种危机。</p><p>在详细说明我们的太空项目如何帮助解决地面上的危机之前，我想先简短讲一个真实的故事。那是在400年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。</p><p>然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气，“我们还在受瘟疫的苦”，他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！”伯爵听到后不为所动，“我会尽可能地接济大家”，他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。”</p><p>果不其然，他的工作赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。</p><p>伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。</p><p>我们目前面临类似的问题。美国总统的年度预算共有2000亿美元，这些钱将用于医疗、教育、福利、城市建设、高速公路、交通运输、海外援助、国防、环保、科技、农业以及其他多项国内外的工程。今年，预算中的1.6%将用于探索宇宙，这些花销将用于阿波罗以计划、其他一些涵盖了天体物理学、深空天文学、空间生物学、行星探测工程、地球资源工程的小项目以及空间工程技术。为担负这些太空项目的支出，平均每个年收入10,000美元的美国纳税人需要支付约30美元给太空，剩下的9,970美元则可用于一般生活开支、休闲娱乐、储蓄、别的税项等花销。</p><p>也许你会问：“为什么不从纳税人为太空支付的30美元里抽出5美元或3美元或是1美元来救济饥饿的儿童呢？”为了回答这个问题，我需要先简单解释一下我们国家的经济是如何运行的，其他国家也是类似的情形。政府由几个部门（如内政部、司法部、卫生部与公众福利部、教育部、运输部、国防部等）和几个机构（国家科学基金会、国家航空航天局等）组成，这些部门和机构根据自己的职能制定相应的年度预算，并严格执行以应对国务委员会的监督，同时还要应付来自预算部门和总统对于其经济效益的压力。当资金最终由国会拨出后，将严格用于经预算批准的计划中的项目。</p><p>显然，NASA的预算中所包含的项目都是和航空航天有关的。未经国会批准的预算项目，是不会得到资金支持的，自然也不会被课税，除非有其他部门的预算涵盖了该项目，借此花掉没有分配给太空项目的资金。由这段简短的说明可以看出，要想援助饥饿的儿童，或在美国已有的对外援助项目上增加援助金额，需要首先由相关部门提出预算，然后由国会批准才行。</p><p>要问是否同意政府实施类似的政策，我个人的意见是绝对赞成。我完全不介意每年多付出一点点税款来帮助饥饿的儿童，无论他们身在何处。</p><p>我相信我的朋友们也会持相同的态度。然而，事情并不是仅靠把去往火星航行的计划取消就能轻易实现的。相对的，我甚至认为可以通过太空项目，来为缓解乃至最终解决地球上的贫穷和饥饿问题作出贡献。解决饥饿问题的关键有两部分：食物的生产和食物的发放。食物的生产所涉及的农业、畜牧业、渔业及其他大规模生产活动在世界上的一些地区高效高产，而在有的地区则产量严重不足。通过高科技手段，如灌溉管理，肥料的使用，天气预报，产量评估，程序化种植，农田优选，作物的习性与耕作时间选择，农作物调查及收割计划，可以显著提高土地的生产效率。</p><p>人造地球卫星无疑是改进这两个关键问题最有力的工具。在远离地面的运行轨道上，卫星能够在很短的时间里扫描大片的陆地，可以同时观察计算农作物生长所需要的多项指标，土壤、旱情、雨雪天气等等，并且可以将这些信息广播至地面接收站以便做进一步处理。事实证明，配备有土地资源传感器及相应的农业程序的人造卫星系统，即便是最简单的型号，也能给农作物的年产量带来数以十亿美元计的提升。</p><p>如何将食品发放给需要的人则是另外一个全新的问题，关键不在于轮船的容量，而在于国际间的合作。小国统治者对于来自大国的大量食品的输入很难做出准确的判断，他们害怕伴随着食物一同而来的还有外国势力对其统治地位的影响。恐怕在国与国之间消除隔阂之前，饥饿问题无法得以高效解决了。我不认为太空计划能一夜之间创造奇迹，然而，探索宇宙有助于促使问题向着良好的方向发展。</p><p>以最近发生的阿波罗13号事故为例。当宇航员处于关键的大气层再入期时，为了保证通讯畅通，苏联关闭了境内与阿波罗飞船所用频带相同的所有广播通信。同时派出舰艇到太平洋和大西洋海域以备第一时间进行搜救工作。如果宇航员的救生舱降落到俄方舰船附近，俄方人员会像对待从太空返回的本国宇航员一样对他们进行救助。同样，如果俄方的宇宙飞船遇到了类似的紧急情况，美国也一定会毫不犹豫地提供援助。 </p><p>通过卫星进行监测与分析来提高食品产量，以及通过改善国际关系提高食品发放的效率，只是通过太空项目提高人类生活质量的两个方面。下面我想介绍另外两个重要作用：促进科学技术的发展和提高一代人的科学素养。</p><p>登月工程需要历史上前所未有的高精度和高可靠性。面对如此严苛的要求，我们要寻找新材料，新方法；开发出更好的工程系统；用更可靠的制作流程；让仪器的工作寿命更长久；甚至需要探索全新的自然规律。</p><p>这些为登月发明的新技术同样可以用于地面上的工程项目。每年，都有大概一千项从太空项目中发展出来的新技术被用于日常生活中，这些技术打造出更好的厨房用具和农场设备，更好的缝纫机和收音机，更好的轮船和飞机，更精确的天气预报和风暴预警，更好的通讯设施，更好的医疗设备，乃至更好的日常小工具。你可能会问为什么先设计出宇航员登月舱的维生系统，而不是先为听力障碍患者造出有声阅读设备呢。答案很简单：解决工程问题时，重要的技术突破往往并不是按部就班直接得到的，而是来自能够激发出强大创新精神，能够燃起的想象力和坚定的行动力，以及能够整合好所有资源的充满挑战的目标。</p><p>太空旅行无可置疑地是一项充满挑战的事业。通往火星的航行并不能直接提供食物解决饥荒问题。然而，它所带来大量的新技术和新方法可以用在火星项目之外，这将产生数倍于原始花费的收益。若希望人类生活得越来越好，除了需要新的技术，我们还需要基础科学不断有新的进展。包括物理学和化学，生物学和生理学，特别是医学，用来照看人类的健康，应对饥饿、疾病、食物和水的污染以及环境污染等问题。</p><p>我们需要更多的年轻人投入到科学事业中来，我们需要给予那些投身科研事业的有天分的科学家更多的帮助。随时要有富于挑战的研究项目，同时要保证对项目给予充分的资源支持。在此我要重申，太空项目是科技进步的催化剂，它为学术研究工作提供了绝佳和实践机会，包括对月球和其他行星的眼睛、物理学和天文学、生物学和医学科学等学科，有它，科学界源源不断出现令人激动不已研究课题，人类得以窥见宇宙无比瑰丽的景象；为了它，新技术新方法不断涌现。</p><p>由美国政府控制并提供资金支持的所有活动中，太空项目无疑最引人瞩目也最容易引起争议，尽管其仅占全部预算的1.6%，不到全民生产总值的千分之三。作为新技术的驱动者和催化剂，太空项目开展了多项基础科学的研究，它的地位注定不同于其他活动。从某种意义上来说，以太空项目的对社会的影响，其地位相当于3-4千年前的战争活动。</p><p>如果国家之间不再比拼轰炸机和远程导弹，取而代之比拼月球飞船的性能，那将避免多少战乱之苦！聪慧的胜利者将满怀希望，失败者也不用饱尝痛苦，不再埋下仇恨的种子，不再带来复仇的战争。</p><p>尽管我们开展的太空项目研究的东西离地球很遥远，已经将人类的视野延伸至月亮、至太阳、至星球、直至那遥远的星辰，但天文学家对地球的关注，超过以上所有天外之物。太空项目带来的不仅有那些新技术所所提供的生活品质的提升，随着对宇宙研究的深入，我们对地球，对生命，对人类自身的感激之情将越深。太空探索让地球更美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。&lt;/p&gt;
&lt;p&gt;1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ern
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.maksim.website/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>在MYSQL中进行日期操作</title>
    <link href="http://www.maksim.website/2018/04/08/1/"/>
    <id>http://www.maksim.website/2018/04/08/1/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-08T14:25:32.113Z</updated>
    
    <content type="html"><![CDATA[<p>平时比较常用的时间、字符串、时间戳之间的互相转换，虽然常用但是几乎每次使用时候都喜欢去搜索一下用法；本文将作为一个笔记，整理一下三者之间的 转换（即：date转字符串、date转时间戳、字符串转date、字符串转时间戳、时间戳转date，时间戳转字符串）用法，方便日后查看；</p><h2 id="涉及的函数"><a href="#涉及的函数" class="headerlink" title="涉及的函数"></a>涉及的函数</h2><p>date_format(date, format) 函数MySQL日期格式化函数date_format()</p><p>str_to_date(str, format) 函数 把字符串转换为日期</p><p>from_unixtime(unix_timestamp, format) 函数，MySQL时间戳格式化函数from_unixtime</p><h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="时间转字符串"><a href="#时间转字符串" class="headerlink" title="时间转字符串"></a>时间转字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select date_format(now(), '%Y-%m-%d');   #结果：2016-01-05</div></pre></td></tr></table></figure><h3 id="时间转时间戳"><a href="#时间转时间戳" class="headerlink" title="时间转时间戳"></a>时间转时间戳</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select unix_timestamp(now());  #结果：1452001082</div></pre></td></tr></table></figure><h3 id="字符串转时间"><a href="#字符串转时间" class="headerlink" title="字符串转时间"></a>字符串转时间</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select str_to_date('2016-01-02', '%Y-%m-%d %H');  #结果：2016-01-02 00:00:00</div></pre></td></tr></table></figure><h3 id="字符串转时间戳"><a href="#字符串转时间戳" class="headerlink" title="字符串转时间戳"></a>字符串转时间戳</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select unix_timestamp('2016-01-02');  #结果：1451664000</div></pre></td></tr></table></figure><h3 id="时间戳转时间"><a href="#时间戳转时间" class="headerlink" title="时间戳转时间"></a>时间戳转时间</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select from_unixtime(1451997924);  #结果：2016-01-05 20:45:24</div></pre></td></tr></table></figure><h3 id="时间戳转字符串"><a href="#时间戳转字符串" class="headerlink" title="时间戳转字符串"></a>时间戳转字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select from_unixtime(1451997924,'%Y-%d');  #结果：2016-01-05 20:45:24</div></pre></td></tr></table></figure><h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><p>MySQL日期格式化（format）取值范围。</p><table><thead><tr><th></th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>秒</td><td>%S、%s</td><td>两位数字形式的秒（ 00,01, …, 59）</td></tr><tr><td>分</td><td>%I、%i</td><td>两位数字形式的分（ 00,01, …, 59）</td></tr><tr><td>小时</td><td>%H</td><td>24小时制，两位数形式小时（00,01, …,23）</td></tr><tr><td>%h</td><td>12小时制，两位数形式小时（00,01, …,12）</td><td></td></tr><tr><td>%k</td><td>24小时制，数形式小时（0,1, …,23）</td><td></td></tr><tr><td>%l</td><td>12小时制，数形式小时（0,1, …,12）</td><td></td></tr><tr><td>%T</td><td>24小时制，时间形式（HH:mm:ss）</td><td></td></tr><tr><td>%r</td><td>12小时制，时间形式（hh:mm:ss AM 或 PM）</td><td></td></tr><tr><td>%p</td><td>AM上午或PM下午</td><td></td></tr><tr><td>周</td><td>%W</td><td>一周中每一天的名称（Sunday,Monday, …,Saturday）</td></tr><tr><td>%a</td><td>一周中每一天名称的缩写（Sun,Mon, …,Sat）</td><td></td></tr><tr><td>%w</td><td>以数字形式标识周（0=Sunday,1=Monday, …,6=Saturday）</td><td></td></tr><tr><td>%U</td><td>数字表示周数，星期天为周中第一天</td><td></td></tr><tr><td>%u</td><td>数字表示周数，星期一为周中第一天</td><td></td></tr><tr><td>天</td><td>%d</td><td>两位数字表示月中天数（01,02, …,31）</td></tr><tr><td>%e</td><td>数字表示月中天数（1,2, …,31）</td><td></td></tr><tr><td>%D</td><td>英文后缀表示月中天数（1st,2nd,3rd …）</td><td></td></tr><tr><td>%j</td><td>以三位数字表示年中天数（001,002, …,366）</td><td></td></tr><tr><td>月</td><td>%M</td><td>英文月名（January,February, …,December）</td></tr><tr><td>%b</td><td>英文缩写月名（Jan,Feb, …,Dec）</td><td></td></tr><tr><td>%m</td><td>两位数字表示月份（01,02, …,12）</td><td></td></tr><tr><td>%c</td><td>数字表示月份（1,2, …,12）</td><td></td></tr><tr><td>年</td><td>%Y</td><td>四位数字表示的年份（2015,2016…）</td></tr><tr><td>%y</td><td>两位数字表示的年份（15,16…）</td><td></td></tr><tr><td>文字输出</td><td>%文字</td><td>直接输出文字内容</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时比较常用的时间、字符串、时间戳之间的互相转换，虽然常用但是几乎每次使用时候都喜欢去搜索一下用法；本文将作为一个笔记，整理一下三者之间的 转换（即：date转字符串、date转时间戳、字符串转date、字符串转时间戳、时间戳转date，时间戳转字符串）用法，方便日后查看；
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.maksim.website/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>《完全写作指南》读书笔记一、写作的准备</title>
    <link href="http://www.maksim.website/2018/04/08/2/"/>
    <id>http://www.maksim.website/2018/04/08/2/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-08T14:44:34.497Z</updated>
    
    <content type="html"><![CDATA[<p>写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：</p><p>目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改</p><p>从理论上讲，按照这个顺序操作，你就能得到一篇组织得当、逻辑严谨的完美稿件。这个方法对一部分人是有用的，但是如果你和大多数人一样，那么他可能就不适合你。在现实生活中，大部分都不是线性思维的写作者。</p><p>这六个步骤没错，错的是这个强制性的顺序。当遵循渐进编程了因循守旧，它可能会阻碍你写作能力的发挥。</p><p>你可以以这个步骤中任意一步作为起点，头脑风暴、提纲或者是写初稿。</p><h2 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h2><p>当要写作时，首先我们要确定自己的目标是什么，你希望达到什么目的。</p><p>仔细思考写作目的能帮你搞清楚该说什么，以及怎么说。又去的是，这样一来你的读者也会更加轻松，如果你也有过收到大量简历的经理，你就会知道一封周到、工整且有针对性的求职信会让你干到多么轻松。</p><h2 id="了解你的读者"><a href="#了解你的读者" class="headerlink" title="了解你的读者"></a>了解你的读者</h2><p>除了私人日记之外，所有的作品都是有读者的，你的作品需要指向这些特定的读者。</p><p>站在读者的角度进行思考，有两个关键问题：</p><ul><li>信息</li><li>态度</li></ul><p>选择信息的黄金法则是：<strong>要有足量的有效信息，让你的读者行动起来。</strong></p><p>了解读者潜在的态度也是成功的关键。</p><ul><li>你的读者会有什么样的反应？</li><li>他们很容易接受你的信息吗?</li><li>还是会有抵触情绪？</li><li>他们是否怀有敌意。</li></ul><blockquote><p>笔者说：</p><p>在这里，可以读《美国航空航天局科学家给赞比亚修女的一封信》，这是一封大师级的回信。</p></blockquote><h2 id="用他头脑风暴锁定你想表达的内容"><a href="#用他头脑风暴锁定你想表达的内容" class="headerlink" title="用他头脑风暴锁定你想表达的内容"></a>用他头脑风暴锁定你想表达的内容</h2><p>头脑风暴有一些规则。如果你在学校或者工作的地方参加过头脑风暴式的讨论，那么你很可能看到过这些规则：</p><ol><li>相处的点子越多越好。如果你能把注意力放在数量而非质量上，那么提出有用的点子概率就会更大，点子都多多益善。</li><li>不要审查，不要评论。头脑风暴时，让你的思绪自由发散。这并不是对点子进行评论的时候，不要说这个点子不太好，那个点子不合适。把脑袋里评论的声音关掉，把所有想到的东西都写出来。你可以之后再删除。</li><li>接受不同寻常的想法。不要考虑你的想法靠不靠谱。你的这些想法可能完全超出预料，但它们当中可能会有一个非常有用，或至少能为你的思考指引方向的点子。充分发挥自己的想象力。</li><li>合并改进你的点子。如果你任由思绪自由发散，那么点子很可能会有一些重合。观察它们的相似之处，并加以合并调整。</li></ol><p>当写完初稿后，发现内容不够完整，不够有说服力时候甚至可以重新进行头脑风暴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：&lt;/p&gt;
&lt;p&gt;目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改&lt;/p&gt;
&lt;p&gt;从理论上讲，按照这个顺序操作，你就能得到一篇组
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.maksim.website/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80jx004oh7rdpt6q63k4/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80jx004oh7rdpt6q63k4/</id>
    <published>2018-04-03T14:53:43.524Z</published>
    <updated>2018-04-03T14:53:43.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光源色、物体色、固有色"><a href="#光源色、物体色、固有色" class="headerlink" title="光源色、物体色、固有色"></a>光源色、物体色、固有色</h1><h2 id="什么是光源色"><a href="#什么是光源色" class="headerlink" title="什么是光源色"></a>什么是光源色</h2><p>光源色指的是发光体所发出光线的颜色。例如，阳光、月光、火光和各种灯光等的光色。光源色的不同会引起物体的固有颜色的变化。例如，一块红布在白天看起来和在晚上灯光下看起来颜色是有所不同的。许多女同志都懂得这一点，她们避免晚上去商店购买衣料，因为晚上灯光下看到的黄色，和白天看到的是有些不一样的。就是同样的眼光来说，在早晨、正午和傍晚其光色也是不相同的，会引起同一景物的色调的显著变化。</p><p>物体在不同颜色的光照下会呈现出跟光颜色比较接近的色彩，这些都是收到光源色彩的影响。</p><h2 id="什么是物体色"><a href="#什么是物体色" class="headerlink" title="什么是物体色"></a>什么是物体色</h2><p>物体色是指光源色经过物体有选择的吸收和反射，反映到人的视觉中的光色感觉。物体本身并不会发光，但都具有对各种波长的光有所选择性的吸收、反射或者投射的特性，因此形成千变万化的不相同的物体色彩。</p><p>物体可以分为透明物体和不透明物体，不透明物体呈现的色彩是由它反射的光色决定的，而透明物体呈现的色彩则是由它透过的色彩决定的。</p><p>如绿色树叶吸收太阳光除绿色光的其他色光，所以我们看到的是绿色，而蓝色玻璃只透过蓝色光吸收其他光所以看起来呈现的是蓝色。</p><h2 id="什么是固有色"><a href="#什么是固有色" class="headerlink" title="什么是固有色"></a>什么是固有色</h2><p>固有色指的是一个物体在通常情况下给人的色彩印象（概念）例如，红旗是红色的，草地是绿色的，中国人的皮肤是黄色的等等。</p><p>从色彩的光学原理知道物体并不存在固定不变的固有颜色，物体的颜色是与光密切相关的，是在一定的条件下变化的，是具体的，而不是一种概念。讲中国人皮肤是黄色的，其实不可能指出是哪一种具体的光色。然而，物体的颜色景观是变化的、复杂的，单扔给我们一定的色彩印象。所以我们既不要受固有色概念的束缚，又不能完全故事固有色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;光源色、物体色、固有色&quot;&gt;&lt;a href=&quot;#光源色、物体色、固有色&quot; class=&quot;headerlink&quot; title=&quot;光源色、物体色、固有色&quot;&gt;&lt;/a&gt;光源色、物体色、固有色&lt;/h1&gt;&lt;h2 id=&quot;什么是光源色&quot;&gt;&lt;a href=&quot;#什么是光源色&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个新的开始</title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80jn0047h7rdexamhizs/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80jn0047h7rdexamhizs/</id>
    <published>2018-04-03T14:53:43.504Z</published>
    <updated>2018-04-03T14:53:43.507Z</updated>
    
    <content type="html"><![CDATA[<p>人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。</p><a id="more"></a><p>于是在不甘，与短暂的刺激后，我又开始了写作，其实也是想试一试，自己到底能不能够成功，我所谓的成功其实就是写一个完整的故事，记得小时候抓周，我抓的就是个笔，奶奶曾经说我以后是个笔杆子，可惜现在虽然现在也是在写东西，不过写的是代码，而不是小说。</p><p>记得那是还在上初中的时候，我接触到了网络文学，我记得我看的第一本网络小说应该是木子心写的《现代修罗》，可惜最后太监了，那个时候我对太监这件事当真是有些厌恶，可是没想到到最后，我也踏入了后宫那洪流之中，成为了诸多太监中的一份子。我朋友曾经对我说过一句话，要是能在我生儿子之前能看到你一本完本的小说就行了。</p><p>其实这段时间一直在思考我要不要继续写东西，我能否坚持下去，最终还是决定试一试，思前想后决定写一篇科幻类的小说，希望能够做到不落俗套，写出自己心目中的网络文学。</p><p>以后每个月我都会更新一篇关于网络文学的文章，主要是去分析曾经红极一时或者是现在当红的网络小说的写作手法。看一看那些大神是如何进行网络文学创作的，同时也是去提升自己的能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.maksim.website/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80k3004th7rdomdxois2/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80k3004th7rdomdxois2/</id>
    <published>2018-04-03T14:53:43.478Z</published>
    <updated>2018-04-03T14:53:43.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务评估"><a href="#业务评估" class="headerlink" title="业务评估"></a>业务评估</h1><h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ul><li>响应时间（request time）</li><li>数据总量</li><li>每秒请求量</li><li>读写比</li><li>重要程度</li></ul><p><strong>响应时间</strong>是与整个数据库的状态有关，不仅与CPU、数据总量、每秒请求量、读写比以及各种场景都是有关系的。所以说相应时间是一个综合指标。</p><p>对于DBA来说最关心的就是业务的相应时间能不能够满足，在满足的情况下再去优化以下的这些点，才是有意义的。</p><p>数据总量往往需要业务方提供一个一到两年的数据总量，这是因为如果没有数据总量，前期是没有办法规划我们的数据库实例的。当然也有很多的不确定因素，比如互联网行业，比如有的业务会爆发性的增长，这些规划可能是不合理的，但是在我们也要有一个大概的评估，因为这是前期资源申请和资源分配的策略。</p><p>每秒请求量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务评估&quot;&gt;&lt;a href=&quot;#业务评估&quot; class=&quot;headerlink&quot; title=&quot;业务评估&quot;&gt;&lt;/a&gt;业务评估&lt;/h1&gt;&lt;h2 id=&quot;业务需求&quot;&gt;&lt;a href=&quot;#业务需求&quot; class=&quot;headerlink&quot; title=&quot;业务需求&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80k1004sh7rdbd0dfa85/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80k1004sh7rdbd0dfa85/</id>
    <published>2018-04-03T14:53:43.475Z</published>
    <updated>2018-04-03T14:53:43.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 - Singleton"></a>单例模式 - Singleton</h1><p>单例模式确保每一个指定的类只存在一个实例对象，并且可以全局访问那个实例。一般情况下会用延时加载的策略，指在第一次需要使用的时候初始化。</p><blockquote><p>设计模式并不局限于某一个语言，他是一种编程思维</p></blockquote><p>在 iOS 开发中单例模式h很常见，NSUserDefaults.standardUserDefaults()等等。</p><p>如果多于一个实例又会怎么样呢？代码和内存还没精贵到这个地步吧？</p><p>某些场景下，保持实例对象仅有一份是很有意义的。举个例子，你的应用实例 (UIApplication)，应该只有一个吧，显然是指你的当前应用。还有一个例子：设备的屏幕 (UIScreen) 实例也是这样，所以对于这些类的情况，你只想要一个实例对象。</p><p>单例模式的应用还有另一种情况：你需要一个全局类来处理配置文件。我们很容易通过单例模式实现线程安全的实例访问，而如果有多个类可以同时访问配置文件，那可就复杂多了。</p><h1 id="使用单例模式"><a href="#使用单例模式" class="headerlink" title="使用单例模式"></a>使用单例模式</h1><p><img src="https://swift-design-patterns.books.yourtion.com/images/singleton1.png" alt=""></p><p>这是一个日志类，有一个属性（是以单例对象）和两个方法（sharedInstance()和 init()）。</p><p>第一吊用 sharedInstance()的时候，instance 属性还没有初始化，所以我们必须创建一个新的实例并且返回。</p><p>下一次再调用 sharedInstance()的时候，instance 已经完成了初始化，直接返回即可，这个逻辑就确保了只有一个实例对象。</p><p>接下来我们继续完善单例模式，通过这个类来管理专辑数据。</p><p>注意到在我们前面的截图里，分组中有个 API 分组，这里可以放那些提供后台服务的类。在这个分组中创建一个新的文件 LibraryAPI.swift ，继承自 NSObject 类。</p><p>在 LibraryAPI 里添加下面这段代码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模式-Singleton&quot;&gt;&lt;a href=&quot;#单例模式-Singleton&quot; class=&quot;headerlink&quot; title=&quot;单例模式 - Singleton&quot;&gt;&lt;/a&gt;单例模式 - Singleton&lt;/h1&gt;&lt;p&gt;单例模式确保每一个指定的类只存在一个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80k7004wh7rda8c6j560/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80k7004wh7rda8c6j560/</id>
    <published>2018-04-03T14:53:43.470Z</published>
    <updated>2018-04-03T14:53:43.473Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:iOS图层树<br>categories:iOS<br>date:2015-12-21</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><h1 id="图层树"><a href="#图层树" class="headerlink" title="图层树"></a>图层树</h1><p>Core Animation 是一个符合引擎，塔的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分分解成独立的图层，存储在一个叫做图层数的体系中，于是这个树形成了 UIKit 以及在 iOS 10应用程序当中你所看能在屏幕上看见的一切的基础。</p><h2 id="图层与视图"><a href="#图层与视图" class="headerlink" title="图层与视图"></a>图层与视图</h2><p>如果你曾经在 iOS 10或MacOS 平台上面写过应用程序，你可能能会对视图的概念比较熟悉。一个视图就是在屏幕上显示一个矩形块（比如图片，文字或者视频），它能拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系。</p><p><img src="https://zsisme.gitbooks.io/ios-/content/chapter1/1.1.jpeg" alt=""></p><p>图1.1一种典型的 iOS 屏幕（左边）和型城市图的层级关系（右边）</p><p>在 iOS 中，所有的视图都从一个叫做 UIview 的基类派生而来，UIView 可以处理触摸事件，可以支持基于 Core Graphics 绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><p>CALayer类在概念上和 UIView 类似，同样也是一些被层级关系树管理的矩形块，同样可以包含一些内容（像图片，文本或者背景色），管理子视图的位置。它们有一些方法和尚需经用来做动画和变换。</p><p>和 UIview 最大的不同是 CALayer 不处理用户的交互。</p><p>CALayer 兵不清楚具体的响应链（iOS通过视图层级关系用来传递触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触电在图层的范围之内。</p><h2 id="平行的层级关系"><a href="#平行的层级关系" class="headerlink" title="平行的层级关系"></a>平行的层级关系</h2><p>每一个 UIView 都有一个 CALayer 实例的图层属性，也就是所谓的 Backing layer,视图的职责就是创建并管理这个图层，以确保子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应是在层级关系树当中有相同的操作（见图1.2）</p><p><img src="https://zsisme.gitbooks.io/ios-/content/chapter1/1.2.jpeg" alt=""></p><p>图1.2 图层的树状结构（左边）以及对应的视图层级（右边）</p><p>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView 仅仅是对它的一个封装，提供了一些 iOS 类似于处理触摸事件的具体功能，以及 Core Animation 底层方法的高级借口。</p><p>但是为什么 iOS 要基于 UIview 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这也是能避免很多重复代码。在 iOS 和 Mac OS两个平台上，时间和用户交互有很多地方不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么 iOS有 UIKit 和 UIView，但是 MacOS 有 APPKit 和 NSView 的元婴。他们功能上很类似，但是在实现上有着显著的区别。</p><p>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。+</p><p>实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:iOS图层树&lt;br&gt;categories:iOS&lt;br&gt;date:2015-12-21&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1&lt;/h2&gt;&lt;h1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Object.defineProperty()模拟双向数据绑定</title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80jt004hh7rd1mmrdjbk/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80jt004hh7rd1mmrdjbk/</id>
    <published>2018-04-03T14:53:43.463Z</published>
    <updated>2018-04-03T14:53:43.464Z</updated>
    
    <content type="html"><![CDATA[<p>对象是由多键值对组成的无序集合，对象中的每个属性对应任意类型的值。定义对象可以使用构造函数或字面量的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//obj = &#123;&#125;</span></div><div class="line">obj.name = <span class="string">'Maksim'</span>;     <span class="comment">//添加属性</span></div><div class="line">obj.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;; <span class="comment">//添加方法</span></div></pre></td></tr></table></figure><p>为对象添加属性我们还可以使用 Object.defineProperty 定义和修改属性。</p><p>语法：<code>Object.defineProperty(obj, prop, descriptor)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象是由多键值对组成的无序集合，对象中的每个属性对应任意类型的值。定义对象可以使用构造函数或字面量的形式。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80iq002wh7rd7pp5wonm/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80iq002wh7rd7pp5wonm/</id>
    <published>2018-04-03T14:53:43.439Z</published>
    <updated>2018-04-03T14:53:43.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RESTFul-是什么？"><a href="#RESTFul-是什么？" class="headerlink" title="RESTFul 是什么？"></a>RESTFul 是什么？</h2><p>RESTful的本质是一种软件架构风格，核心是面向资源，主要用来解决降低开发的复杂性，提高系统的可伸缩性。随着互联网的发展，各种终端层出不穷，手机浏览器，手机 APP 为了节约成本，我们可以使用 RESTful 架构，只需要封装好一套完善的API就可以为多套终端提供服务。</p><p>设计概念和准则</p><ul><li>网络上所有事物都可以被抽象为资源</li><li>每一个资源都有唯一的标识符，对资源的操作不会改变这些标识</li><li>所有的操作都是无状态的</li></ul><p>所谓的资源就是网络上的一个实体，或者说是网络上一个具体的信息。</p><p>HTTP 协议 - URL</p><p>HTTP 是一个属于应用层的协议，特点是简捷、快速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">schema://host[:port]/path[?query-string][#anchor]</div></pre></td></tr></table></figure><ul><li>schema 指定底层使用的协议（如：http,https）</li><li>host   服务器的 IP 地址或者域名</li><li>port 服务器端口</li><li>path 访问资源的路径</li><li>query-string 发送给 http 服务器的数据</li><li>anchor     锚</li></ul><p>HTTP</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RESTFul-是什么？&quot;&gt;&lt;a href=&quot;#RESTFul-是什么？&quot; class=&quot;headerlink&quot; title=&quot;RESTFul 是什么？&quot;&gt;&lt;/a&gt;RESTFul 是什么？&lt;/h2&gt;&lt;p&gt;RESTful的本质是一种软件架构风格，核心是面向资源，主要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP基础手札的引用</title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80id002bh7rds6ygvj50/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80id002bh7rds6ygvj50/</id>
    <published>2018-04-03T14:53:43.433Z</published>
    <updated>2018-04-03T14:53:43.433Z</updated>
    
    <content type="html"><![CDATA[<p>在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。</p><p>PHP 的指针域这些语言机制相同，即可以用一个变量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。&lt;/p&gt;
&lt;p&gt;PHP 的指针域这些语言机制相同，即可以用一个变量&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP页面静态化</title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80il002nh7rdv1vjlk38/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80il002nh7rdv1vjlk38/</id>
    <published>2018-04-03T14:53:43.431Z</published>
    <updated>2018-04-03T14:53:43.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h1><p>要了解静态化页面，首先我们就要知道什么是页面？</p><p>一、静态web页面：</p><p>1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。</p><p>2、为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。</p><p>3、静态web无法连接数据库；</p><p>4、静态web资源开发技术：HTML；</p><p>5、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。</p><p>二、动态web页面：</p><p>动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。</p><p>如果客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</p><p>如果客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</p><p>#静态化</p><p>PHP静态化分为：纯静态化 和 伪静态化；纯静态化又分为：局部静态化 和 完全静态化</p><p>纯静态化：是把PHP生成的动态页面保存成静态的html文件，用户访问该静态页面，而不是用户每一次访问都重新生成一张相同的网页，优点就是减小服务器开销，</p><ul><li>局部静态化：是生成的静态文件中，有局部的数据还是通过ajax技术动态获取的；</li><li>完全静态化：即不存在动态获取数据的情况，所以内容都来自静态的html页面</li></ul><p>伪静态化：其实还是动态访问，其实质是动态生成数据，你访问的网址类似于”<a href="http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化" target="_blank" rel="noopener">http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化</a></p><p>　　伪静态的优点：美观；便于搜索引擎收录</p><p>buffer 概括</p><p>buffer 其实就是缓冲区，一个内存地址空间，主要是用于存储数据的区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于页面&quot;&gt;&lt;a href=&quot;#关于页面&quot; class=&quot;headerlink&quot; title=&quot;关于页面&quot;&gt;&lt;/a&gt;关于页面&lt;/h1&gt;&lt;p&gt;要了解静态化页面，首先我们就要知道什么是页面？&lt;/p&gt;
&lt;p&gt;一、静态web页面：&lt;/p&gt;
&lt;p&gt;1、在静态Web程序中，客
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80hk0015h7rduae6h7io/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80hk0015h7rduae6h7io/</id>
    <published>2018-04-03T14:53:43.410Z</published>
    <updated>2018-04-03T14:53:43.411Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:MySQL索引<br>categories:MySQL</p><h2 id="date-2017-8-6"><a href="#date-2017-8-6" class="headerlink" title="date:2017-8-6"></a>date:2017-8-6</h2><p>数据库索引，是数据库管理系统中一个排序的数据结构，用于协助快速查询、更新数据库表中的数据。它类似于书本上的索引，通过索引可以更便捷地找到书里面的内容而不需要查阅整本书。对于海量数据的检索，索引往往是最有效的。</p><p>目前MySQL主要支持的几种索引有:B树索引(B-tree)、散列索引(hash)、空间索引(R-tree)和全文索引(full-text)。如果没有特别指明，本书指的就是B-Tree索引。由于索引是在存储引擎层实现的，所以不同的存储引擎的索引实现会有一些差异。以下所述的是一些较通用的索引知识。</p><p>逻辑上又可以分为:单列索引、复合索引(多列索引)、唯一(Unique)索引和非唯一(Non Unique)索引。</p><p>如果索引键值的逻辑顺序与索引所服务的表中相应行的物理顺序相同，那么该索引被称为簇索引(cluster index)，也称为聚集索引、聚簇索引，也就是说数据和索引(B+树)在一起，记录被真实地保存在索引的叶子中，簇索引也称为索引组织表，反之为非聚集索引。我们常用的InnoDB表其实使用的就是聚集索引。</p><p>簇索引是一个很重要的概念，InnoDB作为最常使用的引擎，只有在熟悉了它的数据存储方式之后，才可能有针对性地对它进行调优。</p><p>簇索引的一些优点如下。</p><ul><li>将相关的的数据保持在一起，叶子节点内可保存相邻近的记录。·因为索引和数据存储在一起，所以查找数据通常比非簇索引更快。由于主键是有序的，很显然，对于InnoDB表，最高效的存取方式是按主键存取唯一记录或进行小范围的主键扫描。  如果充分利用簇索引，它可以极大地提升性能，但簇索引也有许多不足之处。</li><li>簇索引对I/O密集型的负荷性能提升最佳，但如果数据是在内存中(访问次序不怎么重要)，那么簇索引并没有明显益处。</li><li>插入操作很依赖于插入的顺序，按primary key的顺序插入是最快的。</li><li>更新簇索引列的成本比较高，因为InnoDB不得不将更新的行移动到新的位置。</li><li>全表扫描的性能不佳，尤其是数据存储得不那么紧密时，或者因为页分裂(page split)而导致物理存储不连续。</li><li>二级索引的叶节点中存储了主键索引的值，如果主键采用的是较长的字符，那么索引可能会很大，且通过二级索引查找数据也需要进行两次索引查找。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:MySQL索引&lt;br&gt;categories:MySQL&lt;/p&gt;
&lt;h2 id=&quot;date-2017-8-6&quot;&gt;&lt;a href=&quot;#date-2017-8-6&quot; class=&quot;headerlink&quot; title=&quot;date:2017-8-6&quot;&gt;&lt;/a&gt;d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80hi0013h7rdgnz98m1m/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80hi0013h7rdgnz98m1m/</id>
    <published>2018-04-03T14:53:43.409Z</published>
    <updated>2018-04-03T14:53:43.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL常用存储引擎之Innodb"><a href="#MySQL常用存储引擎之Innodb" class="headerlink" title="MySQL常用存储引擎之Innodb"></a>MySQL常用存储引擎之Innodb</h1><p>Mysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。</p><p>和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。</p><p>特点：</p><ul><li>灾难恢复性好</li><li>支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的</li><li>使用行级锁</li><li>对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的</li><li>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引</li><li>支持外键</li><li>支持热备份</li></ul><p>Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由<code>innodb_file_per_table</code>这个参数决定。</p><p>如果值为 <code>ON</code>,会为每个 innodb 表建立一个<code>tablename.ibd</code>的系统文件，如果该参数为<code>OFF</code>时会把数据存储到系统的表空间<code>ibdataX</code></p><p>引用</p><p>《打造扛得住的 MySQL》 慕课网</p><p>《高性能 MySQL》</p><p>《My》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;a href=&quot;#MySQL常用存储引擎之Innodb&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;/a&gt;MySQL常用存储引擎之Innodb&lt;/h1&gt;&lt;p&gt;Mysql5
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80hq001eh7rdo8nw566m/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80hq001eh7rdo8nw566m/</id>
    <published>2018-04-03T14:53:43.408Z</published>
    <updated>2018-04-03T14:53:43.408Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:MySQL服务器参数介绍<br>categories:MySQL<br>date:2017-10-18</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p>人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。</p><p>MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。</p><p>从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。</p><p>##　MySQl获取配置信息路径</p><ul><li>命令行参数 <code>mysqld_safe --datadir=/data/sql_data</code></li><li>配置文件 <code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code></li></ul><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171013153125.png" alt=""></p><p>MySQL会先从<code>/etc/my.cnf</code>文件下读取配置信息，然后是<code>/etc/mysql/my.cnf</code>。</p><p>MySQL配置参数的作用域</p><ul><li>全局参数 <ul><li><code>set global 参数名 = 参数值;</code></li><li><code>set @@global。参数名:=参数值;</code></li></ul></li><li>会话参数<ul><li><code>set [session] 参数名=参数值;</code></li><li><code>set @@session.参数名:=参数值;</code></li></ul></li></ul><p>会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。</p><p>在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。</p><h2 id="内存配置相关参数"><a href="#内存配置相关参数" class="headerlink" title="内存配置相关参数"></a>内存配置相关参数</h2><p>MySQL对于内存的使用我们可以分为两个类来看。</p><ul><li>无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存</li><li>可以通过参数配置控制的，各类的缓冲池所需要的内存。</li></ul><p>对内存参数配置之前，我们需要进行考虑：</p><ul><li>确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。</li><li>确定MySQL的每个连接使用的内存，例如排序缓冲和临时表</li><li><p>把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。</p><ul><li><p>sort_buffer_size</p><ul><li>join_buufer_szie</li><li>read_buffer_size</li><li>read_rnd_buffer_size  </li></ul></li></ul></li></ul><h3 id="确定需要为操作系统保留多少内存"><a href="#确定需要为操作系统保留多少内存" class="headerlink" title="确定需要为操作系统保留多少内存"></a>确定需要为操作系统保留多少内存</h3><p>给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。</p><p>数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。</p><p>另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。</p><h3 id="如何为缓冲池分配内存"><a href="#如何为缓冲池分配内存" class="headerlink" title="如何为缓冲池分配内存"></a>如何为缓冲池分配内存</h3><p>Innodb_buffer_pool_size，Innodb缓冲区</p><p>总内存-（每个线程所需要的内存*连接数）- 系统保留内存</p><p>手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。</p><h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos;</div></pre></td></tr></table></figure><h2 id="I-O相关配置参数"><a href="#I-O相关配置参数" class="headerlink" title="I/O相关配置参数"></a>I/O相关配置参数</h2><p>Innodb I/O相关配置</p><h2 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h2><p><code>expire_logs_days</code> 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:MySQL服务器参数介绍&lt;br&gt;categories:MySQL&lt;br&gt;date:2017-10-18&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80h6000kh7rdek12kyvc/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80h6000kh7rdek12kyvc/</id>
    <published>2018-04-03T14:53:43.401Z</published>
    <updated>2018-04-03T14:53:43.402Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:C语言中的内存<br>categories:C/C++<br>date:2017-10-21</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p> C 程序在编译后，会以三种形式使用内存。</p><ul><li><p>静态变量/全局内存</p><p>静态声明的变量分配在这里，全局变量也会使用这部分内存。这些内存在程序开始运行时分配，直到程序终止才会消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。</p></li><li><p>自动内存</p><p>这些变量在函数内部声明，并且在函数被调用时才能创建。它们的作用域局限于函数内部，而且在函数被调用才创建。它们的作用域局限于函数内部，热切声明周期限制在函数的执行时间内。</p></li><li><p>动态内存</p><p>内存分派在堆上，可以根据需要存放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:C语言中的内存&lt;br&gt;categories:C/C++&lt;br&gt;date:2017-10-21&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfqx80ip002th7rd3ue4nnc6/"/>
    <id>http://www.maksim.website/2018/04/03/cjfqx80ip002th7rd3ue4nnc6/</id>
    <published>2018-04-03T14:53:03.331Z</published>
    <updated>2018-04-03T14:53:03.331Z</updated>
    
    <content type="html"><![CDATA[<p>#md</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#md&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>删除特殊的用户和用户组</title>
    <link href="http://www.maksim.website/2018/04/02/1/"/>
    <id>http://www.maksim.website/2018/04/02/1/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-04-03T14:53:43.528Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。</p><p>Linux 系统中可以删除的默认用户和用户组大致如下：</p><ul><li>可删除的用户，如 adm、lp、sync、shutdown、halt、news、uucp、operator、games、gopher 等。</li><li>可删除的用户组，如 adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers 等。</li></ul><p>删除的方法很简单，下面以删除 games 用户和用户组为例介绍具体的操作。</p><p>删除用户所使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">userdel games</div></pre></td></tr></table></figure><p>删除用户组使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupdel games</div></pre></td></tr></table></figure><p>有些时候，某些用户仅仅作为进程调度或者用户组调用，并不需要登录功能，此时可以禁止这些用户登录系统的功能，例如要禁止 nagios 用户的登录功能，可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -s /sbin/nologin nagios</div></pre></td></tr></table></figure><p>其实要删除哪些用户和用户组，并没有固定要求，可以根据服务器的用途来决定，如果服务器用于 Web 应用的，那么系统默认的 Apache 用户和用户组就无需删除；如果服务器用于数据库应用，那么建议删除系统默认的 Apache 用户和用户组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。&lt;/p&gt;
&lt;p&gt;Linux 系统中可以删除的默认用户和用户组大
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hash算法</title>
    <link href="http://www.maksim.website/2018/03/13/1/"/>
    <id>http://www.maksim.website/2018/03/13/1/</id>
    <published>2018-03-12T16:00:00.000Z</published>
    <updated>2018-04-03T14:53:43.404Z</updated>
    
    <content type="html"><![CDATA[<p>Hash表（HashTable）又称散列表，通过把关键字 key 映射到数组中的一个位置来访问记录，以加快查找的速度。这个应设函数称之为 Hash 函数，存放记录的数组称之为 Hash 表。</p><p>##HASH 函数</p><p>Hash 函数的作用是把任意长度的输入，通过 Hash 算法编程固定长度的输出，该输出就是 Hash 值。这种转换是一种压缩映射，也就是 Hash 值的空间通常远远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从 Hash 值来唯一地确定输入值。</p><p>一个号的 Hash 函数应该满足以下条件：每个关键字都可以均匀地分布到 Hash 表任意一个位置，并与其他已经被散列到 Hash 表中的关键字不发生冲突，这就是Hash 最难实现的地方。</p><h2 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h2><p>关键字 key 可能是整数或者字符串，可以按照关键字的类型设计不同的 Hash 算法。整数关键字的 Hash 算法有以下几种。</p><h3 id="直接取余数"><a href="#直接取余数" class="headerlink" title="直接取余数"></a>直接取余数</h3><p>直接取余法原理比较简单，直接使用关键字key 除以 Hash 表的大小 m 取余，算法如下：</p><p>h(key) = key mod m</p><p>例如，如果 Hash 表的大小为 m=12，所以关键字 key=100，则 h(key) = 4，这种算法只需要一个求余操作，速度比较快。</p><h3 id="乘积取整法"><a href="#乘积取整法" class="headerlink" title="乘积取整法"></a>乘积取整法</h3><p>未完成····待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hash表（HashTable）又称散列表，通过把关键字 key 映射到数组中的一个位置来访问记录，以加快查找的速度。这个应设函数称之为 Hash 函数，存放记录的数组称之为 Hash 表。&lt;/p&gt;
&lt;p&gt;##HASH 函数&lt;/p&gt;
&lt;p&gt;Hash 函数的作用是把任意长度的
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
</feed>
