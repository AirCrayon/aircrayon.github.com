<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maksim&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maksim.website/"/>
  <updated>2018-04-09T10:30:21.933Z</updated>
  <id>http://www.maksim.website/</id>
  
  <author>
    <name>Maksim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP中的$this</title>
    <link href="http://www.maksim.website/2018/04/09/cjfs3j8st000i3crdsotagdsx/"/>
    <id>http://www.maksim.website/2018/04/09/cjfs3j8st000i3crdsotagdsx/</id>
    <published>2018-04-09T10:30:21.933Z</published>
    <updated>2018-04-09T10:30:21.933Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// property declaration</span></div><div class="line">    <span class="keyword">public</span> $var = <span class="string">'a default value'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// method declaration</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">displayVar</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;var;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>当一个方法在类定义内部被调用时，有一个可用的伪变量 \$this。\$this 是<strong>一个到主叫对象的引用</strong>（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。</p><p><strong>$this 伪变量的示例</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>)) &#123;</div><div class="line">            <span class="keyword">echo</span> <span class="string">'$this is defined ('</span>;</div><div class="line">            <span class="keyword">echo</span> get_class(<span class="keyword">$this</span>);</div><div class="line">            <span class="keyword">echo</span> <span class="string">")\n"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">echo</span> <span class="string">"\$this is not defined.\n"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">        A::foo();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$a = <span class="keyword">new</span> A();</div><div class="line">$a-&gt;foo();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">A::foo();</div><div class="line">$b = <span class="keyword">new</span> B();</div><div class="line">$b-&gt;bar();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">B::bar();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>以上例程会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>this is defined (A)</div><div class="line"><span class="meta"></span></div><div class="line">$this is not defined.</div><div class="line"><span class="meta"></span></div><div class="line">$this is defined (B)</div><div class="line"><span class="meta"></span></div><div class="line">$this is not defined.</div></pre></td></tr></table></figure><p>由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。用静态方式调用一个非静态方法会导致一个 <strong>E_STRICT</strong> 级别的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在MYSQL中进行日期操作</title>
    <link href="http://www.maksim.website/2018/04/08/1/"/>
    <id>http://www.maksim.website/2018/04/08/1/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-09T10:30:21.933Z</updated>
    
    <content type="html"><![CDATA[<p>平时比较常用的时间、字符串、时间戳之间的互相转换，虽然常用但是几乎每次使用时候都喜欢去搜索一下用法；本文将作为一个笔记，整理一下三者之间的 转换（即：date转字符串、date转时间戳、字符串转date、字符串转时间戳、时间戳转date，时间戳转字符串）用法，方便日后查看；</p><h2 id="涉及的函数"><a href="#涉及的函数" class="headerlink" title="涉及的函数"></a>涉及的函数</h2><p>date_format(date, format) 函数MySQL日期格式化函数date_format()</p><p>str_to_date(str, format) 函数 把字符串转换为日期</p><p>from_unixtime(unix_timestamp, format) 函数，MySQL时间戳格式化函数from_unixtime</p><h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="时间转字符串"><a href="#时间转字符串" class="headerlink" title="时间转字符串"></a>时间转字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select date_format(now(), '%Y-%m-%d');   #结果：2016-01-05</div></pre></td></tr></table></figure><h3 id="时间转时间戳"><a href="#时间转时间戳" class="headerlink" title="时间转时间戳"></a>时间转时间戳</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select unix_timestamp(now());  #结果：1452001082</div></pre></td></tr></table></figure><h3 id="字符串转时间"><a href="#字符串转时间" class="headerlink" title="字符串转时间"></a>字符串转时间</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select str_to_date('2016-01-02', '%Y-%m-%d %H');  #结果：2016-01-02 00:00:00</div></pre></td></tr></table></figure><h3 id="字符串转时间戳"><a href="#字符串转时间戳" class="headerlink" title="字符串转时间戳"></a>字符串转时间戳</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select unix_timestamp('2016-01-02');  #结果：1451664000</div></pre></td></tr></table></figure><h3 id="时间戳转时间"><a href="#时间戳转时间" class="headerlink" title="时间戳转时间"></a>时间戳转时间</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select from_unixtime(1451997924);  #结果：2016-01-05 20:45:24</div></pre></td></tr></table></figure><h3 id="时间戳转字符串"><a href="#时间戳转字符串" class="headerlink" title="时间戳转字符串"></a>时间戳转字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select from_unixtime(1451997924,'%Y-%d');  #结果：2016-01-05 20:45:24</div></pre></td></tr></table></figure><h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><p>MySQL日期格式化（format）取值范围。</p><table><thead><tr><th></th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>秒</td><td>%S、%s</td><td>两位数字形式的秒（ 00,01, …, 59）</td></tr><tr><td>分</td><td>%I、%i</td><td>两位数字形式的分（ 00,01, …, 59）</td></tr><tr><td>小时</td><td>%H</td><td>24小时制，两位数形式小时（00,01, …,23）</td></tr><tr><td>%h</td><td>12小时制，两位数形式小时（00,01, …,12）</td><td></td></tr><tr><td>%k</td><td>24小时制，数形式小时（0,1, …,23）</td><td></td></tr><tr><td>%l</td><td>12小时制，数形式小时（0,1, …,12）</td><td></td></tr><tr><td>%T</td><td>24小时制，时间形式（HH:mm:ss）</td><td></td></tr><tr><td>%r</td><td>12小时制，时间形式（hh:mm:ss AM 或 PM）</td><td></td></tr><tr><td>%p</td><td>AM上午或PM下午</td><td></td></tr><tr><td>周</td><td>%W</td><td>一周中每一天的名称（Sunday,Monday, …,Saturday）</td></tr><tr><td>%a</td><td>一周中每一天名称的缩写（Sun,Mon, …,Sat）</td><td></td></tr><tr><td>%w</td><td>以数字形式标识周（0=Sunday,1=Monday, …,6=Saturday）</td><td></td></tr><tr><td>%U</td><td>数字表示周数，星期天为周中第一天</td><td></td></tr><tr><td>%u</td><td>数字表示周数，星期一为周中第一天</td><td></td></tr><tr><td>天</td><td>%d</td><td>两位数字表示月中天数（01,02, …,31）</td></tr><tr><td>%e</td><td>数字表示月中天数（1,2, …,31）</td><td></td></tr><tr><td>%D</td><td>英文后缀表示月中天数（1st,2nd,3rd …）</td><td></td></tr><tr><td>%j</td><td>以三位数字表示年中天数（001,002, …,366）</td><td></td></tr><tr><td>月</td><td>%M</td><td>英文月名（January,February, …,December）</td></tr><tr><td>%b</td><td>英文缩写月名（Jan,Feb, …,Dec）</td><td></td></tr><tr><td>%m</td><td>两位数字表示月份（01,02, …,12）</td><td></td></tr><tr><td>%c</td><td>数字表示月份（1,2, …,12）</td><td></td></tr><tr><td>年</td><td>%Y</td><td>四位数字表示的年份（2015,2016…）</td></tr><tr><td>%y</td><td>两位数字表示的年份（15,16…）</td><td></td></tr><tr><td>文字输出</td><td>%文字</td><td>直接输出文字内容</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时比较常用的时间、字符串、时间戳之间的互相转换，虽然常用但是几乎每次使用时候都喜欢去搜索一下用法；本文将作为一个笔记，整理一下三者之间的 转换（即：date转字符串、date转时间戳、字符串转date、字符串转时间戳、时间戳转date，时间戳转字符串）用法，方便日后查看；
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.maksim.website/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>写作的准备 - 《完全写作指南》</title>
    <link href="http://www.maksim.website/2018/04/08/2/"/>
    <id>http://www.maksim.website/2018/04/08/2/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-09T10:30:21.933Z</updated>
    
    <content type="html"><![CDATA[<p>写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：</p><p>目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改</p><p>从理论上讲，按照这个顺序操作，你就能得到一篇组织得当、逻辑严谨的完美稿件。这个方法对一部分人是有用的，但是如果你和大多数人一样，那么他可能就不适合你。在现实生活中，大部分都不是线性思维的写作者。</p><p>这六个步骤没错，错的是这个强制性的顺序。当遵循渐进编程了因循守旧，它可能会阻碍你写作能力的发挥。</p><p>你可以以这个步骤中任意一步作为起点，头脑风暴、提纲或者是写初稿。</p><h2 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h2><p>当要写作时，首先我们要确定自己的目标是什么，你希望达到什么目的。</p><p>仔细思考写作目的能帮你搞清楚该说什么，以及怎么说。又去的是，这样一来你的读者也会更加轻松，如果你也有过收到大量简历的经理，你就会知道一封周到、工整且有针对性的求职信会让你干到多么轻松。</p><h2 id="了解你的读者"><a href="#了解你的读者" class="headerlink" title="了解你的读者"></a>了解你的读者</h2><p>除了私人日记之外，所有的作品都是有读者的，你的作品需要指向这些特定的读者。</p><p>站在读者的角度进行思考，有两个关键问题：</p><ul><li>信息</li><li>态度</li></ul><p>选择信息的黄金法则是：<strong>要有足量的有效信息，让你的读者行动起来。</strong></p><p>了解读者潜在的态度也是成功的关键。</p><ul><li>你的读者会有什么样的反应？</li><li>他们很容易接受你的信息吗?</li><li>还是会有抵触情绪？</li><li>他们是否怀有敌意。</li></ul><blockquote><p>笔者说：</p><p>在这里，可以读《美国航空航天局科学家给赞比亚修女的一封信》，这是一封大师级的回信。</p></blockquote><h2 id="用他头脑风暴锁定你想表达的内容"><a href="#用他头脑风暴锁定你想表达的内容" class="headerlink" title="用他头脑风暴锁定你想表达的内容"></a>用他头脑风暴锁定你想表达的内容</h2><p>头脑风暴有一些规则。如果你在学校或者工作的地方参加过头脑风暴式的讨论，那么你很可能看到过这些规则：</p><ol><li>相处的点子越多越好。如果你能把注意力放在数量而非质量上，那么提出有用的点子概率就会更大，点子都多多益善。</li><li>不要审查，不要评论。头脑风暴时，让你的思绪自由发散。这并不是对点子进行评论的时候，不要说这个点子不太好，那个点子不合适。把脑袋里评论的声音关掉，把所有想到的东西都写出来。你可以之后再删除。</li><li>接受不同寻常的想法。不要考虑你的想法靠不靠谱。你的这些想法可能完全超出预料，但它们当中可能会有一个非常有用，或至少能为你的思考指引方向的点子。充分发挥自己的想象力。</li><li>合并改进你的点子。如果你任由思绪自由发散，那么点子很可能会有一些重合。观察它们的相似之处，并加以合并调整。</li></ol><p>当写完初稿后，发现内容不够完整，不够有说服力时候甚至可以重新进行头脑风暴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：&lt;/p&gt;
&lt;p&gt;目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改&lt;/p&gt;
&lt;p&gt;从理论上讲，按照这个顺序操作，你就能得到一篇组
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.maksim.website/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>美国航空航天局科学家给赞比亚修女的一封信</title>
    <link href="http://www.maksim.website/2018/04/08/3/"/>
    <id>http://www.maksim.website/2018/04/08/3/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-09T10:30:21.934Z</updated>
    
    <content type="html"><![CDATA[<p>背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。</p><p>1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ernst Stuhlinger）博士写了一封信。施图林格因在火星之旅工程中的原创性研究，成为NASA（美国航空航天局）马绍尔太空航行中心的科学副总监。信中，玛丽·尤肯达修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。施图林格很快给尤肯达修女回了信，同时还附带了一张题为“升起的地球”的照片，这张标志性的照片是宇航员威廉·安德斯于1968年在月球轨道上拍摄的（照片中可以看到月球的地面）。他这封真挚的回信随后由NASA以《为什么要探索宇宙》为标题发表。</p><p>1970年5月6日</p><p>亲爱的玛丽·尤肯达修女：每天，我都会收到很多类似的来信，但这封对我的触动最深，因为它来自一颗慈悲的饱含探求精神的心灵。我会尽自己所能来回答你这个问题。首先，请允许我向你以及你勇敢的姐妹们表达深深的敬意，你们献身于人类最崇高的事业：帮助身处困境的同胞。</p><p>在来信中，你问我在目前地球上还有儿童由于饥饿面临死亡威胁的情况下，为什么还要花费数十亿美元来进行飞向火星的航行。 我清楚你肯定不希望这样的答案：“哦，我之前不知道还有小孩子快饿死了，好吧，从现在开始，暂停所有的太空项目，直到孩子们都吃上饭再说。”事实上，早在了解火星之旅的技术之前，我已经对儿童的饥荒问题有所了解。而且，同我很多朋友的看法一样，我认为此时此刻，我们就应该开始通往月球、火星乃至其他行星的伟大探险。从长远来看，相对于那些要么只有年复一年的辩论和争吵，要么连妥协之后也迟迟无法落实的各种援助计划来说，我甚至觉得探索太空的工程给更有助于解决人类目前所面临的种种危机。</p><p>在详细说明我们的太空项目如何帮助解决地面上的危机之前，我想先简短讲一个真实的故事。那是在400年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。</p><p>然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气，“我们还在受瘟疫的苦”，他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！”伯爵听到后不为所动，“我会尽可能地接济大家”，他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。”</p><p>果不其然，他的工作赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。</p><p>伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。</p><p>我们目前面临类似的问题。美国总统的年度预算共有2000亿美元，这些钱将用于医疗、教育、福利、城市建设、高速公路、交通运输、海外援助、国防、环保、科技、农业以及其他多项国内外的工程。今年，预算中的1.6%将用于探索宇宙，这些花销将用于阿波罗以计划、其他一些涵盖了天体物理学、深空天文学、空间生物学、行星探测工程、地球资源工程的小项目以及空间工程技术。为担负这些太空项目的支出，平均每个年收入10,000美元的美国纳税人需要支付约30美元给太空，剩下的9,970美元则可用于一般生活开支、休闲娱乐、储蓄、别的税项等花销。</p><p>也许你会问：“为什么不从纳税人为太空支付的30美元里抽出5美元或3美元或是1美元来救济饥饿的儿童呢？”为了回答这个问题，我需要先简单解释一下我们国家的经济是如何运行的，其他国家也是类似的情形。政府由几个部门（如内政部、司法部、卫生部与公众福利部、教育部、运输部、国防部等）和几个机构（国家科学基金会、国家航空航天局等）组成，这些部门和机构根据自己的职能制定相应的年度预算，并严格执行以应对国务委员会的监督，同时还要应付来自预算部门和总统对于其经济效益的压力。当资金最终由国会拨出后，将严格用于经预算批准的计划中的项目。</p><p>显然，NASA的预算中所包含的项目都是和航空航天有关的。未经国会批准的预算项目，是不会得到资金支持的，自然也不会被课税，除非有其他部门的预算涵盖了该项目，借此花掉没有分配给太空项目的资金。由这段简短的说明可以看出，要想援助饥饿的儿童，或在美国已有的对外援助项目上增加援助金额，需要首先由相关部门提出预算，然后由国会批准才行。</p><p>要问是否同意政府实施类似的政策，我个人的意见是绝对赞成。我完全不介意每年多付出一点点税款来帮助饥饿的儿童，无论他们身在何处。</p><p>我相信我的朋友们也会持相同的态度。然而，事情并不是仅靠把去往火星航行的计划取消就能轻易实现的。相对的，我甚至认为可以通过太空项目，来为缓解乃至最终解决地球上的贫穷和饥饿问题作出贡献。解决饥饿问题的关键有两部分：食物的生产和食物的发放。食物的生产所涉及的农业、畜牧业、渔业及其他大规模生产活动在世界上的一些地区高效高产，而在有的地区则产量严重不足。通过高科技手段，如灌溉管理，肥料的使用，天气预报，产量评估，程序化种植，农田优选，作物的习性与耕作时间选择，农作物调查及收割计划，可以显著提高土地的生产效率。</p><p>人造地球卫星无疑是改进这两个关键问题最有力的工具。在远离地面的运行轨道上，卫星能够在很短的时间里扫描大片的陆地，可以同时观察计算农作物生长所需要的多项指标，土壤、旱情、雨雪天气等等，并且可以将这些信息广播至地面接收站以便做进一步处理。事实证明，配备有土地资源传感器及相应的农业程序的人造卫星系统，即便是最简单的型号，也能给农作物的年产量带来数以十亿美元计的提升。</p><p>如何将食品发放给需要的人则是另外一个全新的问题，关键不在于轮船的容量，而在于国际间的合作。小国统治者对于来自大国的大量食品的输入很难做出准确的判断，他们害怕伴随着食物一同而来的还有外国势力对其统治地位的影响。恐怕在国与国之间消除隔阂之前，饥饿问题无法得以高效解决了。我不认为太空计划能一夜之间创造奇迹，然而，探索宇宙有助于促使问题向着良好的方向发展。</p><p>以最近发生的阿波罗13号事故为例。当宇航员处于关键的大气层再入期时，为了保证通讯畅通，苏联关闭了境内与阿波罗飞船所用频带相同的所有广播通信。同时派出舰艇到太平洋和大西洋海域以备第一时间进行搜救工作。如果宇航员的救生舱降落到俄方舰船附近，俄方人员会像对待从太空返回的本国宇航员一样对他们进行救助。同样，如果俄方的宇宙飞船遇到了类似的紧急情况，美国也一定会毫不犹豫地提供援助。 </p><p>通过卫星进行监测与分析来提高食品产量，以及通过改善国际关系提高食品发放的效率，只是通过太空项目提高人类生活质量的两个方面。下面我想介绍另外两个重要作用：促进科学技术的发展和提高一代人的科学素养。</p><p>登月工程需要历史上前所未有的高精度和高可靠性。面对如此严苛的要求，我们要寻找新材料，新方法；开发出更好的工程系统；用更可靠的制作流程；让仪器的工作寿命更长久；甚至需要探索全新的自然规律。</p><p>这些为登月发明的新技术同样可以用于地面上的工程项目。每年，都有大概一千项从太空项目中发展出来的新技术被用于日常生活中，这些技术打造出更好的厨房用具和农场设备，更好的缝纫机和收音机，更好的轮船和飞机，更精确的天气预报和风暴预警，更好的通讯设施，更好的医疗设备，乃至更好的日常小工具。你可能会问为什么先设计出宇航员登月舱的维生系统，而不是先为听力障碍患者造出有声阅读设备呢。答案很简单：解决工程问题时，重要的技术突破往往并不是按部就班直接得到的，而是来自能够激发出强大创新精神，能够燃起的想象力和坚定的行动力，以及能够整合好所有资源的充满挑战的目标。</p><p>太空旅行无可置疑地是一项充满挑战的事业。通往火星的航行并不能直接提供食物解决饥荒问题。然而，它所带来大量的新技术和新方法可以用在火星项目之外，这将产生数倍于原始花费的收益。若希望人类生活得越来越好，除了需要新的技术，我们还需要基础科学不断有新的进展。包括物理学和化学，生物学和生理学，特别是医学，用来照看人类的健康，应对饥饿、疾病、食物和水的污染以及环境污染等问题。</p><p>我们需要更多的年轻人投入到科学事业中来，我们需要给予那些投身科研事业的有天分的科学家更多的帮助。随时要有富于挑战的研究项目，同时要保证对项目给予充分的资源支持。在此我要重申，太空项目是科技进步的催化剂，它为学术研究工作提供了绝佳和实践机会，包括对月球和其他行星的眼睛、物理学和天文学、生物学和医学科学等学科，有它，科学界源源不断出现令人激动不已研究课题，人类得以窥见宇宙无比瑰丽的景象；为了它，新技术新方法不断涌现。</p><p>由美国政府控制并提供资金支持的所有活动中，太空项目无疑最引人瞩目也最容易引起争议，尽管其仅占全部预算的1.6%，不到全民生产总值的千分之三。作为新技术的驱动者和催化剂，太空项目开展了多项基础科学的研究，它的地位注定不同于其他活动。从某种意义上来说，以太空项目的对社会的影响，其地位相当于3-4千年前的战争活动。</p><p>如果国家之间不再比拼轰炸机和远程导弹，取而代之比拼月球飞船的性能，那将避免多少战乱之苦！聪慧的胜利者将满怀希望，失败者也不用饱尝痛苦，不再埋下仇恨的种子，不再带来复仇的战争。</p><p>尽管我们开展的太空项目研究的东西离地球很遥远，已经将人类的视野延伸至月亮、至太阳、至星球、直至那遥远的星辰，但天文学家对地球的关注，超过以上所有天外之物。太空项目带来的不仅有那些新技术所所提供的生活品质的提升，随着对宇宙研究的深入，我们对地球，对生命，对人类自身的感激之情将越深。太空探索让地球更美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。&lt;/p&gt;
&lt;p&gt;1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ern
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.maksim.website/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8vt004s3crd51572twn/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8vt004s3crd51572twn/</id>
    <published>2018-04-03T14:53:43.524Z</published>
    <updated>2018-04-03T14:53:43.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光源色、物体色、固有色"><a href="#光源色、物体色、固有色" class="headerlink" title="光源色、物体色、固有色"></a>光源色、物体色、固有色</h1><h2 id="什么是光源色"><a href="#什么是光源色" class="headerlink" title="什么是光源色"></a>什么是光源色</h2><p>光源色指的是发光体所发出光线的颜色。例如，阳光、月光、火光和各种灯光等的光色。光源色的不同会引起物体的固有颜色的变化。例如，一块红布在白天看起来和在晚上灯光下看起来颜色是有所不同的。许多女同志都懂得这一点，她们避免晚上去商店购买衣料，因为晚上灯光下看到的黄色，和白天看到的是有些不一样的。就是同样的眼光来说，在早晨、正午和傍晚其光色也是不相同的，会引起同一景物的色调的显著变化。</p><p>物体在不同颜色的光照下会呈现出跟光颜色比较接近的色彩，这些都是收到光源色彩的影响。</p><h2 id="什么是物体色"><a href="#什么是物体色" class="headerlink" title="什么是物体色"></a>什么是物体色</h2><p>物体色是指光源色经过物体有选择的吸收和反射，反映到人的视觉中的光色感觉。物体本身并不会发光，但都具有对各种波长的光有所选择性的吸收、反射或者投射的特性，因此形成千变万化的不相同的物体色彩。</p><p>物体可以分为透明物体和不透明物体，不透明物体呈现的色彩是由它反射的光色决定的，而透明物体呈现的色彩则是由它透过的色彩决定的。</p><p>如绿色树叶吸收太阳光除绿色光的其他色光，所以我们看到的是绿色，而蓝色玻璃只透过蓝色光吸收其他光所以看起来呈现的是蓝色。</p><h2 id="什么是固有色"><a href="#什么是固有色" class="headerlink" title="什么是固有色"></a>什么是固有色</h2><p>固有色指的是一个物体在通常情况下给人的色彩印象（概念）例如，红旗是红色的，草地是绿色的，中国人的皮肤是黄色的等等。</p><p>从色彩的光学原理知道物体并不存在固定不变的固有颜色，物体的颜色是与光密切相关的，是在一定的条件下变化的，是具体的，而不是一种概念。讲中国人皮肤是黄色的，其实不可能指出是哪一种具体的光色。然而，物体的颜色景观是变化的、复杂的，单扔给我们一定的色彩印象。所以我们既不要受固有色概念的束缚，又不能完全故事固有色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;光源色、物体色、固有色&quot;&gt;&lt;a href=&quot;#光源色、物体色、固有色&quot; class=&quot;headerlink&quot; title=&quot;光源色、物体色、固有色&quot;&gt;&lt;/a&gt;光源色、物体色、固有色&lt;/h1&gt;&lt;h2 id=&quot;什么是光源色&quot;&gt;&lt;a href=&quot;#什么是光源色&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个新的开始</title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8vh004e3crd728mgbmg/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8vh004e3crd728mgbmg/</id>
    <published>2018-04-03T14:53:43.504Z</published>
    <updated>2018-04-03T14:53:43.507Z</updated>
    
    <content type="html"><![CDATA[<p>人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。</p><a id="more"></a><p>于是在不甘，与短暂的刺激后，我又开始了写作，其实也是想试一试，自己到底能不能够成功，我所谓的成功其实就是写一个完整的故事，记得小时候抓周，我抓的就是个笔，奶奶曾经说我以后是个笔杆子，可惜现在虽然现在也是在写东西，不过写的是代码，而不是小说。</p><p>记得那是还在上初中的时候，我接触到了网络文学，我记得我看的第一本网络小说应该是木子心写的《现代修罗》，可惜最后太监了，那个时候我对太监这件事当真是有些厌恶，可是没想到到最后，我也踏入了后宫那洪流之中，成为了诸多太监中的一份子。我朋友曾经对我说过一句话，要是能在我生儿子之前能看到你一本完本的小说就行了。</p><p>其实这段时间一直在思考我要不要继续写东西，我能否坚持下去，最终还是决定试一试，思前想后决定写一篇科幻类的小说，希望能够做到不落俗套，写出自己心目中的网络文学。</p><p>以后每个月我都会更新一篇关于网络文学的文章，主要是去分析曾经红极一时或者是现在当红的网络小说的写作手法。看一看那些大神是如何进行网络文学创作的，同时也是去提升自己的能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.maksim.website/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8vd00493crd5n62elwb/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8vd00493crd5n62elwb/</id>
    <published>2018-04-03T14:53:43.478Z</published>
    <updated>2018-04-03T14:53:43.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务评估"><a href="#业务评估" class="headerlink" title="业务评估"></a>业务评估</h1><h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ul><li>响应时间（request time）</li><li>数据总量</li><li>每秒请求量</li><li>读写比</li><li>重要程度</li></ul><p><strong>响应时间</strong>是与整个数据库的状态有关，不仅与CPU、数据总量、每秒请求量、读写比以及各种场景都是有关系的。所以说相应时间是一个综合指标。</p><p>对于DBA来说最关心的就是业务的相应时间能不能够满足，在满足的情况下再去优化以下的这些点，才是有意义的。</p><p>数据总量往往需要业务方提供一个一到两年的数据总量，这是因为如果没有数据总量，前期是没有办法规划我们的数据库实例的。当然也有很多的不确定因素，比如互联网行业，比如有的业务会爆发性的增长，这些规划可能是不合理的，但是在我们也要有一个大概的评估，因为这是前期资源申请和资源分配的策略。</p><p>每秒请求量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务评估&quot;&gt;&lt;a href=&quot;#业务评估&quot; class=&quot;headerlink&quot; title=&quot;业务评估&quot;&gt;&lt;/a&gt;业务评估&lt;/h1&gt;&lt;h2 id=&quot;业务需求&quot;&gt;&lt;a href=&quot;#业务需求&quot; class=&quot;headerlink&quot; title=&quot;业务需求&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8vx004z3crdosr0x4gi/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8vx004z3crdosr0x4gi/</id>
    <published>2018-04-03T14:53:43.475Z</published>
    <updated>2018-04-03T14:53:43.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 - Singleton"></a>单例模式 - Singleton</h1><p>单例模式确保每一个指定的类只存在一个实例对象，并且可以全局访问那个实例。一般情况下会用延时加载的策略，指在第一次需要使用的时候初始化。</p><blockquote><p>设计模式并不局限于某一个语言，他是一种编程思维</p></blockquote><p>在 iOS 开发中单例模式h很常见，NSUserDefaults.standardUserDefaults()等等。</p><p>如果多于一个实例又会怎么样呢？代码和内存还没精贵到这个地步吧？</p><p>某些场景下，保持实例对象仅有一份是很有意义的。举个例子，你的应用实例 (UIApplication)，应该只有一个吧，显然是指你的当前应用。还有一个例子：设备的屏幕 (UIScreen) 实例也是这样，所以对于这些类的情况，你只想要一个实例对象。</p><p>单例模式的应用还有另一种情况：你需要一个全局类来处理配置文件。我们很容易通过单例模式实现线程安全的实例访问，而如果有多个类可以同时访问配置文件，那可就复杂多了。</p><h1 id="使用单例模式"><a href="#使用单例模式" class="headerlink" title="使用单例模式"></a>使用单例模式</h1><p><img src="https://swift-design-patterns.books.yourtion.com/images/singleton1.png" alt=""></p><p>这是一个日志类，有一个属性（是以单例对象）和两个方法（sharedInstance()和 init()）。</p><p>第一吊用 sharedInstance()的时候，instance 属性还没有初始化，所以我们必须创建一个新的实例并且返回。</p><p>下一次再调用 sharedInstance()的时候，instance 已经完成了初始化，直接返回即可，这个逻辑就确保了只有一个实例对象。</p><p>接下来我们继续完善单例模式，通过这个类来管理专辑数据。</p><p>注意到在我们前面的截图里，分组中有个 API 分组，这里可以放那些提供后台服务的类。在这个分组中创建一个新的文件 LibraryAPI.swift ，继承自 NSObject 类。</p><p>在 LibraryAPI 里添加下面这段代码：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模式-Singleton&quot;&gt;&lt;a href=&quot;#单例模式-Singleton&quot; class=&quot;headerlink&quot; title=&quot;单例模式 - Singleton&quot;&gt;&lt;/a&gt;单例模式 - Singleton&lt;/h1&gt;&lt;p&gt;单例模式确保每一个指定的类只存在一个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8w100533crd4cdp5mpr/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8w100533crd4cdp5mpr/</id>
    <published>2018-04-03T14:53:43.470Z</published>
    <updated>2018-04-03T14:53:43.473Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:iOS图层树<br>categories:iOS<br>date:2015-12-21</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><h1 id="图层树"><a href="#图层树" class="headerlink" title="图层树"></a>图层树</h1><p>Core Animation 是一个符合引擎，塔的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容被分分解成独立的图层，存储在一个叫做图层数的体系中，于是这个树形成了 UIKit 以及在 iOS 10应用程序当中你所看能在屏幕上看见的一切的基础。</p><h2 id="图层与视图"><a href="#图层与视图" class="headerlink" title="图层与视图"></a>图层与视图</h2><p>如果你曾经在 iOS 10或MacOS 平台上面写过应用程序，你可能能会对视图的概念比较熟悉。一个视图就是在屏幕上显示一个矩形块（比如图片，文字或者视频），它能拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系。</p><p><img src="https://zsisme.gitbooks.io/ios-/content/chapter1/1.1.jpeg" alt=""></p><p>图1.1一种典型的 iOS 屏幕（左边）和型城市图的层级关系（右边）</p><p>在 iOS 中，所有的视图都从一个叫做 UIview 的基类派生而来，UIView 可以处理触摸事件，可以支持基于 Core Graphics 绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><p>CALayer类在概念上和 UIView 类似，同样也是一些被层级关系树管理的矩形块，同样可以包含一些内容（像图片，文本或者背景色），管理子视图的位置。它们有一些方法和尚需经用来做动画和变换。</p><p>和 UIview 最大的不同是 CALayer 不处理用户的交互。</p><p>CALayer 兵不清楚具体的响应链（iOS通过视图层级关系用来传递触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触电在图层的范围之内。</p><h2 id="平行的层级关系"><a href="#平行的层级关系" class="headerlink" title="平行的层级关系"></a>平行的层级关系</h2><p>每一个 UIView 都有一个 CALayer 实例的图层属性，也就是所谓的 Backing layer,视图的职责就是创建并管理这个图层，以确保子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应是在层级关系树当中有相同的操作（见图1.2）</p><p><img src="https://zsisme.gitbooks.io/ios-/content/chapter1/1.2.jpeg" alt=""></p><p>图1.2 图层的树状结构（左边）以及对应的视图层级（右边）</p><p>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView 仅仅是对它的一个封装，提供了一些 iOS 类似于处理触摸事件的具体功能，以及 Core Animation 底层方法的高级借口。</p><p>但是为什么 iOS 要基于 UIview 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这也是能避免很多重复代码。在 iOS 和 Mac OS两个平台上，时间和用户交互有很多地方不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么 iOS有 UIKit 和 UIView，但是 MacOS 有 APPKit 和 NSView 的元婴。他们功能上很类似，但是在实现上有着显著的区别。</p><p>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。+</p><p>实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:iOS图层树&lt;br&gt;categories:iOS&lt;br&gt;date:2015-12-21&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1&lt;/h2&gt;&lt;h1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Object.defineProperty()模拟双向数据绑定</title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8vl004j3crdujtxrtxf/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8vl004j3crdujtxrtxf/</id>
    <published>2018-04-03T14:53:43.463Z</published>
    <updated>2018-04-03T14:53:43.464Z</updated>
    
    <content type="html"><![CDATA[<p>对象是由多键值对组成的无序集合，对象中的每个属性对应任意类型的值。定义对象可以使用构造函数或字面量的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//obj = &#123;&#125;</span></div><div class="line">obj.name = <span class="string">'Maksim'</span>;     <span class="comment">//添加属性</span></div><div class="line">obj.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;; <span class="comment">//添加方法</span></div></pre></td></tr></table></figure><p>为对象添加属性我们还可以使用 Object.defineProperty 定义和修改属性。</p><p>语法：<code>Object.defineProperty(obj, prop, descriptor)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象是由多键值对组成的无序集合，对象中的每个属性对应任意类型的值。定义对象可以使用构造函数或字面量的形式。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8un00313crdmlfyme2e/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8un00313crdmlfyme2e/</id>
    <published>2018-04-03T14:53:43.439Z</published>
    <updated>2018-04-03T14:53:43.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RESTFul-是什么？"><a href="#RESTFul-是什么？" class="headerlink" title="RESTFul 是什么？"></a>RESTFul 是什么？</h2><p>RESTful的本质是一种软件架构风格，核心是面向资源，主要用来解决降低开发的复杂性，提高系统的可伸缩性。随着互联网的发展，各种终端层出不穷，手机浏览器，手机 APP 为了节约成本，我们可以使用 RESTful 架构，只需要封装好一套完善的API就可以为多套终端提供服务。</p><p>设计概念和准则</p><ul><li>网络上所有事物都可以被抽象为资源</li><li>每一个资源都有唯一的标识符，对资源的操作不会改变这些标识</li><li>所有的操作都是无状态的</li></ul><p>所谓的资源就是网络上的一个实体，或者说是网络上一个具体的信息。</p><p>HTTP 协议 - URL</p><p>HTTP 是一个属于应用层的协议，特点是简捷、快速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">schema://host[:port]/path[?query-string][#anchor]</div></pre></td></tr></table></figure><ul><li>schema 指定底层使用的协议（如：http,https）</li><li>host   服务器的 IP 地址或者域名</li><li>port 服务器端口</li><li>path 访问资源的路径</li><li>query-string 发送给 http 服务器的数据</li><li>anchor     锚</li></ul><p>HTTP</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RESTFul-是什么？&quot;&gt;&lt;a href=&quot;#RESTFul-是什么？&quot; class=&quot;headerlink&quot; title=&quot;RESTFul 是什么？&quot;&gt;&lt;/a&gt;RESTFul 是什么？&lt;/h2&gt;&lt;p&gt;RESTful的本质是一种软件架构风格，核心是面向资源，主要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP基础手札的引用</title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8u9002g3crdyk3lbiri/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8u9002g3crdyk3lbiri/</id>
    <published>2018-04-03T14:53:43.433Z</published>
    <updated>2018-04-03T14:53:43.433Z</updated>
    
    <content type="html"><![CDATA[<p>在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。</p><p>PHP 的指针域这些语言机制相同，即可以用一个变量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。&lt;/p&gt;
&lt;p&gt;PHP 的指针域这些语言机制相同，即可以用一个变量&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP页面静态化</title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8ui002s3crd8lccjrj0/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8ui002s3crd8lccjrj0/</id>
    <published>2018-04-03T14:53:43.431Z</published>
    <updated>2018-04-03T14:53:43.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h1><p>要了解静态化页面，首先我们就要知道什么是页面？</p><p>一、静态web页面：</p><p>1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。</p><p>2、为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。</p><p>3、静态web无法连接数据库；</p><p>4、静态web资源开发技术：HTML；</p><p>5、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。</p><p>二、动态web页面：</p><p>动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。</p><p>如果客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</p><p>如果客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</p><p>#静态化</p><p>PHP静态化分为：纯静态化 和 伪静态化；纯静态化又分为：局部静态化 和 完全静态化</p><p>纯静态化：是把PHP生成的动态页面保存成静态的html文件，用户访问该静态页面，而不是用户每一次访问都重新生成一张相同的网页，优点就是减小服务器开销，</p><ul><li>局部静态化：是生成的静态文件中，有局部的数据还是通过ajax技术动态获取的；</li><li>完全静态化：即不存在动态获取数据的情况，所以内容都来自静态的html页面</li></ul><p>伪静态化：其实还是动态访问，其实质是动态生成数据，你访问的网址类似于”<a href="http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化" target="_blank" rel="noopener">http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化</a></p><p>　　伪静态的优点：美观；便于搜索引擎收录</p><p>buffer 概括</p><p>buffer 其实就是缓冲区，一个内存地址空间，主要是用于存储数据的区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于页面&quot;&gt;&lt;a href=&quot;#关于页面&quot; class=&quot;headerlink&quot; title=&quot;关于页面&quot;&gt;&lt;/a&gt;关于页面&lt;/h1&gt;&lt;p&gt;要了解静态化页面，首先我们就要知道什么是页面？&lt;/p&gt;
&lt;p&gt;一、静态web页面：&lt;/p&gt;
&lt;p&gt;1、在静态Web程序中，客
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8tg00193crdmm59vhxp/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8tg00193crdmm59vhxp/</id>
    <published>2018-04-03T14:53:43.409Z</published>
    <updated>2018-04-03T14:53:43.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL常用存储引擎之Innodb"><a href="#MySQL常用存储引擎之Innodb" class="headerlink" title="MySQL常用存储引擎之Innodb"></a>MySQL常用存储引擎之Innodb</h1><p>Mysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。</p><p>和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。</p><p>特点：</p><ul><li>灾难恢复性好</li><li>支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的</li><li>使用行级锁</li><li>对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的</li><li>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引</li><li>支持外键</li><li>支持热备份</li></ul><p>Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由<code>innodb_file_per_table</code>这个参数决定。</p><p>如果值为 <code>ON</code>,会为每个 innodb 表建立一个<code>tablename.ibd</code>的系统文件，如果该参数为<code>OFF</code>时会把数据存储到系统的表空间<code>ibdataX</code></p><p>引用</p><p>《打造扛得住的 MySQL》 慕课网</p><p>《高性能 MySQL》</p><p>《My》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;a href=&quot;#MySQL常用存储引擎之Innodb&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;/a&gt;MySQL常用存储引擎之Innodb&lt;/h1&gt;&lt;p&gt;Mysql5
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8tn001l3crd6qilqdai/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8tn001l3crd6qilqdai/</id>
    <published>2018-04-03T14:53:43.408Z</published>
    <updated>2018-04-03T14:53:43.408Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:MySQL服务器参数介绍<br>categories:MySQL<br>date:2017-10-18</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p>人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。</p><p>MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。</p><p>从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。</p><p>##　MySQl获取配置信息路径</p><ul><li>命令行参数 <code>mysqld_safe --datadir=/data/sql_data</code></li><li>配置文件 <code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code></li></ul><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171013153125.png" alt=""></p><p>MySQL会先从<code>/etc/my.cnf</code>文件下读取配置信息，然后是<code>/etc/mysql/my.cnf</code>。</p><p>MySQL配置参数的作用域</p><ul><li>全局参数 <ul><li><code>set global 参数名 = 参数值;</code></li><li><code>set @@global。参数名:=参数值;</code></li></ul></li><li>会话参数<ul><li><code>set [session] 参数名=参数值;</code></li><li><code>set @@session.参数名:=参数值;</code></li></ul></li></ul><p>会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。</p><p>在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。</p><h2 id="内存配置相关参数"><a href="#内存配置相关参数" class="headerlink" title="内存配置相关参数"></a>内存配置相关参数</h2><p>MySQL对于内存的使用我们可以分为两个类来看。</p><ul><li>无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存</li><li>可以通过参数配置控制的，各类的缓冲池所需要的内存。</li></ul><p>对内存参数配置之前，我们需要进行考虑：</p><ul><li>确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。</li><li>确定MySQL的每个连接使用的内存，例如排序缓冲和临时表</li><li><p>把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。</p><ul><li><p>sort_buffer_size</p><ul><li>join_buufer_szie</li><li>read_buffer_size</li><li>read_rnd_buffer_size  </li></ul></li></ul></li></ul><h3 id="确定需要为操作系统保留多少内存"><a href="#确定需要为操作系统保留多少内存" class="headerlink" title="确定需要为操作系统保留多少内存"></a>确定需要为操作系统保留多少内存</h3><p>给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。</p><p>数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。</p><p>另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。</p><h3 id="如何为缓冲池分配内存"><a href="#如何为缓冲池分配内存" class="headerlink" title="如何为缓冲池分配内存"></a>如何为缓冲池分配内存</h3><p>Innodb_buffer_pool_size，Innodb缓冲区</p><p>总内存-（每个线程所需要的内存*连接数）- 系统保留内存</p><p>手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。</p><h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos;</div></pre></td></tr></table></figure><h2 id="I-O相关配置参数"><a href="#I-O相关配置参数" class="headerlink" title="I/O相关配置参数"></a>I/O相关配置参数</h2><p>Innodb I/O相关配置</p><h2 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h2><p><code>expire_logs_days</code> 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:MySQL服务器参数介绍&lt;br&gt;categories:MySQL&lt;br&gt;date:2017-10-18&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8t0000p3crd2d22ty5i/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8t0000p3crd2d22ty5i/</id>
    <published>2018-04-03T14:53:43.401Z</published>
    <updated>2018-04-03T14:53:43.402Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:C语言中的内存<br>categories:C/C++<br>date:2017-10-21</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p> C 程序在编译后，会以三种形式使用内存。</p><ul><li><p>静态变量/全局内存</p><p>静态声明的变量分配在这里，全局变量也会使用这部分内存。这些内存在程序开始运行时分配，直到程序终止才会消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。</p></li><li><p>自动内存</p><p>这些变量在函数内部声明，并且在函数被调用时才能创建。它们的作用域局限于函数内部，而且在函数被调用才创建。它们的作用域局限于函数内部，热切声明周期限制在函数的执行时间内。</p></li><li><p>动态内存</p><p>内存分派在堆上，可以根据需要存放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:C语言中的内存&lt;br&gt;categories:C/C++&lt;br&gt;date:2017-10-21&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjfs3j8uk002v3crdwrivc5yf/"/>
    <id>http://www.maksim.website/2018/04/03/cjfs3j8uk002v3crdwrivc5yf/</id>
    <published>2018-04-03T14:53:03.331Z</published>
    <updated>2018-04-03T14:53:03.331Z</updated>
    
    <content type="html"><![CDATA[<p>#md</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#md&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>删除特殊的用户和用户组</title>
    <link href="http://www.maksim.website/2018/04/02/1/"/>
    <id>http://www.maksim.website/2018/04/02/1/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-04-03T14:53:43.528Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。</p><p>Linux 系统中可以删除的默认用户和用户组大致如下：</p><ul><li>可删除的用户，如 adm、lp、sync、shutdown、halt、news、uucp、operator、games、gopher 等。</li><li>可删除的用户组，如 adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers 等。</li></ul><p>删除的方法很简单，下面以删除 games 用户和用户组为例介绍具体的操作。</p><p>删除用户所使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">userdel games</div></pre></td></tr></table></figure><p>删除用户组使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupdel games</div></pre></td></tr></table></figure><p>有些时候，某些用户仅仅作为进程调度或者用户组调用，并不需要登录功能，此时可以禁止这些用户登录系统的功能，例如要禁止 nagios 用户的登录功能，可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -s /sbin/nologin nagios</div></pre></td></tr></table></figure><p>其实要删除哪些用户和用户组，并没有固定要求，可以根据服务器的用途来决定，如果服务器用于 Web 应用的，那么系统默认的 Apache 用户和用户组就无需删除；如果服务器用于数据库应用，那么建议删除系统默认的 Apache 用户和用户组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。&lt;/p&gt;
&lt;p&gt;Linux 系统中可以删除的默认用户和用户组大
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hash算法</title>
    <link href="http://www.maksim.website/2018/03/13/1/"/>
    <id>http://www.maksim.website/2018/03/13/1/</id>
    <published>2018-03-12T16:00:00.000Z</published>
    <updated>2018-04-03T14:53:43.404Z</updated>
    
    <content type="html"><![CDATA[<p>Hash表（HashTable）又称散列表，通过把关键字 key 映射到数组中的一个位置来访问记录，以加快查找的速度。这个应设函数称之为 Hash 函数，存放记录的数组称之为 Hash 表。</p><p>##HASH 函数</p><p>Hash 函数的作用是把任意长度的输入，通过 Hash 算法编程固定长度的输出，该输出就是 Hash 值。这种转换是一种压缩映射，也就是 Hash 值的空间通常远远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从 Hash 值来唯一地确定输入值。</p><p>一个号的 Hash 函数应该满足以下条件：每个关键字都可以均匀地分布到 Hash 表任意一个位置，并与其他已经被散列到 Hash 表中的关键字不发生冲突，这就是Hash 最难实现的地方。</p><h2 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h2><p>关键字 key 可能是整数或者字符串，可以按照关键字的类型设计不同的 Hash 算法。整数关键字的 Hash 算法有以下几种。</p><h3 id="直接取余数"><a href="#直接取余数" class="headerlink" title="直接取余数"></a>直接取余数</h3><p>直接取余法原理比较简单，直接使用关键字key 除以 Hash 表的大小 m 取余，算法如下：</p><p>h(key) = key mod m</p><p>例如，如果 Hash 表的大小为 m=12，所以关键字 key=100，则 h(key) = 4，这种算法只需要一个求余操作，速度比较快。</p><h3 id="乘积取整法"><a href="#乘积取整法" class="headerlink" title="乘积取整法"></a>乘积取整法</h3><p>未完成····待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hash表（HashTable）又称散列表，通过把关键字 key 映射到数组中的一个位置来访问记录，以加快查找的速度。这个应设函数称之为 Hash 函数，存放记录的数组称之为 Hash 表。&lt;/p&gt;
&lt;p&gt;##HASH 函数&lt;/p&gt;
&lt;p&gt;Hash 函数的作用是把任意长度的
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript系列1、编写高质量JavaScript代码的基本要点</title>
    <link href="http://www.maksim.website/2018/03/09/1/"/>
    <id>http://www.maksim.website/2018/03/09/1/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-04-07T09:39:32.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2011-12-28 23:00 by 汤姆大叔   原地址：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html</a></p></blockquote><p>才华横溢的<a href="http://www.phpied.com/" target="_blank" rel="noopener">Stoyan Stefanov</a>，在他写的由<a href="http://oreilly.com/" target="_blank" rel="noopener">O’Reilly</a>初版的新书<a href="http://amzn.to/93szK7" target="_blank" rel="noopener">《JavaScript Patterns》</a>(JavaScript模式)中，我想要是为我们的读者贡献其摘要，那会是件很美妙的事情。具体一点就是编写高质量JavaScript的一些要素，例如避免全局变量，使用单变量声明，在循环中预缓存length(长度)，遵循代码阅读，以及更多。</p><p>此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写API文档、执行同行评审以及运行JSLint。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码，这些代码在几个月或是几年之后再回过头看看也是会觉得很自豪的。</p><h1 id="书写可维护的代码-Writing-Maintainable-Code"><a href="#书写可维护的代码-Writing-Maintainable-Code" class="headerlink" title="书写可维护的代码(Writing Maintainable Code )"></a>书写可维护的代码(Writing Maintainable Code )</h1><p>软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要：</p><ul><li>花时间学习和理解这个问题</li><li>化时间是了解应该解决的问题代码</li></ul><p>还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。</p><p>另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。</p><p>你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如：</p><ul><li>bug是暴露的</li><li>新功能被添加到应用程序</li><li>程序在新的环境下工作（例如，市场上出现新想浏览器）</li><li>代码改变用途</li><li>代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言</li></ul><p>由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。</p><p>可维护的代码意味着：</p><ul><li>可读的</li><li>一致的</li><li>可预测的</li><li>看上去就像是同一个人写的</li><li>已记录</li></ul><h1 id="最小全局变量-Minimizing-Globals"><a href="#最小全局变量-Minimizing-Globals" class="headerlink" title="最小全局变量(Minimizing Globals)"></a>最小全局变量(Minimizing Globals)</h1><p>JavaScript通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。</p><p>每个JavaScript环境有一个全局对象，当你在任意的函数外面使用this的时候可以访问到。你创建的每一个全部变量都成了这个全局对象的属 性。在浏览器中，方便起见，该全局对象有个附加属性叫做window，此window(通常)指向该全局对象本身。下面的代码片段显示了如何在浏览器环境 中创建和访问的全局变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myglobal = &quot;hello&quot;; // 不推荐写法</div><div class="line">console.log(myglobal); // &quot;hello&quot;</div><div class="line">console.log(window.myglobal); // &quot;hello&quot;</div><div class="line">console.log(window[&quot;myglobal&quot;]); // &quot;hello&quot;</div><div class="line">console.log(this.myglobal); // &quot;hello&quot;</div></pre></td></tr></table></figure><h1 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h1><p>全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p><p>web页面包含不是该页面开发者所写的代码也是比较常见的，例如：</p><ul><li>第三方的JavaScript库</li><li>广告方的脚本代码</li><li>第三方用户跟踪和分析脚本代码</li><li>不同类型的小组件，标志和按钮</li></ul><p>比方说，该第三方脚本定义了一个全局变量，叫做result；接着，在你的函数中也定义一个名为result的全局变量。其结果就是后面的变量覆盖前面的，第三方脚本就一下子嗝屁啦！</p><p>因此，要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。在书中后面提到的一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。</p><p>由于JavaScript的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sum(x, y) &#123;</div><div class="line">   // 不推荐写法: 隐式全局变量 </div><div class="line">   result = x + y;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此段代码中的<code>result</code>没有声明。代码照样运作正常，但在调用函数后你最后的结果就多一个全局命名空间，这可以是一个问题的根源。</p><p>经验法则是始终使用var声明变量，正如改进版的sum()函数所演示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sum(x, y) &#123;</div><div class="line">   var result = x + y;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另一个创建隐式全局变量的反例就是使用任务链进行部分var声明。下面的片段中，<code>a</code>是本地变量但是<code>b</code>确实全局变量，这可能不是你希望发生的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 反例，勿使用 </div><div class="line">function foo() &#123;</div><div class="line">   var a = b = 0;</div><div class="line">   // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此现象发生的原因在于这个从右到左的赋值，首先，是赋值表达式<code>b = 0</code>，此情况下b是未声明的。这个表达式的返回值是0，然后这个0就分配给了通过var定义的这个局部变量a。换句话说，就好比你输入了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a = (b = 0);</div></pre></td></tr></table></figure><p>如果你已经准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">   var a, b;</div><div class="line">   // ... a = b = 0; // 两个均局部变量</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>然而，另外一个避免全局变量的原因是可移植性。如果你想你的代码在不同的环境下（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心大胆地使用，实际上对于有些情况并不适用）。</p></blockquote><h1 id="忘记var的副作用-Side-Effects-When-Forgetting-var"><a href="#忘记var的副作用-Side-Effects-When-Forgetting-var" class="headerlink" title="忘记var的副作用(Side Effects When Forgetting var)"></a>忘记var的副作用(Side Effects When Forgetting var)</h1><p>隐式全局变量和明确定义的全局变量间有些小的差异，就是通过<code>delete</code>操作符让变量未定义的能力。</p><ul><li>通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。</li><li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。</li></ul><p>这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过<code>delete</code>操作符删除的，而变量是不能的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 定义三个全局变量</div><div class="line">var global_var = 1;</div><div class="line">global_novar = 2; // 反面教材</div><div class="line">(function () &#123;</div><div class="line">   global_fromfunc = 3; // 反面教材</div><div class="line">&#125;());</div><div class="line"></div><div class="line">// 试图删除</div><div class="line">delete global_var; // false</div><div class="line">delete global_novar; // true</div><div class="line">delete global_fromfunc; // true</div><div class="line"></div><div class="line">// 测试该删除</div><div class="line">typeof global_var; // &quot;number&quot;</div><div class="line">typeof global_novar; // &quot;undefined&quot;</div><div class="line">typeof global_fromfunc; // &quot;undefined&quot;</div></pre></td></tr></table></figure><p>在ES5严格模式下，未声明的变量（如在前面的代码片段中的两个反面教材）工作时会抛出一个错误。</p><h1 id="访问全局对象-Access-to-the-Global-Object"><a href="#访问全局对象-Access-to-the-Global-Object" class="headerlink" title="访问全局对象(Access to the Global Object)"></a>访问全局对象(Access to the Global Object)</h1><p>在浏览器中，全局对象可以通过<code>window</code>属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的<code>window</code>标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var global = (function () &#123;</div><div class="line">   return this;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p>这种方法可以随时获得全局对象，因为其在函数中被当做函数调用了（不是通过<code>new</code>构造），<code>this</code>总 是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。</p><h1 id="单var形式（Single-var-Pattern）"><a href="#单var形式（Single-var-Pattern）" class="headerlink" title="单var形式（Single var Pattern）"></a>单var形式（Single var Pattern）</h1><p>在函数顶部使用单var语句是比较有用的一种形式，其好处在于：</p><ul><li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li><li>防止变量在定义之前使用的逻辑错误</li><li>帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的…</li><li>少代码（类型啊传值啊单线完成）</li></ul><p>单var形式长得就像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">   var a = 1,</div><div class="line">       b = 2,</div><div class="line">       sum = a + b,</div><div class="line">       myobject = &#123;&#125;,</div><div class="line">       i,</div><div class="line">       j;</div><div class="line">   // function body...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>您可以使用一个var语句声明多个变量，并以逗号分隔。像这种初始化变量同时初始化值的做法是很好的。这样子可以防止逻辑错误（所有未初始化但声明的变量的初始值是<code>undefined</code>）和增加代码的可读性。在你看到代码后，你可以根据初始化的值知道这些变量大致的用途，例如是要当作对象呢还是当作整数来使。</p><p>你也可以在声明的时候做一些实际的工作，例如前面代码中的<code>sum = a + b</code>这个情况，另外一个例子就是当你使用DOM（文档对象模型）引用时，你可以使用单一的var把DOM引用一起指定为局部变量，就如下面代码所示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function updateElement() &#123;</div><div class="line">   var el = document.getElementById(&quot;result&quot;),</div><div class="line">       style = el.style;</div><div class="line">   // 使用el和style干点其他什么事...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars"><a href="#预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars" class="headerlink" title="预解析：var散布的问题(Hoisting: A Problem with Scattered vars)"></a>预解析：var散布的问题(Hoisting: A Problem with Scattered vars)</h1><p>JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 反例</div><div class="line">myname = &quot;global&quot;; // 全局变量</div><div class="line">function func() &#123;</div><div class="line">    alert(myname); // &quot;undefined&quot;</div><div class="line">    var myname = &quot;local&quot;;</div><div class="line">    alert(myname); // &quot;local&quot;</div><div class="line">&#125;</div><div class="line">func();</div></pre></td></tr></table></figure><p>在这个例子中，你可能会以为第一个alert弹出的是”global”，第二个弹出”loacl”。这种期许是可以理解的，因为在第一个alert 的时候，myname未声明，此时函数肯定很自然而然地看全局变量myname，但是，实际上并不是这么工作的。第一个alert会弹 出”undefined”是因为myname被当做了函数的局部变量（尽管是之后声明的），所有的变量声明当被悬置到函数的顶部了。因此，为了避免这种混 乱，最好是预先声明你想使用的全部变量。</p><p>上面的代码片段执行的行为可能就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myname = &quot;global&quot;; // global variable</div><div class="line">function func() &#123;</div><div class="line">   var myname; // 等同于 -&gt; var myname = undefined;</div><div class="line">   alert(myname); // &quot;undefined&quot;</div><div class="line">   myname = &quot;local&quot;;</div><div class="line">   alert(myname); // &quot;local&quot;&#125;</div><div class="line">func();</div></pre></td></tr></table></figure><blockquote><p>为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文 的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了”hoisting”这个概念， 这种ECMAScript标准中并未定义，通常用来描述行为。</p></blockquote><h1 id="for循环-for-Loops"><a href="#for循环-for-Loops" class="headerlink" title="for循环(for Loops)"></a>for循环(for Loops)</h1><p>在<code>for</code>循环中，你可以循环取得数组或是数组类似对象的值，譬如<code>arguments</code>和<code>HTMLCollection</code>对象。通常的循环形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 次佳的循环</div><div class="line">for (var i = 0; i &lt; myarray.length; i++) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当<code>myarray</code>不是数组，而是一个<code>HTMLCollection</code>对象的时候。</p><p><code>HTMLCollections</code>指的是DOM方法返回的对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.getElementsByName()</div><div class="line">document.getElementsByClassName()</div><div class="line">document.getElementsByTagName()</div></pre></td></tr></table></figure><p>还有其他一些<code>HTMLCollections</code>，这些是在DOM标准之前引进并且现在还在使用的。有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">document.images: 页面上所有的图片元素</div><div class="line">document.links : 所有a标签元素</div><div class="line">document.forms : 所有表单</div><div class="line">document.forms[0].elements : 页面上第一个表单中的所有域</div></pre></td></tr></table></figure><p>集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。</p><p>这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i = 0, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，在这个循环过程中，你只检索了一次长度值。</p><p>在所有浏览器下，循环获取内容时缓存<code>HTMLCollections</code>的长度是更快的，2倍(Safari3)到190倍(IE7)之间。//zxx:此数据貌似很老，仅供参考</p><p>注意到，当你明确想要修改循环中的集合的时候（例如，添加更多的DOM元素），你可能更喜欢长度更新而不是常量。</p><p>伴随着单var形式，你可以把变量从循环中提出来，就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function looper() &#123;</div><div class="line">   var i = 0,</div><div class="line">        max,</div><div class="line">        myarray = [];</div><div class="line">   // ...</div><div class="line">   for (i = 0, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">      // 使用myarray[i]做点什么</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种形式具有一致性的好处，因为你坚持了单一var形式。不足在于当重构代码的时候，复制和粘贴整个循环有点困难。例如，你从一个函数复制了一个循环到另一个函数，你不得不去确定你能够把<code>i</code>和<code>max</code>引入新的函数（如果在这里没有用的话，很有可能你要从原函数中把它们删掉）。</p><p>最后一个需要对循环进行调整的是使用下面表达式之一来替换<code>i++</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i = i + 1</div><div class="line">i += 1</div></pre></td></tr></table></figure><p>JSLint提示您这样做，原因是<code>++</code>和<code>–-</code>促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手<br>如果你直接无视它，JSLint的<code>plusplus</code>选项会是<code>false</code>（默认是default）。</p><p>还有两种变化的形式，其又有了些微改进，因为：</p><ul><li>少了一个变量(无max)</li><li>向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//第一种变化的形式：</div><div class="line"></div><div class="line">var i, myarray = [];</div><div class="line">for (i = myarray.length; i–-;) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div><div class="line"></div><div class="line">//第二种使用while循环：</div><div class="line"></div><div class="line">var myarray = [],</div><div class="line">    i = myarray.length;</div><div class="line">while (i–-) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些小的改进只体现在性能上，此外JSLint会对使用i–-加以抱怨。</p><h1 id="for-in循环-for-in-Loops"><a href="#for-in循环-for-in-Loops" class="headerlink" title="for-in循环(for-in Loops)"></a>for-in循环(for-in Loops)</h1><p><code>for-in</code>循环应该用在非数组对象的遍历上，使用<code>for-in</code>进行循环也被称为“枚举”。</p><p>从技术上将，你可以使用<code>for-in</code>循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。</p><p>有个很重要的<code>hasOwnProperty()</code>方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。</p><p>思考下面一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 对象</div><div class="line">var man = &#123;</div><div class="line">   hands: 2,</div><div class="line">   legs: 2,</div><div class="line">   heads: 1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 在代码的某个地方</div><div class="line">// 一个方法添加给了所有对象</div><div class="line">if (typeof Object.prototype.clone === &quot;undefined&quot;) &#123;</div><div class="line">   Object.prototype.clone = function () &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个例子中，我们有一个使用对象字面量定义的名叫man的对象。在man定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举man的时候出现clone()方法，你需要应用<code>hasOwnProperty()</code>方法过滤原型属性。如果不做过滤，会导致clone()函数显示出来，在大多数情况下这是不希望出现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1.</div><div class="line">// for-in 循环</div><div class="line">for (var i in man) &#123;</div><div class="line">   if (man.hasOwnProperty(i)) &#123; // 过滤</div><div class="line">      console.log(i, &quot;:&quot;, man[i]);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">/* 控制台显示结果</div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line">*/</div><div class="line">// 2.</div><div class="line">// 反面例子:</div><div class="line">// for-in loop without checking hasOwnProperty()</div><div class="line">for (var i in man) &#123;</div><div class="line">   console.log(i, &quot;:&quot;, man[i]);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">控制台显示结果</div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line">clone: function()</div><div class="line">*/</div></pre></td></tr></table></figure><p>另外一种使用<code>hasOwnProperty()</code>的形式是取消Object.prototype上的方法。像是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i in man) &#123;</div><div class="line">   if (Object.prototype.hasOwnProperty.call(man, i)) &#123; // 过滤</div><div class="line">      console.log(i, &quot;:&quot;, man[i]);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var i, hasOwn = Object.prototype.hasOwnProperty;</div><div class="line">for (i in man) &#123;</div><div class="line">    if (hasOwn.call(man, i)) &#123; // 过滤</div><div class="line">        console.log(i, &quot;:&quot;, man[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>严格来说，不使用<code>hasOwnProperty()</code>并不是一个错误。根据任务以及你对代码的自信程度，你可以跳过它以提高些许的循环速度。但是当你对当前对象内容（和其原型链）不确定的时候，添加<code>hasOwnProperty()</code>更加保险些。</p></blockquote><p>格式化的变化（通不过JSLint）会直接忽略掉花括号，把if语句放到同一行上。其优点在于循环语句读起来就像一个完整的想法（每个元素都有一个自己的属性”X”，使用”X”干点什么）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 警告： 通不过JSLint检测</div><div class="line">var i, hasOwn = Object.prototype.hasOwnProperty;</div><div class="line">for (i in man) if (hasOwn.call(man, i)) &#123; // 过滤</div><div class="line">    console.log(i, &quot;:&quot;, man[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes"><a href="#（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes" class="headerlink" title="（不）扩展内置原型((Not) Augmenting Built-in Prototypes)"></a>（不）扩展内置原型((Not) Augmenting Built-in Prototypes)</h1><p>扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。</p><p>增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。</p><p>另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。</p><p>因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外：</p><ul><li>可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。</li><li>如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。</li><li>你清楚地文档记录并和团队交流了变化。</li></ul><p>如果这三个条件得到满足，你可以给原型进行自定义的添加，形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (typeof Object.protoype.myMethod !== &quot;function&quot;) &#123;</div><div class="line">   Object.protoype.myMethod = function () &#123;</div><div class="line">      // 实现...</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="switch模式-switch-Pattern"><a href="#switch模式-switch-Pattern" class="headerlink" title="switch模式(switch Pattern)"></a>switch模式(switch Pattern)</h1><p>你可以通过类似下面形式的switch语句增强可读性和健壮性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var inspect_me = 0,</div><div class="line">    result = &apos;&apos;;</div><div class="line">switch (inspect_me) &#123;</div><div class="line">case 0:</div><div class="line">   result = &quot;zero&quot;;</div><div class="line">   break;</div><div class="line">case 1:</div><div class="line">   result = &quot;one&quot;;</div><div class="line">   break;</div><div class="line">default:</div><div class="line">   result = &quot;unknown&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个简单的例子中所遵循的风格约定如下：</p><ul><li>每个case和switch对齐（花括号缩进规则除外）</li><li>每个case中代码缩进</li><li>每个case以break清除结束</li><li>避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。</li><li>以default结束switch：确保总有健全的结果，即使无情况匹配。</li></ul><h1 id="避免隐式类型转换-Avoiding-Implied-Typecasting"><a href="#避免隐式类型转换-Avoiding-Implied-Typecasting" class="headerlink" title="避免隐式类型转换(Avoiding Implied Typecasting )"></a>避免隐式类型转换(Avoiding Implied Typecasting )</h1><p>JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var zero = 0;</div><div class="line">if (zero === false) &#123;</div><div class="line">   // 不执行，因为zero为0, 而不是false</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反面示例</div><div class="line">if (zero == false) &#123;</div><div class="line">   // 执行了...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有另外一种思想观点认为==就足够了===是多余的。例如，当你使用typeof你就知道它会返回一个字符串，所以没有使用严格相等的理由。然而，JSLint要求严格相等，它使代码看上去更有一致性，可以降低代码阅读时的精力消耗。（“==是故意的还是一个疏漏？”）</p><h1 id="避免-Avoiding-eval"><a href="#避免-Avoiding-eval" class="headerlink" title="避免(Avoiding) eval()"></a>避免(Avoiding) eval()</h1><p>如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">var property = &quot;name&quot;;</div><div class="line">alert(eval(&quot;obj.&quot; + property));</div><div class="line"></div><div class="line">// 更好的</div><div class="line">var property = &quot;name&quot;;</div><div class="line">alert(obj[property]);</div></pre></td></tr></table></figure><p>使用eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理Ajax请求得到的JSON 相应的时候。在这些情况下，最好使用JavaScript内置方法来解析JSON相应，以确保安全和有效。若浏览器不支持JSON.parse()，你可 以使用来自JSON.org的库。</p><p>同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。在幕后，JavaScript仍需要评估和执行你给程序传递的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">setTimeout(&quot;myFunc()&quot;, 1000);</div><div class="line">setTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);</div><div class="line"></div><div class="line">// 更好的</div><div class="line">setTimeout(myFunc, 1000);</div><div class="line">setTimeout(function () &#123;</div><div class="line">   myFunc(1, 2, 3);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure><p>使用新的Function()构造就类似于eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用eval()，你 可以考虑使用new Function()代替。有一个小的潜在好处，因为在新Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。</p><p>考虑下面这个例子，这里仅<code>un</code>作为全局变量污染了命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">console.log(typeof un);    // &quot;undefined&quot;</div><div class="line">console.log(typeof deux); // &quot;undefined&quot;</div><div class="line">console.log(typeof trois); // &quot;undefined&quot;</div><div class="line"></div><div class="line">var jsstring = &quot;var un = 1; console.log(un);&quot;;</div><div class="line">eval(jsstring); // logs &quot;1&quot;</div><div class="line"></div><div class="line">jsstring = &quot;var deux = 2; console.log(deux);&quot;;</div><div class="line">new Function(jsstring)(); // logs &quot;2&quot;</div><div class="line"></div><div class="line">jsstring = &quot;var trois = 3; console.log(trois);&quot;;</div><div class="line">(function () &#123;</div><div class="line">   eval(jsstring);</div><div class="line">&#125;()); // logs &quot;3&quot;</div><div class="line"></div><div class="line">console.log(typeof un); // number</div><div class="line">console.log(typeof deux); // &quot;undefined&quot;</div><div class="line">console.log(typeof trois); // &quot;undefined&quot;</div></pre></td></tr></table></figure><p>另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。在下面这个例子中，eval()可以访问和修改它外部作用域中的变量，这是 Function做不来的（注意到使用Function和new Function是相同的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">   var local = 1;</div><div class="line">   eval(&quot;local = 3; console.log(local)&quot;); // logs &quot;3&quot;</div><div class="line">   console.log(local); // logs &quot;3&quot;</div><div class="line">&#125;());</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line">   var local = 1;</div><div class="line">   Function(&quot;console.log(typeof local);&quot;)(); // logs undefined</div><div class="line">&#125;());</div></pre></td></tr></table></figure><h1 id="parseInt-下的数值转换-Number-Conversions-with-parseInt"><a href="#parseInt-下的数值转换-Number-Conversions-with-parseInt" class="headerlink" title="parseInt()下的数值转换(Number Conversions with parseInt())"></a>parseInt()下的数值转换(Number Conversions with parseInt())</h1><p>使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var month = &quot;06&quot;,</div><div class="line">    year = &quot;09&quot;;</div><div class="line">month = parseInt(month, 10);</div><div class="line">year = parseInt(year, 10);</div></pre></td></tr></table></figure><p>此例中，如果你忽略了基数参数，如parseInt(year)，返回的值将是0，因为“09”被当做8进制（好比执行 parseInt( year, 8 )），而09在8进制中不是个有效数字。</p><p>替换方法是将字符串转换成数字，包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+&quot;08&quot; // 结果是 8</div><div class="line">Number(&quot;08&quot;) // 8</div></pre></td></tr></table></figure><p>这些通常快于parseInt()，因为parseInt()方法，顾名思意，不是简单地解析与转换。但是，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以NaN告终。</p><h1 id="编码规范-Coding-Conventions"><a href="#编码规范-Coding-Conventions" class="headerlink" title="编码规范(Coding Conventions)"></a>编码规范(Coding Conventions)</h1><p>建立和遵循编码规范是很重要的，这让你的代码保持一致性，可预测，更易于阅读和理解。一个新的开发者加入这个团队可以通读规范，理解其它团队成员书写的代码，更快上手干活。</p><p>许多激烈的争论发生会议上或是邮件列表上，问题往往针对某些代码规范的特定方面（例如代码缩进，是Tab制表符键还是space空格键）。如果你是 你组织中建议采用规范的，准备好面对各种反对的或是听起来不同但很强烈的观点。要记住，建立和坚定不移地遵循规范要比纠结于规范的细节重要的多。</p><h1 id="缩进-Indentation"><a href="#缩进-Indentation" class="headerlink" title="缩进(Indentation)"></a>缩进(Indentation)</h1><p>代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。</p><p>一些开发人员更喜欢用tab制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，使用四个空格缩进，这也是JSLint中默认的缩进。</p><p>什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do, while, for, for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function outer(a, b) &#123;</div><div class="line">    var c = 1,</div><div class="line">        d = 2,</div><div class="line">        inner;</div><div class="line">    if (a &gt; b) &#123;</div><div class="line">        inner = function () &#123;</div><div class="line">            return &#123;</div><div class="line">                r: c - d</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125; else &#123;</div><div class="line">        inner = function () &#123;</div><div class="line">            return &#123;</div><div class="line">                r: c + d</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return inner;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="花括号-Curly-Braces"><a href="#花括号-Curly-Braces" class="headerlink" title="花括号{}(Curly Braces)"></a>花括号{}(Curly Braces)</h1><p>花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在in或是for中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。</p><p>想象下你有一个只有一条语句的for循环，你可以忽略花括号，而没有解析的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 糟糕的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1)</div><div class="line">   alert(i);</div></pre></td></tr></table></figure><p>但是，如果，后来，主体循环部分又增加了行代码？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 糟糕的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1)</div><div class="line">   alert(i);</div><div class="line">   alert(i + &quot; is &quot; + (i % 2 ? &quot;odd&quot; : &quot;even&quot;));</div></pre></td></tr></table></figure><p>第二个alert已经在循环之外，缩进可能欺骗了你。为了长远打算，最好总是使用花括号，即时值一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 好的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1) &#123;</div><div class="line">   alert(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>if条件类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 坏</div><div class="line">if (true)</div><div class="line">   alert(1);</div><div class="line">else</div><div class="line">   alert(2);</div><div class="line"></div><div class="line">// 好</div><div class="line">if (true) &#123;</div><div class="line">   alert(1);</div><div class="line">&#125; else &#123;</div><div class="line">   alert(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="左花括号的位置-Opening-Brace-Location"><a href="#左花括号的位置-Opening-Brace-Location" class="headerlink" title="左花括号的位置(Opening Brace Location)"></a>左花括号的位置(Opening Brace Location)</h1><p>开发人员对于左大括号的位置有着不同的偏好——在同一行或是下一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">   alert(&quot;It&apos;s TRUE!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//或</div><div class="line"></div><div class="line">if (true)</div><div class="line">&#123;</div><div class="line">   alert(&quot;It&apos;s TRUE!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript是不挑剔的，当你选择不使用分号结束一行代码时JavaScript会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 警告： 意外的返回值</div><div class="line">function func() &#123;</div><div class="line">   return</div><div class="line">  // 下面代码不执行</div><div class="line">   &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果你希望函数返回一个含有name属性的对象，你会惊讶。由于隐含分号，函数返回undefined。前面的代码等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 警告： 意外的返回值</div><div class="line">function func() &#123;</div><div class="line">   return undefined;</div><div class="line">  // 下面代码不执行</div><div class="line">   &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总之，总是使用花括号，并始终把在与之前的语句放在同一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">   return &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>关于分号注：就像使用花括号，你应该总是使用分号，即使他们可由JavaScript解析器隐式创建。这不仅促进更科学和更严格的代码，而且有助于解决存有疑惑的地方，就如前面的例子显示。</p></blockquote><h1 id="空格-White-Space"><a href="#空格-White-Space" class="headerlink" title="空格(White Space)"></a>空格(White Space)</h1><p>空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在JavaScript中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。</p><p>适合使用空格的地方包括：</p><ul><li>for循环分号分开后的的部分：如<code>for (var i = 0; i &lt; 10; i += 1) {...}</code></li><li>for循环中初始化的多变量(i和max)：<code>for (var i = 0, max = 10; i &lt; max; i += 1) {...}</code></li><li>分隔数组项的逗号的后面：<code>var a = [1, 2, 3];</code></li><li>对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：<code>var o = {a: 1, b: 2};</code></li><li>限定函数参数：<code>myFunc(a, b, c)</code></li><li>函数声明的花括号的前面：<code>function myFunc() {}</code></li><li>匿名函数表达式function的后面：<code>var myFunc = function () {};</code></li></ul><p>使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在<code>+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=</code>等前后都需要空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 宽松一致的间距</div><div class="line">// 使代码更易读</div><div class="line">// 使得更加“透气”</div><div class="line">var d = 0,</div><div class="line">    a = b + 1;</div><div class="line">if (a &amp;&amp; b &amp;&amp; c) &#123;</div><div class="line">    d = a % c;</div><div class="line">    a += d;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反面例子</div><div class="line">// 缺失或间距不一</div><div class="line">// 使代码变得疑惑</div><div class="line">var d = 0,</div><div class="line">    a = b + 1;</div><div class="line">if (a&amp;&amp;b&amp;&amp;c) &#123;</div><div class="line">    d=a % c;</div><div class="line">    a+= d;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后需要注意的一个空格——花括号间距。最好使用空格：</p><ul><li>函数、if-else语句、循环、对象字面量的左花括号的前面({)</li><li>else或while之间的右花括号(})</li></ul><p>空格使用的一点不足就是增加了文件的大小，但是压缩无此问题。</p><blockquote><p>有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。</p></blockquote><h3 id="命名规范-Naming-Conventions"><a href="#命名规范-Naming-Conventions" class="headerlink" title="命名规范(Naming Conventions)"></a>命名规范(Naming Conventions)</h3><p>另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。</p><p>下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。</p><h3 id="以大写字母写构造函数-Capitalizing-Constructors"><a href="#以大写字母写构造函数-Capitalizing-Constructors" class="headerlink" title="以大写字母写构造函数(Capitalizing Constructors)"></a>以大写字母写构造函数(Capitalizing Constructors)</h3><p>JavaScript并没有类，但有new调用的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var adam = new Person();</div></pre></td></tr></table></figure><p>因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。</p><p>命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function MyConstructor() &#123;...&#125;</div><div class="line">function myFunction() &#123;...&#125;</div></pre></td></tr></table></figure><h1 id="分隔单词-Separating-Words"><a href="#分隔单词-Separating-Words" class="headerlink" title="分隔单词(Separating Words)"></a>分隔单词(Separating Words)</h1><p>当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。</p><p>对于构造函数，可以使用大驼峰式命名法(upper camel case)，如<code>MyConstructor()</code>。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是<code>myFunction(), calculateArea()</code>和<code>getFirstName()</code>。</p><p>要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，<code>first_name, favorite_bands,</code>和<code>old_company_name</code>，这种标记法帮你直观地区分函数和其他标识——原型和对象。</p><p>ECMAScript的属性和方法均使用Camel标记法，尽管多字的属性名称是罕见的（正则表达式对象的lastIndex和ignoreCase属性）。</p><h1 id="其它命名形式-Other-Naming-Patterns"><a href="#其它命名形式-Other-Naming-Patterns" class="headerlink" title="其它命名形式(Other Naming Patterns)"></a>其它命名形式(Other Naming Patterns)</h1><p>有时，开发人员使用命名规范来弥补或替代语言特性。</p><p>例如，JavaScript中没有定义常量的方法（尽管有些内置的像Number, MAX_VALUE），所以开发者都采用全部单词大写的规范来命名这个程序生命周期中都不会改变的变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 珍贵常数，只可远观</div><div class="line">var PI = 3.14,</div><div class="line">    MAX_WIDTH = 800;</div></pre></td></tr></table></figure><p>还有另外一个完全大写的惯例：全局变量名字全部大写。全部大写命名全局变量可以加强减小全局变量数量的实践，同时让它们易于区分。</p><p>另外一种使用规范来模拟功能的是私有成员。虽然可以在JavaScript中实现真正的私有，但是开发者发现仅仅使用一个下划线前缀来表示一个私有属性或方法会更容易些。考虑下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    getName: function () &#123;</div><div class="line">        return this._getFirst() + &apos; &apos; + this._getLast();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    _getFirst: function () &#123;</div><div class="line">        // ...</div><div class="line">    &#125;,</div><div class="line">    _getLast: function () &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在此例中，<code>getName()</code>就表示公共方法，部分稳定的API。而<code>_getFirst()</code>和<code>_getLast()</code>则表明了私有。它们仍然是正常的公共方法，但是使用下划线前缀来警告person对象的使用者这些方法在下一个版本中时不能保证工作的，是不能直接使用的。注意，JSLint有些不鸟下划线前缀，除非你设置了noman选项为:false。</p><p>下面是一些常见的_private规范：</p><ul><li>使用尾下划线表示私有，如name<em>和getElements</em>()</li><li>使用一个下划线前缀表_protected（保护）属性，两个下划线前缀表示__private （私有）属性</li><li>Firefox中一些内置的变量属性不属于该语言的技术部分，使用两个前下划线和两个后下划线表示，如：<strong>proto</strong>和<strong>parent</strong>。</li></ul><h1 id="注释-Writing-Comments"><a href="#注释-Writing-Comments" class="headerlink" title="注释(Writing Comments)"></a>注释(Writing Comments)</h1><p>你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。</p><p>很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。</p><blockquote><p>最重要的习惯，然而也是最难遵守的，就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。</p></blockquote><h1 id="关于作者（About-the-Author-）"><a href="#关于作者（About-the-Author-）" class="headerlink" title="关于作者（About the Author ）"></a>关于作者（About the Author ）</h1><p>Stoyan Stefanov是Yahoo!web开发人员，多个O’Reilly书籍的作者、投稿者和技术评审。他经常在会议和他的博客<a href="http://www.zhangxinxu.com/wordpress/2010/10/%e7%bf%bb%e8%af%91-%e9%ab%98%e8%b4%a8%e9%87%8fjavascript%e4%bb%a3%e7%a0%81%e4%b9%a6%e5%86%99%e5%9f%ba%e6%9c%ac%e8%a6%81%e7%82%b9/www.phpied.com" target="_blank" rel="noopener">www.phpied.com</a>上发表web开发主题的演讲。Stoyan还是smush.it图片优化工具的创造者，YUI贡献者，雅虎性能优化工具YSlow 2.0的架构设计师。</p><p>本文转自：<a href="http://www.zhangxinxu.com/wordpress/?p=1173" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=1173</a></p><p>英文原文：<a href="http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/" target="_blank" rel="noopener">http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/</a></p><h1 id="同步与结束语"><a href="#同步与结束语" class="headerlink" title="同步与结束语"></a>同步与结束语</h1><p>本文已同步至目录索引：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">深入理解JavaScript系列</a></p><p>深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2011-12-28 23:00 by 汤姆大叔   原地址：&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.maksim.website/categories/JavaScript/"/>
    
    
  </entry>
  
</feed>
