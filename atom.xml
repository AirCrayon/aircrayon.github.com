<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maksim&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maksim.website/"/>
  <updated>2018-04-09T10:30:21.933Z</updated>
  <id>http://www.maksim.website/</id>
  
  <author>
    <name>Maksim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP中的$this</title>
    <link href="http://www.maksim.website/2018/04/09/cjftk4kaq0023rlrdrfxgghsh/"/>
    <id>http://www.maksim.website/2018/04/09/cjftk4kaq0023rlrdrfxgghsh/</id>
    <published>2018-04-09T10:30:21.933Z</published>
    <updated>2018-04-09T10:30:21.933Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// property declaration</span></div><div class="line">    <span class="keyword">public</span> $var = <span class="string">'a default value'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// method declaration</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">displayVar</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;var;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>当一个方法在类定义内部被调用时，有一个可用的伪变量 \$this。\$this 是<strong>一个到主叫对象的引用</strong>（通常是该方法所从属的对象，但如果是从第二个对象静态调用时也可能是另一个对象）。</p><p><strong>$this 伪变量的示例</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>)) &#123;</div><div class="line">            <span class="keyword">echo</span> <span class="string">'$this is defined ('</span>;</div><div class="line">            <span class="keyword">echo</span> get_class(<span class="keyword">$this</span>);</div><div class="line">            <span class="keyword">echo</span> <span class="string">")\n"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">echo</span> <span class="string">"\$this is not defined.\n"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">        A::foo();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$a = <span class="keyword">new</span> A();</div><div class="line">$a-&gt;foo();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">A::foo();</div><div class="line">$b = <span class="keyword">new</span> B();</div><div class="line">$b-&gt;bar();</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">Note:</span> the next line will issue a warning if E_STRICT is enabled.</span></div><div class="line">B::bar();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>以上例程会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>this is defined (A)</div><div class="line"><span class="meta"></span></div><div class="line">$this is not defined.</div><div class="line"><span class="meta"></span></div><div class="line">$this is defined (B)</div><div class="line"><span class="meta"></span></div><div class="line">$this is not defined.</div></pre></td></tr></table></figure><p>由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。用静态方式调用一个非静态方法会导致一个 <strong>E_STRICT</strong> 级别的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>美国航空航天局科学家给赞比亚修女的一封信</title>
    <link href="http://www.maksim.website/2018/04/08/3/"/>
    <id>http://www.maksim.website/2018/04/08/3/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-09T10:30:21.934Z</updated>
    
    <content type="html"><![CDATA[<p>背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。</p><p>1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ernst Stuhlinger）博士写了一封信。施图林格因在火星之旅工程中的原创性研究，成为NASA（美国航空航天局）马绍尔太空航行中心的科学副总监。信中，玛丽·尤肯达修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。施图林格很快给尤肯达修女回了信，同时还附带了一张题为“升起的地球”的照片，这张标志性的照片是宇航员威廉·安德斯于1968年在月球轨道上拍摄的（照片中可以看到月球的地面）。他这封真挚的回信随后由NASA以《为什么要探索宇宙》为标题发表。</p><p>1970年5月6日</p><p>亲爱的玛丽·尤肯达修女：每天，我都会收到很多类似的来信，但这封对我的触动最深，因为它来自一颗慈悲的饱含探求精神的心灵。我会尽自己所能来回答你这个问题。首先，请允许我向你以及你勇敢的姐妹们表达深深的敬意，你们献身于人类最崇高的事业：帮助身处困境的同胞。</p><p>在来信中，你问我在目前地球上还有儿童由于饥饿面临死亡威胁的情况下，为什么还要花费数十亿美元来进行飞向火星的航行。 我清楚你肯定不希望这样的答案：“哦，我之前不知道还有小孩子快饿死了，好吧，从现在开始，暂停所有的太空项目，直到孩子们都吃上饭再说。”事实上，早在了解火星之旅的技术之前，我已经对儿童的饥荒问题有所了解。而且，同我很多朋友的看法一样，我认为此时此刻，我们就应该开始通往月球、火星乃至其他行星的伟大探险。从长远来看，相对于那些要么只有年复一年的辩论和争吵，要么连妥协之后也迟迟无法落实的各种援助计划来说，我甚至觉得探索太空的工程给更有助于解决人类目前所面临的种种危机。</p><p>在详细说明我们的太空项目如何帮助解决地面上的危机之前，我想先简短讲一个真实的故事。那是在400年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。</p><p>然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气，“我们还在受瘟疫的苦”，他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！”伯爵听到后不为所动，“我会尽可能地接济大家”，他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。”</p><p>果不其然，他的工作赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。</p><p>伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。</p><p>我们目前面临类似的问题。美国总统的年度预算共有2000亿美元，这些钱将用于医疗、教育、福利、城市建设、高速公路、交通运输、海外援助、国防、环保、科技、农业以及其他多项国内外的工程。今年，预算中的1.6%将用于探索宇宙，这些花销将用于阿波罗以计划、其他一些涵盖了天体物理学、深空天文学、空间生物学、行星探测工程、地球资源工程的小项目以及空间工程技术。为担负这些太空项目的支出，平均每个年收入10,000美元的美国纳税人需要支付约30美元给太空，剩下的9,970美元则可用于一般生活开支、休闲娱乐、储蓄、别的税项等花销。</p><p>也许你会问：“为什么不从纳税人为太空支付的30美元里抽出5美元或3美元或是1美元来救济饥饿的儿童呢？”为了回答这个问题，我需要先简单解释一下我们国家的经济是如何运行的，其他国家也是类似的情形。政府由几个部门（如内政部、司法部、卫生部与公众福利部、教育部、运输部、国防部等）和几个机构（国家科学基金会、国家航空航天局等）组成，这些部门和机构根据自己的职能制定相应的年度预算，并严格执行以应对国务委员会的监督，同时还要应付来自预算部门和总统对于其经济效益的压力。当资金最终由国会拨出后，将严格用于经预算批准的计划中的项目。</p><p>显然，NASA的预算中所包含的项目都是和航空航天有关的。未经国会批准的预算项目，是不会得到资金支持的，自然也不会被课税，除非有其他部门的预算涵盖了该项目，借此花掉没有分配给太空项目的资金。由这段简短的说明可以看出，要想援助饥饿的儿童，或在美国已有的对外援助项目上增加援助金额，需要首先由相关部门提出预算，然后由国会批准才行。</p><p>要问是否同意政府实施类似的政策，我个人的意见是绝对赞成。我完全不介意每年多付出一点点税款来帮助饥饿的儿童，无论他们身在何处。</p><p>我相信我的朋友们也会持相同的态度。然而，事情并不是仅靠把去往火星航行的计划取消就能轻易实现的。相对的，我甚至认为可以通过太空项目，来为缓解乃至最终解决地球上的贫穷和饥饿问题作出贡献。解决饥饿问题的关键有两部分：食物的生产和食物的发放。食物的生产所涉及的农业、畜牧业、渔业及其他大规模生产活动在世界上的一些地区高效高产，而在有的地区则产量严重不足。通过高科技手段，如灌溉管理，肥料的使用，天气预报，产量评估，程序化种植，农田优选，作物的习性与耕作时间选择，农作物调查及收割计划，可以显著提高土地的生产效率。</p><p>人造地球卫星无疑是改进这两个关键问题最有力的工具。在远离地面的运行轨道上，卫星能够在很短的时间里扫描大片的陆地，可以同时观察计算农作物生长所需要的多项指标，土壤、旱情、雨雪天气等等，并且可以将这些信息广播至地面接收站以便做进一步处理。事实证明，配备有土地资源传感器及相应的农业程序的人造卫星系统，即便是最简单的型号，也能给农作物的年产量带来数以十亿美元计的提升。</p><p>如何将食品发放给需要的人则是另外一个全新的问题，关键不在于轮船的容量，而在于国际间的合作。小国统治者对于来自大国的大量食品的输入很难做出准确的判断，他们害怕伴随着食物一同而来的还有外国势力对其统治地位的影响。恐怕在国与国之间消除隔阂之前，饥饿问题无法得以高效解决了。我不认为太空计划能一夜之间创造奇迹，然而，探索宇宙有助于促使问题向着良好的方向发展。</p><p>以最近发生的阿波罗13号事故为例。当宇航员处于关键的大气层再入期时，为了保证通讯畅通，苏联关闭了境内与阿波罗飞船所用频带相同的所有广播通信。同时派出舰艇到太平洋和大西洋海域以备第一时间进行搜救工作。如果宇航员的救生舱降落到俄方舰船附近，俄方人员会像对待从太空返回的本国宇航员一样对他们进行救助。同样，如果俄方的宇宙飞船遇到了类似的紧急情况，美国也一定会毫不犹豫地提供援助。 </p><p>通过卫星进行监测与分析来提高食品产量，以及通过改善国际关系提高食品发放的效率，只是通过太空项目提高人类生活质量的两个方面。下面我想介绍另外两个重要作用：促进科学技术的发展和提高一代人的科学素养。</p><p>登月工程需要历史上前所未有的高精度和高可靠性。面对如此严苛的要求，我们要寻找新材料，新方法；开发出更好的工程系统；用更可靠的制作流程；让仪器的工作寿命更长久；甚至需要探索全新的自然规律。</p><p>这些为登月发明的新技术同样可以用于地面上的工程项目。每年，都有大概一千项从太空项目中发展出来的新技术被用于日常生活中，这些技术打造出更好的厨房用具和农场设备，更好的缝纫机和收音机，更好的轮船和飞机，更精确的天气预报和风暴预警，更好的通讯设施，更好的医疗设备，乃至更好的日常小工具。你可能会问为什么先设计出宇航员登月舱的维生系统，而不是先为听力障碍患者造出有声阅读设备呢。答案很简单：解决工程问题时，重要的技术突破往往并不是按部就班直接得到的，而是来自能够激发出强大创新精神，能够燃起的想象力和坚定的行动力，以及能够整合好所有资源的充满挑战的目标。</p><p>太空旅行无可置疑地是一项充满挑战的事业。通往火星的航行并不能直接提供食物解决饥荒问题。然而，它所带来大量的新技术和新方法可以用在火星项目之外，这将产生数倍于原始花费的收益。若希望人类生活得越来越好，除了需要新的技术，我们还需要基础科学不断有新的进展。包括物理学和化学，生物学和生理学，特别是医学，用来照看人类的健康，应对饥饿、疾病、食物和水的污染以及环境污染等问题。</p><p>我们需要更多的年轻人投入到科学事业中来，我们需要给予那些投身科研事业的有天分的科学家更多的帮助。随时要有富于挑战的研究项目，同时要保证对项目给予充分的资源支持。在此我要重申，太空项目是科技进步的催化剂，它为学术研究工作提供了绝佳和实践机会，包括对月球和其他行星的眼睛、物理学和天文学、生物学和医学科学等学科，有它，科学界源源不断出现令人激动不已研究课题，人类得以窥见宇宙无比瑰丽的景象；为了它，新技术新方法不断涌现。</p><p>由美国政府控制并提供资金支持的所有活动中，太空项目无疑最引人瞩目也最容易引起争议，尽管其仅占全部预算的1.6%，不到全民生产总值的千分之三。作为新技术的驱动者和催化剂，太空项目开展了多项基础科学的研究，它的地位注定不同于其他活动。从某种意义上来说，以太空项目的对社会的影响，其地位相当于3-4千年前的战争活动。</p><p>如果国家之间不再比拼轰炸机和远程导弹，取而代之比拼月球飞船的性能，那将避免多少战乱之苦！聪慧的胜利者将满怀希望，失败者也不用饱尝痛苦，不再埋下仇恨的种子，不再带来复仇的战争。</p><p>尽管我们开展的太空项目研究的东西离地球很遥远，已经将人类的视野延伸至月亮、至太阳、至星球、直至那遥远的星辰，但天文学家对地球的关注，超过以上所有天外之物。太空项目带来的不仅有那些新技术所所提供的生活品质的提升，随着对宇宙研究的深入，我们对地球，对生命，对人类自身的感激之情将越深。太空探索让地球更美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。&lt;/p&gt;
&lt;p&gt;1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ern
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.maksim.website/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>在MYSQL中进行日期操作</title>
    <link href="http://www.maksim.website/2018/04/08/1/"/>
    <id>http://www.maksim.website/2018/04/08/1/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-09T10:30:21.933Z</updated>
    
    <content type="html"><![CDATA[<p>平时比较常用的时间、字符串、时间戳之间的互相转换，虽然常用但是几乎每次使用时候都喜欢去搜索一下用法；本文将作为一个笔记，整理一下三者之间的 转换（即：date转字符串、date转时间戳、字符串转date、字符串转时间戳、时间戳转date，时间戳转字符串）用法，方便日后查看；</p><h2 id="涉及的函数"><a href="#涉及的函数" class="headerlink" title="涉及的函数"></a>涉及的函数</h2><p>date_format(date, format) 函数MySQL日期格式化函数date_format()</p><p>str_to_date(str, format) 函数 把字符串转换为日期</p><p>from_unixtime(unix_timestamp, format) 函数，MySQL时间戳格式化函数from_unixtime</p><h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="时间转字符串"><a href="#时间转字符串" class="headerlink" title="时间转字符串"></a>时间转字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select date_format(now(), '%Y-%m-%d');   #结果：2016-01-05</div></pre></td></tr></table></figure><h3 id="时间转时间戳"><a href="#时间转时间戳" class="headerlink" title="时间转时间戳"></a>时间转时间戳</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select unix_timestamp(now());  #结果：1452001082</div></pre></td></tr></table></figure><h3 id="字符串转时间"><a href="#字符串转时间" class="headerlink" title="字符串转时间"></a>字符串转时间</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select str_to_date('2016-01-02', '%Y-%m-%d %H');  #结果：2016-01-02 00:00:00</div></pre></td></tr></table></figure><h3 id="字符串转时间戳"><a href="#字符串转时间戳" class="headerlink" title="字符串转时间戳"></a>字符串转时间戳</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select unix_timestamp('2016-01-02');  #结果：1451664000</div></pre></td></tr></table></figure><h3 id="时间戳转时间"><a href="#时间戳转时间" class="headerlink" title="时间戳转时间"></a>时间戳转时间</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select from_unixtime(1451997924);  #结果：2016-01-05 20:45:24</div></pre></td></tr></table></figure><h3 id="时间戳转字符串"><a href="#时间戳转字符串" class="headerlink" title="时间戳转字符串"></a>时间戳转字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select from_unixtime(1451997924,'%Y-%d');  #结果：2016-01-05 20:45:24</div></pre></td></tr></table></figure><h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><p>MySQL日期格式化（format）取值范围。</p><table><thead><tr><th></th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>秒</td><td>%S、%s</td><td>两位数字形式的秒（ 00,01, …, 59）</td></tr><tr><td>分</td><td>%I、%i</td><td>两位数字形式的分（ 00,01, …, 59）</td></tr><tr><td>小时</td><td>%H</td><td>24小时制，两位数形式小时（00,01, …,23）</td></tr><tr><td>%h</td><td>12小时制，两位数形式小时（00,01, …,12）</td><td></td></tr><tr><td>%k</td><td>24小时制，数形式小时（0,1, …,23）</td><td></td></tr><tr><td>%l</td><td>12小时制，数形式小时（0,1, …,12）</td><td></td></tr><tr><td>%T</td><td>24小时制，时间形式（HH:mm:ss）</td><td></td></tr><tr><td>%r</td><td>12小时制，时间形式（hh:mm:ss AM 或 PM）</td><td></td></tr><tr><td>%p</td><td>AM上午或PM下午</td><td></td></tr><tr><td>周</td><td>%W</td><td>一周中每一天的名称（Sunday,Monday, …,Saturday）</td></tr><tr><td>%a</td><td>一周中每一天名称的缩写（Sun,Mon, …,Sat）</td><td></td></tr><tr><td>%w</td><td>以数字形式标识周（0=Sunday,1=Monday, …,6=Saturday）</td><td></td></tr><tr><td>%U</td><td>数字表示周数，星期天为周中第一天</td><td></td></tr><tr><td>%u</td><td>数字表示周数，星期一为周中第一天</td><td></td></tr><tr><td>天</td><td>%d</td><td>两位数字表示月中天数（01,02, …,31）</td></tr><tr><td>%e</td><td>数字表示月中天数（1,2, …,31）</td><td></td></tr><tr><td>%D</td><td>英文后缀表示月中天数（1st,2nd,3rd …）</td><td></td></tr><tr><td>%j</td><td>以三位数字表示年中天数（001,002, …,366）</td><td></td></tr><tr><td>月</td><td>%M</td><td>英文月名（January,February, …,December）</td></tr><tr><td>%b</td><td>英文缩写月名（Jan,Feb, …,Dec）</td><td></td></tr><tr><td>%m</td><td>两位数字表示月份（01,02, …,12）</td><td></td></tr><tr><td>%c</td><td>数字表示月份（1,2, …,12）</td><td></td></tr><tr><td>年</td><td>%Y</td><td>四位数字表示的年份（2015,2016…）</td></tr><tr><td>%y</td><td>两位数字表示的年份（15,16…）</td><td></td></tr><tr><td>文字输出</td><td>%文字</td><td>直接输出文字内容</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时比较常用的时间、字符串、时间戳之间的互相转换，虽然常用但是几乎每次使用时候都喜欢去搜索一下用法；本文将作为一个笔记，整理一下三者之间的 转换（即：date转字符串、date转时间戳、字符串转date、字符串转时间戳、时间戳转date，时间戳转字符串）用法，方便日后查看；
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.maksim.website/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>写作的准备-读《完全写作指南》</title>
    <link href="http://www.maksim.website/2018/04/08/2/"/>
    <id>http://www.maksim.website/2018/04/08/2/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-09T11:37:37.616Z</updated>
    
    <content type="html"><![CDATA[<p>写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：</p><p>目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改</p><p>从理论上讲，按照这个顺序操作，你就能得到一篇组织得当、逻辑严谨的完美稿件。这个方法对一部分人是有用的，但是如果你和大多数人一样，那么他可能就不适合你。在现实生活中，大部分都不是线性思维的写作者。</p><p>这六个步骤没错，错的是这个强制性的顺序。当遵循渐进编程了因循守旧，它可能会阻碍你写作能力的发挥。</p><p>你可以以这个步骤中任意一步作为起点，头脑风暴、提纲或者是写初稿。</p><h2 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h2><p>当要写作时，首先我们要确定自己的目标是什么，你希望达到什么目的。</p><p>仔细思考写作目的能帮你搞清楚该说什么，以及怎么说。又去的是，这样一来你的读者也会更加轻松，如果你也有过收到大量简历的经理，你就会知道一封周到、工整且有针对性的求职信会让你干到多么轻松。</p><h2 id="了解你的读者"><a href="#了解你的读者" class="headerlink" title="了解你的读者"></a>了解你的读者</h2><p>除了私人日记之外，所有的作品都是有读者的，你的作品需要指向这些特定的读者。</p><p>站在读者的角度进行思考，有两个关键问题：</p><ul><li>信息</li><li>态度</li></ul><p>选择信息的黄金法则是：<strong>要有足量的有效信息，让你的读者行动起来。</strong></p><p>了解读者潜在的态度也是成功的关键。</p><ul><li>你的读者会有什么样的反应？</li><li>他们很容易接受你的信息吗?</li><li>还是会有抵触情绪？</li><li>他们是否怀有敌意。</li></ul><blockquote><p>笔者说：</p><p>在这里，可以读《美国航空航天局科学家给赞比亚修女的一封信》，这是一封大师级的回信。</p></blockquote><h2 id="用他头脑风暴锁定你想表达的内容"><a href="#用他头脑风暴锁定你想表达的内容" class="headerlink" title="用他头脑风暴锁定你想表达的内容"></a>用他头脑风暴锁定你想表达的内容</h2><p>头脑风暴有一些规则。如果你在学校或者工作的地方参加过头脑风暴式的讨论，那么你很可能看到过这些规则：</p><ol><li>相处的点子越多越好。如果你能把注意力放在数量而非质量上，那么提出有用的点子概率就会更大，点子都多多益善。</li><li>不要审查，不要评论。头脑风暴时，让你的思绪自由发散。这并不是对点子进行评论的时候，不要说这个点子不太好，那个点子不合适。把脑袋里评论的声音关掉，把所有想到的东西都写出来。你可以之后再删除。</li><li>接受不同寻常的想法。不要考虑你的想法靠不靠谱。你的这些想法可能完全超出预料，但它们当中可能会有一个非常有用，或至少能为你的思考指引方向的点子。充分发挥自己的想象力。</li><li>合并改进你的点子。如果你任由思绪自由发散，那么点子很可能会有一些重合。观察它们的相似之处，并加以合并调整。</li></ol><p>当写完初稿后，发现内容不够完整，不够有说服力时候甚至可以重新进行头脑风暴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：&lt;/p&gt;
&lt;p&gt;目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改&lt;/p&gt;
&lt;p&gt;从理论上讲，按照这个顺序操作，你就能得到一篇组
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.maksim.website/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>一个新的开始</title>
    <link href="http://www.maksim.website/2018/04/03/cjftk4kcu005hrlrd7drnzlay/"/>
    <id>http://www.maksim.website/2018/04/03/cjftk4kcu005hrlrd7drnzlay/</id>
    <published>2018-04-03T14:53:43.504Z</published>
    <updated>2018-04-03T14:53:43.507Z</updated>
    
    <content type="html"><![CDATA[<p>人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。</p><a id="more"></a><p>于是在不甘，与短暂的刺激后，我又开始了写作，其实也是想试一试，自己到底能不能够成功，我所谓的成功其实就是写一个完整的故事，记得小时候抓周，我抓的就是个笔，奶奶曾经说我以后是个笔杆子，可惜现在虽然现在也是在写东西，不过写的是代码，而不是小说。</p><p>记得那是还在上初中的时候，我接触到了网络文学，我记得我看的第一本网络小说应该是木子心写的《现代修罗》，可惜最后太监了，那个时候我对太监这件事当真是有些厌恶，可是没想到到最后，我也踏入了后宫那洪流之中，成为了诸多太监中的一份子。我朋友曾经对我说过一句话，要是能在我生儿子之前能看到你一本完本的小说就行了。</p><p>其实这段时间一直在思考我要不要继续写东西，我能否坚持下去，最终还是决定试一试，思前想后决定写一篇科幻类的小说，希望能够做到不落俗套，写出自己心目中的网络文学。</p><p>以后每个月我都会更新一篇关于网络文学的文章，主要是去分析曾经红极一时或者是现在当红的网络小说的写作手法。看一看那些大神是如何进行网络文学创作的，同时也是去提升自己的能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生又要开启新的篇章了，而我也将重头开始，接触网络文学也有五六年了，断断续续的也算是写了很多东西，但都无疾而终了，可能是那几分钟的热度退去了，仔细回想倒是感觉真的欠缺了自己很多东西，说起来也是蛮遗憾的，为了不让我的青春有遗憾，我做了很多事情，唯独欠缺的可能就是曾经在上大学前许下的承诺，在大学毕业的时候写一本完本的小说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.maksim.website/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjftk4kd3005qrlrdo1l17e06/"/>
    <id>http://www.maksim.website/2018/04/03/cjftk4kd3005qrlrdo1l17e06/</id>
    <published>2018-04-03T14:53:43.478Z</published>
    <updated>2018-04-03T14:53:43.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务评估"><a href="#业务评估" class="headerlink" title="业务评估"></a>业务评估</h1><h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ul><li>响应时间（request time）</li><li>数据总量</li><li>每秒请求量</li><li>读写比</li><li>重要程度</li></ul><p><strong>响应时间</strong>是与整个数据库的状态有关，不仅与CPU、数据总量、每秒请求量、读写比以及各种场景都是有关系的。所以说相应时间是一个综合指标。</p><p>对于DBA来说最关心的就是业务的相应时间能不能够满足，在满足的情况下再去优化以下的这些点，才是有意义的。</p><p>数据总量往往需要业务方提供一个一到两年的数据总量，这是因为如果没有数据总量，前期是没有办法规划我们的数据库实例的。当然也有很多的不确定因素，比如互联网行业，比如有的业务会爆发性的增长，这些规划可能是不合理的，但是在我们也要有一个大概的评估，因为这是前期资源申请和资源分配的策略。</p><p>每秒请求量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务评估&quot;&gt;&lt;a href=&quot;#业务评估&quot; class=&quot;headerlink&quot; title=&quot;业务评估&quot;&gt;&lt;/a&gt;业务评估&lt;/h1&gt;&lt;h2 id=&quot;业务需求&quot;&gt;&lt;a href=&quot;#业务需求&quot; class=&quot;headerlink&quot; title=&quot;业务需求&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Object.defineProperty()模拟双向数据绑定</title>
    <link href="http://www.maksim.website/2018/04/03/cjftk4kd5005srlrdghq72xzr/"/>
    <id>http://www.maksim.website/2018/04/03/cjftk4kd5005srlrdghq72xzr/</id>
    <published>2018-04-03T14:53:43.463Z</published>
    <updated>2018-04-03T14:53:43.464Z</updated>
    
    <content type="html"><![CDATA[<p>对象是由多键值对组成的无序集合，对象中的每个属性对应任意类型的值。定义对象可以使用构造函数或字面量的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//obj = &#123;&#125;</span></div><div class="line">obj.name = <span class="string">'Maksim'</span>;     <span class="comment">//添加属性</span></div><div class="line">obj.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;; <span class="comment">//添加方法</span></div></pre></td></tr></table></figure><p>为对象添加属性我们还可以使用 Object.defineProperty 定义和修改属性。</p><p>语法：<code>Object.defineProperty(obj, prop, descriptor)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象是由多键值对组成的无序集合，对象中的每个属性对应任意类型的值。定义对象可以使用构造函数或字面量的形式。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP基础手札的引用</title>
    <link href="http://www.maksim.website/2018/04/03/cjftk4kbn003qrlrdcidci981/"/>
    <id>http://www.maksim.website/2018/04/03/cjftk4kbn003qrlrdcidci981/</id>
    <published>2018-04-03T14:53:43.433Z</published>
    <updated>2018-04-03T14:53:43.433Z</updated>
    
    <content type="html"><![CDATA[<p>在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。</p><p>PHP 的指针域这些语言机制相同，即可以用一个变量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。&lt;/p&gt;
&lt;p&gt;PHP 的指针域这些语言机制相同，即可以用一个变量&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP页面静态化</title>
    <link href="http://www.maksim.website/2018/04/03/cjftk4kbv0044rlrdzp5380md/"/>
    <id>http://www.maksim.website/2018/04/03/cjftk4kbv0044rlrdzp5380md/</id>
    <published>2018-04-03T14:53:43.431Z</published>
    <updated>2018-04-03T14:53:43.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h1><p>要了解静态化页面，首先我们就要知道什么是页面？</p><p>一、静态web页面：</p><p>1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。</p><p>2、为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。</p><p>3、静态web无法连接数据库；</p><p>4、静态web资源开发技术：HTML；</p><p>5、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。</p><p>二、动态web页面：</p><p>动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。</p><p>如果客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</p><p>如果客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</p><p>#静态化</p><p>PHP静态化分为：纯静态化 和 伪静态化；纯静态化又分为：局部静态化 和 完全静态化</p><p>纯静态化：是把PHP生成的动态页面保存成静态的html文件，用户访问该静态页面，而不是用户每一次访问都重新生成一张相同的网页，优点就是减小服务器开销，</p><ul><li>局部静态化：是生成的静态文件中，有局部的数据还是通过ajax技术动态获取的；</li><li>完全静态化：即不存在动态获取数据的情况，所以内容都来自静态的html页面</li></ul><p>伪静态化：其实还是动态访问，其实质是动态生成数据，你访问的网址类似于”<a href="http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化" target="_blank" rel="noopener">http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化</a></p><p>　　伪静态的优点：美观；便于搜索引擎收录</p><p>buffer 概括</p><p>buffer 其实就是缓冲区，一个内存地址空间，主要是用于存储数据的区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于页面&quot;&gt;&lt;a href=&quot;#关于页面&quot; class=&quot;headerlink&quot; title=&quot;关于页面&quot;&gt;&lt;/a&gt;关于页面&lt;/h1&gt;&lt;p&gt;要了解静态化页面，首先我们就要知道什么是页面？&lt;/p&gt;
&lt;p&gt;一、静态web页面：&lt;/p&gt;
&lt;p&gt;1、在静态Web程序中，客
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjftk4kb3002prlrd3l4p247b/"/>
    <id>http://www.maksim.website/2018/04/03/cjftk4kb3002prlrd3l4p247b/</id>
    <published>2018-04-03T14:53:43.409Z</published>
    <updated>2018-04-03T14:53:43.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL常用存储引擎之Innodb"><a href="#MySQL常用存储引擎之Innodb" class="headerlink" title="MySQL常用存储引擎之Innodb"></a>MySQL常用存储引擎之Innodb</h1><p>Mysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。</p><p>和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。</p><p>特点：</p><ul><li>灾难恢复性好</li><li>支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的</li><li>使用行级锁</li><li>对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的</li><li>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引</li><li>支持外键</li><li>支持热备份</li></ul><p>Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由<code>innodb_file_per_table</code>这个参数决定。</p><p>如果值为 <code>ON</code>,会为每个 innodb 表建立一个<code>tablename.ibd</code>的系统文件，如果该参数为<code>OFF</code>时会把数据存储到系统的表空间<code>ibdataX</code></p><p>引用</p><p>《打造扛得住的 MySQL》 慕课网</p><p>《高性能 MySQL》</p><p>《My》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;a href=&quot;#MySQL常用存储引擎之Innodb&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;/a&gt;MySQL常用存储引擎之Innodb&lt;/h1&gt;&lt;p&gt;Mysql5
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjftk4kb90031rlrdwsvws9ur/"/>
    <id>http://www.maksim.website/2018/04/03/cjftk4kb90031rlrdwsvws9ur/</id>
    <published>2018-04-03T14:53:43.408Z</published>
    <updated>2018-04-03T14:53:43.408Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:MySQL服务器参数介绍<br>categories:MySQL<br>date:2017-10-18</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p>人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。</p><p>MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。</p><p>从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。</p><p>##　MySQl获取配置信息路径</p><ul><li>命令行参数 <code>mysqld_safe --datadir=/data/sql_data</code></li><li>配置文件 <code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code></li></ul><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171013153125.png" alt=""></p><p>MySQL会先从<code>/etc/my.cnf</code>文件下读取配置信息，然后是<code>/etc/mysql/my.cnf</code>。</p><p>MySQL配置参数的作用域</p><ul><li>全局参数 <ul><li><code>set global 参数名 = 参数值;</code></li><li><code>set @@global。参数名:=参数值;</code></li></ul></li><li>会话参数<ul><li><code>set [session] 参数名=参数值;</code></li><li><code>set @@session.参数名:=参数值;</code></li></ul></li></ul><p>会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。</p><p>在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。</p><h2 id="内存配置相关参数"><a href="#内存配置相关参数" class="headerlink" title="内存配置相关参数"></a>内存配置相关参数</h2><p>MySQL对于内存的使用我们可以分为两个类来看。</p><ul><li>无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存</li><li>可以通过参数配置控制的，各类的缓冲池所需要的内存。</li></ul><p>对内存参数配置之前，我们需要进行考虑：</p><ul><li>确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。</li><li>确定MySQL的每个连接使用的内存，例如排序缓冲和临时表</li><li><p>把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。</p><ul><li><p>sort_buffer_size</p><ul><li>join_buufer_szie</li><li>read_buffer_size</li><li>read_rnd_buffer_size  </li></ul></li></ul></li></ul><h3 id="确定需要为操作系统保留多少内存"><a href="#确定需要为操作系统保留多少内存" class="headerlink" title="确定需要为操作系统保留多少内存"></a>确定需要为操作系统保留多少内存</h3><p>给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。</p><p>数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。</p><p>另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。</p><h3 id="如何为缓冲池分配内存"><a href="#如何为缓冲池分配内存" class="headerlink" title="如何为缓冲池分配内存"></a>如何为缓冲池分配内存</h3><p>Innodb_buffer_pool_size，Innodb缓冲区</p><p>总内存-（每个线程所需要的内存*连接数）- 系统保留内存</p><p>手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。</p><h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos;</div></pre></td></tr></table></figure><h2 id="I-O相关配置参数"><a href="#I-O相关配置参数" class="headerlink" title="I/O相关配置参数"></a>I/O相关配置参数</h2><p>Innodb I/O相关配置</p><h2 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h2><p><code>expire_logs_days</code> 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:MySQL服务器参数介绍&lt;br&gt;categories:MySQL&lt;br&gt;date:2017-10-18&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjftk4kc0004erlrdnjmromjr/"/>
    <id>http://www.maksim.website/2018/04/03/cjftk4kc0004erlrdnjmromjr/</id>
    <published>2018-04-03T14:53:03.331Z</published>
    <updated>2018-04-03T14:53:03.331Z</updated>
    
    <content type="html"><![CDATA[<p>#md</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#md&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>删除特殊的用户和用户组</title>
    <link href="http://www.maksim.website/2018/04/02/1/"/>
    <id>http://www.maksim.website/2018/04/02/1/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-04-03T14:53:43.528Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。</p><p>Linux 系统中可以删除的默认用户和用户组大致如下：</p><ul><li>可删除的用户，如 adm、lp、sync、shutdown、halt、news、uucp、operator、games、gopher 等。</li><li>可删除的用户组，如 adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers 等。</li></ul><p>删除的方法很简单，下面以删除 games 用户和用户组为例介绍具体的操作。</p><p>删除用户所使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">userdel games</div></pre></td></tr></table></figure><p>删除用户组使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupdel games</div></pre></td></tr></table></figure><p>有些时候，某些用户仅仅作为进程调度或者用户组调用，并不需要登录功能，此时可以禁止这些用户登录系统的功能，例如要禁止 nagios 用户的登录功能，可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -s /sbin/nologin nagios</div></pre></td></tr></table></figure><p>其实要删除哪些用户和用户组，并没有固定要求，可以根据服务器的用途来决定，如果服务器用于 Web 应用的，那么系统默认的 Apache 用户和用户组就无需删除；如果服务器用于数据库应用，那么建议删除系统默认的 Apache 用户和用户组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。&lt;/p&gt;
&lt;p&gt;Linux 系统中可以删除的默认用户和用户组大
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Hash算法</title>
    <link href="http://www.maksim.website/2018/03/13/1/"/>
    <id>http://www.maksim.website/2018/03/13/1/</id>
    <published>2018-03-12T16:00:00.000Z</published>
    <updated>2018-04-03T14:53:43.404Z</updated>
    
    <content type="html"><![CDATA[<p>Hash表（HashTable）又称散列表，通过把关键字 key 映射到数组中的一个位置来访问记录，以加快查找的速度。这个应设函数称之为 Hash 函数，存放记录的数组称之为 Hash 表。</p><p>##HASH 函数</p><p>Hash 函数的作用是把任意长度的输入，通过 Hash 算法编程固定长度的输出，该输出就是 Hash 值。这种转换是一种压缩映射，也就是 Hash 值的空间通常远远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从 Hash 值来唯一地确定输入值。</p><p>一个号的 Hash 函数应该满足以下条件：每个关键字都可以均匀地分布到 Hash 表任意一个位置，并与其他已经被散列到 Hash 表中的关键字不发生冲突，这就是Hash 最难实现的地方。</p><h2 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h2><p>关键字 key 可能是整数或者字符串，可以按照关键字的类型设计不同的 Hash 算法。整数关键字的 Hash 算法有以下几种。</p><h3 id="直接取余数"><a href="#直接取余数" class="headerlink" title="直接取余数"></a>直接取余数</h3><p>直接取余法原理比较简单，直接使用关键字key 除以 Hash 表的大小 m 取余，算法如下：</p><p>h(key) = key mod m</p><p>例如，如果 Hash 表的大小为 m=12，所以关键字 key=100，则 h(key) = 4，这种算法只需要一个求余操作，速度比较快。</p><h3 id="乘积取整法"><a href="#乘积取整法" class="headerlink" title="乘积取整法"></a>乘积取整法</h3><p>未完成····待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hash表（HashTable）又称散列表，通过把关键字 key 映射到数组中的一个位置来访问记录，以加快查找的速度。这个应设函数称之为 Hash 函数，存放记录的数组称之为 Hash 表。&lt;/p&gt;
&lt;p&gt;##HASH 函数&lt;/p&gt;
&lt;p&gt;Hash 函数的作用是把任意长度的
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>AndroidStudio解决一直处于Building gradle project info的问题</title>
    <link href="http://www.maksim.website/2018/03/10/cjftk4kap0021rlrddvsavqyp/"/>
    <id>http://www.maksim.website/2018/03/10/cjftk4kap0021rlrddvsavqyp/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-04-09T11:41:26.605Z</updated>
    
    <content type="html"><![CDATA[<p>问题的原因是gradle包（即gradle-wrapper.properties里的gradle压缩文件）本地没有需要下载，因为墙的原因，一直卡在下载的环节。 </p><p>有三个解决方案：（选其一，推荐第三个方案） </p><ol><li>科学#上网，不多说，必备。加载多久看你网速了。（但即使是如此速度依旧很慢）</li><li>将 gradle-wrapper.properties中的版本改为已经存在的版本，找一个可以编译的项目复制 gradle 版本号即可。</li><li>下载对应离线包放到本地（如：C:\Users\Administrator.gradle\wrapper\dists\gradle-4.0.1-all\26awvqv6f41r14q9x72t4n0s，不解压，重启as），离线包地址：services.gradle.org/distributions/或者<a href="http://download.csdn.net/album/detail/2265" target="_blank" rel="noopener">http://download.csdn.net/album/detail/2265</a>；然后打开File-&gt;Settings-&gt;Build, Exectution, Deployment-&gt;Gradle ，设置 “Gradle home” 为解压目录即可.</li></ol><blockquote><p>原文地址：<a href="http://blog.csdn.net/nifanggge/article/details/53397942" target="_blank" rel="noopener">http://blog.csdn.net/nifanggge/article/details/53397942</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题的原因是gradle包（即gradle-wrapper.properties里的gradle压缩文件）本地没有需要下载，因为墙的原因，一直卡在下载的环节。 &lt;/p&gt;
&lt;p&gt;有三个解决方案：（选其一，推荐第三个方案） &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;科学#上网，不多说，必备。
      
    
    </summary>
    
      <category term="Andriod" scheme="http://www.maksim.website/categories/Andriod/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript系列2、揭秘命名函数表达式</title>
    <link href="http://www.maksim.website/2018/03/09/2/"/>
    <id>http://www.maksim.website/2018/03/09/2/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-04-07T09:39:32.142Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2011-12-29 09:02 by 汤姆大叔</p><p>原地址：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上还没用发现有人对命名函数表达式进去重复深入的讨论，正因为如此，网上出现了各种各样的误解，本文将从原理和实践两个方面来探讨JavaScript关于命名函数表达式的优缺点。</p><p>简单的说，命名函数表达式只有一个用户，那就是在Debug或者Profiler分析的时候来描述函数的名称，也可以使用函数名实现递归，但很快你就会发现其实是不切实际的。当然，如果你不关注调试，那就没什么可担心的了，否则，如果你想了解兼容性方面的东西的话，你还是应该继续往下看看。</p><p>我们先开始看看，什么叫函数表达式，然后再说一下现代调试器如何处理这些表达式，如果你已经对这方面很熟悉的话，请直接跳过此小节。</p><h1 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h1><p>在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者期间的区别是有点晕，因为ECMA规范只明确了一点：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符：</p><p>　　函数声明:</p><p>　　function 函数名称 <strong>(</strong>参数：可选<strong>){</strong> 函数体<strong> }</strong></p><p>　　函数表达式：</p><p>　　function 函数名称（可选）<strong>(</strong>参数：可选<strong>){</strong> 函数体 <strong>}</strong></p><p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称的话，如何判断是函数声明还是函数表达式呢？ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 声明，因为它是程序的一部分</span></div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 表达式，因为它是赋值表达式的一部分</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 表达式，因为它是new表达式</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 声明，因为它是函数体的一部分</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式，我们来看几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 函数声明</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// 函数表达式：包含在分组操作符内</span></div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  (<span class="keyword">var</span> x = <span class="number">5</span>); <span class="comment">// 分组操作符，只能包含表达式而不能包含语句：这里的var就是语句</span></div><div class="line">&#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">  <span class="comment">// SyntaxError</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你可以会想到，在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval(‘(‘ + json + ‘)’)，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  &#123; <span class="string">"x"</span>: <span class="number">5</span> &#125;; <span class="comment">// "&#123;" 和 "&#125;" 做解析成代码块</span></div><div class="line">&#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">  <span class="comment">// SyntaxError</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">(&#123; <span class="string">"x"</span>: <span class="number">5</span> &#125;); <span class="comment">// 分组操作符强制将"&#123;" 和 "&#125;"作为对象字面量来解析</span></div></pre></td></tr></table></figure><p>表达式和声明存在着十分微妙的差别，首先，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，参考如下例子，函数fn是在alert之后声明的，但是在alert执行的时候，fn已经有定义了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(fn());</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'Hello world!'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外，还有一点需要提醒一下，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 千万别这样做！</span></div><div class="line"><span class="comment">// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'first'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'second'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">// 相反，这样情况，我们要用函数表达式</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'first'</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'second'</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure><p>函数声明的实际规则如下：</p><p><em>函数声明</em>只能出现在<em>程序</em>或<em>函数体</em>内。从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含<em>函数声明</em>这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让<em>表达式</em>出现在Block（块）中情形，就是让它作为<em>表达式语句</em>的一部分。但是，规范明确规定了<em>表达式语句</em>不能以关键字function开头。而这实际上就是说，<em>函数表达式</em>同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 </p><h1 id="函数语句"><a href="#函数语句" class="headerlink" title="函数语句"></a>函数语句</h1><p>在ECMAScript的语法扩展中，有一个是函数语句，目前只有基于Gecko的浏览器实现了该扩展，所以对于下面的例子，我们仅是抱着学习的目的来看，一般来说不推荐使用（除非你针对Gecko浏览器进行开发）。</p><p>1.一般语句能用的地方，函数语句也能用，当然也包括Block块中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.函数语句可以像其他语句一样被解析，包含基于条件执行的情形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// 1</span></div><div class="line"><span class="comment">// 注：其它客户端会将foo解析成函数声明 </span></div><div class="line"><span class="comment">// 因此，第二个foo会覆盖第一个，结果返回2，而不是1</span></div></pre></td></tr></table></figure><p>3.函数语句不是在变量初始化期间声明的，而是在运行时声明的——与函数表达式一样。不过，函数语句的标识符一旦声明能在函数的整个作用域生效了。标识符有效性正是导致函数语句与函数表达式不同的关键所在（下一小节我们将会展示命名函数表达式的具体行为）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 此刻，foo还没用声明</span></div><div class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "undefined"</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="comment">// 进入这里以后，foo就被声明在整个作用域内了</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 从来不会走到这里，所以这里的foo也不会被声明</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "function"</span></div></pre></td></tr></table></figure><p>不过，我们可以使用下面这样的符合标准的代码来模式上面例子中的函数语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.函数语句和函数声明（或命名函数表达式）的字符串表示类似，也包括标识符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">String</span>(foo); <span class="comment">// function foo() &#123; return 1; &#125;</span></div></pre></td></tr></table></figure><p>5.另外一个，早期基于Gecko的实现（Firefox 3及以前版本）中存在一个bug，即函数语句覆盖函数声明的方式不正确。在这些早期的实现中，函数语句不知何故不能覆盖函数声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="comment">// 用函数语句重写</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// FF3以下返回1，FF3.5以上返回2</span></div><div class="line"></div><div class="line"><span class="comment">// 不过，如果前面是函数表达式，则没用问题</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// 所有版本都返回2</span></div></pre></td></tr></table></figure><p>再次强调一点，上面这些例子只是在某些浏览器支持，所以推荐大家不要使用这些，除非你就在特性的浏览器上做开发。</p><h1 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h1><p>函数表达式在实际应用中还是很常见的，在web开发中友个常用的模式是基于对某种特性的测试来伪装函数定义，从而达到性能优化的目的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该代码来自Garrett Smith的APE Javascript library库(http://dhtmlkitchen.com/ape/) </span></div><div class="line"><span class="keyword">var</span> contains = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> docEl.compareDocumentPosition != <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> (el.compareDocumentPosition(b) &amp; <span class="number">16</span>) !== <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> docEl.contains != <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> el !== b &amp;&amp; el.contains(b);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (el === b) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (el != b &amp;&amp; (b = b.parentNode) != <span class="literal">null</span>);</div><div class="line">    <span class="keyword">return</span> el === b;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>提到命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> foo; <span class="comment">// foo是在内部作用域内有效</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// foo在外部用于是不可见的</span></div><div class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "undefined"</span></div><div class="line">f(); <span class="comment">// "function"</span></div></pre></td></tr></table></figure><p>既然，这么要求，那命名函数表达式到底有啥用啊？为啥要取名？</p><p>正如我们开头所说：给它一个名字就是可以让调试过程更方便，因为在调试的时候，如果在调用栈中的每个项都有自己的名字来描述，那么调试过程就太爽了，感受不一样嘛。</p><h1 id="调试器中的函数名"><a href="#调试器中的函数名" class="headerlink" title="调试器中的函数名"></a>调试器中的函数名</h1><p>如果一个函数有名字，那调试器在调试的时候会将它的名字显示在调用的栈上。有些调试器（Firebug）有时候还会为你们函数取名并显示，让他们和那些应用该函数的便利具有相同的角色，可是通常情况下，这些调试器只安装简单的规则来取名，所以说没有太大价格，我们来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> bar();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> baz();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">debugger</span>;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">// 这里我们使用了3个带名字的函数声明</span></div><div class="line"><span class="comment">// 所以当调试器走到debugger语句的时候，Firebug的调用栈上看起来非常清晰明了 </span></div><div class="line"><span class="comment">// 因为很明白地显示了名称</span></div><div class="line">baz</div><div class="line">bar</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>通过查看调用栈的信息，我们可以很明了地知道foo调用了bar, bar又调用了baz（而foo本身有在expr_test.html文档的全局作用域内被调用），不过，还有一个比较爽地方，就是刚才说的Firebug为匿名表达式取名的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> bar();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> baz();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">debugger</span>;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">// Call stack</span></div><div class="line">baz</div><div class="line">bar() <span class="comment">//看到了么？ </span></div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>然后，当函数表达式稍微复杂一些的时候，调试器就不那么聪明了，我们只能在调用栈中看到问号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> bar();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">debugger</span>;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">// Call stack</span></div><div class="line">baz</div><div class="line">(?)() <span class="comment">// 这里可是问号哦</span></div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>另外，当把函数赋值给多个变量的时候，也会出现令人郁闷的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> baz();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">debugger</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> baz = bar;</div><div class="line">bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">  alert(<span class="string">'spoofed'</span>);</div><div class="line">&#125;;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">// Call stack:</span></div><div class="line">bar()</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>这时候，调用栈显示的是foo调用了bar，但实际上并非如此，之所以有这种问题，是因为baz和另外一个包含alert(‘spoofed’)的函数做了引用交换所导致的。</p><p>归根结底，只有给函数表达式取个名字，才是最委托的办法，也就是使用<strong>命名函数表达式</strong>。我们来使用带名字的表达式来重写上面的例子（注意立即调用的表达式块里返回的2个函数的名字都是bar）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> bar();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">debugger</span>;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">// 又再次看到了清晰的调用栈信息了耶!</span></div><div class="line">baz</div><div class="line">bar</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure><p>OK，又学了一招吧？不过在高兴之前，我们再看看不同寻常的JScript吧。</p><h1 id="JScript的Bug"><a href="#JScript的Bug" class="headerlink" title="JScript的Bug"></a>JScript的Bug</h1><p>比较恶的是，IE的ECMAScript实现JScript严重混淆了命名函数表达式，搞得现很多人都出来反对命名函数表达式，而且即便是最新的一版（IE8中使用的5.8版）仍然存在下列问题。<br>下面我们就来看看IE在实现中究竟犯了那些错误，俗话说知已知彼，才能百战不殆。我们来看看如下几个例子：<br><strong>例1：函数表达式的标示符泄露到外部作用域</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">typeof</span> g; <span class="comment">// "function"</span></div></pre></td></tr></table></figure><p>上面我们说过，命名函数表达式的标示符在外部作用域是无效的，但JScript明显是违反了这一规范，上面例子中的标示符g被解析成函数对象，这就乱了套了，很多难以发现的bug都是因为这个原因导致的。</p><p><em>注：IE9貌似已经修复了这个问题</em><br><strong>例2：将命名函数表达式同时当作函数声明和函数表达式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> g; <span class="comment">// "function"</span></div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div></pre></td></tr></table></figure><p>特性环境下，函数声明会优先于任何表达式被解析，上面的例子展示的是JScript实际上是把命名函数表达式当成函数声明了，因为它在实际声明之前就解析了g。<br>这个例子引出了下一个例子。<br><strong>例3：命名函数表达式会创建两个截然不同的函数对象！</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">f === g; <span class="comment">// false</span></div><div class="line"></div><div class="line">f.expando = <span class="string">'foo'</span>;</div><div class="line">g.expando; <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>看到这里，大家会觉得问题严重了，因为修改任何一个对象，另外一个没有什么改变，这太恶了。通过这个例子可以发现，创建2个不同的对象，也就是说如果你想修改f的属性中保存某个信息，然后想当然地通过引用相同对象的g的同名属性来使用，那问题就大了，因为根本就不可能。<br>再来看一个稍微复杂的例子：</p><p><strong>例4：仅仅顺序解析函数声明而忽略条件语句块</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">  f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">g(); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p>这个bug查找就难多了，但导致bug的原因却非常简单。首先，g被当作函数声明解析，由于JScript中的函数声明不受条件代码块约束，所以在这个很恶的if分支中，g被当作另一个函数function g(){ return 2 }，也就是又被声明了一次。然后，所有“常规的”表达式被求值，而此时f被赋予了另一个新创建的对象的引用。由于在对表达式求值的时候，永远不会进入“这个可恶if分支，因此f就会继续引用第一个函数function g(){ return 1 }。分析到这里，问题就很清楚了：假如你不够细心，在f中调用了g，那么将会调用一个毫不相干的g函数对象。</p><p>你可能会文，将不同的对象和arguments.callee相比较时，有什么样的区别呢？我们来看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="keyword">return</span> [</div><div class="line">     <span class="built_in">arguments</span>.callee == f,</div><div class="line">     <span class="built_in">arguments</span>.callee == g</div><div class="line">   ];</div><div class="line"> &#125;;</div><div class="line"> f(); <span class="comment">// [true, false]</span></div><div class="line"> g(); <span class="comment">// [false, true]</span></div></pre></td></tr></table></figure><p>可以看到，arguments.callee的引用一直是被调用的函数，实际上这也是好事，稍后会解释。</p><p>还有一个有趣的例子，那就是在不包含声明的赋值语句中使用命名函数表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>按照代码的分析，我们原本是想创建一个全局属性f（注意不要和一般的匿名函数混淆了，里面用的是带名字的生命），JScript在这里捣乱了一把，首先他把表达式当成函数声明解析了，所以左边的f被声明为局部变量了（和一般的匿名函数里的声明一样），然后在函数执行的时候，f已经是定义过的了，右边的function f(){}则直接就赋值给局部变量f了，所以f根本就不是全局属性。</p><p>了解了JScript这么变态以后，我们就要及时预防这些问题了，首先<strong>防范标识符泄漏带外部作用域</strong>，其次，应该永远<strong>不引用被用作函数名称的标识符</strong>；还记得前面例子中那个讨人厌的标识符g吗？——如果我们能够当g不存在，可以避免多少不必要的麻烦哪。因此，关键就在于始终要通过f或者arguments.callee来引用函数。如果你使用了命名函数表达式，那么应该只在调试的时候利用那个名字。最后，还要记住一点，一定要把<strong>命名函数表达式声明期间错误创建的函数清理干净</strong>。</p><p>对于，上面最后一点，我们还得再解释一下。</p><h1 id="JScript的内存管理"><a href="#JScript的内存管理" class="headerlink" title="JScript的内存管理"></a>JScript的内存管理</h1><p>知道了这些不符合规范的代码解析bug以后，我们如果用它的话，就会发现内存方面其实是有问题的，来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>我们知道，这个匿名函数调用返回的函数（带有标识符g的函数），然后赋值给了外部的f。我们也知道，命名函数表达式会导致产生多余的函数对象，而该对象与返回的函数对象不是一回事。所以这个多余的g函数就死在了返回函数的闭包中了，因此内存问题就出现了。这是因为if语句内部的函数与g是在同一个作用域中被声明的。这种情况下 ，除非我们显式断开对g函数的引用，否则它一直占着内存不放。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> f, g;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 设置g为null以后它就不会再占内存了</span></div><div class="line">  g = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">return</span> f;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>通过设置g为null，垃圾回收器就把g引用的那个隐式函数给回收掉了，为了验证我们的代码，我们来做一些测试，以确保我们的内存被回收了。</p><p>测试</p><p>测试很简单，就是命名函数表达式创建10000个函数，然后把它们保存在一个数组中。等一会儿以后再看这些函数到底占用了多少内存。然后，再断开这些引用并重复这一过程。下面是测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> f;</div><div class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">      f = <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'standard'</span>;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">      f = <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'alternative'</span>;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      f = <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'fallback'</span>;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// var F = null;</span></div><div class="line">    <span class="keyword">return</span> f;</div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [ ];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</div><div class="line">  arr[i] = createFn();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过运行在Windows XP SP2中的任务管理器可以看到如下结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">IE6:</div><div class="line"></div><div class="line">  without <span class="string">`null`</span>:   <span class="number">7.6</span>K -&gt; <span class="number">20.3</span>K</div><div class="line">  <span class="keyword">with</span> <span class="string">`null`</span>:      <span class="number">7.6</span>K -&gt; <span class="number">18</span>K</div><div class="line"></div><div class="line">IE7:</div><div class="line"></div><div class="line">  without <span class="string">`null`</span>:   <span class="number">14</span>K -&gt; <span class="number">29.7</span>K</div><div class="line">  <span class="keyword">with</span> <span class="string">`null`</span>:      <span class="number">14</span>K -&gt; <span class="number">27</span>K</div></pre></td></tr></table></figure><p>如我们所料，显示断开引用可以释放内存，但是释放的内存不是很多，10000个函数对象才释放大约3M的内存，这对一些小型脚本不算什么，但对于大型程序，或者长时间运行在低内存的设备里的时候，这是非常有必要的。</p><p>关于在Safari 2.x中JS的解析也有一些bug，但介于版本比较低，所以我们在这里就不介绍了，大家如果想看的话，请仔细查看英文资料。</p><h1 id="SpiderMonkey的怪癖"><a href="#SpiderMonkey的怪癖" class="headerlink" title="SpiderMonkey的怪癖"></a>SpiderMonkey的怪癖</h1><p>大家都知道，命名函数表达式的标识符只在函数的局部作用域中有效。但包含这个标识符的局部作用域又是什么样子的吗？其实非常简单。在命名函数表达式被求值时，会<strong>创建一个特殊的对象</strong>，该对象的唯一目的就是保存一个属性，而这个属性的名字对应着函数标识符，属性的值对应着那个函数。这个对象会被注入到当前作用域链的前端。然后，被“扩展”的作用域链又被用于初始化函数。</p><p>在这里，有一点十分有意思，那就是ECMA-262定义这个（保存函数标识符的）“特殊”对象的方式。标准说<strong>“像调用new Object()表达式那样”</strong>创建这个对象。如果从字面上来理解这句话，那么这个对象就应该是全局<code>Object</code>的一个实例。然而，只有一个实现是按照标准字面上的要求这么做的，这个实现就是SpiderMonkey。因此，在SpiderMonkey中，扩展<code>Object.prototype</code>有可能会干扰函数的局部作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="string">'outer'</span>;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> x = <span class="string">'inner'</span>;</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line">    函数foo的作用域链中有一个特殊的对象——用于保存函数的标识符。这个特殊的对象实际上就是&#123; foo: &lt;function object&gt; &#125;。</div><div class="line">    当通过作用域链解析x时，首先解析的是foo的局部环境。如果没有找到x，则继续搜索作用域链中的下一个对象。下一个对象</div><div class="line">    就是保存函数标识符的那个对象——&#123; foo: &lt;function object&gt; &#125;，由于该对象继承自Object.prototype，所以在此可以找到x。</div><div class="line">    而这个x的值也就是Object.prototype.x的值（outer）。结果，外部函数的作用域（包含x = 'inner'的作用域）就不会被解析了。</div><div class="line">  */</div><div class="line">  </div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    </div><div class="line">    alert(x); <span class="comment">// 提示框中显示：outer</span></div><div class="line">  </div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>不过，更高版本的SpiderMonkey改变了上述行为，原因可能是认为那是一个安全漏洞。也就是说，“特殊”对象不再继承Object.prototype了。不过，如果你使用Firefox 3或者更低版本，还可以“重温”这种行为。<br>另一个把内部对象实现为全局Object对象的是黑莓（Blackberry）浏览器。目前，它的<em>活动对象</em>（Activation Object）仍然继承Object.prototype。可是，ECMA-262并没有说<em>活动对象</em>也要“像调用new Object()表达式那样”来创建（或者说像创建保存NFE标识符的对象一样创建）。 人家规范只说了<em>活动对象</em>是规范中的一种机制。<br>那我们就来看看黑莓里都发生了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="string">'outer'</span>;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> x = <span class="string">'inner'</span>;</div><div class="line">  </div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">    在沿着作用域链解析x的过程中，首先会搜索局部函数的活动对象。当然，在该对象中找不到x。</div><div class="line">    可是，由于活动对象继承自Object.prototype，因此搜索x的下一个目标就是Object.prototype；而</div><div class="line">    Object.prototype中又确实有x的定义。结果，x的值就被解析为——outer。跟前面的例子差不多，</div><div class="line">    包含x = 'inner'的外部函数的作用域（活动对象）就不会被解析了。</div><div class="line">    */</div><div class="line">    </div><div class="line">    alert(x); <span class="comment">// 显示：outer</span></div><div class="line">    </div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>不过神奇的还是，函数中的变量甚至会与已有的<code>Object.prototype</code>的成员发生冲突，来看看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = function()&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</div><div class="line">  </div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">constructor</span>(); // 求值结果是&#123;&#125;（即相当于调用了<span class="built_in">Object</span>.prototype.constructor()）而不是<span class="number">1</span></div><div class="line">    </div><div class="line">    <span class="keyword">constructor</span> === Object.prototype.<span class="keyword">constructor</span>; // true</div><div class="line">    toString === Object.prototype.toString; // true</div><div class="line">    </div><div class="line">    // ……</div><div class="line">    </div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>要避免这个问题，要避免使用Object.prototype里的属性名称，如toString, valueOf, hasOwnProperty等等。</p><p>JScript解决方案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 声明要引用函数的变量</span></div><div class="line">  <span class="keyword">var</span> f;</div><div class="line"></div><div class="line">  <span class="comment">// 有条件地创建命名函数</span></div><div class="line">  <span class="comment">// 并将其引用赋值给f</span></div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    f = <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">    f = <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    f = <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 声明一个与函数名（标识符）对应的变量，并赋值为null</span></div><div class="line">  <span class="comment">// 这实际上是给相应标识符引用的函数对象作了一个标记，</span></div><div class="line">  <span class="comment">// 以便垃圾回收器知道可以回收它了</span></div><div class="line">  <span class="keyword">var</span> F = <span class="literal">null</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 返回根据条件定义的函数</span></div><div class="line">  <span class="keyword">return</span> f;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>最后我们给出一个应用上述技术的应用实例，这是一个跨浏览器的addEvent函数代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1) 使用独立的作用域包含声明</span></div><div class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</div><div class="line"></div><div class="line">  <span class="comment">// 2) 声明要引用函数的变量</span></div><div class="line">  <span class="keyword">var</span> fn;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (docEl.addEventListener) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 3) 有意给函数一个描述性的标识符</span></div><div class="line">    fn = <span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, eventName, callback</span>) </span>&#123;</div><div class="line">      element.addEventListener(eventName, callback, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (docEl.attachEvent) &#123;</div><div class="line">    fn = <span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, eventName, callback</span>) </span>&#123;</div><div class="line">      element.attachEvent(<span class="string">'on'</span> + eventName, callback);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    fn = <span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, eventName, callback</span>) </span>&#123;</div><div class="line">      element[<span class="string">'on'</span> + eventName] = callback;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 4) 清除由JScript创建的addEvent函数</span></div><div class="line">  <span class="comment">//    一定要保证在赋值前使用var关键字</span></div><div class="line">  <span class="comment">//    除非函数顶部已经声明了addEvent</span></div><div class="line">  <span class="keyword">var</span> addEvent = <span class="literal">null</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 5) 最后返回由fn引用的函数</span></div><div class="line">  <span class="keyword">return</span> fn;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><h1 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h1><p>其实，如果我们不想要这个描述性名字的话，我们就可以用最简单的形式来做，也就是在函数内部声明一个函数（而不是函数表达式），然后返回该函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hasClassName = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 定义私有变量</span></div><div class="line">  <span class="keyword">var</span> cache = &#123; &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 使用函数声明</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hasClassName</span>(<span class="params">element, className</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _className = <span class="string">'(?:^|\\s+)'</span> + className + <span class="string">'(?:\\s+|$)'</span>;</div><div class="line">    <span class="keyword">var</span> re = cache[_className] || (cache[_className] = <span class="keyword">new</span> <span class="built_in">RegExp</span>(_className));</div><div class="line">    <span class="keyword">return</span> re.test(element.className);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 返回函数</span></div><div class="line">  <span class="keyword">return</span> hasClassName;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>显然，当存在多个分支函数定义时，这个方案就不行了。不过有种模式貌似可以实现：那就是提前使用函数声明来定义所有函数，并分别为这些函数指定不同的标识符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addEventListener</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">attachEvent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addEventAsProperty</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">/* ... */</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> docEl.addEventListener != <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> addEventListener;</div><div class="line">  &#125;</div><div class="line">  elseif (<span class="keyword">typeof</span> docEl.attachEvent != <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> attachEvent;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> addEventAsProperty;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>虽然这个方案很优雅，但也不是没有缺点。第一，由于使用不同的标识符，导致丧失了命名的一致性。且不说这样好还是坏，最起码它不够清晰。有人喜欢使用相同的名字，但也有人根本不在乎字眼上的差别。可毕竟，不同的名字会让人联想到所用的不同实现。例如，在调试器中看到attachEvent，我们就知 道<code>addEvent</code>是基于<code>attachEvent</code>的实现。当 然，基于实现来命名的方式也不一定都行得通。假如我们要提供一个API，并按照这种方式把函数命名为inner。那么API用户的很容易就会被相应实现的 细节搞得晕头转向。</p><p>要解决这个问题，当然就得想一套更合理的命名方案了。但关键是不要再额外制造麻烦。我现在能想起来的方案大概有如下几个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'addEvent'</span>, <span class="string">'altAddEvent'</span>, <span class="string">'fallbackAddEvent'</span></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="string">'addEvent'</span>, <span class="string">'addEvent2'</span>, <span class="string">'addEvent3'</span></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="string">'addEvent_addEventListener'</span>, <span class="string">'addEvent_attachEvent'</span>, <span class="string">'addEvent_asProperty'</span></div></pre></td></tr></table></figure><p>另外，这种模式还存在一个小问题，即增加内存占用。提前创建N个不同名字的函数，等于有N-1的函数是用不到的。具体来讲，如果<code>document.documentElement</code> 中包含<code>attachEvent</code>，那么<code>addEventListener</code> 和<code>addEventAsProperty</code>则根本就用不着了。可是，他们都占着内存哪；而且，这些内存将永远都得不到释放，原因跟JScript臭哄哄的命名表达式相同——这两个函数都被“截留”在返回的那个函数的闭包中了。</p><p>不过，增加内存占用这个问题确实没什么大不了的。如果某个库——例如Prototype.js——采用了这种模式，无非也就是多创建一两百个函数而已。只要不是（在运行时）重复地创建这些函数，而是只（在加载时）创建一次，那么就没有什么好担心的。</p><h1 id="WebKit的displayName"><a href="#WebKit的displayName" class="headerlink" title="WebKit的displayName"></a>WebKit的displayName</h1><p>WebKit团队在这个问题采取了有点儿另类的策略。介于匿名和命名函数如此之差的表现力，WebKit引入了一个“特殊的”<code>displayName</code>属性（本质上是一个字符串），如果开发人员为函数的这个属性赋值，则该属性的值将在调试器或性能分析器中被显示在函数“名称”的位置上。<a href="http://www.alertdebugging.com/2009/04/29/building-a-better-javascript-profiler-with-webkit/" target="_blank" rel="noopener">Francisco Tolmasky详细地解释了这个策略的原理和实现</a>。</p><h1 id="未来考虑"><a href="#未来考虑" class="headerlink" title="未来考虑"></a>未来考虑</h1><p>将来的ECMAScript-262第5版（目前还是草案）会引入所谓的<strong>严格模式（strict mode）</strong>。开启严格模式的实现会禁用语言中的那些不稳定、不可靠和不安全的特性。据说出于安全方面的考虑，<code>arguments.callee</code>属性将在严格模式下被“封杀”。因此，在处于严格模式时，访问<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```JavaScript</div><div class="line">  // 此前，你可能会使用arguments.callee</div><div class="line">  (function(x) &#123;</div><div class="line">    if (x &lt;= 1) return 1;</div><div class="line">    return x * arguments.callee(x - 1);</div><div class="line">  &#125;)(10);</div><div class="line">  </div><div class="line">  // 但在严格模式下，有可能就要使用命名函数表达式</div><div class="line">  (function factorial(x) &#123;</div><div class="line">    if (x &lt;= 1) return 1;</div><div class="line">    return x * factorial(x - 1);</div><div class="line">  &#125;)(10);</div><div class="line">  </div><div class="line">  // 要么就退一步，使用没有那么灵活的函数声明</div><div class="line">  function factorial(x) &#123;</div><div class="line">    if (x &lt;= 1) return 1;</div><div class="line">    return x * factorial(x - 1);</div><div class="line">  &#125;</div><div class="line">  factorial(10);</div></pre></td></tr></table></figure></p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><strong>理查德· 康福德（Richard Cornford）</strong>，是他率先<a href="http://groups.google.com/group/comp.lang.javascript/msg/5b508b03b004bce8" target="_blank" rel="noopener">解释了JScript中命名函数表达式所存在的bug</a>。理查德解释了我在这篇文章中提及的大多数bug，所以我强烈建议大家去看看他的解释。我还要感谢<strong>Yann-Erwan Perio</strong>和<strong>道格拉斯·克劳克佛德（Douglas Crockford）</strong>，他们早在2003年就在<a href="http://groups.google.com/group/comp.lang.javascript/msg/03d53d114d176323" target="_blank" rel="noopener">comp.lang.javascript论坛中提及并讨论NFE问题了</a>。</p><p><strong>约翰-戴维·道尔顿（John-David Dalton）</strong>对“最终解决方案”提出了很好的建议。</p><p><strong>托比·兰吉</strong>的点子被我用在了“替代方案”中。</p><p><strong>盖瑞特·史密斯（Garrett Smith）</strong>和<strong>德米特里·苏斯尼科（Dmitry Soshnikov）</strong>对本文的多方面作出了补充和修正。</p><p>英文原文：<a href="http://kangax.github.com/nfe/" target="_blank" rel="noopener">http://kangax.github.com/nfe/</a></p><p>参考译文：<a href="http://www.cn-cuckoo.com/main/wp-content/uploads/2009/12/named-function-expressions-demystified.html#jscript-memory-management" target="_blank" rel="noopener">连接访问</a> (SpiderMonkey的怪癖之后的章节参考该文)</p><h1 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h1><p>本文已同步至目录索引：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">深入理解JavaScript系列</a></p><p>深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2011-12-29 09:02 by 汤姆大叔&lt;/p&gt;
&lt;p&gt;原地址：&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.maksim.website/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JavaScript系列1、编写高质量JavaScript代码的基本要点</title>
    <link href="http://www.maksim.website/2018/03/09/1/"/>
    <id>http://www.maksim.website/2018/03/09/1/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-04-07T09:39:32.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2011-12-28 23:00 by 汤姆大叔   原地址：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html</a></p></blockquote><p>才华横溢的<a href="http://www.phpied.com/" target="_blank" rel="noopener">Stoyan Stefanov</a>，在他写的由<a href="http://oreilly.com/" target="_blank" rel="noopener">O’Reilly</a>初版的新书<a href="http://amzn.to/93szK7" target="_blank" rel="noopener">《JavaScript Patterns》</a>(JavaScript模式)中，我想要是为我们的读者贡献其摘要，那会是件很美妙的事情。具体一点就是编写高质量JavaScript的一些要素，例如避免全局变量，使用单变量声明，在循环中预缓存length(长度)，遵循代码阅读，以及更多。</p><p>此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写API文档、执行同行评审以及运行JSLint。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码，这些代码在几个月或是几年之后再回过头看看也是会觉得很自豪的。</p><h1 id="书写可维护的代码-Writing-Maintainable-Code"><a href="#书写可维护的代码-Writing-Maintainable-Code" class="headerlink" title="书写可维护的代码(Writing Maintainable Code )"></a>书写可维护的代码(Writing Maintainable Code )</h1><p>软件bug的修复是昂贵的，并且随着时间的推移，这些bug的成本也会增加，尤其当这些bug潜伏并慢慢出现在已经发布的软件中时。当你发现bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要：</p><ul><li>花时间学习和理解这个问题</li><li>化时间是了解应该解决的问题代码</li></ul><p>还有问题，特别对于大的项目或是公司，修复bug的这位伙计不是写代码的那个人（且发现bug和修复bug的不是同一个人）。因此，必须降低理解代 码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。</p><p>另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。</p><p>你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如：</p><ul><li>bug是暴露的</li><li>新功能被添加到应用程序</li><li>程序在新的环境下工作（例如，市场上出现新想浏览器）</li><li>代码改变用途</li><li>代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言</li></ul><p>由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。</p><p>可维护的代码意味着：</p><ul><li>可读的</li><li>一致的</li><li>可预测的</li><li>看上去就像是同一个人写的</li><li>已记录</li></ul><h1 id="最小全局变量-Minimizing-Globals"><a href="#最小全局变量-Minimizing-Globals" class="headerlink" title="最小全局变量(Minimizing Globals)"></a>最小全局变量(Minimizing Globals)</h1><p>JavaScript通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。</p><p>每个JavaScript环境有一个全局对象，当你在任意的函数外面使用this的时候可以访问到。你创建的每一个全部变量都成了这个全局对象的属 性。在浏览器中，方便起见，该全局对象有个附加属性叫做window，此window(通常)指向该全局对象本身。下面的代码片段显示了如何在浏览器环境 中创建和访问的全局变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myglobal = &quot;hello&quot;; // 不推荐写法</div><div class="line">console.log(myglobal); // &quot;hello&quot;</div><div class="line">console.log(window.myglobal); // &quot;hello&quot;</div><div class="line">console.log(window[&quot;myglobal&quot;]); // &quot;hello&quot;</div><div class="line">console.log(this.myglobal); // &quot;hello&quot;</div></pre></td></tr></table></figure><h1 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h1><p>全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p><p>web页面包含不是该页面开发者所写的代码也是比较常见的，例如：</p><ul><li>第三方的JavaScript库</li><li>广告方的脚本代码</li><li>第三方用户跟踪和分析脚本代码</li><li>不同类型的小组件，标志和按钮</li></ul><p>比方说，该第三方脚本定义了一个全局变量，叫做result；接着，在你的函数中也定义一个名为result的全局变量。其结果就是后面的变量覆盖前面的，第三方脚本就一下子嗝屁啦！</p><p>因此，要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。在书中后面提到的一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。</p><p>由于JavaScript的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sum(x, y) &#123;</div><div class="line">   // 不推荐写法: 隐式全局变量 </div><div class="line">   result = x + y;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此段代码中的<code>result</code>没有声明。代码照样运作正常，但在调用函数后你最后的结果就多一个全局命名空间，这可以是一个问题的根源。</p><p>经验法则是始终使用var声明变量，正如改进版的sum()函数所演示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sum(x, y) &#123;</div><div class="line">   var result = x + y;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另一个创建隐式全局变量的反例就是使用任务链进行部分var声明。下面的片段中，<code>a</code>是本地变量但是<code>b</code>确实全局变量，这可能不是你希望发生的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 反例，勿使用 </div><div class="line">function foo() &#123;</div><div class="line">   var a = b = 0;</div><div class="line">   // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此现象发生的原因在于这个从右到左的赋值，首先，是赋值表达式<code>b = 0</code>，此情况下b是未声明的。这个表达式的返回值是0，然后这个0就分配给了通过var定义的这个局部变量a。换句话说，就好比你输入了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a = (b = 0);</div></pre></td></tr></table></figure><p>如果你已经准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">   var a, b;</div><div class="line">   // ... a = b = 0; // 两个均局部变量</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>然而，另外一个避免全局变量的原因是可移植性。如果你想你的代码在不同的环境下（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心大胆地使用，实际上对于有些情况并不适用）。</p></blockquote><h1 id="忘记var的副作用-Side-Effects-When-Forgetting-var"><a href="#忘记var的副作用-Side-Effects-When-Forgetting-var" class="headerlink" title="忘记var的副作用(Side Effects When Forgetting var)"></a>忘记var的副作用(Side Effects When Forgetting var)</h1><p>隐式全局变量和明确定义的全局变量间有些小的差异，就是通过<code>delete</code>操作符让变量未定义的能力。</p><ul><li>通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。</li><li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。</li></ul><p>这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过<code>delete</code>操作符删除的，而变量是不能的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 定义三个全局变量</div><div class="line">var global_var = 1;</div><div class="line">global_novar = 2; // 反面教材</div><div class="line">(function () &#123;</div><div class="line">   global_fromfunc = 3; // 反面教材</div><div class="line">&#125;());</div><div class="line"></div><div class="line">// 试图删除</div><div class="line">delete global_var; // false</div><div class="line">delete global_novar; // true</div><div class="line">delete global_fromfunc; // true</div><div class="line"></div><div class="line">// 测试该删除</div><div class="line">typeof global_var; // &quot;number&quot;</div><div class="line">typeof global_novar; // &quot;undefined&quot;</div><div class="line">typeof global_fromfunc; // &quot;undefined&quot;</div></pre></td></tr></table></figure><p>在ES5严格模式下，未声明的变量（如在前面的代码片段中的两个反面教材）工作时会抛出一个错误。</p><h1 id="访问全局对象-Access-to-the-Global-Object"><a href="#访问全局对象-Access-to-the-Global-Object" class="headerlink" title="访问全局对象(Access to the Global Object)"></a>访问全局对象(Access to the Global Object)</h1><p>在浏览器中，全局对象可以通过<code>window</code>属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的<code>window</code>标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var global = (function () &#123;</div><div class="line">   return this;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p>这种方法可以随时获得全局对象，因为其在函数中被当做函数调用了（不是通过<code>new</code>构造），<code>this</code>总 是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。</p><h1 id="单var形式（Single-var-Pattern）"><a href="#单var形式（Single-var-Pattern）" class="headerlink" title="单var形式（Single var Pattern）"></a>单var形式（Single var Pattern）</h1><p>在函数顶部使用单var语句是比较有用的一种形式，其好处在于：</p><ul><li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li><li>防止变量在定义之前使用的逻辑错误</li><li>帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的…</li><li>少代码（类型啊传值啊单线完成）</li></ul><p>单var形式长得就像下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">   var a = 1,</div><div class="line">       b = 2,</div><div class="line">       sum = a + b,</div><div class="line">       myobject = &#123;&#125;,</div><div class="line">       i,</div><div class="line">       j;</div><div class="line">   // function body...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>您可以使用一个var语句声明多个变量，并以逗号分隔。像这种初始化变量同时初始化值的做法是很好的。这样子可以防止逻辑错误（所有未初始化但声明的变量的初始值是<code>undefined</code>）和增加代码的可读性。在你看到代码后，你可以根据初始化的值知道这些变量大致的用途，例如是要当作对象呢还是当作整数来使。</p><p>你也可以在声明的时候做一些实际的工作，例如前面代码中的<code>sum = a + b</code>这个情况，另外一个例子就是当你使用DOM（文档对象模型）引用时，你可以使用单一的var把DOM引用一起指定为局部变量，就如下面代码所示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function updateElement() &#123;</div><div class="line">   var el = document.getElementById(&quot;result&quot;),</div><div class="line">       style = el.style;</div><div class="line">   // 使用el和style干点其他什么事...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars"><a href="#预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars" class="headerlink" title="预解析：var散布的问题(Hoisting: A Problem with Scattered vars)"></a>预解析：var散布的问题(Hoisting: A Problem with Scattered vars)</h1><p>JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 反例</div><div class="line">myname = &quot;global&quot;; // 全局变量</div><div class="line">function func() &#123;</div><div class="line">    alert(myname); // &quot;undefined&quot;</div><div class="line">    var myname = &quot;local&quot;;</div><div class="line">    alert(myname); // &quot;local&quot;</div><div class="line">&#125;</div><div class="line">func();</div></pre></td></tr></table></figure><p>在这个例子中，你可能会以为第一个alert弹出的是”global”，第二个弹出”loacl”。这种期许是可以理解的，因为在第一个alert 的时候，myname未声明，此时函数肯定很自然而然地看全局变量myname，但是，实际上并不是这么工作的。第一个alert会弹 出”undefined”是因为myname被当做了函数的局部变量（尽管是之后声明的），所有的变量声明当被悬置到函数的顶部了。因此，为了避免这种混 乱，最好是预先声明你想使用的全部变量。</p><p>上面的代码片段执行的行为可能就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myname = &quot;global&quot;; // global variable</div><div class="line">function func() &#123;</div><div class="line">   var myname; // 等同于 -&gt; var myname = undefined;</div><div class="line">   alert(myname); // &quot;undefined&quot;</div><div class="line">   myname = &quot;local&quot;;</div><div class="line">   alert(myname); // &quot;local&quot;&#125;</div><div class="line">func();</div></pre></td></tr></table></figure><blockquote><p>为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文 的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了”hoisting”这个概念， 这种ECMAScript标准中并未定义，通常用来描述行为。</p></blockquote><h1 id="for循环-for-Loops"><a href="#for循环-for-Loops" class="headerlink" title="for循环(for Loops)"></a>for循环(for Loops)</h1><p>在<code>for</code>循环中，你可以循环取得数组或是数组类似对象的值，譬如<code>arguments</code>和<code>HTMLCollection</code>对象。通常的循环形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 次佳的循环</div><div class="line">for (var i = 0; i &lt; myarray.length; i++) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当<code>myarray</code>不是数组，而是一个<code>HTMLCollection</code>对象的时候。</p><p><code>HTMLCollections</code>指的是DOM方法返回的对象，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.getElementsByName()</div><div class="line">document.getElementsByClassName()</div><div class="line">document.getElementsByTagName()</div></pre></td></tr></table></figure><p>还有其他一些<code>HTMLCollections</code>，这些是在DOM标准之前引进并且现在还在使用的。有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">document.images: 页面上所有的图片元素</div><div class="line">document.links : 所有a标签元素</div><div class="line">document.forms : 所有表单</div><div class="line">document.forms[0].elements : 页面上第一个表单中的所有域</div></pre></td></tr></table></figure><p>集合的麻烦在于它们实时查询基本文档（HTML页面）。这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。</p><p>这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i = 0, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，在这个循环过程中，你只检索了一次长度值。</p><p>在所有浏览器下，循环获取内容时缓存<code>HTMLCollections</code>的长度是更快的，2倍(Safari3)到190倍(IE7)之间。//zxx:此数据貌似很老，仅供参考</p><p>注意到，当你明确想要修改循环中的集合的时候（例如，添加更多的DOM元素），你可能更喜欢长度更新而不是常量。</p><p>伴随着单var形式，你可以把变量从循环中提出来，就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function looper() &#123;</div><div class="line">   var i = 0,</div><div class="line">        max,</div><div class="line">        myarray = [];</div><div class="line">   // ...</div><div class="line">   for (i = 0, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">      // 使用myarray[i]做点什么</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种形式具有一致性的好处，因为你坚持了单一var形式。不足在于当重构代码的时候，复制和粘贴整个循环有点困难。例如，你从一个函数复制了一个循环到另一个函数，你不得不去确定你能够把<code>i</code>和<code>max</code>引入新的函数（如果在这里没有用的话，很有可能你要从原函数中把它们删掉）。</p><p>最后一个需要对循环进行调整的是使用下面表达式之一来替换<code>i++</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i = i + 1</div><div class="line">i += 1</div></pre></td></tr></table></figure><p>JSLint提示您这样做，原因是<code>++</code>和<code>–-</code>促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手<br>如果你直接无视它，JSLint的<code>plusplus</code>选项会是<code>false</code>（默认是default）。</p><p>还有两种变化的形式，其又有了些微改进，因为：</p><ul><li>少了一个变量(无max)</li><li>向下数到0，通常更快，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//第一种变化的形式：</div><div class="line"></div><div class="line">var i, myarray = [];</div><div class="line">for (i = myarray.length; i–-;) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div><div class="line"></div><div class="line">//第二种使用while循环：</div><div class="line"></div><div class="line">var myarray = [],</div><div class="line">    i = myarray.length;</div><div class="line">while (i–-) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些小的改进只体现在性能上，此外JSLint会对使用i–-加以抱怨。</p><h1 id="for-in循环-for-in-Loops"><a href="#for-in循环-for-in-Loops" class="headerlink" title="for-in循环(for-in Loops)"></a>for-in循环(for-in Loops)</h1><p><code>for-in</code>循环应该用在非数组对象的遍历上，使用<code>for-in</code>进行循环也被称为“枚举”。</p><p>从技术上将，你可以使用<code>for-in</code>循环数组（因为JavaScript中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。</p><p>有个很重要的<code>hasOwnProperty()</code>方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。</p><p>思考下面一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 对象</div><div class="line">var man = &#123;</div><div class="line">   hands: 2,</div><div class="line">   legs: 2,</div><div class="line">   heads: 1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 在代码的某个地方</div><div class="line">// 一个方法添加给了所有对象</div><div class="line">if (typeof Object.prototype.clone === &quot;undefined&quot;) &#123;</div><div class="line">   Object.prototype.clone = function () &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个例子中，我们有一个使用对象字面量定义的名叫man的对象。在man定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举man的时候出现clone()方法，你需要应用<code>hasOwnProperty()</code>方法过滤原型属性。如果不做过滤，会导致clone()函数显示出来，在大多数情况下这是不希望出现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1.</div><div class="line">// for-in 循环</div><div class="line">for (var i in man) &#123;</div><div class="line">   if (man.hasOwnProperty(i)) &#123; // 过滤</div><div class="line">      console.log(i, &quot;:&quot;, man[i]);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">/* 控制台显示结果</div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line">*/</div><div class="line">// 2.</div><div class="line">// 反面例子:</div><div class="line">// for-in loop without checking hasOwnProperty()</div><div class="line">for (var i in man) &#123;</div><div class="line">   console.log(i, &quot;:&quot;, man[i]);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">控制台显示结果</div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line">clone: function()</div><div class="line">*/</div></pre></td></tr></table></figure><p>另外一种使用<code>hasOwnProperty()</code>的形式是取消Object.prototype上的方法。像是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i in man) &#123;</div><div class="line">   if (Object.prototype.hasOwnProperty.call(man, i)) &#123; // 过滤</div><div class="line">      console.log(i, &quot;:&quot;, man[i]);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其好处在于在man对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var i, hasOwn = Object.prototype.hasOwnProperty;</div><div class="line">for (i in man) &#123;</div><div class="line">    if (hasOwn.call(man, i)) &#123; // 过滤</div><div class="line">        console.log(i, &quot;:&quot;, man[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>严格来说，不使用<code>hasOwnProperty()</code>并不是一个错误。根据任务以及你对代码的自信程度，你可以跳过它以提高些许的循环速度。但是当你对当前对象内容（和其原型链）不确定的时候，添加<code>hasOwnProperty()</code>更加保险些。</p></blockquote><p>格式化的变化（通不过JSLint）会直接忽略掉花括号，把if语句放到同一行上。其优点在于循环语句读起来就像一个完整的想法（每个元素都有一个自己的属性”X”，使用”X”干点什么）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 警告： 通不过JSLint检测</div><div class="line">var i, hasOwn = Object.prototype.hasOwnProperty;</div><div class="line">for (i in man) if (hasOwn.call(man, i)) &#123; // 过滤</div><div class="line">    console.log(i, &quot;:&quot;, man[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes"><a href="#（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes" class="headerlink" title="（不）扩展内置原型((Not) Augmenting Built-in Prototypes)"></a>（不）扩展内置原型((Not) Augmenting Built-in Prototypes)</h1><p>扩增构造函数的prototype属性是个很强大的增加功能的方法，但有时候它太强大了。</p><p>增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript方法来持续不断地工作，而不是你另加的方法。</p><p>另外，属性添加到原型中，可能会导致不使用hasOwnProperty属性时在循环中显示出来，这会造成混乱。</p><p>因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外：</p><ul><li>可以预期将来的ECMAScript版本或是JavaScript实现将一直将此功能当作内置方法来实现。例如，你可以添加ECMAScript 5中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。</li><li>如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器JavaScript引擎部分。</li><li>你清楚地文档记录并和团队交流了变化。</li></ul><p>如果这三个条件得到满足，你可以给原型进行自定义的添加，形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (typeof Object.protoype.myMethod !== &quot;function&quot;) &#123;</div><div class="line">   Object.protoype.myMethod = function () &#123;</div><div class="line">      // 实现...</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="switch模式-switch-Pattern"><a href="#switch模式-switch-Pattern" class="headerlink" title="switch模式(switch Pattern)"></a>switch模式(switch Pattern)</h1><p>你可以通过类似下面形式的switch语句增强可读性和健壮性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var inspect_me = 0,</div><div class="line">    result = &apos;&apos;;</div><div class="line">switch (inspect_me) &#123;</div><div class="line">case 0:</div><div class="line">   result = &quot;zero&quot;;</div><div class="line">   break;</div><div class="line">case 1:</div><div class="line">   result = &quot;one&quot;;</div><div class="line">   break;</div><div class="line">default:</div><div class="line">   result = &quot;unknown&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个简单的例子中所遵循的风格约定如下：</p><ul><li>每个case和switch对齐（花括号缩进规则除外）</li><li>每个case中代码缩进</li><li>每个case以break清除结束</li><li>避免贯穿（故意忽略break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。</li><li>以default结束switch：确保总有健全的结果，即使无情况匹配。</li></ul><h1 id="避免隐式类型转换-Avoiding-Implied-Typecasting"><a href="#避免隐式类型转换-Avoiding-Implied-Typecasting" class="headerlink" title="避免隐式类型转换(Avoiding Implied Typecasting )"></a>避免隐式类型转换(Avoiding Implied Typecasting )</h1><p>JavaScript的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var zero = 0;</div><div class="line">if (zero === false) &#123;</div><div class="line">   // 不执行，因为zero为0, 而不是false</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反面示例</div><div class="line">if (zero == false) &#123;</div><div class="line">   // 执行了...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有另外一种思想观点认为==就足够了===是多余的。例如，当你使用typeof你就知道它会返回一个字符串，所以没有使用严格相等的理由。然而，JSLint要求严格相等，它使代码看上去更有一致性，可以降低代码阅读时的精力消耗。（“==是故意的还是一个疏漏？”）</p><h1 id="避免-Avoiding-eval"><a href="#避免-Avoiding-eval" class="headerlink" title="避免(Avoiding) eval()"></a>避免(Avoiding) eval()</h1><p>如果你现在的代码中使用了eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作JavaScript代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用eval()。如果代码是在运行时动态生成，有一个更好的方式不使用eval而达到同样的目 标。例如，用方括号表示法来访问动态属性会更好更简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">var property = &quot;name&quot;;</div><div class="line">alert(eval(&quot;obj.&quot; + property));</div><div class="line"></div><div class="line">// 更好的</div><div class="line">var property = &quot;name&quot;;</div><div class="line">alert(obj[property]);</div></pre></td></tr></table></figure><p>使用eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理Ajax请求得到的JSON 相应的时候。在这些情况下，最好使用JavaScript内置方法来解析JSON相应，以确保安全和有效。若浏览器不支持JSON.parse()，你可 以使用来自JSON.org的库。</p><p>同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。在幕后，JavaScript仍需要评估和执行你给程序传递的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">setTimeout(&quot;myFunc()&quot;, 1000);</div><div class="line">setTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);</div><div class="line"></div><div class="line">// 更好的</div><div class="line">setTimeout(myFunc, 1000);</div><div class="line">setTimeout(function () &#123;</div><div class="line">   myFunc(1, 2, 3);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure><p>使用新的Function()构造就类似于eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用eval()，你 可以考虑使用new Function()代替。有一个小的潜在好处，因为在新Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。</p><p>考虑下面这个例子，这里仅<code>un</code>作为全局变量污染了命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">console.log(typeof un);    // &quot;undefined&quot;</div><div class="line">console.log(typeof deux); // &quot;undefined&quot;</div><div class="line">console.log(typeof trois); // &quot;undefined&quot;</div><div class="line"></div><div class="line">var jsstring = &quot;var un = 1; console.log(un);&quot;;</div><div class="line">eval(jsstring); // logs &quot;1&quot;</div><div class="line"></div><div class="line">jsstring = &quot;var deux = 2; console.log(deux);&quot;;</div><div class="line">new Function(jsstring)(); // logs &quot;2&quot;</div><div class="line"></div><div class="line">jsstring = &quot;var trois = 3; console.log(trois);&quot;;</div><div class="line">(function () &#123;</div><div class="line">   eval(jsstring);</div><div class="line">&#125;()); // logs &quot;3&quot;</div><div class="line"></div><div class="line">console.log(typeof un); // number</div><div class="line">console.log(typeof deux); // &quot;undefined&quot;</div><div class="line">console.log(typeof trois); // &quot;undefined&quot;</div></pre></td></tr></table></figure><p>另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。在下面这个例子中，eval()可以访问和修改它外部作用域中的变量，这是 Function做不来的（注意到使用Function和new Function是相同的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">   var local = 1;</div><div class="line">   eval(&quot;local = 3; console.log(local)&quot;); // logs &quot;3&quot;</div><div class="line">   console.log(local); // logs &quot;3&quot;</div><div class="line">&#125;());</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line">   var local = 1;</div><div class="line">   Function(&quot;console.log(typeof local);&quot;)(); // logs undefined</div><div class="line">&#125;());</div></pre></td></tr></table></figure><h1 id="parseInt-下的数值转换-Number-Conversions-with-parseInt"><a href="#parseInt-下的数值转换-Number-Conversions-with-parseInt" class="headerlink" title="parseInt()下的数值转换(Number Conversions with parseInt())"></a>parseInt()下的数值转换(Number Conversions with parseInt())</h1><p>使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在ECMAScript 3中，开头为”0″的字符串被当做8进制处理了，但这已在ECMAScript 5中改变了。为了避免矛盾和意外的结果，总是指定基数参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var month = &quot;06&quot;,</div><div class="line">    year = &quot;09&quot;;</div><div class="line">month = parseInt(month, 10);</div><div class="line">year = parseInt(year, 10);</div></pre></td></tr></table></figure><p>此例中，如果你忽略了基数参数，如parseInt(year)，返回的值将是0，因为“09”被当做8进制（好比执行 parseInt( year, 8 )），而09在8进制中不是个有效数字。</p><p>替换方法是将字符串转换成数字，包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+&quot;08&quot; // 结果是 8</div><div class="line">Number(&quot;08&quot;) // 8</div></pre></td></tr></table></figure><p>这些通常快于parseInt()，因为parseInt()方法，顾名思意，不是简单地解析与转换。但是，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以NaN告终。</p><h1 id="编码规范-Coding-Conventions"><a href="#编码规范-Coding-Conventions" class="headerlink" title="编码规范(Coding Conventions)"></a>编码规范(Coding Conventions)</h1><p>建立和遵循编码规范是很重要的，这让你的代码保持一致性，可预测，更易于阅读和理解。一个新的开发者加入这个团队可以通读规范，理解其它团队成员书写的代码，更快上手干活。</p><p>许多激烈的争论发生会议上或是邮件列表上，问题往往针对某些代码规范的特定方面（例如代码缩进，是Tab制表符键还是space空格键）。如果你是 你组织中建议采用规范的，准备好面对各种反对的或是听起来不同但很强烈的观点。要记住，建立和坚定不移地遵循规范要比纠结于规范的细节重要的多。</p><h1 id="缩进-Indentation"><a href="#缩进-Indentation" class="headerlink" title="缩进(Indentation)"></a>缩进(Indentation)</h1><p>代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。</p><p>一些开发人员更喜欢用tab制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，使用四个空格缩进，这也是JSLint中默认的缩进。</p><p>什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do, while, for, for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function outer(a, b) &#123;</div><div class="line">    var c = 1,</div><div class="line">        d = 2,</div><div class="line">        inner;</div><div class="line">    if (a &gt; b) &#123;</div><div class="line">        inner = function () &#123;</div><div class="line">            return &#123;</div><div class="line">                r: c - d</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125; else &#123;</div><div class="line">        inner = function () &#123;</div><div class="line">            return &#123;</div><div class="line">                r: c + d</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return inner;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="花括号-Curly-Braces"><a href="#花括号-Curly-Braces" class="headerlink" title="花括号{}(Curly Braces)"></a>花括号{}(Curly Braces)</h1><p>花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在in或是for中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。</p><p>想象下你有一个只有一条语句的for循环，你可以忽略花括号，而没有解析的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 糟糕的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1)</div><div class="line">   alert(i);</div></pre></td></tr></table></figure><p>但是，如果，后来，主体循环部分又增加了行代码？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 糟糕的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1)</div><div class="line">   alert(i);</div><div class="line">   alert(i + &quot; is &quot; + (i % 2 ? &quot;odd&quot; : &quot;even&quot;));</div></pre></td></tr></table></figure><p>第二个alert已经在循环之外，缩进可能欺骗了你。为了长远打算，最好总是使用花括号，即时值一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 好的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1) &#123;</div><div class="line">   alert(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>if条件类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 坏</div><div class="line">if (true)</div><div class="line">   alert(1);</div><div class="line">else</div><div class="line">   alert(2);</div><div class="line"></div><div class="line">// 好</div><div class="line">if (true) &#123;</div><div class="line">   alert(1);</div><div class="line">&#125; else &#123;</div><div class="line">   alert(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="左花括号的位置-Opening-Brace-Location"><a href="#左花括号的位置-Opening-Brace-Location" class="headerlink" title="左花括号的位置(Opening Brace Location)"></a>左花括号的位置(Opening Brace Location)</h1><p>开发人员对于左大括号的位置有着不同的偏好——在同一行或是下一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">   alert(&quot;It&apos;s TRUE!&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//或</div><div class="line"></div><div class="line">if (true)</div><div class="line">&#123;</div><div class="line">   alert(&quot;It&apos;s TRUE!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript是不挑剔的，当你选择不使用分号结束一行代码时JavaScript会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 警告： 意外的返回值</div><div class="line">function func() &#123;</div><div class="line">   return</div><div class="line">  // 下面代码不执行</div><div class="line">   &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果你希望函数返回一个含有name属性的对象，你会惊讶。由于隐含分号，函数返回undefined。前面的代码等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 警告： 意外的返回值</div><div class="line">function func() &#123;</div><div class="line">   return undefined;</div><div class="line">  // 下面代码不执行</div><div class="line">   &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总之，总是使用花括号，并始终把在与之前的语句放在同一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">   return &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>关于分号注：就像使用花括号，你应该总是使用分号，即使他们可由JavaScript解析器隐式创建。这不仅促进更科学和更严格的代码，而且有助于解决存有疑惑的地方，就如前面的例子显示。</p></blockquote><h1 id="空格-White-Space"><a href="#空格-White-Space" class="headerlink" title="空格(White Space)"></a>空格(White Space)</h1><p>空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在JavaScript中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。</p><p>适合使用空格的地方包括：</p><ul><li>for循环分号分开后的的部分：如<code>for (var i = 0; i &lt; 10; i += 1) {...}</code></li><li>for循环中初始化的多变量(i和max)：<code>for (var i = 0, max = 10; i &lt; max; i += 1) {...}</code></li><li>分隔数组项的逗号的后面：<code>var a = [1, 2, 3];</code></li><li>对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：<code>var o = {a: 1, b: 2};</code></li><li>限定函数参数：<code>myFunc(a, b, c)</code></li><li>函数声明的花括号的前面：<code>function myFunc() {}</code></li><li>匿名函数表达式function的后面：<code>var myFunc = function () {};</code></li></ul><p>使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在<code>+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=</code>等前后都需要空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 宽松一致的间距</div><div class="line">// 使代码更易读</div><div class="line">// 使得更加“透气”</div><div class="line">var d = 0,</div><div class="line">    a = b + 1;</div><div class="line">if (a &amp;&amp; b &amp;&amp; c) &#123;</div><div class="line">    d = a % c;</div><div class="line">    a += d;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 反面例子</div><div class="line">// 缺失或间距不一</div><div class="line">// 使代码变得疑惑</div><div class="line">var d = 0,</div><div class="line">    a = b + 1;</div><div class="line">if (a&amp;&amp;b&amp;&amp;c) &#123;</div><div class="line">    d=a % c;</div><div class="line">    a+= d;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后需要注意的一个空格——花括号间距。最好使用空格：</p><ul><li>函数、if-else语句、循环、对象字面量的左花括号的前面({)</li><li>else或while之间的右花括号(})</li></ul><p>空格使用的一点不足就是增加了文件的大小，但是压缩无此问题。</p><blockquote><p>有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。</p></blockquote><h3 id="命名规范-Naming-Conventions"><a href="#命名规范-Naming-Conventions" class="headerlink" title="命名规范(Naming Conventions)"></a>命名规范(Naming Conventions)</h3><p>另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。</p><p>下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。</p><h3 id="以大写字母写构造函数-Capitalizing-Constructors"><a href="#以大写字母写构造函数-Capitalizing-Constructors" class="headerlink" title="以大写字母写构造函数(Capitalizing Constructors)"></a>以大写字母写构造函数(Capitalizing Constructors)</h3><p>JavaScript并没有类，但有new调用的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var adam = new Person();</div></pre></td></tr></table></figure><p>因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。</p><p>命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function MyConstructor() &#123;...&#125;</div><div class="line">function myFunction() &#123;...&#125;</div></pre></td></tr></table></figure><h1 id="分隔单词-Separating-Words"><a href="#分隔单词-Separating-Words" class="headerlink" title="分隔单词(Separating Words)"></a>分隔单词(Separating Words)</h1><p>当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。</p><p>对于构造函数，可以使用大驼峰式命名法(upper camel case)，如<code>MyConstructor()</code>。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是<code>myFunction(), calculateArea()</code>和<code>getFirstName()</code>。</p><p>要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，<code>first_name, favorite_bands,</code>和<code>old_company_name</code>，这种标记法帮你直观地区分函数和其他标识——原型和对象。</p><p>ECMAScript的属性和方法均使用Camel标记法，尽管多字的属性名称是罕见的（正则表达式对象的lastIndex和ignoreCase属性）。</p><h1 id="其它命名形式-Other-Naming-Patterns"><a href="#其它命名形式-Other-Naming-Patterns" class="headerlink" title="其它命名形式(Other Naming Patterns)"></a>其它命名形式(Other Naming Patterns)</h1><p>有时，开发人员使用命名规范来弥补或替代语言特性。</p><p>例如，JavaScript中没有定义常量的方法（尽管有些内置的像Number, MAX_VALUE），所以开发者都采用全部单词大写的规范来命名这个程序生命周期中都不会改变的变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 珍贵常数，只可远观</div><div class="line">var PI = 3.14,</div><div class="line">    MAX_WIDTH = 800;</div></pre></td></tr></table></figure><p>还有另外一个完全大写的惯例：全局变量名字全部大写。全部大写命名全局变量可以加强减小全局变量数量的实践，同时让它们易于区分。</p><p>另外一种使用规范来模拟功能的是私有成员。虽然可以在JavaScript中实现真正的私有，但是开发者发现仅仅使用一个下划线前缀来表示一个私有属性或方法会更容易些。考虑下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    getName: function () &#123;</div><div class="line">        return this._getFirst() + &apos; &apos; + this._getLast();</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    _getFirst: function () &#123;</div><div class="line">        // ...</div><div class="line">    &#125;,</div><div class="line">    _getLast: function () &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在此例中，<code>getName()</code>就表示公共方法，部分稳定的API。而<code>_getFirst()</code>和<code>_getLast()</code>则表明了私有。它们仍然是正常的公共方法，但是使用下划线前缀来警告person对象的使用者这些方法在下一个版本中时不能保证工作的，是不能直接使用的。注意，JSLint有些不鸟下划线前缀，除非你设置了noman选项为:false。</p><p>下面是一些常见的_private规范：</p><ul><li>使用尾下划线表示私有，如name<em>和getElements</em>()</li><li>使用一个下划线前缀表_protected（保护）属性，两个下划线前缀表示__private （私有）属性</li><li>Firefox中一些内置的变量属性不属于该语言的技术部分，使用两个前下划线和两个后下划线表示，如：<strong>proto</strong>和<strong>parent</strong>。</li></ul><h1 id="注释-Writing-Comments"><a href="#注释-Writing-Comments" class="headerlink" title="注释(Writing Comments)"></a>注释(Writing Comments)</h1><p>你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。</p><p>很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。</p><blockquote><p>最重要的习惯，然而也是最难遵守的，就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。</p></blockquote><h1 id="关于作者（About-the-Author-）"><a href="#关于作者（About-the-Author-）" class="headerlink" title="关于作者（About the Author ）"></a>关于作者（About the Author ）</h1><p>Stoyan Stefanov是Yahoo!web开发人员，多个O’Reilly书籍的作者、投稿者和技术评审。他经常在会议和他的博客<a href="http://www.zhangxinxu.com/wordpress/2010/10/%e7%bf%bb%e8%af%91-%e9%ab%98%e8%b4%a8%e9%87%8fjavascript%e4%bb%a3%e7%a0%81%e4%b9%a6%e5%86%99%e5%9f%ba%e6%9c%ac%e8%a6%81%e7%82%b9/www.phpied.com" target="_blank" rel="noopener">www.phpied.com</a>上发表web开发主题的演讲。Stoyan还是smush.it图片优化工具的创造者，YUI贡献者，雅虎性能优化工具YSlow 2.0的架构设计师。</p><p>本文转自：<a href="http://www.zhangxinxu.com/wordpress/?p=1173" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=1173</a></p><p>英文原文：<a href="http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/" target="_blank" rel="noopener">http://net.tutsplus.com/tutorials/javascript-ajax/the-essentials-of-writing-high-quality-javascript/</a></p><h1 id="同步与结束语"><a href="#同步与结束语" class="headerlink" title="同步与结束语"></a>同步与结束语</h1><p>本文已同步至目录索引：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="noopener">深入理解JavaScript系列</a></p><p>深入理解JavaScript系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2011-12-28 23:00 by 汤姆大叔   原地址：&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.maksim.website/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx的安装</title>
    <link href="http://www.maksim.website/2018/02/27/cjftk4kbd0038rlrdqrzxje1z/"/>
    <id>http://www.maksim.website/2018/02/27/cjftk4kbd0038rlrdqrzxje1z/</id>
    <published>2018-02-26T16:00:00.000Z</published>
    <updated>2018-04-03T14:53:43.414Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。</p><p>在安装 Nginx 时，我们可以通过以下两种方式进行安装：</p><ol><li>使用包管理器安装 Nginx</li><li>通过源代码安装 Nginx</li></ol><h2 id="使用包管理器安装-Nginx"><a href="#使用包管理器安装-Nginx" class="headerlink" title="使用包管理器安装 Nginx"></a>使用包管理器安装 Nginx</h2><p>使用包管理器安装 Nginx 的机会，是你使用的操作系统已经提供了 Nginx 的安装包。使用包管理器安装 Nginx 的方式很简单，只需要在终端输入：</p><p>Linux(基于 deb，如 Ubunut)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure><p> Linux（基于 rpm，如 CentOS)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>FreeBSD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pkg_install -r nginx</div></pre></td></tr></table></figure><p>通过上述命令，Nginx 将会安装到操作系统的标准位置下。如果使用操作系统的安装包安装 Nginx，那么通过上面的命令来安装是最佳方式。</p><p>Nginx 核心团队也提供了稳定的二进制版本，可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 页面下载可用版本。未发布 Nginx 安装包的系统用户（例如，CentOS），可以使用下面指导来安装预测试、预编译二进制版本。</p><p>通过创建下面的文件，在系统中添加 Nginx 仓库的 yum 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/yum.repos.d/nginx.repo</div><div class="line">[nginx]</div><div class="line">name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure><p>然后，听过执行如下命令来安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>也可以按照前面介绍的 URL 下载 nginx 发行版安装。</p><h2 id="从源代码安装-Nginx"><a href="#从源代码安装-Nginx" class="headerlink" title="从源代码安装 Nginx"></a>从源代码安装 Nginx</h2><p>Nginx 代码提供了两种独立的下载分支——开发版与稳定版。开发分支是一个正处于积极开发状态的版本。在这个版本中，会有一些新功能被集成到其中，在稳定版中是找不到这些功能的。当发布一个“开发”版时，它会经历同样的 QA 和作为稳定版本的一组类似测试功能。因此无论哪一个分支都一颗用于生产环境中，两者主要的不同，在于对第三方模块的支持。在开发板中，内部的 API 可能会发生改变，而稳定版则保持不变。因此，为了与第三方模块向下兼容，在稳定版中第三方模块都可以有效使用。</p><h3 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h3><p>为了从源代码编译 Nginx，系统需要满足某些必要条件，除了编译器外，如果想分别启用 SSL 支持和使用 rewrite 模块，那么还需要提供响应的 OpenSSL 与 PCRE（Perl Compatible Regular Expressions）库及开发头文件。rewrite 模块是默认安装的。如果你还没有 PCRE 库与开发头文件，你需要在配置阶段禁用 rewrite 模块。这依赖于系统，也有可能在系统中已经默认安装了这些必要条件。如果没有安装，则需要从其安装包安装或者从源码下载并且解压安装，在 Nginx 配置脚本中指定他们在系统中的安装位置。</p><p>如果在配置文件中使用了—with-\<library\>=\<path\>选项，那么 Nginx 会视图建立一个静态依赖库。如果你想让 Nginx 不依赖于系统的任何其他部分，或是想获得些 Nginx 的二进制额外性能，那么你可能会使用构建静态库的做法。如果你使用外部库功能只能从某一个版本起有效（例如，NPN[Next Protocol Negotiation]TLS扩展从 OpenSSL1.0.1版有效），那么你就不得不将其指定到特定版本解压后的源代码路径中。</path\></library\></p><p>根据自己的喜好，你可能会提供其他的、可选安装包。你可以为这些安装包提供支持。他们包括 MD5和 SHA-1以支持散列算法、zip 压缩库、libatomic 库。在 Nginx 中，很多地方法会用到散列库，例如为了计算 URI 散列进而计算缓存 key。</p><p>zlib 压缩裤被用来投递 gzip 压缩内容。如果 atomic_ops 库有效，那么 Nginx 会用它来实现自动内存更新操作，以实现高性能的内存锁定代码。</p><h3 id="从源代码编译"><a href="#从源代码编译" class="headerlink" title="从源代码编译"></a>从源代码编译</h3><p>读者可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载 Nginx，在该页面找到.tar.gz 或者.zip 格式的源代码分支，安装如下步骤将下载的安装包解压到一个临时目录中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir ~/bulid</div><div class="line"><span class="meta">$</span> cd ~/bulid &amp;&amp; tar xzf nginx-&lt;version-number&gt;.tar.gz</div></pre></td></tr></table></figure><p>使用下面命令配置 Nginx:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cd ~/bulid/nginx-&lt;version-number&gt; &amp;&amp; ./configure</div></pre></td></tr></table></figure><p>然后，使用下面命令进行编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> make &amp;&amp; sudo make install</div></pre></td></tr></table></figure><p>在编译自己的二进制 nginx 时，你会有很大的灵活性来包含你仅使用的功能。你已经指定使用哪个用户运行 Nginx 了吗?你要使用默认的 logfile 位置，以便不用在 Nginx 的配置文件明确地说明它们吗?表 1-1 所示是配置选项列表，通过它来帮助你设计出自己的 nginx 命令。这些选项对 Nginx 都是有效的，模块可以被独立激活。</p><table><thead><tr><th>选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td>–prefix=\<path\></path\></td><td style="text-align:left">Nginx 安装的根路径，所有其他的安装路径都要依赖于该选项</td></tr><tr><td>–sbin-path=\<path\></path\></td><td style="text-align:left">指定 Nginx 二进制文件的路径。如果没有指定，那么这个路径依赖于——prefix 选项</td></tr><tr><td>–conf-path=\<path\></path\></td><td style="text-align:left">如果在命令行没有指定配置文件，那么将会通过这里指定的路径，Nginx 将会去那里寻找它的配置文件</td></tr><tr><td>–error-log-path=\<path\></path\></td><td style="text-align:left">指定错误文件的路径，Nginx 会将其中写入错误日志文件，除非有其他配置</td></tr><tr><td>–pid-path=\<path\></path\></td><td style="text-align:left">指定的文件将会写入 Nginx master 进程的pid，通常在/var/run 下</td></tr><tr><td>–lock-path=\<path\></path\></td><td style="text-align:left">共享存储器互斥锁文件的路径</td></tr><tr><td>–user=\<user\></user\></td><td style="text-align:left">worker 进程运行的用户</td></tr><tr><td>–group=\<group\></group\></td><td style="text-align:left">worker 进程运行的组</td></tr><tr><td>–with-file-aio</td><td style="text-align:left">为 FreeBSD4.3+和 Linux2.6.22+系统启用异步 I/O</td></tr><tr><td>–with-debug</td><td style="text-align:left">这个选项用于启用调试日志。在生产环境中不推荐使用该选项。</td></tr></tbody></table><p>你可以使用优化编译，单但是如果使用包管理工具进行安装将无法获得这些优化，如下表：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–with-cc=\<path\></path\></td><td>如果想设置一个不再默认 Path 下的编译器</td></tr><tr><td>–with-cpp=\<path\></path\></td><td>设置 C 预处理器的响应路径</td></tr><tr><td>–with-cc-opt=\<options></options></td><td>指定必要的 include 文件路径，可能（-I\<path\>）指出，也可能是优化(-O4)并指定64位构建</path\></td></tr><tr><td>–with-ld-opt=\<options\></options\></td><td>包含连接器库的路径(-L\<path\>)和运行路径(-R\<path\>)</path\></path\></td></tr><tr><td>—with-cpu-opt=\<cpu\></cpu\></td><td>通过该选项为特定的 CPU 构建 Nginx</td></tr></tbody></table><h2 id="配置-SSL-支持"><a href="#配置-SSL-支持" class="headerlink" title="配置 SSL 支持"></a>配置 SSL 支持</h2><p>对于 TLS/SSL 协议，Nginx 使用 OpenSSL 项目。有关此开源工具包的更多信息，请访问 <a href="https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对" target="_blank" rel="noopener">https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对</a> SSL 的支持。如果使用不带–with-ssl 选项的–with-http_ssl_module 或者–with-mail_ssl_module，你正在使用执行了 configure 命令的、安装在计算机上的 OpenSSL 库。如果你想要针对特定版本的 OpenSSL 进行编译，请下载该分发包，将其解压缩到一个目录中，然后将该目录的路径指定为–with-openssl 的参数。使用–with-openssl-opt 选项为 OpenSSL本身指定额外的构建选项。</p><p>例如，为了使用具有优化椭圆曲线的 OpenSSL 来构建 Nginx，您将使用如下的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ./configure --with-http_ssl_module --with-openssl=$&#123;BUILD_DIR&#125;/openssl-1.0.1p --with-openssl-opt=enable-ec_nistp_64_gcc_128</div></pre></td></tr></table></figure><h2 id="查找并安装第三方模块"><a href="#查找并安装第三方模块" class="headerlink" title="查找并安装第三方模块"></a>查找并安装第三方模块</h2><p>由于有多个开源项目，所以在 Nginx 周围就会有一个活跃的开发社区。由于 Nginx 的模块化特性，这个社区能够开发和发布模块，从而为 Nginx 提供额外的功能。它们涵盖了广泛的应用，所以着手开发自己的模块之前应该看看有什么可用模块。</p><p>安装第三方模块的过程相当简单，步骤如下。</p><p>1.定位你想要使用的模块(在 <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 或者是 <a href="http://wiki.nginx.org/3rdPartyModules查找)。" target="_blank" rel="noopener">http://wiki.nginx.org/3rdPartyModules查找)。</a></p><p>2.下载该模块。</p><p>3.解压缩源代码安装包。</p><p>4.如果有 README 文件，那么阅读 README 文件，查看在安装中是否有依赖安装。</p><p>5.通过./configure–add-module=\<path\>选项配置使用该模块。</path\></p><p>这个过程会给你的 nginx 二进制文件与模块附加这个功能。</p><p>需要注意的是，很多第三方模块是实验性质的。因此，在将这些模块用于生产系统之前，首先要测试使用这些模块。另外请记住，Nginx 的开发版本中可能会有 API 的变化，会导致第三方模块出现问题。</p><h2 id="添加对-Lua-的支持"><a href="#添加对-Lua-的支持" class="headerlink" title="添加对 Lua 的支持"></a>添加对 Lua 的支持</h2><p>特别应该提到的是 ngx_lua 这个第三方模块，ngx_lua 模块提供了启用 Lua 的功能，而不是像 Perl 一样在配置时嵌入式脚本语言。该模块对于 perl 模块来说最大的优点就是它的无阻塞性，并与其他第三方模块紧密集成。对于它的安装说明的完整描述详见:<a href="https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过编译你自己的二进制文件，你可以定制 Nginx能够为你提供哪些功能。对于你来说，构建和安装软件应该不会陌生。所以，创造一个构建环境或者确保所有依赖关系都存在，这并不会花费你很多的时间。一个 Nginx 的安装应该是按照你的需要，能随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。</p><p>参考资料：</p><p>《精通 Nginx》第二版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。&lt;/p&gt;
&lt;p&gt;在安装 Nginx 时，我们可
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Pathogen安装VIM插件</title>
    <link href="http://www.maksim.website/2018/02/23/1/"/>
    <id>http://www.maksim.website/2018/02/23/1/</id>
    <published>2018-02-22T16:00:00.000Z</published>
    <updated>2018-04-09T10:30:21.932Z</updated>
    
    <content type="html"><![CDATA[<p>  pathogen的安装其实非常简单。git上有非常全面的介绍和文档，<a href="http://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">http://github.com/tpope/vim-pathogen</a>。简单的几条命令即可搞定pathogen的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p ~/.vim/autoload ~/.vim/bundle   </div><div class="line">curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</div></pre></td></tr></table></figure><p>也就是在 ~/.vim目录下（如果没有，则新建）新建目录autoload、bundle（插件会放在这个目录），然后将pathogen放在autoload目录下即可</p><p>安装完成之后，这时候，pathogen还没有生效，需要在~/.vimrc添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execute pathogen#infect()</div></pre></td></tr></table></figure><p>如果没有~/.vimrc则需要新建文件，并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">execute pathogen#infect()  </div><div class="line">syntax on  </div><div class="line">filetype plugin indent on</div></pre></td></tr></table></figure><p>完成之后，就可以使用pathogen管理vim插件了，只需要将插件放在~/.vim/bundle目录下即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  pathogen的安装其实非常简单。git上有非常全面的介绍和文档，&lt;a href=&quot;http://github.com/tpope/vim-pathogen&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/tpope
      
    
    </summary>
    
      <category term="工具" scheme="http://www.maksim.website/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>function与感叹号</title>
    <link href="http://www.maksim.website/2018/02/01/cjftk4kcb004urlrd1ms0jtr6/"/>
    <id>http://www.maksim.website/2018/02/01/cjftk4kcb004urlrd1ms0jtr6/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-04-03T14:53:43.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="function与感叹号"><a href="#function与感叹号" class="headerlink" title="function与感叹号"></a>function与感叹号</h1><p>最近有空可以让我静下心来看看各种代码，function与感叹号的频繁出现，让我回想起2个月前我回杭州最后参加团队会议的时候，<a href="http://weibo.com/exqy" target="_blank" rel="noopener">@西子剑影</a>抛出的一样的问题：<strong>如果在function之前加上感叹号 (!) 会怎么样</strong>？比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？</p><p>平时我们可能对添加括号来调用匿名函数的方式更为习惯：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>虽然上述两者括号的位置不同，不过效果完全一样。</p><p>那么，是什么好处使得为数不少的人对这种叹号的方式情有独钟？如果只是为了节约一个字符未免太没有必要了，这样算来即使一个100K的库恐怕也节省不了多少空间。既然不是空间，那么就是说也许还有时间上的考量，事实很难说清，文章的最后有提到性能。</p><p>回到核心问题，为什么能这么做？甚至更为核心的问题是，为什么必须这么做？</p><p>其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是<strong>让一个函数声明语句变成了一个表达式</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// SyntaxError: unexpected_token</span></div></pre></td></tr></table></figure><p>因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 <code>a</code>，就应该以 <code>a();</code> 的方式调用。</p><p>但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。</p><p>所以，<strong>任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别</strong>。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">10</span>&#125;();        <span class="comment">// undefined</span></div><div class="line"><span class="number">1</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;();        <span class="comment">// true</span></div><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;();        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些<strong>一元运算都是有效的</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// -1</span></div></pre></td></tr></table></figure><p>甚至下面这些关键字，都能很好的工作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// undefined</span></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// Object</span></div><div class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// undefined</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。</p><p>最后讨论下性能。我在jsperf上简单建立了一个测试：<a href="http://jsperf.com/js-funcion-expression-speed" target="_blank" rel="noopener">http://jsperf.com/js-funcion-expression-speed</a> ，可以用不同浏览器访问，运行测试查看结果。我也同时将结果罗列如下表所示（由于我比较穷，测试配置有点丢人不过那也没办法：奔腾双核1.4G，2G内存，win7企业版）：</p><table><thead><tr><th>Option</th><th>Code</th><th>Ops/sec</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Chrome 13</td><td>Firefox 6</td><td>IE9</td><td>Safari 5</td><td></td><td></td></tr><tr><td>!</td><td>!function(){;}()</td><td>3,773,196</td><td>10,975,198</td><td>572,694</td><td>2,810,197</td></tr><tr><td>+</td><td>+function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,812,238</td></tr><tr><td>-</td><td>-function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,864,155</td></tr><tr><td>~</td><td>~function(){;}()</td><td>3,551,136</td><td>3,651,652</td><td>572,694</td><td>1,876,002</td></tr><tr><td>(1)</td><td>(function(){;})()</td><td>3,914,953</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>(2)</td><td>(function(){;}())</td><td>4,075,201</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>void</td><td>void function(){;}()</td><td>4,030,756</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>new</td><td>new function(){;}()</td><td>619,606</td><td>299,100</td><td>407,104</td><td>816,903</td></tr><tr><td>delete</td><td>delete function(){;}()</td><td>4,816,225</td><td>12,135,960</td><td>572,694</td><td>2,693,524</td></tr><tr><td>=</td><td>var i = function(){;}()</td><td>4,984,774</td><td>12,135,960</td><td>565,982</td><td>2,602,630</td></tr><tr><td>&amp;&amp;</td><td>1 &amp;&amp; function(){;}()</td><td>5,307,200</td><td>4,393,486</td><td>572,694</td><td>2,565,645</td></tr><tr><td>\</td><td>\</td><td></td><td>0 \</td><td>\</td><td>function(){;}()</td><td>5,000,000</td><td>4,406,035</td><td>572,694</td><td>2,490,128</td></tr><tr><td>&amp;</td><td>1 &amp; function(){;}()</td><td>4,918,209</td><td>12,135,960</td><td>572,694</td><td>1,705,551</td></tr><tr><td>\</td><td></td><td>1 \</td><td>function(){;}()</td><td>4,859,802</td><td>12,135,960</td><td>572,694</td><td>1,612,372</td></tr><tr><td>^</td><td>1 ^ function(){;}()</td><td>4,654,916</td><td>12,135,960</td><td>572,694</td><td>1,579,778</td></tr><tr><td>,</td><td>1, function(){;}()</td><td>4,878,193</td><td>12,135,960</td><td>572,694</td><td>2,281,186</td></tr></tbody></table><p>可见不同的方式产生的结果并不相同，而且，差别很大，因浏览器而异。</p><p>但我们还是可以从中找出很多共性：<strong>new方法永远最慢</strong>——这也是理所当然的。其它方面很多差距其实不大，但有一点可以肯定的是，感叹号并非最为理想的选择。反观<strong>传统的括号，在测试里表现始终很快</strong>，在大多数情况下比感叹号更快——所以平时我们常用的方式毫无问题，甚至可以说是最优的。<strong>加减号在chrome表现惊人</strong>，而且在其他浏览器下也普遍很快，相比感叹号效果更好。</p><p>当然这只是个简单测试，不能说明问题。但有些结论是有意义的：括号和加减号最优。</p><p>但是为什么这么多开发者钟情于感叹号？我觉得这只是一个习惯问题，它们之间的优劣完全可以忽略。一旦习惯了一种代码风格，那么这种约定会使得程序从混乱变得可读。如果习惯了感叹号，我不得不承认，它比括号有更好的可读性。我不用在阅读时留意括号的匹配，也不用在编写时粗心遗忘——</p><p>当我也这么干然后嚷嚷着这居然又节省了一个字符而沾沾自喜的时候，却忘了自己仓皇翻出一本卷边的C语言教科书的窘迫和荒唐……任何人都有忘记的时候，当再捡起来的时候，捡起的就已经不单单是忘掉的东西了。</p><p>2011-10-31更新：如果你使用aptana，那么在使用（!+-）时要注意一点，它们会让aptana的解析失效，导致Outline窗口没有任何显示。但是就代码本身而言，其运行没有任何问题。</p><blockquote><p>本文转自扩葵中剑的博客</p><p>原文地址：<a href="https://swordair.com/function-and-exclamation-mark/" target="_blank" rel="noopener">https://swordair.com/function-and-exclamation-mark/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;function与感叹号&quot;&gt;&lt;a href=&quot;#function与感叹号&quot; class=&quot;headerlink&quot; title=&quot;function与感叹号&quot;&gt;&lt;/a&gt;function与感叹号&lt;/h1&gt;&lt;p&gt;最近有空可以让我静下心来看看各种代码，function与感叹
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.maksim.website/categories/javascript/"/>
    
    
  </entry>
  
</feed>
