<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maksim&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maksim.website/"/>
  <updated>2018-06-25T12:37:34.429Z</updated>
  <id>http://www.maksim.website/</id>
  
  <author>
    <name>Maksim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swoole 基础（一）：起步</title>
    <link href="http://www.maksim.website/2018/06/12/1/"/>
    <id>http://www.maksim.website/2018/06/12/1/</id>
    <published>2018-06-11T16:00:00.000Z</published>
    <updated>2018-06-25T12:37:34.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>Swoole 是使用纯 C 语言编写，提供了 PHP 语言的异步多线程服务器，异步 TCP/UDP 网络客户端，异步 MySQL，异步 Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询。 Swoole内置了Http/WebSocket服务器端/客户端、Http2.0服务器端。</p><p>除了异步 IO 的支持之外，Swoole 为 PHP 多进程的模式设计了多个并发数据结构和IPC通信机制，可以大大简化多进程并发编程的工作。其中包括了并发原子计数器，并发 HashTable，Channel，Lock，进程间通信IPC等丰富的功能特性。</p><p>Swoole2.0 支持了类似 Go 语言的协程，可以使用完全同步的代码实现异步程序。PHP 代码无需额外增加任何关键词，底层自动进行协程调度，实现异步。</p><p>Swoole 的官网是 <a href="http://www.swoole.com" target="_blank" rel="noopener">http://www.swoole.com</a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>移动互联网 API 服务器</li><li>物联网（IOT）</li><li>微服务（Micro Service）</li><li>高性能 Web 服务器</li><li>游戏服务器</li><li>在线聊天室</li></ul><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>安装扩展的方法有很多，那么我们为什么要学习编译安装呢，因为大公司基本上都是以编译进行安装。</p><p>在 PHP 内核书中也提到过，建议开发者以编译形式进行安装，这样可以根据业务要求进行定制安装，例如线程安全等功能，而且对 PHP 的运行速度也会有稍微提升。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Linux 环境下</li><li>PHP7  Swoole 2.1 redis</li><li>源码安装 PHP7、Swoole</li></ul><h2 id="获取-PHP-源代码"><a href="#获取-PHP-源代码" class="headerlink" title="获取 PHP 源代码"></a>获取 PHP 源代码</h2><p>我们可以到 PHP 官网下载，我们的生产环境都不会使用集成环境，比如 PHPStudy，WAMP，在生产环境我们都是使用编译安装 PHP 源代码。</p><p>我们最好选择最新的 PHP 版本，到本博文截止，最新的版本是7.2.6。</p><p>下载好后我们将其解压，然后按照如下步骤进行安装：</p><ol><li>configure</li><li>make</li><li>make install </li></ol><p>configure 可以对即将安装的软件进行配置与依赖检测，在这里需要注意，编译安装 PHP 需要用到 GCC、autoconfig，如果没有这两个依赖，请进行安装，configure 会给出提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/home/work/stduy/soft/php</div></pre></td></tr></table></figure><ul><li>–prefix 安装目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make </div><div class="line">make test //对编译结果进行测试</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make install</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /home/work/stduy/soft/php/bin</div><div class="line">./php -v</div></pre></td></tr></table></figure><p>我们可以看到PHP 的版本信息记大功搞成。</p><p>这样 PHP7.2.6 就已经安装完毕了。</p><p>但是每一次都要进入该目录是在是太麻烦了，我们可以直接修改系统的环境变量，也就是 profile。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo vim ~/.bash_profile</div><div class="line">alias /home/work/stduy/soft/php/bin/php</div><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure><h2 id="编译安装-Swoole"><a href="#编译安装-Swoole" class="headerlink" title="编译安装 Swoole"></a>编译安装 Swoole</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><ul><li>仅支持 <code>Linux</code>、<code>FreeBSD</code>、<code>MacOS</code> 三种操作系统</li><li>在<code>Windows</code>平台，可使用<code>CygWin</code>或<code>WSL(Windows Subsystem for Linux)</code></li><li><code>Linux</code> 内核版本 <code>2.3.32</code> 以上</li><li><code>gcc4.4</code> 以上版本或者<code>clang</code></li><li><code>4.x</code>版本起需要<code>gcc-4.8</code>或更高版本</li><li>编译为 <code>libswoole.so</code> 作为 <code>C/C++</code> 库时需要使用 <code>cmake-2.4</code> 或更高版本</li></ul><blockquote><p> 建议使用 <code>Ubuntu14</code>、<code>CentOS7</code> 或更高版本的操作系统</p></blockquote><h3 id="PHP版本依赖"><a href="#PHP版本依赖" class="headerlink" title="PHP版本依赖"></a>PHP版本依赖</h3><ul><li><code>Swoole-1.x</code>需要<code>PHP-5.3.10</code>或更高版本</li><li><code>Swoole-2.x</code>需要<code>PHP-7.0.0</code>或更高版本</li><li>依赖不<code>PHP</code>的<code>stream</code>，<code>sockets</code>，<code>pcntl</code>，<code>posix</code>，<code>sysvmsg</code>等扩展。<code>PHP</code>只需安装最基本的扩展即可</li></ul><h3 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h3><p>安装swoole前必须保证系统已经安装了下列软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">php-5.3.10 或更高版本</div><div class="line">gcc-4.4 或更高版本</div><div class="line">make</div><div class="line">autoconf</div><div class="line">pcre (centos系统可以执行命令：yum install pcre-devel)</div></pre></td></tr></table></figure><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><ul><li><a href="https://github.com/swoole/swoole-src/releases" target="_blank" rel="noopener">https://github.com/swoole/swoole-src/releases</a></li><li><a href="http://pecl.php.net/package/swoole" target="_blank" rel="noopener">http://pecl.php.net/package/swoole</a></li><li><a href="http://git.oschina.net/swoole/swoole" target="_blank" rel="noopener">http://git.oschina.net/swoole/swoole</a></li></ul><p>下载源代码包后，在终端进入源码目录，执行下面的命令进行编译和安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd swoole</div><div class="line">phpize</div><div class="line">./configure</div><div class="line">make </div><div class="line">sudo make install</div></pre></td></tr></table></figure><h3 id="完整编译示例"><a href="#完整编译示例" class="headerlink" title="完整编译示例"></a>完整编译示例</h3><p>以下脚本会下载并编译主分支的swoole源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mkdir -p ~/build &amp;&amp; \</div><div class="line">cd ~/build &amp;&amp; \</div><div class="line">rm -rf ./swoole-src &amp;&amp; \</div><div class="line">curl -o ./tmp/swoole.tar.gz https://github.com/swoole/swoole-src/archive/master.tar.gz -L &amp;&amp; \</div><div class="line">tar zxvf ./tmp/swoole.tar.gz &amp;&amp; \</div><div class="line">mv swoole-src* swoole-src &amp;&amp; \</div><div class="line">cd swoole-src &amp;&amp; \</div><div class="line">phpize &amp;&amp; \</div><div class="line">./configure \</div><div class="line">--enable-coroutine \</div><div class="line">--enable-openssl  \</div><div class="line">--enable-http2  \</div><div class="line">--enable-async-redis \</div><div class="line">--enable-sockets \</div><div class="line">--enable-mysqlnd &amp;&amp; \</div><div class="line">make clean &amp;&amp; make &amp;&amp; sudo make install</div></pre></td></tr></table></figure><p>详细参数详解请到swoole 官方文档进行查看——<a href="https://wiki.swoole.com/wiki/page/437.html" target="_blank" rel="noopener">传送门</a>。</p><h3 id="PECL"><a href="#PECL" class="headerlink" title="PECL"></a>PECL</h3><p>swoole项目已收录到PHP官方扩展库，除了手工下载编译外，还可以通过PHP官方提供的PECL命令，一键下载安装swoole</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pecl install swoole</div></pre></td></tr></table></figure><h2 id="配置的php-ini"><a href="#配置的php-ini" class="headerlink" title="配置的php.ini"></a>配置的php.ini</h2><p>编译安装成功后，修改php.ini中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extension=swoole.so</div></pre></td></tr></table></figure><p>通过<code>php -m</code>或<code>phpinfo()</code>来查看是否成功加载了swoole，如果可能没有的英文<code>php.ini</code>的路径不对，使用可以<code>php --ini</code>来定位到<code>php.ini</code>的绝对路径</p><p>这样我们进入下载的 swoole 目录下，进入 <code>[examples]</code>目录运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php echo.php</div></pre></td></tr></table></figure><p>如果没有报错便是安装成功了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h1&gt;&lt;p&gt;Swoole 是使用纯 C 语言编写，提供了 PHP 语言的异步多线程服务器，异步 TCP/UDP 网络客户端，异步 MySQL，异步 Re
      
    
    </summary>
    
      <category term="php" scheme="http://www.maksim.website/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构入门（01）：数组</title>
    <link href="http://www.maksim.website/2018/05/01/1/"/>
    <id>http://www.maksim.website/2018/05/01/1/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-06-26T08:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组基础</p><p>数组其实就是把所有数据码成一排进行存放，数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。 在Java中数组所存放的类型是固定的，在 PHP 中数组是可以存储不同类型数据的。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180626161609.png" alt=""></p><p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 length - 1。</p><p>在这里我们需要<strong>注意</strong>，<strong>索引可以有语意；也可以没有语意</strong>。如上图，scores[2]这个索引2可以有实际的意义，上面的8个索引，可以代表八名学生的成绩，而索引可以代表他们的学号，那么scores[2]就是取2号学员的分数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="comment">// 数组大小</span></div><div class="line">      <span class="keyword">int</span> size = <span class="number">8</span>;</div><div class="line">      <span class="comment">// 定义数组</span></div><div class="line">      <span class="keyword">double</span>[] scores = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">8</span>];</div><div class="line">      scores[<span class="number">0</span>] = <span class="number">55.6</span>;</div><div class="line">      scores[<span class="number">1</span>] = <span class="number">60.5</span>;</div><div class="line">      scores[<span class="number">2</span>] = <span class="number">30.3</span>;</div><div class="line">      scores[<span class="number">3</span>] = <span class="number">18.2</span>;</div><div class="line">      scores[<span class="number">4</span>] = <span class="number">43.0</span>;</div><div class="line">      scores[<span class="number">5</span>] = <span class="number">34.33</span>;</div><div class="line">      scores[<span class="number">6</span>] = <span class="number">34.0</span>;</div><div class="line">      scores[<span class="number">7</span>] = <span class="number">45.45</span>;</div><div class="line">      <span class="comment">// 计算所有元素的总和</span></div><div class="line">      <span class="keyword">double</span> total = <span class="number">0</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">         total += scores[i];</div><div class="line">      &#125;</div><div class="line">      System.out.println(<span class="string">"总和为： "</span> + total);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面这段代码就是数组的操作，这里不再介绍其他语法，因为本文主要侧重于讲述数据结构，而不是Java的基础语法和使用。</p><p>数组最大的优点是快速查找，myList[2]，数组最好应用于“索引有语意”得情况。如果索引没有语义建议使用其他数据结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组基础&lt;/p&gt;
&lt;p&gt;数组其实就是把所有数据码成一排进行存放，数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。 在Java中数组所存放的类型是固定的，在 PHP 中数组是可以存储不同类型数据的。&lt;/p&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.maksim.website/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux典型应用实践：NFS共享文件</title>
    <link href="http://www.maksim.website/2018/04/12/2/"/>
    <id>http://www.maksim.website/2018/04/12/2/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-06-27T13:33:29.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用NFS"><a href="#为什么要用NFS" class="headerlink" title="为什么要用NFS"></a>为什么要用NFS</h1><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。</p><p>NFS最早是由Sun公司发展出来的，</p><p>简单的来说：它就是是可以透过网络，让不同的主机、不同的操作系统可以共享存储。</p><p>以下是NFS最显而易见的好处：</p><ol><li>节省本地存储空间，将常用的数据存放在一台NFS服务器上且可以通过网络访问，那么本地终端将可以减少自身存储空间的使用。</li><li>用户不需要在网络中的每个机器上都建有Home目录，Home目录可以放在NFS服务器上且可以在网络上被访问使用。</li><li>一些存储设备CDROM和Zip（一种高储存密度的磁盘驱动器与磁盘）等都可以在网络上被别的机器使用。这可以减少整个网络上可移动介质设备的数量。</li></ol><p>NFS 的基本原则是“容许不同的客户端及服务端通过一组RPC分享相同的文件系统”，它是独立于操作系统，容许不同硬件及操作系统的系统共同进行文件的分享。</p><p>NFS在文件传送或信息传送过程中依赖于RPC协议。RPC，远程过程调用 (Remote Procedure Call) 是能使客户端执行其他系统中程序的一种机制。NFS本身是没有提供信息传输的协议和功能的，但NFS却能让我们通过网络进行资料的分享，这是因为NFS使用了一些其它的传输协议。而这些传输协议用到这个RPC功能的。</p><p>可以说NFS本身就是使用RPC的一个程序。或者说NFS也是一个RPC SERVER。所以只要用到NFS的地方都要启动RPC服务，不论是NFS SERVER或者NFS CLIENT。这样SERVER和CLIENT才能通过RPC来实现PROGRAM PORT的对应。可以这么理解RPC和NFS的关系：NFS是一个文件系统，而RPC是负责负责信息的传输。</p><h1 id="NSF-的工作流程"><a href="#NSF-的工作流程" class="headerlink" title="NSF 的工作流程"></a>NSF 的工作流程</h1><ol><li>由程序在NFS客户端发起存取文件的请求，客户端本地的RPC(rpcbind)服务会通过网络向NFS服务端的RPC的111端口发出文件存取功能的请求。</li><li>NFS服务端的RPC找到对应已注册的NFS端口，通知客户端RPC服务。</li><li>客户端获取正确的端口，并与NFS daemon联机存取数据。</li><li>存取数据成功后，返回前端访问程序，完成一次存取操作。</li></ol><h1 id="CentOS-7搭建NFS服务器实例"><a href="#CentOS-7搭建NFS服务器实例" class="headerlink" title="CentOS 7搭建NFS服务器实例"></a>CentOS 7搭建NFS服务器实例</h1><table><thead><tr><th style="text-align:center">服务器系统</th><th style="text-align:center">角色</th><th style="text-align:center">IP</th></tr></thead><tbody><tr><td style="text-align:center">CentOS 7</td><td style="text-align:center">Server</td><td style="text-align:center">192.168.0.100</td></tr><tr><td style="text-align:center">CentOS 7</td><td style="text-align:center">Client</td><td style="text-align:center">192.168.0.101</td></tr></tbody></table><p><strong>1、因是测试环境，先关闭selinux和firewalld</strong></p><p>关闭selinux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# sed -i s#SELINUX=enforcing#SELINUX=disabled#g /etc/selinux/config</div></pre></td></tr></table></figure><p>停止防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# systemctl stop firewalld.service</div></pre></td></tr></table></figure><p><strong>2、服务器部署</strong></p><p>1）检查系统版本及NFS服务nfs-utils 和rpcbind有没有安装 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# cat /etc/redhat-release #查看系统版本</div><div class="line">CentOS Linux release 7.5.1804 (Core)</div><div class="line">[root@service ~]# uname -r #查看系统内核版本</div><div class="line">3.10.0-862.el7.x86_64</div><div class="line">[root@servicer ~]# uname -m #查看系统是否64位</div><div class="line">x86_64</div><div class="line">[root@service ~]# rpm -qa nfs-utils rpcbind #检查安装的软件包</div><div class="line">rpcbind-0.2.0-44.el7.x86_64</div><div class="line">nfs-utils-1.3.0-0.54.el7.x86_64</div></pre></td></tr></table></figure><p>2）如果没有安装在系统中通过yum 命令进行安装以上两个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# yum install -y nfs-utils rpcbind #安装上述所需的两个软件包</div></pre></td></tr></table></figure><p>3）启动rpcbind服务（<strong>一定要先启动rpcbind服务再启动nfs服务</strong>,由于在NFS服务过程中，必须先启动rpcbind，再启动nfs，这样才能让NFS在rpcbind上注册成功) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@service ~]#  systemctl start rpcbind  #启动</div><div class="line">[root@service ~]#  systemctl status rpcbind  #查看状态</div><div class="line">● rpcbind.service - RPC bind service</div><div class="line">   Loaded: loaded (/usr/lib/systemd/system/rpcbind.service; enabled; vendor preset: enabled)</div><div class="line">   Active: active (running) since 三 2018-06-27 16:02:27 CST; 29s ago</div><div class="line">  Process: 1577 ExecStart=/sbin/rpcbind -w $RPCBIND_ARGS (code=exited, status=0/SUCCESS)</div><div class="line"> Main PID: 1578 (rpcbind)</div><div class="line">   CGroup: /system.slice/rpcbind.service</div><div class="line">           └─1578 /sbin/rpcbind -w</div><div class="line"></div><div class="line">6月 27 16:02:27 bogon systemd[1]: Starting RPC bind service...</div><div class="line">6月 27 16:02:27 bogon systemd[1]: Started RPC bind service.</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# lsof -i :111  #查询rpcbind监听状态 (111是rpcbind的主端口)</div><div class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</div><div class="line">rpcbind 1578  rpc    6u  IPv4  19786      0t0  UDP *:sunrpc</div><div class="line">rpcbind 1578  rpc    8u  IPv4  19788      0t0  TCP *:sunrpc (LISTEN)</div><div class="line">rpcbind 1578  rpc    9u  IPv6  19789      0t0  UDP *:sunrpc</div><div class="line">rpcbind 1578  rpc   11u  IPv6  19791      0t0  TCP *:sunrpc (LISTEN)</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# netstat -lntup |grep rpcbind #查询rpcbind服务启动状态 (同lsof查询端口效果一样)</div><div class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1578/rpcbind</div><div class="line">tcp6       0      0 :::111                  :::*                    LISTEN      1578/rpcbind</div><div class="line">udp        0      0 0.0.0.0:905             0.0.0.0:*                           1578/rpcbind</div><div class="line">udp        0      0 0.0.0.0:111             0.0.0.0:*                           1578/rpcbind</div><div class="line">udp6       0      0 :::905                  :::*                                1578/rpcbind</div><div class="line">udp6       0      0 :::111                  :::*                                1578/rpcbind</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# rpcinfo -p localhost#查看nfs服务向rpc注册的端 口信息</div><div class="line">program vers proto   port  service</div><div class="line">    100000    4   tcp    111  portmapper</div><div class="line">    100000    3   tcp    111  portmapper</div><div class="line">    100000    2   tcp    111  portmapper</div><div class="line">    100000    4   udp    111  portmapper</div><div class="line">    100000    3   udp    111  portmapper</div><div class="line">    100000    2   udp    111  portmapper</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# systemctl list-unit-files | grep rpcbind #检查rpcbind自启动情况</div><div class="line">rpcbind.service                               enabled</div><div class="line">rpcbind.socket                                enabled</div><div class="line">rpcbind.target                                static</div></pre></td></tr></table></figure><p>如果rpcbind.service不是enable将其加入自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# systemctl enable rpcbind.service</div></pre></td></tr></table></figure><p>4）启动NFS服务并查看其状态 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# systemctl start nfs #启动NFS</div><div class="line">[root@service ~]# systemctl status nfs #查看NFS</div><div class="line">● nfs-server.service - NFS server and services</div><div class="line">   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; disabled; vendor preset: disabled)</div><div class="line">   Active: active (exited) since 三 2018-06-27 16:15:44 CST; 30s ago</div><div class="line">  Process: 9397 ExecStart=/usr/sbin/rpc.nfsd $RPCNFSDARGS (code=exited, status=0/SUCCESS)</div><div class="line">  Process: 9392 ExecStartPre=/bin/sh -c /bin/kill -HUP `cat /run/gssproxy.pid` (code=exited, status=0/SUCCESS)</div><div class="line">  Process: 9391 ExecStartPre=/usr/sbin/exportfs -r (code=exited, status=0/SUCCESS)</div><div class="line"> Main PID: 9397 (code=exited, status=0/SUCCESS)</div><div class="line">   CGroup: /system.slice/nfs-server.service</div><div class="line"></div><div class="line">6月 27 16:15:44 bogon systemd[1]: Starting NFS server and services...</div><div class="line">6月 27 16:15:44 bogon systemd[1]: Started NFS server and services.</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@NFS-server ~]# netstat -lntup|grep nfs #查看NFS端口启动(FNS默认端口为2049)</div><div class="line">[root@NFS-server ~]# lsof -i :2049 #查看NFS端口启动(FNS默认端口为2049)</div><div class="line">[root@NFS-server ~]# netstat -lntup|grep 2049 #查看NFS端口启动(FNS默认端口为2049)</div><div class="line">tcp        0      0 0.0.0.0:2049            0.0.0.0:*               LISTEN      -</div><div class="line">tcp6       0      0 :::2049                 :::*                    LISTEN      -</div><div class="line">udp        0      0 0.0.0.0:2049            0.0.0.0:*                           -</div><div class="line">udp6       0      0 :::2049                 :::*                                -</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@NFS-server ~]# rpcinfo -p localhost #启动NFS过后rpcbind服务已经启用了对FNS的端口映射</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@NFS-server ~]# systemctl list-unit-files | grep nfs  #查看nfs的开机自启动情况</div><div class="line">proc-fs-nfsd.mount                            static</div><div class="line">var-lib-nfs-rpc_pipefs.mount                  static</div><div class="line">nfs-blkmap.service                            disabled</div><div class="line">nfs-config.service                            static</div><div class="line">nfs-idmap.service                             static</div><div class="line">nfs-idmapd.service                            static</div><div class="line">nfs-lock.service                              static</div><div class="line">nfs-mountd.service                            static</div><div class="line">nfs-rquotad.service                           disabled</div><div class="line">nfs-secure.service                            static</div><div class="line">nfs-server.service                            disabled</div><div class="line">nfs-utils.service                             static</div><div class="line">nfs.service                                   disabled</div><div class="line">nfslock.service                               static</div><div class="line">nfs-client.target                             enabled</div><div class="line">[root@NFS-server ~]# systemctl enable nfs #让FNS开机自启动</div></pre></td></tr></table></figure><p>5）授权nfsnobody于/data/bbs让客户端挂载后可写可读</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service /]# chown nfsnobody:nfsnobody /data/bbs</div></pre></td></tr></table></figure><p>6）创建测试目录及文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# mkdir /data/bbs -p</div><div class="line">[root@service ~]# mkdir /data/bbs/test.txt</div></pre></td></tr></table></figure><p>7）配置NFS服务的export文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# echo "/data/bbs/ 192.168.0.0/24(rw,sync,root_squash)"&gt;&gt;/etc/exports</div></pre></td></tr></table></figure><p>重新加载nfs配置文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# exportfs -rv</div><div class="line">exporting 192.168.0.0/24:/data/bbs</div></pre></td></tr></table></figure><p>exportfs：NFS服务端发布共享控制命令。 </p><ul><li>-r：表示重新刷新共享</li><li>-a：表示将配置文件/etc/exports中的所有定义共享发布出去。</li><li>-v：显示确认共享设置</li><li>-u：表示不发布共享</li></ul><p>查看nfs服务器挂载情况 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@service ~]# showmount -e localhost</div><div class="line">Export list for localhost:</div><div class="line">/data/bbs 192.168.10.1/24</div></pre></td></tr></table></figure><ul><li>ro：目录只读</li><li>rw：目录读写</li><li>sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性</li><li>async：将数据先保存在内存缓冲区中，必要时才写入磁盘</li><li>all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组(nfsnobody)</li><li>no_all_squash：与all_squash取反(默认设置)</li><li>root_squash：将root用户及所属组都映射为匿名用户或用户组(默认设置)</li><li>no_root_squash：与rootsquash取反</li><li>anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户(UID=xxx)</li><li>anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户</li></ul><p><strong>3、客户端配置</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# yum install nfs-utils rpcbind</div></pre></td></tr></table></figure><p>把rpcbind加入开机自启动 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# systemctl enable rpcbind.service</div></pre></td></tr></table></figure><p>创建测试目录文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# mkdir /data/bbs/ -p</div></pre></td></tr></table></figure><p>扫描NFS服务器的文件共享列表 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# showmount -e 192.168.0.100</div><div class="line">Export list for 192.168.0.100:</div><div class="line">/data/bbs 192.168.0.100/24</div></pre></td></tr></table></figure><p>把服务器的目录挂载到客户端 的目录下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div><div class="line">[root@localhost ~]# df -h</div><div class="line">文件系统                 容量  已用  可用 已用% 挂载点</div><div class="line">/dev/mapper/centos-root  6.2G  1.1G  5.1G   18% /</div><div class="line">devtmpfs                 485M     0  485M    0% /dev</div><div class="line">tmpfs                    496M     0  496M    0% /dev/shm</div><div class="line">tmpfs                    496M  6.8M  490M    2% /run</div><div class="line">tmpfs                    496M     0  496M    0% /sys/fs/cgroup</div><div class="line">/dev/sda1               1014M  129M  886M   13% /boot</div><div class="line">tmpfs                    100M     0  100M    0% /run/user/0</div><div class="line">192.168.0.100:/data/bbs  6.2G  1.1G  5.1G   18% /data/bbs</div></pre></td></tr></table></figure><h1 id="数据测试"><a href="#数据测试" class="headerlink" title="数据测试"></a>数据测试</h1><p>Service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@service /]# cd /data/bbs</div><div class="line">[root@service bbs]# touch a.txt</div></pre></td></tr></table></figure><p>Client</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# ls /data/bbsa.txt</div></pre></td></tr></table></figure><p>提示:  </p><ol><li>配置NFS服务端后，不用重启NFS服务，只要使用exportfs -rv           </li><li>rpc主程序Centos5.8下为portmap 、Centos6.4和Centos7下为rpcbind          </li><li>NFS共享目录不要授权于777权限，可以改所属主和组为nfsnobody，因为nfsnobody权限不是很大，也不能登陆 </li></ol><h1 id="配置客户端-开机自动挂载NFS共享目录"><a href="#配置客户端-开机自动挂载NFS共享目录" class="headerlink" title="配置客户端 开机自动挂载NFS共享目录"></a>配置客户端 开机自动挂载NFS共享目录</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# chmod +x /etc/rc.d/rc.local     #centos7需要给rc.local赋予执行权限后，rc.local文件才能生效</div><div class="line">[root@localhost ~]# echo "mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs"&gt;&gt;/etc/rc.local</div><div class="line">[root@localhost ~]# cat /etc/rc.local</div><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES#</div><div class="line"><span class="meta">#</span> It is highly advisable to create own systemd services or udev rules</div><div class="line"><span class="meta">#</span> to run scripts during boot instead of using this file.#</div><div class="line"><span class="meta">#</span> In contrast to previous versions due to parallel execution during boot</div><div class="line"><span class="meta">#</span> this script will NOT be run after all other services.#</div><div class="line"><span class="meta">#</span> Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure</div><div class="line"><span class="meta">#</span> that this script will be executed during boot.</div><div class="line"> </div><div class="line">mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><h1 id="客户端mount挂载优化"><a href="#客户端mount挂载优化" class="headerlink" title="客户端mount挂载优化"></a>客户端mount挂载优化</h1><p>在企业生产环境中，NFS客户端挂载的参数有noexec、nosuid、nodev、noatime、rsize、wsize、nodiratime等，</p><p> 一般来说，NFS服务器共享的只是普通静态数据（图片、附件、视频），不需要执行suid、exec等权限，挂载的这个文件系统只能作为数据存取之用，无法执行程序，对于客户端来讲增加了安全性，例如：很多<em>*</em>修改站点文件都是由上传入口上传的程序存储目录，然后执行，因此在挂载时，用下面的命令是有必要的，</p><p>普遍安全挂载参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t nfs -o nosuid,noexec,nodev,rw 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p>挂载的读写缓存</p><p>wsize和rsize写和读缓存</p><p>wsize和rsize的最大值</p><p>NFSV2   rsize=8192 wsize=8192</p><p>NFSV3   rsize=32768 wsize=32768</p><p>NFSV4   rsize=65536 wsize=65536</p><p>现在一般centos5.8以上的系统都己经增加了读写缓存，如需修改可以加以上参数</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p>mount的一些常用挂载优化参数：</p><ul><li><p>wsize和rsize写和读缓存</p></li><li><p>async     数据不同步写到磁盘，提高性参，但降低数据安全，不推荐使用</p></li><li>noatime和nodiratime  这两个选是说在读写磁盘时，不更新文件和目录的时间戳，而更新文件时间戳对于工作数据必要性不大，增加了磁盘IO的次数，拖慢系统性参，</li><li>defaults   这个缺省值包括rw,suid,dev,exec,auto,nouser,and async  cat /etc/fstab的结果默认大部人都是缺省值</li><li>noauto    不会自动挂载文件系统</li><li>noexec    不允许安装的直接执行任何二进制文件</li><li>ro         挂载一个只读文件系统</li><li>rw        挂载一个可写的文件系统</li><li>sync       把数据同步写入硬盘</li><li>nosuid     不允许设置用户标识或设置组标识符位</li><li>nodev      不解释字符或文件块特殊设备</li><li><p>intr       表示可以中断</p><p>企业生产环境中nfs性参优化挂载例子：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mount -t nfs -o noatime,nodiratime 192.168.10.150:/data/bbs /data/bbs</div><div class="line">mount -t nfs -o nosuid,noexec,nodev,noatime,nodiratime,intr,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p>如果是本地系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -o defaults,async,noatime,data=writeback,barrier=0 /dev/sdb1 /mnt</div></pre></td></tr></table></figure><p>data=writeback,barrier=0 是日志文件系统的优化</p><p>提示：本地文件系统挂载如果加nodiratime会报错，</p><h1 id="加优化参数和不加的数据写入测试"><a href="#加优化参数和不加的数据写入测试" class="headerlink" title="加优化参数和不加的数据写入测试"></a>加优化参数和不加的数据写入测试</h1><p><strong>使用普通挂载</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# mount -t nfs 192.168.0.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p> 测试单个文件写入速度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cd /data/bbs</div><div class="line">[root@localhost bbs]# time dd if=/dev/zero of=/data/bbs/dingjianfile bs=9k count=2000</div><div class="line">2000+0 records in</div><div class="line">2000+0 records out</div><div class="line">18432000 bytes (18 MB) copied, 0.114592 s, 161 MB/s</div><div class="line">real    0m0.125s</div><div class="line">user    0m0.000s</div><div class="line">sys     0m0.021s</div></pre></td></tr></table></figure><p>测试批量创建文件的写入速度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# time for ((i=1;i&lt;10000;i++));do /bin/cp /bin/touch /data/bbs/test$i;done</div><div class="line">real    2m2.877s</div><div class="line">user    0m10.242s</div><div class="line">sys     0m33.882s</div></pre></td></tr></table></figure><p><strong>加优化参数挂载:</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]#mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs</div></pre></td></tr></table></figure><p>测试单个文件写入速度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]#  time dd if=/dev/zero of=/data/bbs/dingjianfile bs=9k count=2000</div><div class="line">2000+0 records in</div><div class="line">2000+0 records out</div><div class="line">18432000 bytes (18 MB) copied, 0.10043 s, 184 MB/s</div><div class="line">real    0m0.107s</div><div class="line">user    0m0.001s</div><div class="line">sys     0m0.017s</div></pre></td></tr></table></figure><p>测试批量创建文件的写入速度 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# time for ((i=1;i&lt;10000;i++));do /bin/cp /bin/touch /data/bbs/test$i;done</div><div class="line">real    1m38.526s</div><div class="line">user    0m9.989s</div><div class="line">sys     0m32.788s</div></pre></td></tr></table></figure><h1 id="配置fstab文件令开机自动加载网络文件系统和本地的文件系统-和rc-local效果一样"><a href="#配置fstab文件令开机自动加载网络文件系统和本地的文件系统-和rc-local效果一样" class="headerlink" title="配置fstab文件令开机自动加载网络文件系统和本地的文件系统(和rc.local效果一样)"></a>配置fstab文件令开机自动加载网络文件系统和本地的文件系统(和rc.local效果一样)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@localhost bbs]# vi /etc/fstab</div><div class="line"><span class="meta">#</span> /etc/fstab</div><div class="line"><span class="meta">#</span> Created by anaconda on Wed Jun 27 15:39:33 2018</div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta">#</span> Accessible filesystems, by reference, are maintained under '/dev/disk'</div><div class="line"><span class="meta">#</span> See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</div><div class="line"><span class="meta">#</span></div><div class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</div><div class="line">UUID=cbf5711b-4a2b-44ca-a6da-69d181f03617 /boot xfs     defaults        0 0</div><div class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</div><div class="line"></div><div class="line">192.168.0.100:/data/bbs /data/bbs   nfs defaults,nosuid,noatime,nodiratime,noexec,nodev,intr,rsize=65536,wsize=65536     0 0</div><div class="line">~</div></pre></td></tr></table></figure><p>参考资料：</p><ol><li>《centos7下NFS使用与配置》 <a href="http://blog.51cto.com/mrxiong2017/2087001" target="_blank" rel="noopener">http://blog.51cto.com/mrxiong2017/2087001</a></li><li>《详细讲解NFS配置过程》(<a href="https://www.cnblogs.com/alonones/p/6105586.html" target="_blank" rel="noopener">https://www.cnblogs.com/alonones/p/6105586.html</a>)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要用NFS&quot;&gt;&lt;a href=&quot;#为什么要用NFS&quot; class=&quot;headerlink&quot; title=&quot;为什么要用NFS&quot;&gt;&lt;/a&gt;为什么要用NFS&lt;/h1&gt;&lt;p&gt;NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>写作的准备-读《完全写作指南》</title>
    <link href="http://www.maksim.website/2018/04/08/1/"/>
    <id>http://www.maksim.website/2018/04/08/1/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-06-25T12:39:07.539Z</updated>
    
    <content type="html"><![CDATA[<p>写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：</p><p>目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改</p><p>从理论上讲，按照这个顺序操作，你就能得到一篇组织得当、逻辑严谨的完美稿件。这个方法对一部分人是有用的，但是如果你和大多数人一样，那么他可能就不适合你。在现实生活中，大部分都不是线性思维的写作者。</p><p>这六个步骤没错，错的是这个强制性的顺序。当遵循渐进编程了因循守旧，它可能会阻碍你写作能力的发挥。</p><p>你可以以这个步骤中任意一步作为起点，头脑风暴、提纲或者是写初稿。</p><h2 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h2><p>当要写作时，首先我们要确定自己的目标是什么，你希望达到什么目的。</p><p>仔细思考写作目的能帮你搞清楚该说什么，以及怎么说。又去的是，这样一来你的读者也会更加轻松，如果你也有过收到大量简历的经理，你就会知道一封周到、工整且有针对性的求职信会让你干到多么轻松。</p><h2 id="了解你的读者"><a href="#了解你的读者" class="headerlink" title="了解你的读者"></a>了解你的读者</h2><p>除了私人日记之外，所有的作品都是有读者的，你的作品需要指向这些特定的读者。</p><p>站在读者的角度进行思考，有两个关键问题：</p><ul><li>信息</li><li>态度</li></ul><p>选择信息的黄金法则是：<strong>要有足量的有效信息，让你的读者行动起来。</strong></p><p>了解读者潜在的态度也是成功的关键。</p><ul><li>你的读者会有什么样的反应？</li><li>他们很容易接受你的信息吗?</li><li>还是会有抵触情绪？</li><li>他们是否怀有敌意。</li></ul><blockquote><p>笔者说：</p><p>在这里，可以读《美国航空航天局科学家给赞比亚修女的一封信》，这是一封大师级的回信，在本文结束处。</p></blockquote><h2 id="用他头脑风暴锁定你想表达的内容"><a href="#用他头脑风暴锁定你想表达的内容" class="headerlink" title="用他头脑风暴锁定你想表达的内容"></a>用他头脑风暴锁定你想表达的内容</h2><p>头脑风暴有一些规则。如果你在学校或者工作的地方参加过头脑风暴式的讨论，那么你很可能看到过这些规则：</p><ol><li>相处的点子越多越好。如果你能把注意力放在数量而非质量上，那么提出有用的点子概率就会更大，点子都多多益善。</li><li>不要审查，不要评论。头脑风暴时，让你的思绪自由发散。这并不是对点子进行评论的时候，不要说这个点子不太好，那个点子不合适。把脑袋里评论的声音关掉，把所有想到的东西都写出来。你可以之后再删除。</li><li>接受不同寻常的想法。不要考虑你的想法靠不靠谱。你的这些想法可能完全超出预料，但它们当中可能会有一个非常有用，或至少能为你的思考指引方向的点子。充分发挥自己的想象力。</li><li>合并改进你的点子。如果你任由思绪自由发散，那么点子很可能会有一些重合。观察它们的相似之处，并加以合并调整。</li></ol><p>当写完初稿后，发现内容不够完整，不够有说服力时候甚至可以重新进行头脑风暴。</p><h1 id="美国航空航天局科学家给赞比亚修女的一封信"><a href="#美国航空航天局科学家给赞比亚修女的一封信" class="headerlink" title="美国航空航天局科学家给赞比亚修女的一封信"></a>美国航空航天局科学家给赞比亚修女的一封信</h1><p>背景： 1970年，赞比亚修女玛丽·尤肯达给美国航空航天局科学家恩斯特·施图林格博士问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。</p><p>1970年，赞比亚修女玛丽·尤肯达（Mary Jucunda）给恩斯特·施图林格（Ernst Stuhlinger）博士写了一封信。施图林格因在火星之旅工程中的原创性研究，成为NASA（美国航空航天局）马绍尔太空航行中心的科学副总监。信中，玛丽·尤肯达修女问道：目前地球上还有这么多小孩子吃不上饭，他怎么能舍得为远在火星的项目花费数十亿美元。施图林格很快给尤肯达修女回了信，同时还附带了一张题为“升起的地球”的照片，这张标志性的照片是宇航员威廉·安德斯于1968年在月球轨道上拍摄的（照片中可以看到月球的地面）。他这封真挚的回信随后由NASA以《为什么要探索宇宙》为标题发表。</p><p>1970年5月6日</p><p>亲爱的玛丽·尤肯达修女：每天，我都会收到很多类似的来信，但这封对我的触动最深，因为它来自一颗慈悲的饱含探求精神的心灵。我会尽自己所能来回答你这个问题。首先，请允许我向你以及你勇敢的姐妹们表达深深的敬意，你们献身于人类最崇高的事业：帮助身处困境的同胞。</p><p>在来信中，你问我在目前地球上还有儿童由于饥饿面临死亡威胁的情况下，为什么还要花费数十亿美元来进行飞向火星的航行。 我清楚你肯定不希望这样的答案：“哦，我之前不知道还有小孩子快饿死了，好吧，从现在开始，暂停所有的太空项目，直到孩子们都吃上饭再说。”事实上，早在了解火星之旅的技术之前，我已经对儿童的饥荒问题有所了解。而且，同我很多朋友的看法一样，我认为此时此刻，我们就应该开始通往月球、火星乃至其他行星的伟大探险。从长远来看，相对于那些要么只有年复一年的辩论和争吵，要么连妥协之后也迟迟无法落实的各种援助计划来说，我甚至觉得探索太空的工程给更有助于解决人类目前所面临的种种危机。</p><p>在详细说明我们的太空项目如何帮助解决地面上的危机之前，我想先简短讲一个真实的故事。那是在400年前，德国某小镇里有一位伯爵。他是个心地善良的人，他将自己收入的一大部分捐给了镇子上的穷人。这十分令人钦佩，因为中世纪时穷人很多，而且那时经常爆发席卷全国的瘟疫。一天，伯爵碰到了一个奇怪的人，他家中有一个工作台和一个小实验室，他白天卖力工作，每天晚上的几小时的时间专心进行研究。他把小玻璃片研磨成镜片，然后把研磨好的镜片装到镜筒里，用此来观察细小的物件。伯爵被这个前所未见的可以把东西放大观察的小发明迷住了。他邀请这个怪人住到了他的城堡里，作为伯爵的门客，此后他可以专心投入所有的时间来研究这些光学器件。</p><p>然而，镇子上的人得知伯爵在这么一个怪人和他那些无用的玩意儿上花费金钱之后，都很生气，“我们还在受瘟疫的苦”，他们抱怨道，“而他却为那个闲人和他没用的爱好乱花钱！”伯爵听到后不为所动，“我会尽可能地接济大家”，他表示，“但我会继续资助这个人和他的工作，我确信终有一天会有回报。”</p><p>果不其然，他的工作赢来了丰厚的回报：显微镜。显微镜的发明给医学带来了前所未有的发展，由此展开的研究及其成果，消除了世界上大部分地区肆虐的瘟疫和其他一些传染性疾病。</p><p>伯爵为支持这项研究发明所花费的金钱，其最终结果大大减轻了人类所遭受的苦难，这回报远远超过单纯将这些钱用来救济那些遭受瘟疫的人。</p><p>我们目前面临类似的问题。美国总统的年度预算共有2000亿美元，这些钱将用于医疗、教育、福利、城市建设、高速公路、交通运输、海外援助、国防、环保、科技、农业以及其他多项国内外的工程。今年，预算中的1.6%将用于探索宇宙，这些花销将用于阿波罗以计划、其他一些涵盖了天体物理学、深空天文学、空间生物学、行星探测工程、地球资源工程的小项目以及空间工程技术。为担负这些太空项目的支出，平均每个年收入10,000美元的美国纳税人需要支付约30美元给太空，剩下的9,970美元则可用于一般生活开支、休闲娱乐、储蓄、别的税项等花销。</p><p>也许你会问：“为什么不从纳税人为太空支付的30美元里抽出5美元或3美元或是1美元来救济饥饿的儿童呢？”为了回答这个问题，我需要先简单解释一下我们国家的经济是如何运行的，其他国家也是类似的情形。政府由几个部门（如内政部、司法部、卫生部与公众福利部、教育部、运输部、国防部等）和几个机构（国家科学基金会、国家航空航天局等）组成，这些部门和机构根据自己的职能制定相应的年度预算，并严格执行以应对国务委员会的监督，同时还要应付来自预算部门和总统对于其经济效益的压力。当资金最终由国会拨出后，将严格用于经预算批准的计划中的项目。</p><p>显然，NASA的预算中所包含的项目都是和航空航天有关的。未经国会批准的预算项目，是不会得到资金支持的，自然也不会被课税，除非有其他部门的预算涵盖了该项目，借此花掉没有分配给太空项目的资金。由这段简短的说明可以看出，要想援助饥饿的儿童，或在美国已有的对外援助项目上增加援助金额，需要首先由相关部门提出预算，然后由国会批准才行。</p><p>要问是否同意政府实施类似的政策，我个人的意见是绝对赞成。我完全不介意每年多付出一点点税款来帮助饥饿的儿童，无论他们身在何处。</p><p>我相信我的朋友们也会持相同的态度。然而，事情并不是仅靠把去往火星航行的计划取消就能轻易实现的。相对的，我甚至认为可以通过太空项目，来为缓解乃至最终解决地球上的贫穷和饥饿问题作出贡献。解决饥饿问题的关键有两部分：食物的生产和食物的发放。食物的生产所涉及的农业、畜牧业、渔业及其他大规模生产活动在世界上的一些地区高效高产，而在有的地区则产量严重不足。通过高科技手段，如灌溉管理，肥料的使用，天气预报，产量评估，程序化种植，农田优选，作物的习性与耕作时间选择，农作物调查及收割计划，可以显著提高土地的生产效率。</p><p>人造地球卫星无疑是改进这两个关键问题最有力的工具。在远离地面的运行轨道上，卫星能够在很短的时间里扫描大片的陆地，可以同时观察计算农作物生长所需要的多项指标，土壤、旱情、雨雪天气等等，并且可以将这些信息广播至地面接收站以便做进一步处理。事实证明，配备有土地资源传感器及相应的农业程序的人造卫星系统，即便是最简单的型号，也能给农作物的年产量带来数以十亿美元计的提升。</p><p>如何将食品发放给需要的人则是另外一个全新的问题，关键不在于轮船的容量，而在于国际间的合作。小国统治者对于来自大国的大量食品的输入很难做出准确的判断，他们害怕伴随着食物一同而来的还有外国势力对其统治地位的影响。恐怕在国与国之间消除隔阂之前，饥饿问题无法得以高效解决了。我不认为太空计划能一夜之间创造奇迹，然而，探索宇宙有助于促使问题向着良好的方向发展。</p><p>以最近发生的阿波罗13号事故为例。当宇航员处于关键的大气层再入期时，为了保证通讯畅通，苏联关闭了境内与阿波罗飞船所用频带相同的所有广播通信。同时派出舰艇到太平洋和大西洋海域以备第一时间进行搜救工作。如果宇航员的救生舱降落到俄方舰船附近，俄方人员会像对待从太空返回的本国宇航员一样对他们进行救助。同样，如果俄方的宇宙飞船遇到了类似的紧急情况，美国也一定会毫不犹豫地提供援助。 </p><p>通过卫星进行监测与分析来提高食品产量，以及通过改善国际关系提高食品发放的效率，只是通过太空项目提高人类生活质量的两个方面。下面我想介绍另外两个重要作用：促进科学技术的发展和提高一代人的科学素养。</p><p>登月工程需要历史上前所未有的高精度和高可靠性。面对如此严苛的要求，我们要寻找新材料，新方法；开发出更好的工程系统；用更可靠的制作流程；让仪器的工作寿命更长久；甚至需要探索全新的自然规律。</p><p>这些为登月发明的新技术同样可以用于地面上的工程项目。每年，都有大概一千项从太空项目中发展出来的新技术被用于日常生活中，这些技术打造出更好的厨房用具和农场设备，更好的缝纫机和收音机，更好的轮船和飞机，更精确的天气预报和风暴预警，更好的通讯设施，更好的医疗设备，乃至更好的日常小工具。你可能会问为什么先设计出宇航员登月舱的维生系统，而不是先为听力障碍患者造出有声阅读设备呢。答案很简单：解决工程问题时，重要的技术突破往往并不是按部就班直接得到的，而是来自能够激发出强大创新精神，能够燃起的想象力和坚定的行动力，以及能够整合好所有资源的充满挑战的目标。</p><p>太空旅行无可置疑地是一项充满挑战的事业。通往火星的航行并不能直接提供食物解决饥荒问题。然而，它所带来大量的新技术和新方法可以用在火星项目之外，这将产生数倍于原始花费的收益。若希望人类生活得越来越好，除了需要新的技术，我们还需要基础科学不断有新的进展。包括物理学和化学，生物学和生理学，特别是医学，用来照看人类的健康，应对饥饿、疾病、食物和水的污染以及环境污染等问题。</p><p>我们需要更多的年轻人投入到科学事业中来，我们需要给予那些投身科研事业的有天分的科学家更多的帮助。随时要有富于挑战的研究项目，同时要保证对项目给予充分的资源支持。在此我要重申，太空项目是科技进步的催化剂，它为学术研究工作提供了绝佳和实践机会，包括对月球和其他行星的眼睛、物理学和天文学、生物学和医学科学等学科，有它，科学界源源不断出现令人激动不已研究课题，人类得以窥见宇宙无比瑰丽的景象；为了它，新技术新方法不断涌现。</p><p>由美国政府控制并提供资金支持的所有活动中，太空项目无疑最引人瞩目也最容易引起争议，尽管其仅占全部预算的1.6%，不到全民生产总值的千分之三。作为新技术的驱动者和催化剂，太空项目开展了多项基础科学的研究，它的地位注定不同于其他活动。从某种意义上来说，以太空项目的对社会的影响，其地位相当于3-4千年前的战争活动。</p><p>如果国家之间不再比拼轰炸机和远程导弹，取而代之比拼月球飞船的性能，那将避免多少战乱之苦！聪慧的胜利者将满怀希望，失败者也不用饱尝痛苦，不再埋下仇恨的种子，不再带来复仇的战争。</p><p>尽管我们开展的太空项目研究的东西离地球很遥远，已经将人类的视野延伸至月亮、至太阳、至星球、直至那遥远的星辰，但天文学家对地球的关注，超过以上所有天外之物。太空项目带来的不仅有那些新技术所所提供的生活品质的提升，随着对宇宙研究的深入，我们对地球，对生命，对人类自身的感激之情将越深。太空探索让地球更美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写作需要明确目标、确定读者、用头脑风暴总结出中心思想、组织内容、写初稿以及修改。但在大多数写作课上，这些步骤以现行的方式展现的，像这样：&lt;/p&gt;
&lt;p&gt;目标 → 读者 → 头脑风暴 → 组织 → 写初稿 → 修改&lt;/p&gt;
&lt;p&gt;从理论上讲，按照这个顺序操作，你就能得到一篇组
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://www.maksim.website/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2018/04/03/cjix5kzdv005g82rdkrvvqmai/"/>
    <id>http://www.maksim.website/2018/04/03/cjix5kzdv005g82rdkrvvqmai/</id>
    <published>2018-04-03T14:53:43.408Z</published>
    <updated>2018-06-20T07:17:28.071Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:MySQL服务器参数介绍<br>categories:MySQL<br>date:2017-10-18</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p>人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。</p><p>MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。</p><p>从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。</p><p>##　MySQl获取配置信息路径</p><ul><li>命令行参数 <code>mysqld_safe --datadir=/data/sql_data</code></li><li>配置文件 <code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code></li></ul><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171013153125.png" alt=""></p><p>MySQL会先从<code>/etc/my.cnf</code>文件下读取配置信息，然后是<code>/etc/mysql/my.cnf</code>。</p><p>MySQL配置参数的作用域</p><ul><li>全局参数 <ul><li><code>set global 参数名 = 参数值;</code></li><li><code>set @@global。参数名:=参数值;</code></li></ul></li><li>会话参数<ul><li><code>set [session] 参数名=参数值;</code></li><li><code>set @@session.参数名:=参数值;</code></li></ul></li></ul><p>会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。</p><p>在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。</p><h2 id="内存配置相关参数"><a href="#内存配置相关参数" class="headerlink" title="内存配置相关参数"></a>内存配置相关参数</h2><p>MySQL对于内存的使用我们可以分为两个类来看。</p><ul><li>无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存</li><li>可以通过参数配置控制的，各类的缓冲池所需要的内存。</li></ul><p>对内存参数配置之前，我们需要进行考虑：</p><ul><li>确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。</li><li>确定MySQL的每个连接使用的内存，例如排序缓冲和临时表</li><li><p>把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。</p><ul><li><p>sort_buffer_size</p><ul><li>join_buufer_szie</li><li>read_buffer_size</li><li>read_rnd_buffer_size  </li></ul></li></ul></li></ul><h3 id="确定需要为操作系统保留多少内存"><a href="#确定需要为操作系统保留多少内存" class="headerlink" title="确定需要为操作系统保留多少内存"></a>确定需要为操作系统保留多少内存</h3><p>给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。</p><p>数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。</p><p>另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。</p><h3 id="如何为缓冲池分配内存"><a href="#如何为缓冲池分配内存" class="headerlink" title="如何为缓冲池分配内存"></a>如何为缓冲池分配内存</h3><p>Innodb_buffer_pool_size，Innodb缓冲区</p><p>总内存-（每个线程所需要的内存*连接数）- 系统保留内存</p><p>手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。</p><h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos;</div></pre></td></tr></table></figure><h2 id="I-O相关配置参数"><a href="#I-O相关配置参数" class="headerlink" title="I/O相关配置参数"></a>I/O相关配置参数</h2><p>Innodb I/O相关配置</p><h2 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h2><p><code>expire_logs_days</code> 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:MySQL服务器参数介绍&lt;br&gt;categories:MySQL&lt;br&gt;date:2017-10-18&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 安全系列之删除特殊的用户和用户组</title>
    <link href="http://www.maksim.website/2018/04/02/1/"/>
    <id>http://www.maksim.website/2018/04/02/1/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-06-20T05:07:51.210Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。</p><p>Linux 系统中可以删除的默认用户和用户组大致如下：</p><ul><li>可删除的用户，如 adm、lp、sync、shutdown、halt、news、uucp、operator、games、gopher 等。</li><li>可删除的用户组，如 adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers 等。</li></ul><p>删除的方法很简单，下面以删除 games 用户和用户组为例介绍具体的操作。</p><p>删除用户所使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">userdel games</div></pre></td></tr></table></figure><p>删除用户组使用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">groupdel games</div></pre></td></tr></table></figure><p>有些时候，某些用户仅仅作为进程调度或者用户组调用，并不需要登录功能，此时可以禁止这些用户登录系统的功能，例如要禁止 nagios 用户的登录功能，可以执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usermod -s /sbin/nologin nagios</div></pre></td></tr></table></figure><p>其实要删除哪些用户和用户组，并没有固定要求，可以根据服务器的用途来决定，如果服务器用于 Web 应用的，那么系统默认的 Apache 用户和用户组就无需删除；如果服务器用于数据库应用，那么建议删除系统默认的 Apache 用户和用户组。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 提供了各种不同角色的系统账号，在系统安装完成后，默认会按照很多不必要的用户和用户组，如果不需要某些用户或者用户组，应立即删除它们，因为账户越多，系统就越不安全，从而很渴能被黑客利用，威胁服务器的安全。&lt;/p&gt;
&lt;p&gt;Linux 系统中可以删除的默认用户和用户组大
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>AndroidStudio解决一直处于Building gradle project info的问题</title>
    <link href="http://www.maksim.website/2018/03/10/1/"/>
    <id>http://www.maksim.website/2018/03/10/1/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-06-25T12:39:00.687Z</updated>
    
    <content type="html"><![CDATA[<p>问题的原因是gradle包（即gradle-wrapper.properties里的gradle压缩文件）本地没有需要下载，因为墙的原因，一直卡在下载的环节。 </p><p>有三个解决方案：（选其一，推荐第三个方案） </p><ol><li>科学#上网，不多说，必备。加载多久看你网速了。（但即使是如此速度依旧很慢）</li><li>将 gradle-wrapper.properties中的版本改为已经存在的版本，找一个可以编译的项目复制 gradle 版本号即可。</li><li>下载对应离线包放到本地（如：C:\Users\Administrator.gradle\wrapper\dists\gradle-4.0.1-all\26awvqv6f41r14q9x72t4n0s，不解压，重启as），离线包地址：services.gradle.org/distributions/或者<a href="http://download.csdn.net/album/detail/2265" target="_blank" rel="noopener">http://download.csdn.net/album/detail/2265</a>；然后打开File-&gt;Settings-&gt;Build, Exectution, Deployment-&gt;Gradle ，设置 “Gradle home” 为解压目录即可.</li></ol><blockquote><p>原文地址：<a href="http://blog.csdn.net/nifanggge/article/details/53397942" target="_blank" rel="noopener">http://blog.csdn.net/nifanggge/article/details/53397942</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题的原因是gradle包（即gradle-wrapper.properties里的gradle压缩文件）本地没有需要下载，因为墙的原因，一直卡在下载的环节。 &lt;/p&gt;
&lt;p&gt;有三个解决方案：（选其一，推荐第三个方案） &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;科学#上网，不多说，必备。
      
    
    </summary>
    
      <category term="Andriod" scheme="http://www.maksim.website/categories/Andriod/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx的安装</title>
    <link href="http://www.maksim.website/2018/02/27/1/"/>
    <id>http://www.maksim.website/2018/02/27/1/</id>
    <published>2018-02-26T16:00:00.000Z</published>
    <updated>2018-06-25T12:39:20.550Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。</p><p>在安装 Nginx 时，我们可以通过以下两种方式进行安装：</p><ol><li>使用包管理器安装 Nginx</li><li>通过源代码安装 Nginx</li></ol><h2 id="使用包管理器安装-Nginx"><a href="#使用包管理器安装-Nginx" class="headerlink" title="使用包管理器安装 Nginx"></a>使用包管理器安装 Nginx</h2><p>使用包管理器安装 Nginx 的机会，是你使用的操作系统已经提供了 Nginx 的安装包。使用包管理器安装 Nginx 的方式很简单，只需要在终端输入：</p><p>Linux(基于 deb，如 Ubunut)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure><p> Linux（基于 rpm，如 CentOS)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>FreeBSD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pkg_install -r nginx</div></pre></td></tr></table></figure><p>通过上述命令，Nginx 将会安装到操作系统的标准位置下。如果使用操作系统的安装包安装 Nginx，那么通过上面的命令来安装是最佳方式。</p><p>Nginx 核心团队也提供了稳定的二进制版本，可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 页面下载可用版本。未发布 Nginx 安装包的系统用户（例如，CentOS），可以使用下面指导来安装预测试、预编译二进制版本。</p><p>通过创建下面的文件，在系统中添加 Nginx 仓库的 yum 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/yum.repos.d/nginx.repo</div><div class="line">[nginx]</div><div class="line">name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure><p>然后，听过执行如下命令来安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>也可以按照前面介绍的 URL 下载 nginx 发行版安装。</p><h2 id="从源代码安装-Nginx"><a href="#从源代码安装-Nginx" class="headerlink" title="从源代码安装 Nginx"></a>从源代码安装 Nginx</h2><p>Nginx 代码提供了两种独立的下载分支——开发版与稳定版。开发分支是一个正处于积极开发状态的版本。在这个版本中，会有一些新功能被集成到其中，在稳定版中是找不到这些功能的。当发布一个“开发”版时，它会经历同样的 QA 和作为稳定版本的一组类似测试功能。因此无论哪一个分支都一颗用于生产环境中，两者主要的不同，在于对第三方模块的支持。在开发板中，内部的 API 可能会发生改变，而稳定版则保持不变。因此，为了与第三方模块向下兼容，在稳定版中第三方模块都可以有效使用。</p><h3 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h3><p>为了从源代码编译 Nginx，系统需要满足某些必要条件，除了编译器外，如果想分别启用 SSL 支持和使用 rewrite 模块，那么还需要提供响应的 OpenSSL 与 PCRE（Perl Compatible Regular Expressions）库及开发头文件。rewrite 模块是默认安装的。如果你还没有 PCRE 库与开发头文件，你需要在配置阶段禁用 rewrite 模块。这依赖于系统，也有可能在系统中已经默认安装了这些必要条件。如果没有安装，则需要从其安装包安装或者从源码下载并且解压安装，在 Nginx 配置脚本中指定他们在系统中的安装位置。</p><p>如果在配置文件中使用了—with-\<library\>=\<path\>选项，那么 Nginx 会视图建立一个静态依赖库。如果你想让 Nginx 不依赖于系统的任何其他部分，或是想获得些 Nginx 的二进制额外性能，那么你可能会使用构建静态库的做法。如果你使用外部库功能只能从某一个版本起有效（例如，NPN[Next Protocol Negotiation]TLS扩展从 OpenSSL1.0.1版有效），那么你就不得不将其指定到特定版本解压后的源代码路径中。</path\></library\></p><p>根据自己的喜好，你可能会提供其他的、可选安装包。你可以为这些安装包提供支持。他们包括 MD5和 SHA-1以支持散列算法、zip 压缩库、libatomic 库。在 Nginx 中，很多地方法会用到散列库，例如为了计算 URI 散列进而计算缓存 key。</p><p>zlib 压缩裤被用来投递 gzip 压缩内容。如果 atomic_ops 库有效，那么 Nginx 会用它来实现自动内存更新操作，以实现高性能的内存锁定代码。</p><h3 id="从源代码编译"><a href="#从源代码编译" class="headerlink" title="从源代码编译"></a>从源代码编译</h3><p>读者可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载 Nginx，在该页面找到.tar.gz 或者.zip 格式的源代码分支，安装如下步骤将下载的安装包解压到一个临时目录中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir ~/bulid</div><div class="line"><span class="meta">$</span> cd ~/bulid &amp;&amp; tar xzf nginx-&lt;version-number&gt;.tar.gz</div></pre></td></tr></table></figure><p>使用下面命令配置 Nginx:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cd ~/bulid/nginx-&lt;version-number&gt; &amp;&amp; ./configure</div></pre></td></tr></table></figure><p>然后，使用下面命令进行编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> make &amp;&amp; sudo make install</div></pre></td></tr></table></figure><p>在编译自己的二进制 nginx 时，你会有很大的灵活性来包含你仅使用的功能。你已经指定使用哪个用户运行 Nginx 了吗?你要使用默认的 logfile 位置，以便不用在 Nginx 的配置文件明确地说明它们吗?表 1-1 所示是配置选项列表，通过它来帮助你设计出自己的 nginx 命令。这些选项对 Nginx 都是有效的，模块可以被独立激活。</p><table><thead><tr><th>选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td>–prefix=\<path\></path\></td><td style="text-align:left">Nginx 安装的根路径，所有其他的安装路径都要依赖于该选项</td></tr><tr><td>–sbin-path=\<path\></path\></td><td style="text-align:left">指定 Nginx 二进制文件的路径。如果没有指定，那么这个路径依赖于——prefix 选项</td></tr><tr><td>–conf-path=\<path\></path\></td><td style="text-align:left">如果在命令行没有指定配置文件，那么将会通过这里指定的路径，Nginx 将会去那里寻找它的配置文件</td></tr><tr><td>–error-log-path=\<path\></path\></td><td style="text-align:left">指定错误文件的路径，Nginx 会将其中写入错误日志文件，除非有其他配置</td></tr><tr><td>–pid-path=\<path\></path\></td><td style="text-align:left">指定的文件将会写入 Nginx master 进程的pid，通常在/var/run 下</td></tr><tr><td>–lock-path=\<path\></path\></td><td style="text-align:left">共享存储器互斥锁文件的路径</td></tr><tr><td>–user=\<user\></user\></td><td style="text-align:left">worker 进程运行的用户</td></tr><tr><td>–group=\<group\></group\></td><td style="text-align:left">worker 进程运行的组</td></tr><tr><td>–with-file-aio</td><td style="text-align:left">为 FreeBSD4.3+和 Linux2.6.22+系统启用异步 I/O</td></tr><tr><td>–with-debug</td><td style="text-align:left">这个选项用于启用调试日志。在生产环境中不推荐使用该选项。</td></tr></tbody></table><p>你可以使用优化编译，单但是如果使用包管理工具进行安装将无法获得这些优化，如下表：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–with-cc=\<path\></path\></td><td>如果想设置一个不再默认 Path 下的编译器</td></tr><tr><td>–with-cpp=\<path\></path\></td><td>设置 C 预处理器的响应路径</td></tr><tr><td>–with-cc-opt=\<options></options></td><td>指定必要的 include 文件路径，可能（-I\<path\>）指出，也可能是优化(-O4)并指定64位构建</path\></td></tr><tr><td>–with-ld-opt=\<options\></options\></td><td>包含连接器库的路径(-L\<path\>)和运行路径(-R\<path\>)</path\></path\></td></tr><tr><td>—with-cpu-opt=\<cpu\></cpu\></td><td>通过该选项为特定的 CPU 构建 Nginx</td></tr></tbody></table><h2 id="配置-SSL-支持"><a href="#配置-SSL-支持" class="headerlink" title="配置 SSL 支持"></a>配置 SSL 支持</h2><p>对于 TLS/SSL 协议，Nginx 使用 OpenSSL 项目。有关此开源工具包的更多信息，请访问 <a href="https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对" target="_blank" rel="noopener">https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对</a> SSL 的支持。如果使用不带–with-ssl 选项的–with-http_ssl_module 或者–with-mail_ssl_module，你正在使用执行了 configure 命令的、安装在计算机上的 OpenSSL 库。如果你想要针对特定版本的 OpenSSL 进行编译，请下载该分发包，将其解压缩到一个目录中，然后将该目录的路径指定为–with-openssl 的参数。使用–with-openssl-opt 选项为 OpenSSL本身指定额外的构建选项。</p><p>例如，为了使用具有优化椭圆曲线的 OpenSSL 来构建 Nginx，您将使用如下的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ./configure --with-http_ssl_module --with-openssl=$&#123;BUILD_DIR&#125;/openssl-1.0.1p --with-openssl-opt=enable-ec_nistp_64_gcc_128</div></pre></td></tr></table></figure><h2 id="查找并安装第三方模块"><a href="#查找并安装第三方模块" class="headerlink" title="查找并安装第三方模块"></a>查找并安装第三方模块</h2><p>由于有多个开源项目，所以在 Nginx 周围就会有一个活跃的开发社区。由于 Nginx 的模块化特性，这个社区能够开发和发布模块，从而为 Nginx 提供额外的功能。它们涵盖了广泛的应用，所以着手开发自己的模块之前应该看看有什么可用模块。</p><p>安装第三方模块的过程相当简单，步骤如下。</p><p>1.定位你想要使用的模块(在 <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 或者是 <a href="http://wiki.nginx.org/3rdPartyModules查找)。" target="_blank" rel="noopener">http://wiki.nginx.org/3rdPartyModules查找)。</a></p><p>2.下载该模块。</p><p>3.解压缩源代码安装包。</p><p>4.如果有 README 文件，那么阅读 README 文件，查看在安装中是否有依赖安装。</p><p>5.通过./configure–add-module=\<path\>选项配置使用该模块。</path\></p><p>这个过程会给你的 nginx 二进制文件与模块附加这个功能。</p><p>需要注意的是，很多第三方模块是实验性质的。因此，在将这些模块用于生产系统之前，首先要测试使用这些模块。另外请记住，Nginx 的开发版本中可能会有 API 的变化，会导致第三方模块出现问题。</p><h2 id="添加对-Lua-的支持"><a href="#添加对-Lua-的支持" class="headerlink" title="添加对 Lua 的支持"></a>添加对 Lua 的支持</h2><p>特别应该提到的是 ngx_lua 这个第三方模块，ngx_lua 模块提供了启用 Lua 的功能，而不是像 Perl 一样在配置时嵌入式脚本语言。该模块对于 perl 模块来说最大的优点就是它的无阻塞性，并与其他第三方模块紧密集成。对于它的安装说明的完整描述详见:<a href="https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过编译你自己的二进制文件，你可以定制 Nginx能够为你提供哪些功能。对于你来说，构建和安装软件应该不会陌生。所以，创造一个构建环境或者确保所有依赖关系都存在，这并不会花费你很多的时间。一个 Nginx 的安装应该是按照你的需要，能随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。</p><p>参考资料：</p><p>《精通 Nginx》第二版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。&lt;/p&gt;
&lt;p&gt;在安装 Nginx 时，我们可
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Pathogen安装VIM插件</title>
    <link href="http://www.maksim.website/2018/02/23/1/"/>
    <id>http://www.maksim.website/2018/02/23/1/</id>
    <published>2018-02-22T16:00:00.000Z</published>
    <updated>2018-06-20T03:25:08.862Z</updated>
    
    <content type="html"><![CDATA[<p>pathogen的安装其实非常简单。git上有非常全面的介绍和文档，<a href="http://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">http://github.com/tpope/vim-pathogen</a>。简单的几条命令即可搞定pathogen的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p ~/.vim/autoload ~/.vim/bundle   </div><div class="line">curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</div></pre></td></tr></table></figure><p>也就是在 ~/.vim目录下（如果没有，则新建）新建目录autoload、bundle（插件会放在这个目录），然后将pathogen放在autoload目录下即可</p><p>安装完成之后，这时候，pathogen还没有生效，需要在~/.vimrc添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execute pathogen#infect()</div></pre></td></tr></table></figure><p>如果没有~/.vimrc则需要新建文件，并添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">execute pathogen#infect()  </div><div class="line">syntax on  </div><div class="line">filetype plugin indent on</div></pre></td></tr></table></figure><p>完成之后，就可以使用pathogen管理vim插件了，只需要将插件放在~/.vim/bundle目录下即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;pathogen的安装其实非常简单。git上有非常全面的介绍和文档，&lt;a href=&quot;http://github.com/tpope/vim-pathogen&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/tpope/v
      
    
    </summary>
    
      <category term="工具" scheme="http://www.maksim.website/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>function与感叹号</title>
    <link href="http://www.maksim.website/2018/02/01/1/"/>
    <id>http://www.maksim.website/2018/02/01/1/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-06-25T12:39:27.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="function与感叹号"><a href="#function与感叹号" class="headerlink" title="function与感叹号"></a>function与感叹号</h1><p>最近有空可以让我静下心来看看各种代码，function与感叹号的频繁出现，让我回想起2个月前我回杭州最后参加团队会议的时候，<a href="http://weibo.com/exqy" target="_blank" rel="noopener">@西子剑影</a>抛出的一样的问题：<strong>如果在function之前加上感叹号 (!) 会怎么样</strong>？比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？</p><p>平时我们可能对添加括号来调用匿名函数的方式更为习惯：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>虽然上述两者括号的位置不同，不过效果完全一样。</p><p>那么，是什么好处使得为数不少的人对这种叹号的方式情有独钟？如果只是为了节约一个字符未免太没有必要了，这样算来即使一个100K的库恐怕也节省不了多少空间。既然不是空间，那么就是说也许还有时间上的考量，事实很难说清，文章的最后有提到性能。</p><p>回到核心问题，为什么能这么做？甚至更为核心的问题是，为什么必须这么做？</p><p>其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是<strong>让一个函数声明语句变成了一个表达式</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// SyntaxError: unexpected_token</span></div></pre></td></tr></table></figure><p>因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 <code>a</code>，就应该以 <code>a();</code> 的方式调用。</p><p>但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。</p><p>所以，<strong>任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别</strong>。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">10</span>&#125;();        <span class="comment">// undefined</span></div><div class="line"><span class="number">1</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;();        <span class="comment">// true</span></div><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;();        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些<strong>一元运算都是有效的</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// -1</span></div></pre></td></tr></table></figure><p>甚至下面这些关键字，都能很好的工作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// undefined</span></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// Object</span></div><div class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// undefined</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。</p><p>最后讨论下性能。我在jsperf上简单建立了一个测试：<a href="http://jsperf.com/js-funcion-expression-speed" target="_blank" rel="noopener">http://jsperf.com/js-funcion-expression-speed</a> ，可以用不同浏览器访问，运行测试查看结果。我也同时将结果罗列如下表所示（由于我比较穷，测试配置有点丢人不过那也没办法：奔腾双核1.4G，2G内存，win7企业版）：</p><table><thead><tr><th>Option</th><th>Code</th><th>Ops/sec</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Chrome 13</td><td>Firefox 6</td><td>IE9</td><td>Safari 5</td><td></td><td></td></tr><tr><td>!</td><td>!function(){;}()</td><td>3,773,196</td><td>10,975,198</td><td>572,694</td><td>2,810,197</td></tr><tr><td>+</td><td>+function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,812,238</td></tr><tr><td>-</td><td>-function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,864,155</td></tr><tr><td>~</td><td>~function(){;}()</td><td>3,551,136</td><td>3,651,652</td><td>572,694</td><td>1,876,002</td></tr><tr><td>(1)</td><td>(function(){;})()</td><td>3,914,953</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>(2)</td><td>(function(){;}())</td><td>4,075,201</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>void</td><td>void function(){;}()</td><td>4,030,756</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>new</td><td>new function(){;}()</td><td>619,606</td><td>299,100</td><td>407,104</td><td>816,903</td></tr><tr><td>delete</td><td>delete function(){;}()</td><td>4,816,225</td><td>12,135,960</td><td>572,694</td><td>2,693,524</td></tr><tr><td>=</td><td>var i = function(){;}()</td><td>4,984,774</td><td>12,135,960</td><td>565,982</td><td>2,602,630</td></tr><tr><td>&amp;&amp;</td><td>1 &amp;&amp; function(){;}()</td><td>5,307,200</td><td>4,393,486</td><td>572,694</td><td>2,565,645</td></tr><tr><td>\</td><td>\</td><td></td><td>0 \</td><td>\</td><td>function(){;}()</td><td>5,000,000</td><td>4,406,035</td><td>572,694</td><td>2,490,128</td></tr><tr><td>&amp;</td><td>1 &amp; function(){;}()</td><td>4,918,209</td><td>12,135,960</td><td>572,694</td><td>1,705,551</td></tr><tr><td>\</td><td></td><td>1 \</td><td>function(){;}()</td><td>4,859,802</td><td>12,135,960</td><td>572,694</td><td>1,612,372</td></tr><tr><td>^</td><td>1 ^ function(){;}()</td><td>4,654,916</td><td>12,135,960</td><td>572,694</td><td>1,579,778</td></tr><tr><td>,</td><td>1, function(){;}()</td><td>4,878,193</td><td>12,135,960</td><td>572,694</td><td>2,281,186</td></tr></tbody></table><p>可见不同的方式产生的结果并不相同，而且，差别很大，因浏览器而异。</p><p>但我们还是可以从中找出很多共性：<strong>new方法永远最慢</strong>——这也是理所当然的。其它方面很多差距其实不大，但有一点可以肯定的是，感叹号并非最为理想的选择。反观<strong>传统的括号，在测试里表现始终很快</strong>，在大多数情况下比感叹号更快——所以平时我们常用的方式毫无问题，甚至可以说是最优的。<strong>加减号在chrome表现惊人</strong>，而且在其他浏览器下也普遍很快，相比感叹号效果更好。</p><p>当然这只是个简单测试，不能说明问题。但有些结论是有意义的：括号和加减号最优。</p><p>但是为什么这么多开发者钟情于感叹号？我觉得这只是一个习惯问题，它们之间的优劣完全可以忽略。一旦习惯了一种代码风格，那么这种约定会使得程序从混乱变得可读。如果习惯了感叹号，我不得不承认，它比括号有更好的可读性。我不用在阅读时留意括号的匹配，也不用在编写时粗心遗忘——</p><p>当我也这么干然后嚷嚷着这居然又节省了一个字符而沾沾自喜的时候，却忘了自己仓皇翻出一本卷边的C语言教科书的窘迫和荒唐……任何人都有忘记的时候，当再捡起来的时候，捡起的就已经不单单是忘掉的东西了。</p><p>2011-10-31更新：如果你使用aptana，那么在使用（!+-）时要注意一点，它们会让aptana的解析失效，导致Outline窗口没有任何显示。但是就代码本身而言，其运行没有任何问题。</p><blockquote><p>本文转自扩葵中剑的博客</p><p>原文地址：<a href="https://swordair.com/function-and-exclamation-mark/" target="_blank" rel="noopener">https://swordair.com/function-and-exclamation-mark/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;function与感叹号&quot;&gt;&lt;a href=&quot;#function与感叹号&quot; class=&quot;headerlink&quot; title=&quot;function与感叹号&quot;&gt;&lt;/a&gt;function与感叹号&lt;/h1&gt;&lt;p&gt;最近有空可以让我静下心来看看各种代码，function与感叹
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.maksim.website/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（9）：数据库缓存</title>
    <link href="http://www.maksim.website/2018/01/14/1/"/>
    <id>http://www.maksim.website/2018/01/14/1/</id>
    <published>2018-01-13T16:00:00.000Z</published>
    <updated>2018-06-27T13:23:46.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是数据库缓存"><a href="#什么是数据库缓存" class="headerlink" title="什么是数据库缓存"></a>什么是数据库缓存</h1><p><strong>MySQL</strong> 等一些常见的关系型数据库的数据都存储在硬盘当中，在高并发场景下，业务应用对 MySQL 产生的增、删、改、查的操作造成巨大的I/O开销和查询压力，这无疑对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生。</p><p>使用数据库缓存可以极大的解决我们数据的压力，提高应用数据的响应速度，因为不用再动态查询了，直接将静态数据返回，无论是速度还是效率都要更快一些，节省了，很多查询和计算的时间。</p><p>常见的缓存形式：内存缓存，文件缓存</p><p>为了避免I/O开销，应该尽量使用内存缓存。</p><h1 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h1><p>缓存诗句是为了让客户端很少，甚至是不访问数据库服务器进行数据的查询，高并发下，能最大程度地降低对数据库服务器的访问压力。</p><p>当我们默认情况下<strong>不使用缓存</strong>的情况下，我们的执行顺序如下：</p><ol><li>用户请求</li><li>数据查询</li><li>链接数据库服务器并查询数据</li><li>将数据缓存起来（HTML、内存、JSON、序列化数据）</li><li>显示给客户端</li></ol><p>当我们第二次请求或者是新用户访问时候，执行顺序如下：</p><ol><li>用户再次请求或者新用户访问</li><li>数据查询</li><li>直接从缓存中获取数据</li><li>显示给客户端</li></ol><h2 id="缓存需要考虑的内容"><a href="#缓存需要考虑的内容" class="headerlink" title="缓存需要考虑的内容"></a>缓存需要考虑的内容</h2><ul><li><p>缓存方式的选择</p></li><li><p>缓存场景的选择</p></li><li><p>缓存数据的实时性</p></li><li>缓存数据的稳定性</li></ul><h1 id="使用-MySQL查询缓存"><a href="#使用-MySQL查询缓存" class="headerlink" title="使用 MySQL查询缓存"></a>使用 MySQL查询缓存</h1><p>启用MySQL查询缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query_cache_type</div></pre></td></tr></table></figure><p>查询缓存类型，有0、1、2三个取值。</p><ul><li>0 不是用查询缓存</li><li>1 始终使用查询缓存</li><li>2 按需查询缓存</li></ul><p>query_cache_type为1时，也可以关闭查询缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span>　my_table <span class="keyword">WHERE</span> condition;</div></pre></td></tr></table></figure><p>query_cache_type为2时，可以按需使用查询缓存</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SQL_CACHE</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> condition;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query_cache_size</div></pre></td></tr></table></figure><p>默认情况下query_cache_size为0，表示查询缓存预留的内存为0，则无法使用查询缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SET GLOBAL query_cache_size = 134217728;</div></pre></td></tr></table></figure><p>查询缓存可以看成是 SQL 文本和查询结果的映射。</p><p>第二查询的SQL和第二次查询的SQL要完全相同，才会使用缓存。</p><p>我们可以通过下面的语句查看缓存的命中次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SHOW STATUS LIKE &apos;Qcache_hits&apos;;</div></pre></td></tr></table></figure><p>表的结构发生改变时候，查询缓存中的数据不再有效。</p><p>清理缓存如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FLUSH QUERY CACHE;  //清理查询缓存内部碎片</div><div class="line">RESET QUERY CACHE;  //从查询花村中移出所有查询</div><div class="line">FLUSH TABLES;//关闭所有打开的表，同时该操作将会清空查询缓存中的内容。</div></pre></td></tr></table></figure><h1 id="使用-Memcache"><a href="#使用-Memcache" class="headerlink" title="使用 Memcache"></a>使用 Memcache</h1><p>对于大型的站点，如果没有中间缓存层，当流量打入数据库层的时候，即便有之前的几层为我们挡住了大量流量，但是在大并发的请胯下，还是会有大量请求涌入数据库，这样对于数据库服务器的压力冲击很大，响应速度也会下降，因此添加中间缓存层很有必要。</p><p>Memcache 是一套分布式的高速缓存系统， 由 LiveJournal 的Brad Fitzpatrick 开发，但目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Memcache 是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的Hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索出来的结果等。简单的说就是讲数据调用到内存，然后从内存中读取，从而大大提高读取速度。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>先检查服务端的请求数据是否在 <code>memcached</code>中，如果存在直接把请求数据返回，不再对数据库进行任何操作。如果请求的数据不再<code>memcached</code>中，就去查询数据库, 把从数据库中获取的诗句返回给客户端，同时把数据缓存一份到<code>memcached</code>中。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>获取：get(key)</p><p>设置：set(key, val, expire)</p><p>删除 : delete(key)</p><h2 id="通用缓存机制"><a href="#通用缓存机制" class="headerlink" title="通用缓存机制"></a>通用缓存机制</h2><p>用查询的方法名 + 参数作为查询时的key value对应中的key值。</p><h1 id="使用-Redis"><a href="#使用-Redis" class="headerlink" title="使用 Redis"></a>使用 Redis</h1><h2 id="与Memcache的区别"><a href="#与Memcache的区别" class="headerlink" title="与Memcache的区别"></a>与Memcache的区别</h2><ul><li>性能相差不大</li><li>Redis 在2.0版本后增加了自己的 VM 特性，突破了物理内存的限制</li><li>Memcache 可以修改最大可用内存，采用 LRU（缓存淘汰） 算法</li><li>Redis 依赖客户端来实现分布式读写</li><li>Memcache 本身没有数据冗余机制</li><li>Redis 支持（快照、AOF），依赖快照进行持久化，AOF 增强了可靠性的同时，对性能也有所影响</li><li>Memcache 不支持持久化，通常做缓存，提升性能</li><li>Memcache 在并发场景下，用 cas 保证一致性，Redis 事务支持比较弱，只能保证事务中的每个操作的连续执行</li><li>Redis 支持多种数据类型</li><li>Redis 用于数据量较小的高性能操作和运算上</li><li>Memcache 用于动态系统中减少数据库负载，提升性能；适合做缓存，提高性能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是数据库缓存&quot;&gt;&lt;a href=&quot;#什么是数据库缓存&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库缓存&quot;&gt;&lt;/a&gt;什么是数据库缓存&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;MySQL&lt;/strong&gt; 等一些常见的关系型数据库的数据都存储在硬盘当中
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（10）：MySQL优化</title>
    <link href="http://www.maksim.website/2018/01/14/2/"/>
    <id>http://www.maksim.website/2018/01/14/2/</id>
    <published>2018-01-13T16:00:00.000Z</published>
    <updated>2018-06-25T12:49:07.254Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，并没有实现过程，算是一个提纲，当我们需要对MySQL进行优化的时候，可以通过本篇文章，了解一下，我们要对MySQL进行哪些优化，也算是对MySQL的优化先要有一个总体的认知。</p><p>因为如果要将所有的操作过程都放到这篇文章中，估计还没等看完，你就已经睡着了，具体的操作，我会在其他系列的博文中陆续的更新出来。</p><h1 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h1><ul><li>数据表数据类型优化</li><li>索引优化</li><li>SQL 语句优化</li><li>存储引擎的优化</li><li>数据表结构设计的优化</li><li>数据库服务器架构的优化</li></ul><h1 id="数据表数据类型优化"><a href="#数据表数据类型优化" class="headerlink" title="数据表数据类型优化"></a>数据表数据类型优化</h1><p>在做数据表结构类型优化时，我们需要考虑如下几点：</p><ul><li>字段使用什么样的数据类型更合适</li><li>字段使用什么样的数据类型性能更快</li></ul><h3 id="Int-tinyint、smallint、bigint"><a href="#Int-tinyint、smallint、bigint" class="headerlink" title="Int: tinyint、smallint、bigint"></a>Int: tinyint、smallint、bigint</h3><p>在使用Int类型存储值的时候，一定要按需选择，需要对空间、范围进行考虑，比如存储年龄通常是0~120多，所以我们选择一个最小的tinyint类型，如果加上无符号那么最大值是255，足够我们存储年龄，选择smallint或者bigint明显是一种浪费。</p><h3 id="char、varchar"><a href="#char、varchar" class="headerlink" title="char、varchar"></a>char、varchar</h3><p>char 的空间效率要比 varchar 要好，如果是存储电话号码，固定为11位，这种类似的需求，使用char要更好。</p><p>对于varchar存储一些可变的数据，如用户名。</p><p>###　enum</p><p>特性、固定的分类可以使用 enum 存储，效率更快。</p><p>一定要是固定的分类，如果将来的分类会变，就不适合使用enum，因为这样我们就需要去修改数据库表结构，扩展性会变得很差。</p><h3 id="IP-地址的存储"><a href="#IP-地址的存储" class="headerlink" title="IP 地址的存储"></a>IP 地址的存储</h3><p>IP 地址一般会采用字符型来进行存储，但是这种存储方式会带来很大的空间占用，我们可以使用整型来进行存储，PHP为我们提供了转换函数 <code>ip2lang</code></p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>在做索引型优化时，我们需要考虑如下几点：</p><ul><li>建立合适的索引</li><li>索引在什么场景下效率最高</li></ul><h2 id="索引的创建原则"><a href="#索引的创建原则" class="headerlink" title="索引的创建原则"></a>索引的创建原则</h2><ul><li><p>索引不是越多越好，在合适的字段上创建合适的索引，索引本身会影响我们的写操作的速度，并且会占用磁盘空间。</p></li><li><p>符合索引的前缀原则。</p></li></ul><h2 id="索引的注意事项"><a href="#索引的注意事项" class="headerlink" title="索引的注意事项"></a>索引的注意事项</h2><ul><li>符合索引的前缀原则</li><li>like 查询%的问题</li><li>全表扫描优化</li><li>or 条件索引使用情况</li><li>字符串类型索引失效的问题</li></ul><h1 id="SQL-语句的优化"><a href="#SQL-语句的优化" class="headerlink" title="SQL 语句的优化"></a>SQL 语句的优化</h1><ul><li>优化查询过程中的数据访问<ul><li>使用Limit</li><li>返回列不用 *</li></ul></li><li>优化长难句的查询语句<ul><li>变复杂为简单</li><li>切分查询</li><li>分解关联查询</li></ul></li><li>优化特定类型的查询语句<ul><li>优化count()</li><li>优化关联查询</li><li>优化子查询</li><li>优化 Group by 和 distinct</li><li>优化 limit 和 union</li></ul></li></ul><h1 id="存储引擎的优化"><a href="#存储引擎的优化" class="headerlink" title="存储引擎的优化"></a>存储引擎的优化</h1><ul><li>尽量使用 <code>InnoDB</code> 存储引擎</li></ul><h1 id="数据表结构设计的优化"><a href="#数据表结构设计的优化" class="headerlink" title="数据表结构设计的优化"></a>数据表结构设计的优化</h1><ul><li>分区操作<ul><li>通过特定的策略对数据表进行物理拆分</li><li>对用户透明</li><li>partition by</li></ul></li><li>分库分表<ul><li>水平拆分</li><li>垂直拆分</li></ul></li></ul><h1 id="数据库架构的优化"><a href="#数据库架构的优化" class="headerlink" title="数据库架构的优化"></a>数据库架构的优化</h1><ul><li>主从复制</li><li>读写分离</li><li>双主热备</li><li>负载均衡<ul><li>通过 <code>LVS</code> 的三种基本模式实现负载均衡</li><li><code>MyCat</code> 数据库中间件实现负载均衡。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本文中，并没有实现过程，算是一个提纲，当我们需要对MySQL进行优化的时候，可以通过本篇文章，了解一下，我们要对MySQL进行哪些优化，也算是对MySQL的优化先要有一个总体的认知。&lt;/p&gt;
&lt;p&gt;因为如果要将所有的操作过程都放到这篇文章中，估计还没等看完，你就已经睡着了
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（11）：Web服务器负载均衡</title>
    <link href="http://www.maksim.website/2018/01/14/3/"/>
    <id>http://www.maksim.website/2018/01/14/3/</id>
    <published>2018-01-13T16:00:00.000Z</published>
    <updated>2018-06-27T12:00:17.955Z</updated>
    
    <content type="html"><![CDATA[<p>负载均衡，英文名称为 <code>LoadBalance</code>，其意思就是将负载(工作任务)进行平衡，分摊到多个操作单元上进行执行(例如Web服务器、FTP服务器等)，实现多个服务器共同完成工作任务的目标。负载均衡建立在现有网络结构之上，它提升了服务器的性能、提高了带宽利用率，增强了网络的灵活性和可靠性。</p><h1 id="七层负载均衡的实现"><a href="#七层负载均衡的实现" class="headerlink" title="七层负载均衡的实现"></a>七层负载均衡的实现</h1><p>基于URL等应用层信息的负载均衡，Nginx 的 proxy 是它一个很强大的功能，实现了7层负载均衡。</p><ul><li>功能强大，性能卓越，运行稳定</li><li>配置简单灵活</li><li>能够自动剔除工作不正常的后端服务器</li><li>上传文件可以使用异步模式</li><li>支持多种分配策略，可以分配权重，分配方式灵活</li></ul><p>NGINX 拥有两种策略：<strong>内置策略</strong>、<strong>扩展策略</strong></p><p>内置策略是NGINX安装后内置，开箱即用的均衡策略，而扩展策略反之，需要我们安装特定的模块才能进行使用。</p><p>内置策略： IP Hash、加权轮询</p><p>扩展策略：fair策略、通用hash、一致性hash。</p><p><strong>加权轮询：</strong>首先将请求都发给高权的机器，直到该机器的权值降到了比其他机器底，才开始将请求分给下一个高权重的机器。当所有后端机器都 down 掉时，NGINX 会立即将所有机器的标志位清成初始状态，以避免所有的机器都处于 timeout 的状态。</p><p><strong>IP Hash：</strong> 流程和轮询很类似，只是其中的算法和具体的策略有些变化，IP HASH算法算是一种变相的轮询算法。</p><p><strong>fair 策略：</strong>根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流。</p><p><strong>通用hash、一致性hash：</strong>比较简单，可以以 NGINX 内置的变量为key进行hash，一致性hash采用了NGINX内置的一致性Hash环，支持 memcache。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    upstream cluster &#123;</div><div class="line">        ip hash;</div><div class="line">        server serv1;</div><div class="line">        server serv2;</div><div class="line">        server serv3;</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        listen 80;</div><div class="line">        location/ &#123;</div><div class="line">            proxy_pass http://cluster;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="四层负载均衡的实现"><a href="#四层负载均衡的实现" class="headerlink" title="四层负载均衡的实现"></a>四层负载均衡的实现</h1><p>通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>LVS 实现服务器集群负载均衡有三种方式，NAT，DR 和TUN。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;负载均衡，英文名称为 &lt;code&gt;LoadBalance&lt;/code&gt;，其意思就是将负载(工作任务)进行平衡，分摊到多个操作单元上进行执行(例如Web服务器、FTP服务器等)，实现多个服务器共同完成工作任务的目标。负载均衡建立在现有网络结构之上，它提升了服务器的性能、提高了
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（7）：动态语言静态化</title>
    <link href="http://www.maksim.website/2018/01/13/3/"/>
    <id>http://www.maksim.website/2018/01/13/3/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-06-25T12:48:51.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是动态语言静态化"><a href="#什么是动态语言静态化" class="headerlink" title="什么是动态语言静态化"></a>什么是动态语言静态化</h1><p>将现有 PHP 等动态语言的逻辑代码生成为静态HTML 文件，用户访问动态脚本重定向到静态 HTML 文件的过程。</p><p>如果页面中的的数据一直都在变化，那么不建议使用静态化。</p><h1 id="为什么要静态化"><a href="#为什么要静态化" class="headerlink" title="为什么要静态化"></a>为什么要静态化</h1><p>动态脚本通常会做逻辑运算和数据查询，访问量越大，服务器压力越大。</p><p>访问量大的时候可能造成 CPU 负载过高，数据服务器压力过大，静态化可以减轻逻辑处理能力，降低数据库服务器的查询压力。</p><h1 id="静态化的实现方式"><a href="#静态化的实现方式" class="headerlink" title="静态化的实现方式"></a>静态化的实现方式</h1><h2 id="使用模板引擎"><a href="#使用模板引擎" class="headerlink" title="使用模板引擎"></a>使用模板引擎</h2><p>可以使用 Smarty 的缓存机制生成静态 HTML 缓存文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$smarty-&gt;cache_dir = $ROOT.<span class="string">'/cache'</span>; <span class="comment">//缓存目录</span></div><div class="line">$smarty-&gt;caching = <span class="keyword">true</span>;    <span class="comment">//是否开启缓存</span></div><div class="line">$smarty-&gt;cache_lifetime = <span class="string">'3600'</span>;    <span class="comment">//缓存时间</span></div></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$smarty-&gt;display(strign template [,string cache_id[, strign compile_id]]);</div></pre></td></tr></table></figure><p>如果开启了缓存，Smarty 会自动的生成 HTML 缓存文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$smarty-&gt;clear_all_cache();<span class="comment">//清除所有缓存</span></div><div class="line">$smarty-&gt;clear_cache(<span class="string">'file.html'</span>);<span class="comment">//清除指定缓存</span></div><div class="line">$smarty-&gt;clear_cache(<span class="string">'article,html'</span>, $cache_id) <span class="comment">//清除一同模板下的指定缓存号的缓存。</span></div></pre></td></tr></table></figure><h2 id="利用-OB-系列函数"><a href="#利用-OB-系列函数" class="headerlink" title="利用 OB 系列函数"></a>利用 OB 系列函数</h2><ul><li>ob_start()：打开输出控制缓冲</li><li>ob_get_contents()：返回输出缓冲区的内容</li><li>ob_clean()：清空输出缓冲区</li><li>ob_end_flush()：冲刷出（送出）输出缓冲区内容并且关闭缓冲</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ob_start();</div><div class="line">输出到页面的 HTML 代码</div><div class="line">ob_get_contents();</div><div class="line">ob_end_flush();</div><div class="line">fopen()写入</div></pre></td></tr></table></figure><p>可以使用 filectime 函数 判断文件的 inode 修改时间，判断是否过期。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$cache_name = md5(<span class="keyword">__FILE__</span>).<span class="string">'html'</span>;</div><div class="line">$cache_lifetime = <span class="number">3600</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( filectime(<span class="keyword">__FILE__</span>) &lt;= filectime($cache_name) file_exists($cache_name) &amp;&amp; filectime($cache_name) + $cache_lifetime &gt; time()) &#123;</div><div class="line">    <span class="comment">//判断 PHP 文件修改时间</span></div><div class="line"><span class="comment">//判断是否存在缓存</span></div><div class="line"><span class="comment">//判断是否过期</span></div><div class="line">    <span class="keyword">include</span> $cache_name;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line">ob_start();</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;b&gt; This is my Script&lt;/b&gt;</div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$content = ob_get_contents();    </div><div class="line">$ob_end_flush();</div><div class="line">$handle = fopen($cache_name, <span class="string">'w'</span>);</div><div class="line">fwrite($handle, $content);</div><div class="line">fclose($handle);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是动态语言静态化&quot;&gt;&lt;a href=&quot;#什么是动态语言静态化&quot; class=&quot;headerlink&quot; title=&quot;什么是动态语言静态化&quot;&gt;&lt;/a&gt;什么是动态语言静态化&lt;/h1&gt;&lt;p&gt;将现有 PHP 等动态语言的逻辑代码生成为静态HTML 文件，用户访问动态脚
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（5）： CDN 加速</title>
    <link href="http://www.maksim.website/2018/01/13/1/"/>
    <id>http://www.maksim.website/2018/01/13/1/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-06-25T12:48:38.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h1><p>CDN 的全城是 Content Delivery Network，即内容分发网络，尽可能避开互联网上有可能影响数据传输速度和稳定性的平静和环节，是内容传输的更快、更稳定。</p><p>在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层只能虚拟网络，比如说我们现在有一个服务器的集群，现在在北京，有几台服务器在北京，在上海访问北京服务器就会比较慢，我们就可以使用 CDN 解决这样的问题，可以在香港、上海建立一个 CDN 节点，这样当我的用户在某一个节点访问我们的网站时，可以去请求香港的 CDN 节点，这样距离他比较近，CDN 已经把真实服务器的数据缓存到了 CDN 当中，相当于一个镜像。</p><p>CDN 系统能够实时地根据网络流量和各节点的连接、敷在情况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p><h1 id="使用-CDN-的优势"><a href="#使用-CDN-的优势" class="headerlink" title="使用 CDN 的优势"></a>使用 CDN 的优势</h1><p>本地 Cache 加速，提高企业站点（尤其含有大量图片和静态资源页面站点）的访问速度。</p><p>跨运营商的网络加速，保证不同网络的用户能得到最好的访问质量。</p><p>远程访问用户根据 DNS 负载均衡技术只能选择 Cache 服务器。</p><p>自动生成服务器的远程 Mirror（镜像）Cache 服务器，远程用户访问时从 Cache 服务器上读取数据，减少远程访问的带宽、分带网络流量、减轻原站点 WEB 服务器负载等能力。</p><p>广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵。</p><h1 id="CDN-的工作原理"><a href="#CDN-的工作原理" class="headerlink" title="CDN 的工作原理"></a>CDN 的工作原理</h1><h2 id="传统访问"><a href="#传统访问" class="headerlink" title="传统访问"></a>传统访问</h2><p>用户在浏览器输入域名发起请求–&gt;解析域名获取服务器 IP 地址–&gt;根据 IP 地址找到对应的服务器—&gt;服务器响应并返回。</p><h2 id="使用-CDN-访问"><a href="#使用-CDN-访问" class="headerlink" title="使用 CDN 访问"></a>使用 CDN 访问</h2><p>用户发起请求–&gt;只能 DND 解析（根据 IP 判断地理位置、接入网类型、选择路由最短和负载最轻的服务器）–&gt;获得缓存服务器 IP–&gt;把内容返回给用户（如果缓存中有）—&gt;向源站发起请求—&gt;将结果返回给用户—&gt;将结果存入缓存服务器。</p><h1 id="CDN-适用场景"><a href="#CDN-适用场景" class="headerlink" title="CDN 适用场景"></a>CDN 适用场景</h1><ul><li>站点或者应用中大量静态资源的加速分发，例如：CSS，JS，图片和 HTML。</li><li>大文件下载</li><li>直播网站</li></ul><h1 id="CDN-的实现"><a href="#CDN-的实现" class="headerlink" title="CDN 的实现"></a>CDN 的实现</h1><p>BAT 等都有提供 CDN 服务。</p><p>可用 LVS 做4层负载均衡。</p><p>可用 Nginx，Varnish，Squid，Apache TrafficServer 做7层负载均衡和 Cache。</p><p>使用 squid 反向代理，或者 Nginx 等的反向代理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是CDN&quot;&gt;&lt;a href=&quot;#什么是CDN&quot; class=&quot;headerlink&quot; title=&quot;什么是CDN&quot;&gt;&lt;/a&gt;什么是CDN&lt;/h1&gt;&lt;p&gt;CDN 的全城是 Content Delivery Network，即内容分发网络，尽可能避开互联网上有可能
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（8）：独立图片服务器的部署</title>
    <link href="http://www.maksim.website/2018/01/13/4/"/>
    <id>http://www.maksim.website/2018/01/13/4/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-06-27T13:22:58.702Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="独立图片服务器的必要性"><a href="#独立图片服务器的必要性" class="headerlink" title="独立图片服务器的必要性"></a>独立图片服务器的必要性</h1><p>我们知道，无论对于Apache还是Nginx，图片始终是最消耗系统资源的，如果将图片服务和应用服务放在同一个服务器的话，应用服务器很容易会因为图片的 高I/O负载而崩溃，因此对于有些大型网站项目，我们有必要将图片服务器和应用服务器分离。</p><p>部署独立的图片服务器（甚至是服务器集群）是大型网站图片存储解决方案中最基础的，因为有了独立的图片服务器后，我们才能对图片服务器做更有针对性的性能优化，为图片服务器设置针对性的缓存方案，减少带宽成本，提高访问速度。</p><p>从硬件角度说，图片服务器可以配置高端的硬盘，7200转的换成15000转的，而CPU只需要使用一般的CPU就可以了。</p><p>从软件角度说，可以为图片服务器配置特殊的文件系统来满足对图片的I/O请求，如淘宝 的TFS，就很好地解决了大规模小图片文件带来的I/O噩梦，同时，我们也可以采用Nginx、squid来代理图片请求，通过增加图片服务器，提高图片吞吐能力。</p><p>分担 Web 服务器的 I/O 负载-将耗资源的图片服务分离出来，提高服务器的性能、稳定性和扩展性。</p><h1 id="采用独立域名"><a href="#采用独立域名" class="headerlink" title="采用独立域名"></a>采用独立域名</h1><p>注意，这里是指独立域名，不是子域哦，比如yahoo.com图片服务器用了yimg.com的域名，而不是用二级域名img.yahoo.com。</p><p>同一域名下浏览器的并发链接数有限制，突破浏览器链接数的限制，通常情况下浏览器的并发连接数是2到6个。</p><p>这样，我们如果给图片服务器配置独立的域名，那么在一个页面中加载图片时，就可以突破浏览器连接数的限制，理论上，增加一个独立域名，并发连接数加倍。  </p><p>另外还有由于 Cookie 的原因，大部分 Web Cache都只缓存不带 Cookie 的请求，导致每次的图片请求都不能命中 Cache。而仍旧要去原始服务器获取图片，导致图片缓存意义不大。所以，还是给单独搞一个图片独立域名吧，当然，不只是图片，CSS和JavaScript文件也可以参照这个思路来搞。  </p><h1 id="如何进行图片上传和图片同步"><a href="#如何进行图片上传和图片同步" class="headerlink" title="如何进行图片上传和图片同步?"></a>如何进行图片上传和图片同步?</h1><h2 id="NFS-共享方式"><a href="#NFS-共享方式" class="headerlink" title="NFS 共享方式"></a>NFS 共享方式</h2><p>NFS是Network  File System（网络文件系统）。主要功能是通过网络让不同的服务器之间可以共享文件或者目录。</p><p>NFS客户端一般是应用服务器（比如web，负载均衡等），可以通过挂载的方式将NFS服务器端共享的目录挂载到NFS客户端本地的目录下。       </p><p>NFS在文件传送过程中依赖与RPC（远程过程调用）协议。NFS本身是没有提供信息传送的协议和功能的，但是能够用过网络进行图片，视频，附件等分享功能。只要用到NFS的地方都需要启动RPC服务，不论是NFS的服务端还是客户端。       </p><p>NFS和RPC的关系：可以理解为NFS是一个网络文件系统（比喻为租房的房主），而RPC是负责信息的传输（中介），客户端（相当于租房的租客） </p><p>了解 NFS 可以看我的另外一篇博文《LInux 典型应用：》</p><h2 id="利用-FTP-同步"><a href="#利用-FTP-同步" class="headerlink" title="利用 FTP 同步"></a>利用 FTP 同步</h2><p>用户上传完图片后是利用 FTP 同步到各个图片服务器的，PHP、Java、Asp.net基本上都能操作 FTP。这样的话 每个图片服务器就都保存一份图片的副本，也起到了备份的作用。但是缺点是将图片ftp到服务器比较耗时，如果异步去同步的话又会有延时，不过一般的小图片 文件也还好了。  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h1 id=&quot;独立图片服务器的必要性&quot;&gt;&lt;a href=&quot;#独立图片服务器的必要性&quot; class=&quot;headerlink&quot; title=&quot;独立图片服务器的必要性&quot;&gt;&lt;/a&gt;独立图片服务器的必要性&lt;/h1&gt;&lt;p&gt;我们知道，无论对于Apache还是Nginx，图片
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（6）：动态语言并发处理</title>
    <link href="http://www.maksim.website/2018/01/13/2/"/>
    <id>http://www.maksim.website/2018/01/13/2/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-06-25T12:48:45.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是进程、线程、协程"><a href="#什么是进程、线程、协程" class="headerlink" title="什么是进程、线程、协程"></a>什么是进程、线程、协程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p><h3 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h3><p>进程的三态模型：多道程序系统中，进程在处理器上交替运行，状态不断地发生变化</p><p><strong>运行：</strong>当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单机处理系统，处于运行状态的进程只有一个。没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。</p><p><strong>就绪</strong>：当一个程序获得了除处理机意外的一切所需资源，一旦得到处理机即可运行，则称此进程出于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程处于时间片用完而进入就绪状态时，排入低优先级队列；当前进程由 I/O 操作完成而进入就绪状态时，排入高优先队列。</p><p><strong>阻塞：</strong>也称之为等待或者睡眠状态，一个进程正在等待某一事件发生（例如请求 I/O而等待 I/O 完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程出于阻塞状态。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180621140421.png" alt=""></p><h3 id="进程的五态模型"><a href="#进程的五态模型" class="headerlink" title="进程的五态模型"></a>进程的五态模型</h3><p>进程的五态模型：对于一个实际的系统，进程的状态及其转换更为复杂分为新建态、活跃就绪/静止就绪、运行、活跃阻塞/静止阻塞、终止态,可见下图。</p><p><img src="http://blog.51cto.com/attachment/201302/105409473.png" alt=""></p><p><strong>新建态：</strong>对应于进程刚刚被创建时没有被提交的状态，并等待系统完成创建进程的所有必要信息。</p><p><strong>活跃就绪：</strong>是指进程在主内存并且可被调度的状态。</p><p><strong>静止就绪（挂起就绪）：</strong>是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将被挂起就绪态进程调回主存并转化为活跃就绪。</p><p><strong>活跃阻塞</strong>：是指进程已在主存，一旦等待事件产生便进入活跃就绪状态</p><p><strong>静止阻塞：</strong>进程对换到辅存时的阻塞状态，一旦等地啊的事件产生便进入静止就绪状态。</p><p><strong>终止态：</strong>进程已经结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中有关信息。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>由于我们用户的并发请求，为每一个请求都创建一个进程显然是行不通的，从系统资源开销方面或是响应用户请求的效率方面来看。因此系统中线程概念便被引进了。</p><p>线程，有时被称之为轻量级的进程（Lightweight Process, LWP），是程序执行流的最小单元。</p><p>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属的一个进程的其他线程共享进程所拥有的全部资源。</p><p>一个线程可以创建和撤销另一个线程，统一进程的多个线程之间可以并发执行。</p><p>线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。</p><p>在单个程序中同事运行多个线程完成不同的工作，称之为<strong>多线程。</strong></p><p>每一个程序都只要有一个线程，若程序只有一个线程，那就是程序本身。</p><p>线程的状态：<strong>就绪</strong>、<strong>阻塞</strong>、<strong>运行</strong>。</p><p><strong>就绪状态：</strong>线程具备运行的所有条件，逻辑上可以运行，在等待处理机。</p><p><strong>阻塞状态：</strong>线程在等待一个事件（如某个信号量），逻辑上不可执行。</p><p><strong>运行状态：</strong>线程占有处理机正在运行。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程已拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈基本没有内核切换开销，可以不加锁访问全局变量，所以上下文的切换非常快。</p><p>如果想要深入的了解协程的实现，可以读鸟哥有关于协程的博文，里面详细介绍了PHP协程 的实现——<a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="noopener">传送门</a>。</p><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><ol><li>线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间。</li><li>进程是资源分配和拥有的单元，同一个进程内的线程共享进程的资源。</li><li>线城市处理器调度的基本单位，进程不是。</li><li>两者均可并发执行</li><li>每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li></ol><h2 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h2><ol><li>一个线程可以有多个协程，一个协程也可以单独拥有多个协程</li><li>线程进程都是同步机制，而协程这是异步</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</li></ol><h1 id="什么是多进程，多线程"><a href="#什么是多进程，多线程" class="headerlink" title="什么是多进程，多线程"></a>什么是多进程，多线程</h1><p><strong>多进程</strong>是指同一时间里，统一计算机系统中如果允许两个或者两个以上的进程处于运行状态，就是多进程。多开一个进程，多分配一份资源，进程间通信不方便。</p><p><strong>多线程</strong>就是把一个进程分为很多片，每一片都可以是一个独立的流程与多进程的却别是只会使用一个进程的资源，线程间可以直接通信。</p><h1 id="同步阻塞模型"><a href="#同步阻塞模型" class="headerlink" title="同步阻塞模型"></a>同步阻塞模型</h1><p>在最早的服务器端程序透视通过多进程、多线程来解决并发IO的问题。</p><p>一个请求创建一个进程，然后子进程进入循环同步阻塞地与客户端进行交互，收发处理数据。</p><p>多线程模式实现非常简单，线程可以直接向某一个客户端连接发送数据。</p><p>步骤：</p><ol><li>创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现。</li><li>进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入睡眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket</li><li>主进程在多进程模型下通过fork（PHP: pcntl_fork）创建子进程，多线程模型下使用pthread_create（PHP: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。</li><li>子进程创建成功后进入while循环，阻塞在recv（PHP: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（PHP: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。</li><li>当客户端连接关闭时，子进程/线程退出并销毁所有资源。主进程/线程会回收掉此子进程/线程。</li></ol><p>缺点：</p><ul><li>这种模型严重依赖进程的数量解决并发问题，一个客户端连接就需要占用一个进程，工作进程的数量有多少，并发处理能力就有多少。操作系统可以创建的进程数量是有限的。</li><li>启动大量进程会带来额外的进程调度消耗。数百个进程时可能进程上下文切换调度消耗占CPU不到1%可以忽略不计，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到 CPU 的百分之几十甚至 100%。</li></ul><p>另外有一些场景多进程模型无法解决，比如即时聊天程序（IM），一台服务器要同时维持上万甚至几十万上百万的连接（经典的C10K问题），多进程模型就力不从心了。</p><p>还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100 ms，100个进程可以提供1000 QPS，这样的处理能力还是不错的。但是如果请求内要调用外网HTTP接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到QPS，这样的处理能力就太差了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建scoket监听</span></div><div class="line">$scokserv = stream_scoket_server(<span class="string">'tcp://0.0.0.0:8880'</span>, $errno, $errstr);</div><div class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">5</span>; $i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>（pcntl_fork() == <span class="number">0</span>） &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            $conn = stream_scoket_accept($sockserv);</div><div class="line">            <span class="keyword">if</span> ($conn == <span class="keyword">false</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            $request = fread($conn, <span class="number">9000</span>);</div><div class="line">            $response = <span class="string">'hello'</span>;</div><div class="line">            fwrite($conn, $response);</div><div class="line">            fclose($conn);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">exit</span>();</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="异步非阻塞模型"><a href="#异步非阻塞模型" class="headerlink" title="异步非阻塞模型"></a>异步非阻塞模型</h1><p>现在各种高并发异步IO的服务器程序都是基于 <strong>epoll</strong> 实现的。</p><p>在早期Linux就提供了<strong>select</strong>，可以在一个进程内维持1024个连接，后来加入了<strong>poll</strong>，可以维持任意数量个连接。</p><p>但是<strong>poll</strong>需要循环检测是否有事件，如果服务器当前有100 W个连接，但是某一个时间内只有一条连接向服务器发送数据，这样系统就会循环100 W次，对于CPU是一种浪费。</p><p><strong>Linux在2.6时提供了epoll</strong>，可以在系统内维持无数个连接，而且无需轮训。</p><p>IO复用异步非阻塞程序使用经典的 <strong>Reactor</strong> 模型，<strong>Reactor</strong> 顾名思义，就是反应堆的意思，它本身不处理任何数据收发，只是可以监视一个socket句柄的事件变化。</p><p>Reactor模型：</p><ul><li><strong>Add:</strong>  添加一个 SOCKET到 Reactor </li><li><strong>Set：</strong> 修改 SOCKET 对应的事件，如可读可写</li><li><strong>Del：</strong> 从 Reactor 中移除</li><li><strong>Callback：</strong> 事件发生后回调指定的函数</li></ul><p><img src="http://rango.swoole.com/static/io/6.png" alt=""></p><h1 id="PHP-并发编程实践"><a href="#PHP-并发编程实践" class="headerlink" title="PHP 并发编程实践"></a>PHP 并发编程实践</h1><h3 id="PHP的Swoole扩展"><a href="#PHP的Swoole扩展" class="headerlink" title="PHP的Swoole扩展"></a>PHP的Swoole扩展</h3><p>PHP的异步、并行、高性能的网络通信引擎，使用纯C语言编写，提供了PHP语言的异步多线程服务器，异步TCP/UDP 网络客户端，异步 MySQL，异步 Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步 DNS 查询。</p><p>除了异步IO的支持之外，Swoole 为 PHP 多进程的模式设计了多个并发数据结构和 IPC 通信机制，可以大大简化多进程并发编程的工作。</p><p>Swoole 2.0支持了类似Go语言的协程，可以使用完全同步的代码实现异步程序。</p><h4 id="Swoole-的异步MySQL实现"><a href="#Swoole-的异步MySQL实现" class="headerlink" title="Swoole 的异步MySQL实现"></a>Swoole 的异步MySQL实现</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$db = <span class="keyword">new</span> swoole_mysql;</div><div class="line">$server = <span class="keyword">array</span>(</div><div class="line">    <span class="string">'host'</span> =&gt; <span class="string">'192.168.56.102'</span>,</div><div class="line">    <span class="string">'port'</span> =&gt; <span class="number">3306</span>,</div><div class="line">    <span class="string">'user'</span> =&gt; <span class="string">'test'</span>,</div><div class="line">    <span class="string">'password'</span> =&gt; <span class="string">'test'</span>,</div><div class="line">    <span class="string">'database'</span> =&gt; <span class="string">'test'</span>,</div><div class="line">    <span class="string">'charset'</span> =&gt; <span class="string">'utf8'</span>, <span class="comment">//指定字符集</span></div><div class="line">    <span class="string">'timeout'</span> =&gt; <span class="number">2</span>,  <span class="comment">// 可选：连接超时时间（非查询超时时间），默认为SW_MYSQL_CONNECT_TIMEOUT（1.0）</span></div><div class="line">);</div><div class="line"></div><div class="line">$db-&gt;connect($server, <span class="function"><span class="keyword">function</span> <span class="params">($db, $r)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ($r === <span class="keyword">false</span>) &#123;</div><div class="line">        var_dump($db-&gt;connect_errno, $db-&gt;connect_error);</div><div class="line">        <span class="keyword">die</span>;</div><div class="line">    &#125;</div><div class="line">    $sql = <span class="string">'show tables'</span>;</div><div class="line">    $db-&gt;query($sql, <span class="function"><span class="keyword">function</span><span class="params">(swoole_mysql $db, $r)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ($r === <span class="keyword">false</span>)</div><div class="line">        &#123;</div><div class="line">            var_dump($db-&gt;error, $db-&gt;errno);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">elseif</span> ($r === <span class="keyword">true</span> )</div><div class="line">        &#123;</div><div class="line">            var_dump($db-&gt;affected_rows, $db-&gt;insert_id);</div><div class="line">        &#125;</div><div class="line">        var_dump($r);</div><div class="line">        $db-&gt;close();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h4><p><strong>场景说明：</strong>当用户注册后，需要发注册邮件和注册短信。</p><p><strong>串行方式：</strong>将注册信息写入数据库成功以后，发送注册邮件，再发送注册短信。</p><p><strong>并行方式：</strong>将注册写入数据库成功后，发送注册邮件的同事，发送注册短信。</p><p><strong>消息队列方式：</strong>将注册信息写入数据库成功后，将成功信息写入队列，此时直接返回成功给用户，写入队列的时间非常短，可以忽略不计，然后异步发送邮件和短信。</p><h4 id="解耦操作"><a href="#解耦操作" class="headerlink" title="解耦操作"></a>解耦操作</h4><p><strong>场景说明：</strong>用户下单后，订单系统需要通知库存系统。假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。此时需要进行解耦。</p><p><strong>引入队列：</strong> </p><ol><li>用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户下单成功。</li><li>库存系统订阅下单的消息，采用拉/推得方式，获取下单信息，库存系统根据下单信息，进行库存操作。</li></ol><h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p><strong>应用场景：</strong>秒杀活动，流量瞬间激增，服务器压力大</p><p>用户发起请求，服务器接收后，先写入消息队列，假如消息队列长度超过最大值，则直接报错或提示用户。</p><p>后续程序读取消息队列，在进行处理。</p><h4 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h4><p><strong>应用场景：</strong>解决大量日志的传输</p><p>日志采集程序可以将日志写入消息队列，然后通过日志处理程序的订阅消费日志。</p><h4 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h4><p><strong>应用场景：</strong> 聊天室</p><p>多个客户端订阅同一主题，进行消息发布和接收。</p><h4 id="常见的消息队列产品"><a href="#常见的消息队列产品" class="headerlink" title="常见的消息队列产品"></a>常见的消息队列产品</h4><p>kafka、ActiveMQ、ZeroMQ, RabbitMQ、Redis等等。</p><h3 id="接口的并发请求"><a href="#接口的并发请求" class="headerlink" title="接口的并发请求"></a>接口的并发请求</h3><p>curl_multi系列函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是进程、线程、协程&quot;&gt;&lt;a href=&quot;#什么是进程、线程、协程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程、线程、协程&quot;&gt;&lt;/a&gt;什么是进程、线程、协程&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;head
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（4）：浏览器缓存和压缩优化技术</title>
    <link href="http://www.maksim.website/2018/01/12/2/"/>
    <id>http://www.maksim.website/2018/01/12/2/</id>
    <published>2018-01-12T13:29:10.000Z</published>
    <updated>2018-06-27T13:24:14.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-缓存机制"><a href="#HTTP-缓存机制" class="headerlink" title="HTTP 缓存机制"></a>HTTP 缓存机制</h1><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>在HTTP缓存模型中，如果请求成功会有三种情况。</p><ul><li>200 from cache</li><li>304 Not Modified</li><li>200 OK</li></ul><p><strong>200 from cache: </strong>直接从本地缓存中获取响应，最快速，最省流量，因为根本没有向服务器发送请求I看到。</p><p>浏览器本身就有缓存机制，当我们浏览器检测到该资源在本地存在，那么就不需要向服务器发送请求，从下图中我们可以看到size没有大小显示的是 <strong>from cache</strong>，就是读取的缓存。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180627102555.png" alt=""></p><p>查看其响应头我们可以看到下图。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180627103642.png" alt=""></p><p><strong>304 Not Modified: </strong>协商缓存，浏览器在本地没有命中的情况下请求头中发送一定的教研数据到服务端，如果服务端数据没有改变，浏览器从本地缓存响应，返回304。    </p><p>快速，发送的数据很少，只会返回一些基本的响应头信息，数据量很小，不发送实际响应体。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180627103903.png" alt=""></p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180627104104.png" alt=""></p><p><strong>200 OK：</strong> 以上两种缓存全部失效，服务器返回完整响应。没有用到缓存，相对较慢，对于200 OK不能称之为缓存，因为根本没有用到缓存机制。</p><h2 id="相关-Header"><a href="#相关-Header" class="headerlink" title="相关 Header"></a>相关 Header</h2><ul><li>Pragma</li><li>Expires</li><li>Cache-Control</li></ul><p><strong>Pragma：</strong> HTTP 1.0 时代的遗留产物，该字段被设置为no-cache时，会告知浏览器禁用本地缓存，即每次都向服务器发送请求。</p><p><strong>Expires：</strong>HTTP 1.0 时代用来启用本地缓存的字段，expires值对应一个形式如Thu, 31 Dec 2037 23:55:55 GMT的格林威治时间，告诉浏览器缓存实现的时刻，如果还没到该时刻，标明缓存有效，无需发送请求。</p><p>浏览器与服务器的时间无法保持一致，如果时间差比较大，就会影响缓存结果。我们可以保证服务器的时间，但是无法保证客户端的时间与服务器时间的一致。（QQ 空间就有对客户端时间进行检测，感兴趣的可以将本地时间调整一下然后去访问QQ空间）</p><p><strong>Cache-Control：</strong>HTTP 1.1 针对 Expires 时间不一致的解决方案，运用 Cache-Control 告知浏览器缓存过期时间间隔，而不是时刻，即使具体时间不一致，也不影响缓存的管理。</p><p>在Cache-Control下我们还可以设置一些头信息：</p><ul><li>no-store：禁止浏览器缓存响应</li><li>no-cache：不允许直接使用本地缓存，先发起请求和服务器协商，也就是协商缓存</li><li>max-age=delta-seconds：告知浏览器该响应本地缓存有效的最长期限，以秒为单位。</li></ul><p>优先级： Pragma &gt; Cache-Control &gt; Expires</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180627110528.png" alt=""></p><p>在上图中，我们可以看到上面的头信息，设置了Cache-Control和Expires。</p><p><strong>协商缓存</strong>当浏览器没有命中本地缓存，如果本地缓存过期或者响应中生命不允许直接使用本地缓存（Pragma或者Cache-Control设置成了no-cache），那么浏览器肯定会发起服务端请求。服务端会验证数据是否修改，如果没有通知浏览器使用本地缓存。</p><p>相关的Header:</p><ul><li>Last-Modified：通知浏览器资源的最后修改时间，格式如上图。</li><li>If-Modified-Since：这是与Last-Modified相对应的一个头信息，得到资源的最后修改时间后，会将这个信息通过If-Modified-Since提交到服务器进行检查，如果没有修改则返回304状态码。</li><li>ETag: HTTP 1.1 推出，文件的指纹标识符，如果文件内容修改，指纹会改变，Last-Modified只能精确到秒，而 ETag 如果发生了改变，它就会改变，它就相当于文件的标识（”78437822c-6739”），也更加准确。</li><li>If-Node-Match：与ETag相对应的一个头信息，本地缓存失效，会携带此值去请求服务端，服务端判断该资源是否改变，如果没有改变直接使用本地缓存，返回304</li></ul><p>通过下面的两张图，我们可以看到完整的协商缓存交互：</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180627112513.png" alt=""></p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180627112544.png" alt="">    </p><h2 id="缓存策略的选择"><a href="#缓存策略的选择" class="headerlink" title="缓存策略的选择"></a>缓存策略的选择</h2><p>适合的内容：</p><ul><li>不变的图像，如logo，图标等</li><li>js、css静态文件</li><li>可下载的内容，媒体文件</li></ul><p>建议使用协商缓存：</p><ul><li>HTML文件</li><li>经常替换的图片</li><li>经常修改的js、css</li><li>js、css问价你的加载可以加入文件的签名来拒绝缓存 （index.css?签名、index.签名.js）</li></ul><p>不建议缓存的内容：</p><ul><li>用户隐私等敏感数据</li><li>经常改变的 api 数据接口</li></ul><h1 id="NGINX-配置缓存策略"><a href="#NGINX-配置缓存策略" class="headerlink" title="NGINX 配置缓存策略"></a>NGINX 配置缓存策略</h1><p>首先，我们使用PHP模拟NGINX的缓存。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="comment">//1. 获取If-Modified-Since</span></div><div class="line">    $since = $_SERVER[<span class="string">'HTTP_IF_MODIFIED_SINCE'</span>];</div><div class="line"><span class="comment">//2. 设置过期时间一个小时</span></div><div class="line">$lifetime = <span class="number">3600</span>;</div><div class="line"><span class="comment">//3. 如果没有过期直接返回304告诉浏览器使用本地缓存</span></div><div class="line">    <span class="keyword">if</span> (strtotime($since) + $lifetime &gt; time()) &#123;</div><div class="line">header(<span class="string">'HTTP/1.1 304 Not Modified'</span>);</div><div class="line">        <span class="keyword">exit</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//4. 设置最后修改时间</span></div><div class="line">header(<span class="string">'Last-Modified:'</span>. gmdate(<span class="string">'D, d M Y H:i:s'</span>, time()). <span class="string">' GMT'</span>);</div><div class="line"><span class="comment">//5. 网页显示的内容，用于验证是否开启缓存</span></div><div class="line"><span class="keyword">echo</span> time();</div></pre></td></tr></table></figure><p>上述代码就是NGINX的缓存原理，不过NGINX判断的不是3600秒，而是文件的修改时间。</p><p>本地缓存配置</p><p>add_header指令：添加状态码为2XX和3XX的响应头信息。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">add_header</span> name value [always];</div></pre></td></tr></table></figure><p>可以设置Pragma/Expires/Cache-Control，可以继承</p><p>expires指令：通知浏览器过期市场</p><p>expires time; </p><ul><li>为负值时表示Cache-Control:no-cache；</li><li>为正或0时，就表示Cache-Control:max-age=指定的时间；</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</div><div class="line">&#123;</div><div class="line">    expires 30d;</div><div class="line">&#125;</div><div class="line">location ~ .*\.(js|css)?$ </div><div class="line">｛</div><div class="line">expires 12h;</div><div class="line">｝</div></pre></td></tr></table></figure><p>当设为max时，会把Expires设置为”Thu, 31 Dec 2037 23:55:55 GMT”，Cache-Control设置到10年。</p><p>协商缓存配置</p><p>ETag指令：指定签名</p><p>etag on | off 默认是on</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span></div><div class="line">&#123;</div><div class="line">    <span class="attribute">etag</span> <span class="literal">on</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Cache-Control</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location ~ .*\.(js|css)?$ </div><div class="line">｛</div><div class="line">add_header cache-control max-age = 3600;</div><div class="line">｝</div></pre></td></tr></table></figure><h1 id="前端代码和资源的压缩"><a href="#前端代码和资源的压缩" class="headerlink" title="前端代码和资源的压缩"></a>前端代码和资源的压缩</h1><ul><li>优势<ul><li>让资源文件更小</li><li>加快文件在网络中的传输</li><li>让网页更快的展示</li><li>降低带宽和流量的开销</li></ul></li></ul><p>压缩方式</p><ul><li>JS、CSS、图片、HTML代码的压缩</li><li>Gzip压缩</li></ul><h2 id="JavaScript代码压缩"><a href="#JavaScript代码压缩" class="headerlink" title="JavaScript代码压缩"></a>JavaScript代码压缩</h2><p>JavaScript压缩的原理一般是去掉多余的空格和回车、替换长变量名、简化一些代码的写法。</p><p>压缩工具有很多，有在线工具、有应用程序、有编辑器插件。</p><p><strong>常用的压缩工具：</strong></p><ul><li>UglifyJs： 压缩、语法检查、美化代码、代码缩减、转化</li><li>YUI compressor：来自Yahoo，只有压缩功能</li><li>Closure Compiler：来自Google、功能和UglifyJs有些类似，压缩的方式不太一样。</li></ul><h2 id="CSS代码压缩"><a href="#CSS代码压缩" class="headerlink" title="CSS代码压缩"></a>CSS代码压缩</h2><p>原理和JavaScript压缩原理类似，同样是去除空白符、注释并且优化一些CSS语义规则。</p><p><strong>常用的压缩工具：</strong></p><ul><li>YUI compressor：来自Yahoo，只有压缩功能</li><li>CSS Compiler：压缩时候可以选择模式，也可以对一些语法进行优化</li></ul><h2 id="HTML代码压缩"><a href="#HTML代码压缩" class="headerlink" title="HTML代码压缩"></a>HTML代码压缩</h2><p>不建议使用代码压缩，有时会破坏代码结构，可以使用Gzip压缩，当然也可以使用htmlcompressor工具，不过转换后一定要检查代码结构。</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>除了代码的压缩外，有时对图片的压缩也是很有必要的，一般情况下图片在Web系统的比重都比较大。</p><p>压缩工具</p><ul><li>tinypng</li><li>JpegMini</li><li>ImageOptim</li></ul><h2 id="Gzip压缩"><a href="#Gzip压缩" class="headerlink" title="Gzip压缩"></a>Gzip压缩</h2><p>GZIP最早由Jean-loup Gailly和Mark Adler创建，用于UNⅨ系统的<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9" target="_blank" rel="noopener">文件压缩</a>。我们在<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>中经常会用到后缀为.gz的文件，它们就是GZIP格式的。现今已经成为Internet 上使用非常普遍的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9" target="_blank" rel="noopener">数据压缩</a>格式，或者说一种文件格式。</p><p>HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP<a href="https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener">压缩技术</a>来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来.一般对纯文本内容可压缩到原大小的40%.这样传输就快了，效果就是你点击网址后会很快的显示出来.当然这也会增加服务器的负载. 一般服务器中都安装有这个功能模块的。</p><p>NGINX配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">gzip</span> <span class="literal">on</span>|of <span class="comment">#是否开启gzip</span></div><div class="line">gzip_buffres <span class="number">32</span> <span class="number">4k</span>| <span class="number">16</span> <span class="number">8k</span>; <span class="comment">#缓冲（在内存中缓冲几块，每块多大）</span></div><div class="line"><span class="attribute">gzip_comp_level</span> [<span class="number">1</span>-<span class="number">9</span>] <span class="comment">#推荐6 压缩级别（级别越高，压缩的越小，越浪费CPU计算资源）</span></div><div class="line">gzip_disable <span class="comment">#正则匹配UA什么样的Uri不进行gzip</span></div><div class="line">gzip_min_length <span class="number">200</span> <span class="comment">#开始压缩的最小长度</span></div><div class="line">gzip_http_version <span class="number">1</span>.<span class="number">0</span>|<span class="number">1</span>.<span class="number">1</span> <span class="comment">#开启压缩的http协议版本</span></div><div class="line">gzip_proxied<span class="comment">#设置请求者代理服务器，该如何缓存内容</span></div><div class="line">gzip_types text/plain applecation/xml <span class="comment">#对那些文件类型使用压缩</span></div><div class="line">gzip_vary <span class="literal">on</span> | <span class="literal">off</span> <span class="comment">#是否传输gzip压缩标志</span></div></pre></td></tr></table></figure><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul><li>自动化构建工具Grunt</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP-缓存机制&quot;&gt;&lt;a href=&quot;#HTTP-缓存机制&quot; class=&quot;headerlink&quot; title=&quot;HTTP 缓存机制&quot;&gt;&lt;/a&gt;HTTP 缓存机制&lt;/h1&gt;&lt;h2 id=&quot;缓存分类&quot;&gt;&lt;a href=&quot;#缓存分类&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="高并发" scheme="http://www.maksim.website/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（3）：减少 HTTP 请求</title>
    <link href="http://www.maksim.website/2018/01/12/1/"/>
    <id>http://www.maksim.website/2018/01/12/1/</id>
    <published>2018-01-12T11:29:10.000Z</published>
    <updated>2018-06-25T13:14:17.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要减少HTTP请求"><a href="#为什么要减少HTTP请求" class="headerlink" title="为什么要减少HTTP请求"></a>为什么要减少HTTP请求</h2><h3 id="性能黄金法则："><a href="#性能黄金法则：" class="headerlink" title="性能黄金法则："></a>性能黄金法则：</h3><p>只有10%~20%的最终永不响应时间花在接收请求的HTML文档上，剩下的80%~90%时间花在HTML文档所引用的所有组件（图片，script，css，flash等等）进行的HTTP请求上。</p><h3 id="如何改善"><a href="#如何改善" class="headerlink" title="如何改善"></a>如何改善</h3><p>改善响应时间的最简单途径就是减少组件的数量，并由此减少HTTP请求的数量。</p><h3 id="HTTP链接产生的开销"><a href="#HTTP链接产生的开销" class="headerlink" title="HTTP链接产生的开销"></a>HTTP链接产生的开销</h3><p>域名解析 – TCP链接 – 发送请求 – 等待 – 下载资源 –  解析时间</p><ul><li>需要注意 DNS 缓存也需要时间，多个缓存就要查找多次有可能缓存会被清除 </li><li>HTTP1.1 协议规定请求只能串行发送，也就是说一百个请求必须一次逐个发送，前面的一个请求完成才能开始下一个请求。</li></ul><h2 id="减少HTTP请求的方式"><a href="#减少HTTP请求的方式" class="headerlink" title="减少HTTP请求的方式"></a>减少HTTP请求的方式</h2><h3 id="图片地图"><a href="#图片地图" class="headerlink" title="图片地图"></a>图片地图</h3><p>图片地图允许你在一个图片上关联多个URL。目标URL的选择取决于用户单击了图片上的哪个位置。 </p><p>我们可以通过使用五个分开的图片，然后每个图片对应一个超链接产生了5个HTTP请求，我们的目标是要减少HTTP请求。</p><p>将五个图片合并成为一张图片，然后以位置信息定位超链接。</p><p>把HTTP请求减少为一个 ，可以暴增设计的完整性和功能的齐全性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span><span class="tag">&lt;<span class="name">area</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>未使用图像地图的例子：</p><p><a href="http://stevesouders.com/hpws/imagemap-no.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/imagemap-no.php</a></p><p>使用图像地图的例子：    </p><p><a href="http://stevesouders.com/hpws/imagemap.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/imagemap.php</a></p><h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>CSS Sprites 中文翻译为 CSS 精灵，通过使用合并图片，通过指定 CSS 的 backgroud-image 和backgroud-position来显示元素。</p><p><strong>backgroud-position属性</strong></p><p>backgroud-position:x,y; x和y可以写负值也可以写正值，我们可以想象图片的左上方为（0，0），以（0，0）坐标向右是为负数的 X 轴，以（0，0）坐标向下是为负数的 y 轴。</p><p>使用图片精灵的案例：</p><p><a href="http://stevesouders.com/hpws/sprites.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/sprites.php</a></p><p>图片地图和 CSS Sprites 的响应时间基本相同，但比使用各自独立图片的方式要快50%以上。</p><h3 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h3><p>使用外部的 JS 和 CSS 文件引用的方式，因为这要比直接写在页面中性能要更好一点。</p><p>独立的一个 JS 比用多个 JS 文件组成的页面载入要快38%。</p><p>把多个脚本合并为一个脚本，把多个样式表合并成为一个样式表。</p><p><a href="http://stevesouders.com/hpws/combo-none.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/combo-none.php</a></p><p><a href="http://stevesouders.com/hpws/combo.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/combo.php</a></p><h3 id="图片使用base64编码减少页面请求数"><a href="#图片使用base64编码减少页面请求数" class="headerlink" title="图片使用base64编码减少页面请求数"></a>图片使用base64编码减少页面请求数</h3><p>采用Base64的编码方式将图片直接嵌入到网页中，而不是从外部载入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/gif;base64,/9j/4AAqsKZJ....."</span>&gt;</span></div></pre></td></tr></table></figure><p><a href="http://stevesouders.com/hpws/inline-images.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/inline-images.php</a></p><p><a href="http://stevesouders.com/hpws/inline-css-images.php" target="_blank" rel="noopener">http://stevesouders.com/hpws/inline-css-images.php</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要减少HTTP请求&quot;&gt;&lt;a href=&quot;#为什么要减少HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;为什么要减少HTTP请求&quot;&gt;&lt;/a&gt;为什么要减少HTTP请求&lt;/h2&gt;&lt;h3 id=&quot;性能黄金法则：&quot;&gt;&lt;a href=&quot;#性能黄金法则
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="高并发" scheme="http://www.maksim.website/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发和大流量解决方案（2）：Web资源防盗链</title>
    <link href="http://www.maksim.website/2018/01/11/2/"/>
    <id>http://www.maksim.website/2018/01/11/2/</id>
    <published>2018-01-11T04:20:11.000Z</published>
    <updated>2018-06-25T12:46:36.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是防盗链"><a href="#什么是防盗链" class="headerlink" title="什么是防盗链"></a>什么是防盗链</h1><p>盗链是指在自己的页面上展示一些并不在自己服务器上的内容。</p><p>获得他人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容。</p><p>常见的是小站盗用大站的图片、音乐、视频、软件等资源。</p><p>通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器。</p><p>防盗链就是防止别人通过一些技术手段绕过本站的资源展示页面，盗用本站的资源，让绕开本站资源展示页面的资源链接失效。</p><h1 id="防盗链的工作原理"><a href="#防盗链的工作原理" class="headerlink" title="防盗链的工作原理"></a>防盗链的工作原理</h1><p>通过 Referer 或者签名，网站可以检测目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示它的网页地址。</p><p>一旦检测到来源不是本站即进行组织或者返回指定的页面。</p><h1 id="Nginx防盗链的实现"><a href="#Nginx防盗链的实现" class="headerlink" title="Nginx防盗链的实现"></a>Nginx防盗链的实现</h1><h2 id="Nginx-Referer"><a href="#Nginx-Referer" class="headerlink" title="Nginx Referer"></a>Nginx Referer</h2><p>Nginx 模块 ngx_http_referer_module 用于阻挡来源非法的域名请求。</p><p>Nginx 指令 valid_referers，全局变量$invalid_referer。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">valid_referers</span> <span class="literal">none</span> | <span class="literal">blocked</span> | server_names| string ...;</div></pre></td></tr></table></figure><p>none: “Referer” 来源头部为空的情况</p><p>blocked: “Referer”来源头部不为空，但是里面的值被代理或者防火墙删除了，这些值都以 <a href="http://或者" target="_blank" rel="noopener">http://或者</a> <a href="https://开头。" target="_blank" rel="noopener">https://开头。</a></p><p>server_names: “Referer” 来源头不包含当前的 server_names</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">location</span> ~.*\.(gif|jpg|png|flv|swf|rar|zip)$</div><div class="line">&#123;</div><div class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> maksim.website <span class="regexp">*.maksim.website</span>;</div><div class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">#return 403;</span></div><div class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/http://www.maksim.website/403.jpg</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>针对目录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">location</span> /images/</div><div class="line">&#123;</div><div class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> maksim.website <span class="regexp">*.maksim.website</span>;</div><div class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">#return 403;</span></div><div class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/http://www.maksim.website/403.jpg</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Nginx-HTTPAccessKeyModule-加密签名"><a href="#Nginx-HTTPAccessKeyModule-加密签名" class="headerlink" title="Nginx HTTPAccessKeyModule 加密签名"></a>Nginx HTTPAccessKeyModule 加密签名</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">accesskey</span> <span class="literal">on</span> | <span class="literal">off</span></div><div class="line">accesskey_hashmethod md5 | sha-<span class="number">1</span> </div><div class="line">accesskey_arg GET参数名称</div><div class="line">accesskey_signatrue 加密规则</div></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">location</span> ~.*\.(gif|jpg|png|flv|swf|rar|zip)$</div><div class="line">&#123;</div><div class="line">    <span class="attribute">accesskey</span> <span class="literal">on</span></div><div class="line">    accesskey_hashmethod md5</div><div class="line">    accesskey_arg <span class="string">"key"</span></div><div class="line">    accesskey_signatrue <span class="string">"maksim<span class="variable">$remote_addr</span>"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="comment">//md5(maksim.ip)</span></div><div class="line">    $sign = md5(<span class="string">'maksim'</span>.$_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</div><div class="line"><span class="keyword">echo</span> <span class="string">'&lt;img src="./image/maksim.png?sign='</span>. $sign .<span class="string">'"&gt;'</span>;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是防盗链&quot;&gt;&lt;a href=&quot;#什么是防盗链&quot; class=&quot;headerlink&quot; title=&quot;什么是防盗链&quot;&gt;&lt;/a&gt;什么是防盗链&lt;/h1&gt;&lt;p&gt;盗链是指在自己的页面上展示一些并不在自己服务器上的内容。&lt;/p&gt;
&lt;p&gt;获得他人服务器上的资源地址，绕过别人
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
</feed>
