<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maksim&#39;s Website</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.maksim.website/"/>
  <updated>2018-02-27T14:04:44.098Z</updated>
  <id>http://www.maksim.website/</id>
  
  <author>
    <name>Maksim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx的安装</title>
    <link href="http://www.maksim.website/2018/02/27/cjek1d3iq0018rhrdma2piy7p/"/>
    <id>http://www.maksim.website/2018/02/27/cjek1d3iq0018rhrdma2piy7p/</id>
    <published>2018-02-26T16:00:00.000Z</published>
    <updated>2018-02-27T14:04:44.098Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。</p><p>在安装 Nginx 时，我们可以通过以下两种方式进行安装：</p><ol><li>使用包管理器安装 Nginx</li><li>通过源代码安装 Nginx</li></ol><h2 id="使用包管理器安装-Nginx"><a href="#使用包管理器安装-Nginx" class="headerlink" title="使用包管理器安装 Nginx"></a>使用包管理器安装 Nginx</h2><p>使用包管理器安装 Nginx 的机会，是你使用的操作系统已经提供了 Nginx 的安装包。使用包管理器安装 Nginx 的方式很简单，只需要在终端输入：</p><p>Linux(基于 deb，如 Ubunut)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure><p> Linux（基于 rpm，如 CentOS)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>FreeBSD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pkg_install -r nginx</div></pre></td></tr></table></figure><p>通过上述命令，Nginx 将会安装到操作系统的标准位置下。如果使用操作系统的安装包安装 Nginx，那么通过上面的命令来安装是最佳方式。</p><p>Nginx 核心团队也提供了稳定的二进制版本，可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 页面下载可用版本。未发布 Nginx 安装包的系统用户（例如，CentOS），可以使用下面指导来安装预测试、预编译二进制版本。</p><p>通过创建下面的文件，在系统中添加 Nginx 仓库的 yum 配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vi /etc/yum.repos.d/nginx.repo</div><div class="line">[nginx]</div><div class="line">name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure><p>然后，听过执行如下命令来安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nginx</div></pre></td></tr></table></figure><p>也可以按照前面介绍的 URL 下载 nginx 发行版安装。</p><h2 id="从源代码安装-Nginx"><a href="#从源代码安装-Nginx" class="headerlink" title="从源代码安装 Nginx"></a>从源代码安装 Nginx</h2><p>Nginx 代码提供了两种独立的下载分支——开发版与稳定版。开发分支是一个正处于积极开发状态的版本。在这个版本中，会有一些新功能被集成到其中，在稳定版中是找不到这些功能的。当发布一个“开发”版时，它会经历同样的 QA 和作为稳定版本的一组类似测试功能。因此无论哪一个分支都一颗用于生产环境中，两者主要的不同，在于对第三方模块的支持。在开发板中，内部的 API 可能会发生改变，而稳定版则保持不变。因此，为了与第三方模块向下兼容，在稳定版中第三方模块都可以有效使用。</p><h3 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h3><p>为了从源代码编译 Nginx，系统需要满足某些必要条件，除了编译器外，如果想分别启用 SSL 支持和使用 rewrite 模块，那么还需要提供响应的 OpenSSL 与 PCRE（Perl Compatible Regular Expressions）库及开发头文件。rewrite 模块是默认安装的。如果你还没有 PCRE 库与开发头文件，你需要在配置阶段禁用 rewrite 模块。这依赖于系统，也有可能在系统中已经默认安装了这些必要条件。如果没有安装，则需要从其安装包安装或者从源码下载并且解压安装，在 Nginx 配置脚本中指定他们在系统中的安装位置。</p><p>如果在配置文件中使用了—with-\<library\>=\<path\>选项，那么 Nginx 会视图建立一个静态依赖库。如果你想让 Nginx 不依赖于系统的任何其他部分，或是想获得些 Nginx 的二进制额外性能，那么你可能会使用构建静态库的做法。如果你使用外部库功能只能从某一个版本起有效（例如，NPN[Next Protocol Negotiation]TLS扩展从 OpenSSL1.0.1版有效），那么你就不得不将其指定到特定版本解压后的源代码路径中。</path\></library\></p><p>根据自己的喜好，你可能会提供其他的、可选安装包。你可以为这些安装包提供支持。他们包括 MD5和 SHA-1以支持散列算法、zip 压缩库、libatomic 库。在 Nginx 中，很多地方法会用到散列库，例如为了计算 URI 散列进而计算缓存 key。</p><p>zlib 压缩裤被用来投递 gzip 压缩内容。如果 atomic_ops 库有效，那么 Nginx 会用它来实现自动内存更新操作，以实现高性能的内存锁定代码。</p><h3 id="从源代码编译"><a href="#从源代码编译" class="headerlink" title="从源代码编译"></a>从源代码编译</h3><p>读者可以从 <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> 下载 Nginx，在该页面找到.tar.gz 或者.zip 格式的源代码分支，安装如下步骤将下载的安装包解压到一个临时目录中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mkdir ~/bulid</div><div class="line"><span class="meta">$</span> cd ~/bulid &amp;&amp; tar xzf nginx-&lt;version-number&gt;.tar.gz</div></pre></td></tr></table></figure><p>使用下面命令配置 Nginx:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cd ~/bulid/nginx-&lt;version-number&gt; &amp;&amp; ./configure</div></pre></td></tr></table></figure><p>然后，使用下面命令进行编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> make &amp;&amp; sudo make install</div></pre></td></tr></table></figure><p>在编译自己的二进制 nginx 时，你会有很大的灵活性来包含你仅使用的功能。你已经指定使用哪个用户运行 Nginx 了吗?你要使用默认的 logfile 位置，以便不用在 Nginx 的配置文件明确地说明它们吗?表 1-1 所示是配置选项列表，通过它来帮助你设计出自己的 nginx 命令。这些选项对 Nginx 都是有效的，模块可以被独立激活。</p><table><thead><tr><th>选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td>–prefix=\<path\></path\></td><td style="text-align:left">Nginx 安装的根路径，所有其他的安装路径都要依赖于该选项</td></tr><tr><td>–sbin-path=\<path\></path\></td><td style="text-align:left">指定 Nginx 二进制文件的路径。如果没有指定，那么这个路径依赖于——prefix 选项</td></tr><tr><td>–conf-path=\<path\></path\></td><td style="text-align:left">如果在命令行没有指定配置文件，那么将会通过这里指定的路径，Nginx 将会去那里寻找它的配置文件</td></tr><tr><td>–error-log-path=\<path\></path\></td><td style="text-align:left">指定错误文件的路径，Nginx 会将其中写入错误日志文件，除非有其他配置</td></tr><tr><td>–pid-path=\<path\></path\></td><td style="text-align:left">指定的文件将会写入 Nginx master 进程的pid，通常在/var/run 下</td></tr><tr><td>–lock-path=\<path\></path\></td><td style="text-align:left">共享存储器互斥锁文件的路径</td></tr><tr><td>–user=\<user\></user\></td><td style="text-align:left">worker 进程运行的用户</td></tr><tr><td>–group=\<group\></group\></td><td style="text-align:left">worker 进程运行的组</td></tr><tr><td>–with-file-aio</td><td style="text-align:left">为 FreeBSD4.3+和 Linux2.6.22+系统启用异步 I/O</td></tr><tr><td>–with-debug</td><td style="text-align:left">这个选项用于启用调试日志。在生产环境中不推荐使用该选项。</td></tr></tbody></table><p>你可以使用优化编译，单但是如果使用包管理工具进行安装将无法获得这些优化，如下表：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>–with-cc=\<path\></path\></td><td>如果想设置一个不再默认 Path 下的编译器</td></tr><tr><td>–with-cpp=\<path\></path\></td><td>设置 C 预处理器的响应路径</td></tr><tr><td>–with-cc-opt=\<options></options></td><td>指定必要的 include 文件路径，可能（-I\<path\>）指出，也可能是优化(-O4)并指定64位构建</path\></td></tr><tr><td>–with-ld-opt=\<options\></options\></td><td>包含连接器库的路径(-L\<path\>)和运行路径(-R\<path\>)</path\></path\></td></tr><tr><td>—with-cpu-opt=\<cpu\></cpu\></td><td>通过该选项为特定的 CPU 构建 Nginx</td></tr></tbody></table><h2 id="配置-SSL-支持"><a href="#配置-SSL-支持" class="headerlink" title="配置 SSL 支持"></a>配置 SSL 支持</h2><p>对于 TLS/SSL 协议，Nginx 使用 OpenSSL 项目。有关此开源工具包的更多信息，请访问 <a href="https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对" target="_blank" rel="noopener">https://www.openssl.org。你可以从操作系统或者直接从工具包的单独副本来获取对</a> SSL 的支持。如果使用不带–with-ssl 选项的–with-http_ssl_module 或者–with-mail_ssl_module，你正在使用执行了 configure 命令的、安装在计算机上的 OpenSSL 库。如果你想要针对特定版本的 OpenSSL 进行编译，请下载该分发包，将其解压缩到一个目录中，然后将该目录的路径指定为–with-openssl 的参数。使用–with-openssl-opt 选项为 OpenSSL本身指定额外的构建选项。</p><p>例如，为了使用具有优化椭圆曲线的 OpenSSL 来构建 Nginx，您将使用如下的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ./configure --with-http_ssl_module --with-openssl=$&#123;BUILD_DIR&#125;/openssl-1.0.1p --with-openssl-opt=enable-ec_nistp_64_gcc_128</div></pre></td></tr></table></figure><h2 id="查找并安装第三方模块"><a href="#查找并安装第三方模块" class="headerlink" title="查找并安装第三方模块"></a>查找并安装第三方模块</h2><p>由于有多个开源项目，所以在 Nginx 周围就会有一个活跃的开发社区。由于 Nginx 的模块化特性，这个社区能够开发和发布模块，从而为 Nginx 提供额外的功能。它们涵盖了广泛的应用，所以着手开发自己的模块之前应该看看有什么可用模块。</p><p>安装第三方模块的过程相当简单，步骤如下。</p><p>1.定位你想要使用的模块(在 <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> 或者是 <a href="http://wiki.nginx.org/3rdPartyModules查找)。" target="_blank" rel="noopener">http://wiki.nginx.org/3rdPartyModules查找)。</a></p><p>2.下载该模块。</p><p>3.解压缩源代码安装包。</p><p>4.如果有 README 文件，那么阅读 README 文件，查看在安装中是否有依赖安装。</p><p>5.通过./configure–add-module=\<path\>选项配置使用该模块。</path\></p><p>这个过程会给你的 nginx 二进制文件与模块附加这个功能。</p><p>需要注意的是，很多第三方模块是实验性质的。因此，在将这些模块用于生产系统之前，首先要测试使用这些模块。另外请记住，Nginx 的开发版本中可能会有 API 的变化，会导致第三方模块出现问题。</p><h2 id="添加对-Lua-的支持"><a href="#添加对-Lua-的支持" class="headerlink" title="添加对 Lua 的支持"></a>添加对 Lua 的支持</h2><p>特别应该提到的是 ngx_lua 这个第三方模块，ngx_lua 模块提供了启用 Lua 的功能，而不是像 Perl 一样在配置时嵌入式脚本语言。该模块对于 perl 模块来说最大的优点就是它的无阻塞性，并与其他第三方模块紧密集成。对于它的安装说明的完整描述详见:<a href="https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module#installation。我们将以这个模块为例，在下一节中介绍如何安装第三方模块。</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过编译你自己的二进制文件，你可以定制 Nginx能够为你提供哪些功能。对于你来说，构建和安装软件应该不会陌生。所以，创造一个构建环境或者确保所有依赖关系都存在，这并不会花费你很多的时间。一个 Nginx 的安装应该是按照你的需要，能随时启用或禁用模块，正如你看到的，启用或者是禁用一个模块应该感到很容易。</p><p>参考资料：</p><p>《精通 Nginx》第二版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx 最初的设计，是成为一个 HTTP 服务器，一个能解决 C10K 问题的 HTTP 服务器，为了实现这个目标，Nginx 通过基于事件的链接——处理机制，并且操作系统也要使用相应的事件机制，便可以解决 C10K 问题。&lt;/p&gt;
&lt;p&gt;在安装 Nginx 时，我们可
      
    
    </summary>
    
      <category term="Linux" scheme="http://www.maksim.website/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>function与感叹号</title>
    <link href="http://www.maksim.website/2018/02/01/cjek1d3k6003crhrdu2lf6h07/"/>
    <id>http://www.maksim.website/2018/02/01/cjek1d3k6003crhrdu2lf6h07/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-03-09T13:33:02.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="function与感叹号"><a href="#function与感叹号" class="headerlink" title="function与感叹号"></a>function与感叹号</h1><p>最近有空可以让我静下心来看看各种代码，function与感叹号的频繁出现，让我回想起2个月前我回杭州最后参加团队会议的时候，<a href="http://weibo.com/exqy" target="_blank" rel="noopener">@西子剑影</a>抛出的一样的问题：<strong>如果在function之前加上感叹号 (!) 会怎么样</strong>？比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>在控制台运行后得到的值时true，为什么是true这很容易理解，因为这个匿名函数没有返回值，默认返回的就是undefined，求反的结果很自然的就是true。所以问题并不在于结果值，而是在于，为什么求反操作能够让一个匿名函数的自调变的合法？</p><p>平时我们可能对添加括号来调用匿名函数的方式更为习惯：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>或者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>虽然上述两者括号的位置不同，不过效果完全一样。</p><p>那么，是什么好处使得为数不少的人对这种叹号的方式情有独钟？如果只是为了节约一个字符未免太没有必要了，这样算来即使一个100K的库恐怕也节省不了多少空间。既然不是空间，那么就是说也许还有时间上的考量，事实很难说清，文章的最后有提到性能。</p><p>回到核心问题，为什么能这么做？甚至更为核心的问题是，为什么必须这么做？</p><p>其实无论是括号，还是感叹号，让整个语句合法做的事情只有一件，就是<strong>让一个函数声明语句变成了一个表达式</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>这是一个函数声明，如果在这么一个声明后直接加上括号调用，解析器自然不会理解而报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// SyntaxError: unexpected_token</span></div></pre></td></tr></table></figure><p>因为这样的代码混淆了函数声明和函数调用，以这种方式声明的函数 <code>a</code>，就应该以 <code>a();</code> 的方式调用。</p><p>但是括号则不同，它将一个函数声明转化成了一个表达式，解析器不再以函数声明的方式处理函数a，而是作为一个函数表达式处理，也因此只有在程序执行到函数a时它才能被访问。</p><p>所以，<strong>任何消除函数声明和函数表达式间歧义的方法，都可以被解析器正确识别</strong>。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">10</span>&#125;();        <span class="comment">// undefined</span></div><div class="line"><span class="number">1</span> &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;();        <span class="comment">// true</span></div><div class="line"><span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;();        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>赋值，逻辑，甚至是逗号，各种操作符都可以告诉解析器，这个不是函数声明，它是个函数表达式。并且，对函数一元运算可以算的上是消除歧义最快的方式，感叹号只是其中之一，如果不在乎返回值，这些<strong>一元运算都是有效的</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// NaN</span></div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// -1</span></div></pre></td></tr></table></figure><p>甚至下面这些关键字，都能很好的工作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// undefined</span></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// Object</span></div><div class="line"><span class="keyword">delete</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;()        <span class="comment">// true</span></div></pre></td></tr></table></figure><p>最后，括号做的事情也是一样的，消除歧义才是它真正的工作，而不是把函数作为一个整体，所以无论括号括在声明上还是把整个函数都括在里面，都是合法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;)()        <span class="comment">// undefined</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'iifksp'</span>)&#125;())        <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>说了这么多，实则在说的一些都是最为基础的概念——语句，表达式，表达式语句，这些概念如同指针与指针变量一样容易产生混淆。虽然这种混淆对编程无表征影响，但却是一块绊脚石随时可能因为它而头破血流。</p><p>最后讨论下性能。我在jsperf上简单建立了一个测试：<a href="http://jsperf.com/js-funcion-expression-speed" target="_blank" rel="noopener">http://jsperf.com/js-funcion-expression-speed</a> ，可以用不同浏览器访问，运行测试查看结果。我也同时将结果罗列如下表所示（由于我比较穷，测试配置有点丢人不过那也没办法：奔腾双核1.4G，2G内存，win7企业版）：</p><table><thead><tr><th>Option</th><th>Code</th><th>Ops/sec</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Chrome 13</td><td>Firefox 6</td><td>IE9</td><td>Safari 5</td><td></td><td></td></tr><tr><td>!</td><td>!function(){;}()</td><td>3,773,196</td><td>10,975,198</td><td>572,694</td><td>2,810,197</td></tr><tr><td>+</td><td>+function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,812,238</td></tr><tr><td>-</td><td>-function(){;}()</td><td>21,553,847</td><td>12,135,960</td><td>572,694</td><td>1,864,155</td></tr><tr><td>~</td><td>~function(){;}()</td><td>3,551,136</td><td>3,651,652</td><td>572,694</td><td>1,876,002</td></tr><tr><td>(1)</td><td>(function(){;})()</td><td>3,914,953</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>(2)</td><td>(function(){;}())</td><td>4,075,201</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>void</td><td>void function(){;}()</td><td>4,030,756</td><td>12,135,960</td><td>572,694</td><td>3,025,608</td></tr><tr><td>new</td><td>new function(){;}()</td><td>619,606</td><td>299,100</td><td>407,104</td><td>816,903</td></tr><tr><td>delete</td><td>delete function(){;}()</td><td>4,816,225</td><td>12,135,960</td><td>572,694</td><td>2,693,524</td></tr><tr><td>=</td><td>var i = function(){;}()</td><td>4,984,774</td><td>12,135,960</td><td>565,982</td><td>2,602,630</td></tr><tr><td>&amp;&amp;</td><td>1 &amp;&amp; function(){;}()</td><td>5,307,200</td><td>4,393,486</td><td>572,694</td><td>2,565,645</td></tr><tr><td>\</td><td>\</td><td></td><td>0 \</td><td>\</td><td>function(){;}()</td><td>5,000,000</td><td>4,406,035</td><td>572,694</td><td>2,490,128</td></tr><tr><td>&amp;</td><td>1 &amp; function(){;}()</td><td>4,918,209</td><td>12,135,960</td><td>572,694</td><td>1,705,551</td></tr><tr><td>\</td><td></td><td>1 \</td><td>function(){;}()</td><td>4,859,802</td><td>12,135,960</td><td>572,694</td><td>1,612,372</td></tr><tr><td>^</td><td>1 ^ function(){;}()</td><td>4,654,916</td><td>12,135,960</td><td>572,694</td><td>1,579,778</td></tr><tr><td>,</td><td>1, function(){;}()</td><td>4,878,193</td><td>12,135,960</td><td>572,694</td><td>2,281,186</td></tr></tbody></table><p>可见不同的方式产生的结果并不相同，而且，差别很大，因浏览器而异。</p><p>但我们还是可以从中找出很多共性：<strong>new方法永远最慢</strong>——这也是理所当然的。其它方面很多差距其实不大，但有一点可以肯定的是，感叹号并非最为理想的选择。反观<strong>传统的括号，在测试里表现始终很快</strong>，在大多数情况下比感叹号更快——所以平时我们常用的方式毫无问题，甚至可以说是最优的。<strong>加减号在chrome表现惊人</strong>，而且在其他浏览器下也普遍很快，相比感叹号效果更好。</p><p>当然这只是个简单测试，不能说明问题。但有些结论是有意义的：括号和加减号最优。</p><p>但是为什么这么多开发者钟情于感叹号？我觉得这只是一个习惯问题，它们之间的优劣完全可以忽略。一旦习惯了一种代码风格，那么这种约定会使得程序从混乱变得可读。如果习惯了感叹号，我不得不承认，它比括号有更好的可读性。我不用在阅读时留意括号的匹配，也不用在编写时粗心遗忘——</p><p>当我也这么干然后嚷嚷着这居然又节省了一个字符而沾沾自喜的时候，却忘了自己仓皇翻出一本卷边的C语言教科书的窘迫和荒唐……任何人都有忘记的时候，当再捡起来的时候，捡起的就已经不单单是忘掉的东西了。</p><p>2011-10-31更新：如果你使用aptana，那么在使用（!+-）时要注意一点，它们会让aptana的解析失效，导致Outline窗口没有任何显示。但是就代码本身而言，其运行没有任何问题。</p><blockquote><p>本文转自扩葵中剑的博客</p><p>原文地址：<a href="https://swordair.com/function-and-exclamation-mark/" target="_blank" rel="noopener">https://swordair.com/function-and-exclamation-mark/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;function与感叹号&quot;&gt;&lt;a href=&quot;#function与感叹号&quot; class=&quot;headerlink&quot; title=&quot;function与感叹号&quot;&gt;&lt;/a&gt;function与感叹号&lt;/h1&gt;&lt;p&gt;最近有空可以让我静下心来看看各种代码，function与感叹
      
    
    </summary>
    
      <category term="javascript" scheme="http://www.maksim.website/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>创建型设计模式之抽象工厂</title>
    <link href="http://www.maksim.website/2018/01/10/cjek1etny0000rtrdtvtz7xp0/"/>
    <id>http://www.maksim.website/2018/01/10/cjek1etny0000rtrdtvtz7xp0/</id>
    <published>2018-01-10T12:44:02.000Z</published>
    <updated>2018-03-09T14:29:03.542Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://designpatternsphp.readthedocs.io" target="_blank" rel="noopener">http://designpatternsphp.readthedocs.io</a></p><p>在软件工程中，创建型设计模式承担着对象创建的职责，尝试创建适合程序上下文的对象，对象创建设计模式的产生是由于软件工程设计的问题，具体说是向设计中增加复杂度，创建型设计模式解决了程序设计中对象创建的问题。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>创建一系列互相关联或依赖的对象时不需要指定将要创建的对象对应的类，因为这些将被创建的对象对应的类都实现了同一个接口。抽象工厂的使用者不需要关心对象的创建过程，它只需要知道这些对象是如何协调工作的。</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p><img src="http://designpatternsphp.readthedocs.io/zh_CN/latest/_images/uml12.png" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在 <a href="https://github.com/domnikl/DesignPatternsPHP/tree/master/Creational/AbstractFactory" target="_blank" rel="noopener">GitHub</a> 上查看代码</p><p>AbstractFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * In this case, the abstract factory is a contract for creating some components</div><div class="line"> * for the web. There are two ways of rendering text: HTML and JSON</div><div class="line"> */</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JsonFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonText($content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HtmlFactory.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createText</span><span class="params">(string $content)</span>: <span class="title">Text</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HtmlText($content);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Text.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@var</span> string</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> $text;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $text)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;text = $text;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JsonText.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonText</span> <span class="keyword">extends</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// do something here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>HtmlText.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlText</span> <span class="keyword">extends</span> <span class="title">Text</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// do something here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">Tests</span>;</div><div class="line"></div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">HtmlFactory</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">HtmlText</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">JsonFactory</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">DesignPatterns</span>\<span class="title">Creational</span>\<span class="title">AbstractFactory</span>\<span class="title">JsonText</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanCreateHtmlText</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $factory = <span class="keyword">new</span> HtmlFactory();</div><div class="line">        $text = $factory-&gt;createText(<span class="string">'foobar'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertInstanceOf(HtmlText::class, $text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testCanCreateJsonText</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        $factory = <span class="keyword">new</span> JsonFactory();</div><div class="line">        $text = $factory-&gt;createText(<span class="string">'foobar'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;assertInstanceOf(JsonText::class, $text);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;http://designpatternsphp.readthedocs.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://designpatternsphp.readthedocs.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>DOM本质</title>
    <link href="http://www.maksim.website/2018/01/05/1/"/>
    <id>http://www.maksim.website/2018/01/05/1/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-01-07T10:42:36.852Z</updated>
    
    <content type="html"><![CDATA[<p>抛出问题!</p><ul><li>DOM是那种基本的数据结构？</li><li>DOM操作的常用API都有哪些？</li><li>DOM节点的attr和property有何区别？</li></ul><p>解答问题:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">other</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">other</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="DOM本质"><a href="#DOM本质" class="headerlink" title="DOM本质"></a>DOM本质</h2><p>上面的代码是一段XML，这是一个结构化语言，跟它其同样作用的还有JSON，他们可以用于描述一切可以结构化的数据。</p><p>这段代码快描述了一封信，to收件人，from 来源，title标题，body内容。</p><p>DOM本质上是一个树形结构。我们可以将其理解为，浏览器把拿到的HTML代码，结构化成一个浏览器能够识别且能被js操作的一个模型。</p><p>我们知道HTML本质上就是字符串，计算机处理字符串是一件相当头疼的一件事情，通过DOM，我们就可以将HTML文件抽象成一个树形结构，只要是结构化的数据，计算机处理起来，无论你的逻辑结构有多复杂，他都能够轻松的进行处理。</p><h2 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>) <span class="comment">//元素 </span></div><div class="line"><span class="keyword">var</span> divList = <span class="built_in">document</span>.getElementByTagName(<span class="string">'div'</span>) <span class="comment">//集合</span></div><div class="line"><span class="built_in">console</span>.log(divList.length)</div><div class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="keyword">var</span> containerList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'.container'</span>);  <span class="comment">//集合</span></div><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>) <span class="comment">//集合</span></div></pre></td></tr></table></figure><p>上面的代码都是JavaScript的基础API，有的人可能用jQuery或其他的的库时间长了，就把基础API给忘了，或者是基础并不是很牢，一直都在用库，这样的话最好将基础补齐，因为在面试的时候，大多数的面试题都是问的基础。</p><p>在面试的时候有个技巧，不要轻易的撩起用的熟，但是不知道实现原理的东西，比如说你会用jQuery的绑定事件，面试官肯定会问你实现原理。</p><h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</div><div class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</div><div class="line"><span class="built_in">console</span>.log(p.style.width) <span class="comment">//获取样式</span></div><div class="line">p.style.width = <span class="string">'100px;'</span></div><div class="line"><span class="built_in">console</span>.log(p.className)</div><div class="line">p.className = <span class="string">'p1'</span></div><div class="line"></div><div class="line"><span class="comment">//获取nodeName 和 nodeType</span></div><div class="line"><span class="built_in">console</span>.log(p.nodeName)</div><div class="line"><span class="built_in">console</span>.log(p.nodeType)</div></pre></td></tr></table></figure><p>在这里我们需要知道P是个什么东西，它不就是个DOM节点吗？</p><p>其实它本质上就是一个JS对象。上面我们说过DOM的本质是一个JS可识别可操作的。既然本质上是一个对象，我们就可以操作他的属性，那这些属性都是怎么进去的？</p><p>这是浏览器规定的，W3C就是这么规定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj &#123;<span class="attr">x</span>:<span class="number">100</span>, <span class="attr">y</span>:<span class="number">200</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(obj.x) <span class="comment">// 100</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>]</div><div class="line">cosnole.log(p.nodeName); <span class="comment">//p</span></div></pre></td></tr></table></figure><h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</div><div class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</div><div class="line">p.getAttribute(<span class="string">'data-name'</span>)</div><div class="line">p.setAttribute(<span class="string">'data-name'</span>, <span class="string">'maksim'</span>)</div><div class="line">p.getAttribute(<span class="string">'style'</span>)</div><div class="line">p.setAttribute(<span class="string">'style'</span>, <span class="string">'font-size:30px;'</span>)</div></pre></td></tr></table></figure><p>我们在上述代码中该的 <code>data-name</code> 和 <code>style</code> 到底是什么呢？</p><p>其实就是HTML文档里的标签，并不是JavaScript里的对象。这也是两者之间的区别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;抛出问题!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM是那种基本的数据结构？&lt;/li&gt;
&lt;li&gt;DOM操作的常用API都有哪些？&lt;/li&gt;
&lt;li&gt;DOM节点的attr和property有何区别？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解答问题:&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.maksim.website/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>cookie, sessionStorage和localStorage的区别</title>
    <link href="http://www.maksim.website/2018/01/05/3/"/>
    <id>http://www.maksim.website/2018/01/05/3/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-01-07T10:42:39.757Z</updated>
    
    <content type="html"><![CDATA[<p>在HTML5出来之前，只有cookie作为本地存储的一个方法（JavaScript Web API）。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul><li>本身用于客户端和服务器端通信的，</li><li>但是它有本地存储的功能， 于是被“借用”</li><li>使用document.cookie = … 获取和修改即可，用起来特别麻烦</li></ul><p>缺点：</p><ul><li>存储量太小，只有4kb</li><li>所有http请求都带着，会影响获取资源的效率，所以cookie只适合保存很小的数据，如会话标识</li><li>API简单，需要封装才能用document.cookie = …</li><li><p>有效时长根据设定的过期时间而定。</p><p>​</p></li></ul><h2 id="sessionStorage-和localStorage"><a href="#sessionStorage-和localStorage" class="headerlink" title="sessionStorage 和localStorage"></a>sessionStorage 和localStorage</h2><ul><li>HTML5专门为存储而设计，因为不需要像服务端发送数据，所以最大容量5M</li><li>API简单易用：</li><li>localStorage.setItem(key, value); localStorage.getItem(key)</li><li>sessionStorage当关闭浏览器后便会被清除，localStorage则不会，即使关闭浏览器localStorage也会一直存在，直到删除</li><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的</li><li>在iOS Safari 隐匿模式下，localStorage.getItem会报错，建议同一使用try-catch</li><li>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在HTML5出来之前，只有cookie作为本地存储的一个方法（JavaScript Web API）。&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.maksim.website/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP基础手札的引用</title>
    <link href="http://www.maksim.website/2017/10/21/cjek1d3j4001trhrd6r6g622d/"/>
    <id>http://www.maksim.website/2017/10/21/cjek1d3j4001trhrd6r6g622d/</id>
    <published>2017-10-21T10:06:24.000Z</published>
    <updated>2017-10-21T10:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。</p><p>PHP 的指针域这些语言机制相同，即可以用一个变量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 C 或C++里，我们都知道有“指针”的概念，它是一个指向内存地址的变量，这也是被称为指针的原因。C++的指针在内部，对于开发者来说不可见，它的特点是可直接访问到需要的内容，速度更快。&lt;/p&gt;
&lt;p&gt;PHP 的指针域这些语言机制相同，即可以用一个变量&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2017/10/21/cjek1d3i4000drhrdipe4d96n/"/>
    <id>http://www.maksim.website/2017/10/21/cjek1d3i4000drhrdipe4d96n/</id>
    <published>2017-10-21T09:59:26.000Z</published>
    <updated>2018-01-07T10:50:24.324Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:C语言中的内存<br>categories:C/C++<br>date:2017-10-21</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p> C 程序在编译后，会以三种形式使用内存。</p><ul><li><p>静态变量/全局内存</p><p>静态声明的变量分配在这里，全局变量也会使用这部分内存。这些内存在程序开始运行时分配，直到程序终止才会消失。所有函数都能访问全局变量，静态变量的作用域则局限在定义它们的函数内部。</p></li><li><p>自动内存</p><p>这些变量在函数内部声明，并且在函数被调用时才能创建。它们的作用域局限于函数内部，而且在函数被调用才创建。它们的作用域局限于函数内部，热切声明周期限制在函数的执行时间内。</p></li><li><p>动态内存</p><p>内存分派在堆上，可以根据需要存放，而且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:C语言中的内存&lt;br&gt;categories:C/C++&lt;br&gt;date:2017-10-21&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP常见的经典面试题</title>
    <link href="http://www.maksim.website/2017/10/21/2/"/>
    <id>http://www.maksim.website/2017/10/21/2/</id>
    <published>2017-10-20T16:00:00.000Z</published>
    <updated>2017-10-22T04:14:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>常见经典面试题</p><ol><li>什么是引用变量？在 PHP 当中用什么符号定义引用变量？</li><li>要求写出JQuery 中，可以处理AJAX的几种方法。</li><li>写出尽可能多的Linux 命令</li><li>写出三种以上 MySQL数据存储引擎的名字</li><li>编写在线留言本，实现用户的在线留言功能</li><li>谈谈你对 MVC 的认识，介绍几中目前比较流行的MVC 框架</li><li>请写出常见的排序算法</li><li>PHP 如何解决网站大流量与高并发</li></ol><p>1.什么是引用变量？在 PHP 当中用什么符号定义引用变量。</p><ul><li>考官考点： PHP 的引用变量的概念以及定义方式</li><li><strong>延伸：PHP 引用变量的原理</strong></li></ul><p><strong>概念</strong>： 在 PHP 中引用意味着用不同的名字访问同一个变量内容。</p><p><strong>定义方式</strong> ： 使用&amp;符号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常见经典面试题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是引用变量？在 PHP 当中用什么符号定义引用变量？&lt;/li&gt;
&lt;li&gt;要求写出JQuery 中，可以处理AJAX的几种方法。&lt;/li&gt;
&lt;li&gt;写出尽可能多的Linux 命令&lt;/li&gt;
&lt;li&gt;写出三种以上 MySQL数据存储
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="面试" scheme="http://www.maksim.website/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP 控制反转、依赖注入、依赖查找服务容器？</title>
    <link href="http://www.maksim.website/2017/10/19/cjek1d3j90023rhrdswx0qmjq/"/>
    <id>http://www.maksim.website/2017/10/19/cjek1d3j90023rhrdswx0qmjq/</id>
    <published>2017-10-18T16:00:00.000Z</published>
    <updated>2017-10-22T04:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>控制反转（Inversion of Control，英文缩写为IoC）是框架的重要特征，并非面向对象编程的专用术语。它与依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）并没有关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;控制反转（Inversion of Control，英文缩写为IoC）是框架的重要特征，并非面向对象编程的专用术语。它与依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）并没有关系。&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="服务容器" scheme="http://www.maksim.website/tags/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>《PHP internals Book》 一本深入PHP 扩展开发的书籍</title>
    <link href="http://www.maksim.website/2017/10/18/10/"/>
    <id>http://www.maksim.website/2017/10/18/10/</id>
    <published>2017-10-17T16:00:00.000Z</published>
    <updated>2018-01-07T10:45:32.198Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家介绍一本 PHP 扩展开发相关的书籍<a href="http://www.phpinternalsbook.com/" target="_blank" rel="noopener">《PHP internals Book》</a>，这本书是几个PHP开发人员之间的协作努力，可以更好地记录和描述PHP内部的工作原理。</p><p>《PHP internals Book》 有三个主要目标：</p><ul><li>记录和描述PHP内部工作原理。</li><li>记录并描述如何使用扩展扩展语言。</li><li>记录并描述如何与社区进行交互以开发PHP本身。</li></ul><p>《PHP internals Book》 主要面向具有C编程语言经验的开发人员。然而，尽管如此，我们将尝试提炼信息并对其进行总结，以便不了解C的开发人员仍然能够理解内容。</p><p>但是，让我们坚持。如果您不知道C语言，您将无法实现高效，稳定（任何平台下的崩溃），性能和实用性。以下是有关C语言本身，生态系统和构建工具以及操作系统API的一些非常好的在线资源：</p><ul><li><a href="http://www.tenouk.com/" target="_blank" rel="noopener">http://www.tenouk.com/</a></li><li><a href="https://en.wikibooks.org/wiki/C_Programming" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/C_Programming</a></li><li><a href="http://c-faq.com/" target="_blank" rel="noopener">http://c-faq.com/</a></li><li><a href="https://www.gnu.org/software/libc/" target="_blank" rel="noopener">https://www.gnu.org/software/libc/</a></li><li><a href="http://www.faqs.org/docs/Linux-HOWTO/Program-Library-HOWTO.html" target="_blank" rel="noopener">http://www.faqs.org/docs/Linux-HOWTO/Program-Library-HOWTO.html</a></li><li><a href="http://www.iecc.com/linker/linker10.html" target="_blank" rel="noopener">http://www.iecc.com/linker/linker10.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天给大家介绍一本 PHP 扩展开发相关的书籍&lt;a href=&quot;http://www.phpinternalsbook.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《PHP internals Book》&lt;/a&gt;，这本书是几个PHP开发人员之间
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP基础解惑： =与==、===的区别</title>
    <link href="http://www.maksim.website/2017/10/18/1/"/>
    <id>http://www.maksim.website/2017/10/18/1/</id>
    <published>2017-10-17T16:00:00.000Z</published>
    <updated>2017-10-18T13:19:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先等于号（=）在大多数语言中都是赋值操作；</p><p><code>==</code>和<code>===</code>都是比较运算符，用来比较两个变量间的关系，他们两个都有“等于”的含义，不过<code>===</code>是恒等计算符。两侧数据类型不一致时会返回 false，在官方文档中给出如下：</p><p><code>==</code>如果两侧的变量类型不同时，会转化类型后在进行比较。</p><table><thead><tr><th>例子</th><th>名称</th><th>结果</th></tr></thead><tbody><tr><td>$a == $b</td><td>等于</td><td><strong>TRUE</strong>，如果类型转换后 $a 等于 $b。</td></tr><tr><td>$a === $b</td><td>全等</td><td><strong>TRUE</strong>，如果 $a 等于 $b，并且它们的类型也相同。</td></tr></tbody></table><p>上表摘自 PHP 手册。下面来看一个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">   $age = <span class="number">18</span>;</div><div class="line">   var_dump($age == <span class="number">18</span>)l    <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age === <span class="number">18</span>);   <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age == <span class="string">'18'</span>);  <span class="comment">//bool(true)</span></div><div class="line">   var_dump($age === <span class="string">'18'</span>); <span class="comment">//bool(false)</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先等于号（=）在大多数语言中都是赋值操作；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;===&lt;/code&gt;都是比较运算符，用来比较两个变量间的关系，他们两个都有“等于”的含义，不过&lt;code&gt;===&lt;/code&gt;是恒等计算符。两侧数据类型不一致时会返回 f
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="PHP基础" scheme="http://www.maksim.website/tags/PHP%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP页面静态化</title>
    <link href="http://www.maksim.website/2017/10/16/cjek1d3jl002frhrd7arohwj6/"/>
    <id>http://www.maksim.website/2017/10/16/cjek1d3jl002frhrd7arohwj6/</id>
    <published>2017-10-16T11:17:47.000Z</published>
    <updated>2017-10-16T11:30:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h1><p>要了解静态化页面，首先我们就要知道什么是页面？</p><p>一、静态web页面：</p><p>1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。</p><p>2、为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。</p><p>3、静态web无法连接数据库；</p><p>4、静态web资源开发技术：HTML；</p><p>5、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。</p><p>二、动态web页面：</p><p>动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。</p><p>如果客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</p><p>如果客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</p><p>#静态化</p><p>PHP静态化分为：纯静态化 和 伪静态化；纯静态化又分为：局部静态化 和 完全静态化</p><p>纯静态化：是把PHP生成的动态页面保存成静态的html文件，用户访问该静态页面，而不是用户每一次访问都重新生成一张相同的网页，优点就是减小服务器开销，</p><ul><li>局部静态化：是生成的静态文件中，有局部的数据还是通过ajax技术动态获取的；</li><li>完全静态化：即不存在动态获取数据的情况，所以内容都来自静态的html页面</li></ul><p>伪静态化：其实还是动态访问，其实质是动态生成数据，你访问的网址类似于”<a href="http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化" target="_blank" rel="noopener">http://yourhost,com/index/post/12&quot;,是一个静态地址，该地址多见于博客地址，但伪静态化中，你访问的网址实际上经过服务器解析，还是会解析成类似于&quot;http://yourhost,com/?c=index&amp;a=post&amp;id=12&quot;的地址，所以称之为伪静态化</a></p><p>　　伪静态的优点：美观；便于搜索引擎收录</p><p>buffer 概括</p><p>buffer 其实就是缓冲区，一个内存地址空间，主要是用于存储数据的区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于页面&quot;&gt;&lt;a href=&quot;#关于页面&quot; class=&quot;headerlink&quot; title=&quot;关于页面&quot;&gt;&lt;/a&gt;关于页面&lt;/h1&gt;&lt;p&gt;要了解静态化页面，首先我们就要知道什么是页面？&lt;/p&gt;
&lt;p&gt;一、静态web页面：&lt;/p&gt;
&lt;p&gt;1、在静态Web程序中，客
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP基础解惑：省略结束标签</title>
    <link href="http://www.maksim.website/2017/10/16/1/"/>
    <id>http://www.maksim.website/2017/10/16/1/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2018-03-09T13:13:44.475Z</updated>
    
    <content type="html"><![CDATA[<p>对于PHP编译器来说，脚本的结束标签<code>?&gt;</code>是可选的，在写程序时你可以忽略它。你或许碰见过：在使用include()、require()或输入输出缓冲函数时，页面顶部有时会多空行或者出现<code>“header had send”</code>之类的错误信息，这类问题与结束标签有关。</p><p>省略结束标签适合纯PHP文件。如果是PHP与HTML混合开发，则不可省略。</p><p>忽略结束标签不仅能少些两个字符，而且可以使得我们开发的过程更加顺利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于PHP编译器来说，脚本的结束标签&lt;code&gt;?&amp;gt;&lt;/code&gt;是可选的，在写程序时你可以忽略它。你或许碰见过：在使用include()、require()或输入输出缓冲函数时，页面顶部有时会多空行或者出现&lt;code&gt;“header had send”&lt;/code&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
      <category term="PHP基础" scheme="http://www.maksim.website/tags/PHP%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP基础手札之emtpy、isset、is_null的区别</title>
    <link href="http://www.maksim.website/2017/10/16/2/"/>
    <id>http://www.maksim.website/2017/10/16/2/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-10-16T01:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>PHP提供了3个用于测试变量值的函数，分别是isset()、empty()、is_null（从这里就可以看出PHP系统函数变量名命名的混乱，这也是一直被人诟病的地方）.这几个函数均返回布尔值，有时使用不当会造成意想不到的结果。</p><p>比如，用isset()和empty()返回的结果是相反的，但却并非一直如此。</p><p>isset()用来检测一个变量是否已声明且值不为null。只能在变量不是null时返回真。</p><p>empty()用来检测一个变量是否为空，也就是说有如下情况时返回真值：变量是一个空字符串，false，空数组,null,’’,以及被unset删除后的变量。</p><blockquote><p>在PHP5.5之后，empty()函数可以接受任意类型的表达式</p></blockquote><p>is_null()函数用来判断变量内容是否是null，即返回真值的条件仅为变量值是null，值得一提的是，is_null() 是 isset() 的反函数，区别是isset()函数可以应用到未知变量，但is_null()只能针对以声明的变量。</p><table><thead><tr><th>对比项</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>变量值($var)</td><td>isset($var)</td><td>empty($var)</td><td>is_null($var)</td></tr><tr><td>“”（空字符串）</td><td>bool(true)</td><td>bool(true)</td><td>bool(false)</td></tr><tr><td>“ “(空格)</td><td>bool(true)</td><td>bool(false)</td><td>bool(false)</td></tr><tr><td>false</td><td>bool(true)</td><td>bool(true)</td><td>bool(false)</td></tr><tr><td>true</td><td>bool(true)</td><td>bool(false)</td><td>bool(false)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PHP提供了3个用于测试变量值的函数，分别是isset()、empty()、is_null（从这里就可以看出PHP系统函数变量名命名的混乱，这也是一直被人诟病的地方）.这几个函数均返回布尔值，有时使用不当会造成意想不到的结果。&lt;/p&gt;
&lt;p&gt;比如，用isset()和empt
      
    
    </summary>
    
      <category term="PHP" scheme="http://www.maksim.website/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2017/10/15/cjek1d3ij000xrhrdv57fvp4q/"/>
    <id>http://www.maksim.website/2017/10/15/cjek1d3ij000xrhrdv57fvp4q/</id>
    <published>2017-10-15T11:24:45.000Z</published>
    <updated>2017-10-15T11:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL常用存储引擎之Innodb"><a href="#MySQL常用存储引擎之Innodb" class="headerlink" title="MySQL常用存储引擎之Innodb"></a>MySQL常用存储引擎之Innodb</h1><p>Mysql5.5(5.58)及之后的版本默认的存储引擎由 MyISAM 引擎替换为 Innodb。</p><p>和 MyISAM 存储引擎不同，InnoDB是事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况下是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非实物型存储的需求中也很六星。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑 innoDB 引擎。</p><p>特点：</p><ul><li>灾难恢复性好</li><li>支持全部四种级别的事务。默认的事务隔离级别是可重复度（Repeatable Read），它的事务支持通过多版本并发控制（MVVC）来提供的</li><li>使用行级锁</li><li>对于 InnoDB 引擎的表，其数据的物理组织形式是簇表（Cluster Table），数据按主键来组织，也就是说主键索引和数据是在一起的，数据主键的顺序物理分布。数据表的另一种常见形式是非簇表，其索引是有序的，而数据时无序的</li><li>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的读取。相比之下，MyISAM 只是缓存了索引</li><li>支持外键</li><li>支持热备份</li></ul><p>Innodb 拥有表空间的概念，表中的数据时存储在表空间之中的，具体存储在什么样的表空间之中则由<code>innodb_file_per_table</code>这个参数决定。</p><p>如果值为 <code>ON</code>,会为每个 innodb 表建立一个<code>tablename.ibd</code>的系统文件，如果该参数为<code>OFF</code>时会把数据存储到系统的表空间<code>ibdataX</code></p><p>引用</p><p>《打造扛得住的 MySQL》 慕课网</p><p>《高性能 MySQL》</p><p>《My》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;a href=&quot;#MySQL常用存储引擎之Innodb&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用存储引擎之Innodb&quot;&gt;&lt;/a&gt;MySQL常用存储引擎之Innodb&lt;/h1&gt;&lt;p&gt;Mysql5
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2017/10/13/cjek1d3in0012rhrdm1dktew0/"/>
    <id>http://www.maksim.website/2017/10/13/cjek1d3in0012rhrdm1dktew0/</id>
    <published>2017-10-13T08:56:28.000Z</published>
    <updated>2018-02-27T13:04:29.467Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:MySQL服务器参数介绍<br>categories:MySQL<br>date:2017-10-18</p><h2 id="id-1"><a href="#id-1" class="headerlink" title="id:1"></a>id:1</h2><p>人们经常问，“我的服务器有32G内存，12核CPU，怎样配置最好？”很遗憾，问题没有那么简单。服务器的配置应该符合它的工作负载、数据，以及对应需求，并不仅仅看硬件的情况。</p><p>MySQL有大量可以修改的参数——但是不应该随意去修改。通常只需要把基本的配置正确（大部分情况下至于很少的一些参数是真正重要的），应该更多的时间花在schema的优化、索引、以及查询设计上。在正确地配置了MySQL的基本配置项之后，再花力气去修改其他配置项的收益通常就比较小了。</p><p>从另外一方面来说，没用的配置项会导致潜风险的可能更大。我们碰到过不止一个“高度调优”过的服务器不停地彭奎，停止服务或者运行缓慢，结果都是因为错误的配置导致的。</p><p>##　MySQl获取配置信息路径</p><ul><li>命令行参数 <code>mysqld_safe --datadir=/data/sql_data</code></li><li>配置文件 <code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code></li></ul><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20171013153125.png" alt=""></p><p>MySQL会先从<code>/etc/my.cnf</code>文件下读取配置信息，然后是<code>/etc/mysql/my.cnf</code>。</p><p>MySQL配置参数的作用域</p><ul><li>全局参数 <ul><li><code>set global 参数名 = 参数值;</code></li><li><code>set @@global。参数名:=参数值;</code></li></ul></li><li>会话参数<ul><li><code>set [session] 参数名=参数值;</code></li><li><code>set @@session.参数名:=参数值;</code></li></ul></li></ul><p>会话参数在没有被单独指定的时会使用全局参数的值来当做默认值。</p><p>在这里需要注意，如果在服务器运行时修改了变量的全局值，这个值对当前回话和其他任何已经存在的会话是不起作用的，这是因为会话的变量值是在连接创建时从全局值初始化来的。在每次更改之后，应该检查 SHOW GLOBAL VARIABLES 的输出，确认已经按照期望变更了。</p><h2 id="内存配置相关参数"><a href="#内存配置相关参数" class="headerlink" title="内存配置相关参数"></a>内存配置相关参数</h2><p>MySQL对于内存的使用我们可以分为两个类来看。</p><ul><li>无法通过配置参数设置的，如MySQL运行，解析，运行，查询所需要的内存</li><li>可以通过参数配置控制的，各类的缓冲池所需要的内存。</li></ul><p>对内存参数配置之前，我们需要进行考虑：</p><ul><li>确定可以使用内存的上限，最根本的一点是不能超过本身物理内存的。还有一点是系统架构的问题，如果是32位系统，那么单个进程只能设置低于3G的内存空间。</li><li>确定MySQL的每个连接使用的内存，例如排序缓冲和临时表</li><li><p>把剩下的内存全部给 MySQL 的缓存，例如 InnoDB 的缓冲池。</p><ul><li><p>sort_buffer_size</p><ul><li>join_buufer_szie</li><li>read_buffer_size</li><li>read_rnd_buffer_size  </li></ul></li></ul></li></ul><h3 id="确定需要为操作系统保留多少内存"><a href="#确定需要为操作系统保留多少内存" class="headerlink" title="确定需要为操作系统保留多少内存"></a>确定需要为操作系统保留多少内存</h3><p>给操作系统保留的内存还需要保留，在系统中运行的其他所有服务所需要的内存，以及前面提到的我们无法为MySQL进行控制的那一部分内存。</p><p>数据库最好使用专用的服务器，不要与其他服务共用服务器，不可避免的会造成内存的争用，给配置内存带来更多的考虑因素。</p><p>另外也有人喜欢在一台物理服务器上，运行多个MySQL实例，从内存分配上来看这样做也不好，除非是在开发、测试中可以节约服务器成本，但是在生产环境中最好不要运行多个MySQL实例，因为这样也会造成内存和I/O的争用，影响mysql服务的性能。</p><h3 id="如何为缓冲池分配内存"><a href="#如何为缓冲池分配内存" class="headerlink" title="如何为缓冲池分配内存"></a>如何为缓冲池分配内存</h3><p>Innodb_buffer_pool_size，Innodb缓冲区</p><p>总内存-（每个线程所需要的内存*连接数）- 系统保留内存</p><p>手册中建议大家该内存大小应该为服务器内存大小的百分之七十五以上，上面提到了MySQL是如何使用内存的，所以不能简单粗暴的设置成百分之七十五，必须还得考虑其他的一些因素。</p><h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>设置这个变量可以一次性为缓冲区(key buffer，也叫键缓存 key cache)分配所指定的空间，然而</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(index_length) from information_schema.tables where engine=&apos;myisam&apos;</div></pre></td></tr></table></figure><h2 id="I-O相关配置参数"><a href="#I-O相关配置参数" class="headerlink" title="I/O相关配置参数"></a>I/O相关配置参数</h2><p>Innodb I/O相关配置</p><h2 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h2><p><code>expire_logs_days</code> 指定自动清理binlog的天数，这个天数的设置，最好能够覆盖两次全备间隔的天数，如果每天都进行全备的话，最好也能够保持7天，这样以备在特殊情况下数据的查找，比如数据出现异常的情况下，就可能会使用到binlog日志进行查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:MySQL服务器参数介绍&lt;br&gt;categories:MySQL&lt;br&gt;date:2017-10-18&lt;/p&gt;
&lt;h2 id=&quot;id-1&quot;&gt;&lt;a href=&quot;#id-1&quot; class=&quot;headerlink&quot; title=&quot;id:1&quot;&gt;&lt;/a&gt;id:1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.maksim.website/2017/10/13/cjek1d3kl003zrhrdqn2bsqsg/"/>
    <id>http://www.maksim.website/2017/10/13/cjek1d3kl003zrhrdqn2bsqsg/</id>
    <published>2017-10-13T05:41:58.000Z</published>
    <updated>2017-10-13T05:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务评估"><a href="#业务评估" class="headerlink" title="业务评估"></a>业务评估</h1><h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ul><li>响应时间（request time）</li><li>数据总量</li><li>每秒请求量</li><li>读写比</li><li>重要程度</li></ul><p><strong>响应时间</strong>是与整个数据库的状态有关，不仅与CPU、数据总量、每秒请求量、读写比以及各种场景都是有关系的。所以说相应时间是一个综合指标。</p><p>对于DBA来说最关心的就是业务的相应时间能不能够满足，在满足的情况下再去优化以下的这些点，才是有意义的。</p><p>数据总量往往需要业务方提供一个一到两年的数据总量，这是因为如果没有数据总量，前期是没有办法规划我们的数据库实例的。当然也有很多的不确定因素，比如互联网行业，比如有的业务会爆发性的增长，这些规划可能是不合理的，但是在我们也要有一个大概的评估，因为这是前期资源申请和资源分配的策略。</p><p>每秒请求量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务评估&quot;&gt;&lt;a href=&quot;#业务评估&quot; class=&quot;headerlink&quot; title=&quot;业务评估&quot;&gt;&lt;/a&gt;业务评估&lt;/h1&gt;&lt;h2 id=&quot;业务需求&quot;&gt;&lt;a href=&quot;#业务需求&quot; class=&quot;headerlink&quot; title=&quot;业务需求&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL体系结构</title>
    <link href="http://www.maksim.website/2017/10/13/1/"/>
    <id>http://www.maksim.website/2017/10/13/1/</id>
    <published>2017-10-12T16:00:00.000Z</published>
    <updated>2017-10-13T11:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库产品的架构一般可以分为应用层、逻辑层、物理层，对于MySQL，同样可以理解为如下3个层次。</p><p><img src="http://ogxeww23n.bkt.clouddn.com/http://images2015.cnblogs.com/blog/676456/201707/676456-20170722164214340-166686649.jpg210050572965263.gif" alt="img"></p><p>其中<code>Connectors</code>可以理解为各种客户端、 应用服务； <code>Connection Pool</code>可以理解为<strong>应用层</strong>，负责和客户端、用户进行交互，需要和不同的客户端（<code>PHP</code>,<code>Java</code>,<code>C API</code>,<code>.Net</code>以及<code>ODBC</code>,<code>JDBC</code>等等）和中间服务器进行交互，这一层主要完成的是链接处理，授权认证，和安全等一些功能，连接到<code>MySQL</code>的客户端在其进程中，都会有一个独立的线程，连接的查询只会在这个登录线程中进行查询。</p><p><code>Management Services&amp;Utilities</code>、<code>SQL Interface</code>、 <code>Parser</code>、 <code>Optimizer</code>、 <code>Caches&amp;Buffers</code>、 <code>Pluggable Storage Engines</code>可以理解为数据库的大脑——<strong>逻辑层</strong>。</p><p>负责具体的查询处理、事务处理、存储管理、恢复管理，以及其他附加功能。查询处理器负责查询的解析、执行。当接收到客户端的查询时，数据库会分配一个县城来处理它。先友查询处理器（优化器）生成执行计划，然后交由计划执行器来执行，执行器有时需要访问更底层的事务管理器、存储管理器来操作数据，事务管理器、存储管理器主要负责事务控制、并发控制、存储管理。在其中，将由事务管理来保证“<code>ACID</code>”特性，通过锁管理器来控制并发，由日志管理器来确保数据持久化，存储故那里器一般还包括一个缓冲管理器，有它来确定磁盘和缓存之间的数据传输。</p><p>根据上面的架构图，我们可以看到在逻辑层中<code>Pluggable Storage Engines</code></p><p>这是MySQL服务逻辑架构中的第三层，是MySQL的存储引擎，MySQL提供出了存储引擎接口，第三方可以根据自己的业务逻辑需求开发自己的存储引擎，Innodb起初就是由Innobase Oy公司所开发，2006年5月被甲骨文公司并购。</p><p>服务器通过API与存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作，但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地相应上层和服务的请求。</p><blockquote><p>注意：存储引擎是针对于表的而不是针对于库的，不同的表可以使用不同的引擎；</p></blockquote><p> 最下方的Files&amp;Logs可以理解为物理层，实际物理磁盘（存储）上的数据库文件，比如数据文件、日志文件等等。</p><p>引用：</p><p>《MySQL DBA修炼之道》 作者陈晓勇  出版社：华章图书</p><p>《打造扛得住的MySQL》 电子工业出版社</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库产品的架构一般可以分为应用层、逻辑层、物理层，对于MySQL，同样可以理解为如下3个层次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ogxeww23n.bkt.clouddn.com/http://images2015.cnblogs.com/blog/676
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.maksim.website/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL常用存储引擎之MyISAM</title>
    <link href="http://www.maksim.website/2017/10/13/2/"/>
    <id>http://www.maksim.website/2017/10/13/2/</id>
    <published>2017-10-12T16:00:00.000Z</published>
    <updated>2017-10-18T13:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>MyISAM存储引擎是MySQL5.5之前版本默认的存储引擎，由于这个原因，现在还有大量的数据库在使用MyISAM的表。</p><p>同时它也是MySQL大部分系统表和临时表使用的而存储引擎，这个临时表并非是我们使用<code>CREATE TEMPORARY TABLE</code>所建立的临时表。</p><p>使用<code>CREATE TEMPORARY TABLE</code>语句创建的临时表，我们可以使用MySQL各种存储引擎的，这里所说的临时表指的是在排序、分组等操作中，当当数量超过一定大小后，由查询优化器所建立的磁盘临时表。</p><p>MyISAM存储引擎表由MYD和MYI组成。</p><p>在这里，我们建立一个myIsam的表，并且存储引擎使用了MyISAM。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`myIsam`</span> (</div><div class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line"><span class="string">`c1`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></div><div class="line">)<span class="keyword">ENGINE</span>= MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</div></pre></td></tr></table></figure><p>下图为MyISAM在文件系统上的存储方式：</p><p><img src="http://ogxeww23n.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20171013110625.png" alt=""></p><p>以frm为扩展名存储的文件并非是MyISAM存储引擎独有，它是用于记录表的结构。MyISAM表可以存储的记录数，一般首选治愈可用磁盘空间，或者是操作系统单个文件最大尺寸的限制。</p><p>作为MySQL最早的存储引擎之一，MyISAM有一些已经开发出来很多年的特性，可以满足用户的实际需求。</p><p><strong>加锁与并发</strong></p><ul><li>MyISAM使用的是表级锁，进行读取操作时会对需要读到的所有表加共享锁，写入时则会对表加排他锁。但是在表有读取查询的同时，可以往表中插入新的记录，这也被称之为并发插入，CONCURRENT INSERT</li></ul><p><strong>修复</strong> </p><ul><li>对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作，但是此处的修复和事务恢复以及崩溃恢复并不是一个概念，执行表的修复可能导致数据的丢失，而且修复操作时非常慢的。可以通过CHECK TABLE table检查表的错误，如果存在错误可以通过REPAIR TABLE table进行修复。在MySQL服务器处于<strong>关闭状态</strong>时，可以通过myisamcheck命令工具进行检查和恢复，切记是处于<strong>关闭状态</strong>。</li></ul><p><strong>索引</strong></p><ul><li>对于MyISAM表，即使是BLOG和TEXT等长字段，也可以基于前500个字符创建索引，而且MyISAM也支持全文索引。</li><li>延迟更新索引（Delayed Key Write）创建MyISAM表的时候，如果制定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃的时候会造成索引损坏，需要执行修复操作。此属性可以再全局设置，也可以为单个表设置。</li></ul><p><strong>压缩</strong></p><ul><li>如果表在创建并导入数据以后，不会再进行修改操作，可以使用myisampa对表进行压缩（打包）。压缩表不能进行修改，除非解除压缩，压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升性能，压缩表支持索引，但索引也是只读的。</li><li>压缩时表中的记录是独立压缩的，所以读取单行的时候不需要去解压整个表。</li></ul><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><ul><li>版本&lt;MySYQL5.0时默认表大小为4G，如存储大表则需要修改MAX_Rows和AVG_ROW_LENGTH这两个参数，调整后表会进行重建，这需要很长的时间。</li><li>版本 &gt; 5.0时默认支持256TB </li></ul><p>适用场景：</p><ul><li>非事务性应用</li><li>只读类应用</li><li>空间类应用（在5.7之前，MyISAM是唯一支持空间函数的存储引擎）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MyISAM存储引擎是MySQL5.5之前版本默认的存储引擎，由于这个原因，现在还有大量的数据库在使用MyISAM的表。&lt;/p&gt;
&lt;p&gt;同时它也是MySQL大部分系统表和临时表使用的而存储引擎，这个临时表并非是我们使用&lt;code&gt;CREATE TEMPORARY TABLE
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.maksim.website/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>服务器硬件对MYSQL性能的影响</title>
    <link href="http://www.maksim.website/2017/10/10/1/"/>
    <id>http://www.maksim.website/2017/10/10/1/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2017-10-15T11:12:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>影响数据库性能的主要因素有很多，主要包括以下几点：</p><ol><li>服务器硬件</li><li>服务器系统</li><li>数据库存储引擎的选择</li><li>数据库参数配置</li><li>数据库结构设计和SQL语句</li></ol><h1 id="服务器硬件："><a href="#服务器硬件：" class="headerlink" title="服务器硬件："></a>服务器硬件：</h1><p>每当大促或者一些活动的时候，我们监控系统时会发现，CPU和可用内存的资源都是很紧张的，特别对于一些计算密集型的应用，CPU的资源可能会变成系统的瓶颈。</p><p>当我们工作所需要的热数据的大小大于可用内存大小的时候，IO系统就会变成我们的瓶颈。</p><p>网络也算是一种IO，它对于性能的影响往往发生在大量的数据被查询时，特别是使用MemCache这类缓存系统时，当缓存大量失效时，就会造成大量的网络传输从而影响服务性能。</p><p>当发生这类问题的时候，我们可以升级I/O子系统，来增加大量的内存。</p><h2 id="如何选择CPU？"><a href="#如何选择CPU？" class="headerlink" title="如何选择CPU？"></a>如何选择CPU？</h2><h4 id="我们是选择更多的CPU，还是更快的CPU？"><a href="#我们是选择更多的CPU，还是更快的CPU？" class="headerlink" title="我们是选择更多的CPU，还是更快的CPU？"></a>我们是选择更多的CPU，还是更快的CPU？</h4><p>Intel Xeon E7-8890 v2</p><p>主频2.5GHz 核心数量：18核36线程</p><p>正常情况下，这两点我们都想要，但是现实是残酷的，44499RMB的价格，并不是所有公司都能够接受的。</p><p>首先，我们需要考虑几个问题。</p><p>####我们的应用是CPU密集型的应用吗？</p><p>如果是CPU密集型的应用要加快SQL的处理速度，显然我们需要的是更快的CPU而不是核心较多的CPU。</p><p>值得注意的是，MySQL目前还不支持多CPU对同一SQL并发处理。</p><p>也就是说，一条SQL只能使用一颗CPU来进行处理，多颗CPU对于一条SQL的处理效率是没有帮助的。</p><p>我们系统的并发量如何？</p><p>虽然单个SQL无法利用到多个CPU资源，如果要提高系统的吞吐量和并发处理量呢？</p><p>这时我们就需要CPU越多越好。</p><p>在Web应用中，CPU的数量就要比频率要重要一些。</p><p>我们所使用的MySQL版本也会决定如何选择CPU，老版本的MySQL对于多核CPU的支持并不好，5.0之前的版本限制是非常严重的，5.6、5.7对多核CPU的支持已经有了很好的改善。</p><h4 id="选择32位还是64位的CPU？"><a href="#选择32位还是64位的CPU？" class="headerlink" title="选择32位还是64位的CPU？"></a>选择32位还是64位的CPU？</h4><p>这个问题已经是多余的了，目前64位已经是默认配置了，而且MySQL对于64位CPU的支持已经很好了。</p><p>不过值得注意的是，<strong>在64位CPU上使用32位操作系统</strong>，意味着我们不能使用大的内存，任何一个单独的进程都不能寻址到4G以上的内存，MySQL是一个单线程的服务，这样就会对MySQL的性能造成极大的影响。</p><h2 id="内存、更大更快？"><a href="#内存、更大更快？" class="headerlink" title="内存、更大更快？"></a>内存、更大更快？</h2><p>内存的大小直接影响数据库的性能，目前内存的IO效率要远远高于磁盘，所以把数据缓存到内存中可以大大提高数据库性能。</p><p>MyISAM会把索引缓存到内存中，数据放到系统上进行缓存。</p><p>InnoDB会在内存上同时缓存索引和数据，所以可以提高运行效率</p><p>内存的确是越多越好，可是数据库的性能影响也是有限的，并不能无限增加性能，数据库可以利用的内存是有限的。</p><p>当所有的数据都被缓存到内后，再增加内存大小就变成没有意义的了。</p><p>如果我们的数据的大小是100G，内存是64G，我们可以通过扩展内存到128G来扩大数据库的缓冲区来提高数据库性能。</p><p>可是如果此时内存以经256G了，并且数据库的缓存池大小已经达到了196G的情况下，就不能指望增加内存来提高数据库心梗了。</p><p>多余的内存可以增加操作系统等其他服务的性能。</p><p>缓存虽然不能避免磁盘的写操作，但是可以起到延缓作用，把多次写入变成一次写入。</p><p>###　内存的选择？</p><p>内存的频率越高读取也就越快，应该选择主板所支持的最高主频，组成购买升级，每个通道的内存最高相同品牌、颗粒、频率、电压、校验技术和型号。单条容量要尽可能的大。</p><p>根据数据库大小选择内存，例如现在热数据有100G，那么我们就可以选择128G的内存。但是还有一个问题，那就是数据的增长率，为了避免短时间内多次升级硬件，可以选择更大一些的内存。</p><p>##I/O子系统（磁盘的配置和选择）</p><p>虽然内存对数据库的性能影响很重要，通过增加内存大小可以解决大部分性能问题，但是并不能忽视I/O子系统对性能影响。</p><p>有时我们需要以牺牲内存为代价提高I/O子系统的性能，因为无论如何最终，数据都要通过磁盘来进行持久化的存储。</p><p>目前主流的四种磁盘配置：</p><ol><li>使用传统机器磁盘</li><li>使用RAID增强传统机器磁盘</li><li>使用固态存储SSD和PCIe卡</li><li>使用网络存储NAS和SAN</li></ol><h3 id="传统机器硬盘"><a href="#传统机器硬盘" class="headerlink" title="传统机器硬盘"></a>传统机器硬盘</h3><p>传统机器磁盘是目前最常见的选择，使用最多，这类磁盘价格低，存储空间大，但是读、写速度较慢，传统机器硬盘的读、写效率取决于它的存储机制。</p><p>传统机器硬盘读取数据的过程：</p><ol><li>移动磁头到磁盘表面的正确位置</li><li>等待磁盘旋转，使所需的数据在磁头之下</li><li>等待磁盘旋转过去，所有所需的数据都被磁头读取</li></ol><p>磁盘执行这些操作有多快，也就决定了磁盘的读取速度，第1,2步骤被称之为访问时间，第3步称之为传输速度。</p><p>如何选择传统机器硬盘</p><ol><li>存储容量</li><li>传输速度</li><li>访问时间</li><li>主轴转速</li><li>物理尺寸</li></ol><h3 id="RAID增强机器硬盘的性能"><a href="#RAID增强机器硬盘的性能" class="headerlink" title="RAID增强机器硬盘的性能"></a>RAID增强机器硬盘的性能</h3><p>首先我们要知道什么是RAID，RAID是磁盘冗余队列的简称（Redundant Arrays of independent Disks）简单来说RAID的作用就是可以把多个容量较小的磁盘组成一组容量更大的磁盘，并提供数据冗余保证数据完整性的技术。</p><h4 id="数据库中使用的RAID-0级别："><a href="#数据库中使用的RAID-0级别：" class="headerlink" title="数据库中使用的RAID 0级别："></a>数据库中使用的RAID 0级别：</h4><p><strong>RAID 0</strong>是最早出现的RAID模式，也称之为数据条带，是组建磁盘阵列中<strong>最简单</strong>的一种形式，只需要两块以上的硬盘即可，<strong>成本低</strong>，可以提高整个磁盘的性能和吞吐量。RAID 0<strong>没有提供冗余或错误修复能力</strong>，但是实现成本是最低的。</p><p><img src="http://www.maixj.net/wp-content/uploads/2015/02/raid0.png" alt="RAID 0"></p><p>RAID 0 就是多个独立的磁盘串联到一起，比如有三块300G的磁盘组合到一起，就可以组成一块900G的磁盘，在写入时可以并发同时对三块磁盘进行写入，理论上写入效率就是普通磁盘的三倍。</p><p>RAID 0可能是性价比最高的解决方案，但是如果考虑到数据的恢复、可靠性因素，RAID 0就变成了一种成本最高的一种解决方案。</p><p>因为在RAID 0 中数据没有冗余，数据损坏的几率要比单块磁盘的几率还要高，因为RAID 0中任意一块磁盘损坏了，都会造成数据丢失。</p><p>所以RAID 0比较适合于不担心数据丢失的情况，比如可以随时从其他数据库克隆的备存，或者是一次性使用的数据。</p><h4 id="数据库中使用的RAID-1级别"><a href="#数据库中使用的RAID-1级别" class="headerlink" title="数据库中使用的RAID 1级别"></a>数据库中使用的RAID 1级别</h4><p><strong>RAID 1</strong>又称磁盘镜像，原理是把一块磁盘的数据镜像到另一个磁盘上，也就是说数据写入一块磁盘的同事，会在另一块限制的磁盘上生成镜像文件，在不影响性能的情况下最大限度的保证系统的可靠性和可修复性。</p><p><img src="http://www.maixj.net/wp-content/uploads/2015/02/raid1.jpg" alt="RAID 1"></p><p>RAID 1当一块硬盘失效时，系统会忽略该硬盘，转而使用剩余的镜像盘来读取数据，拥有很好的冗余能力，虽然这样对数据的安全性而言是绝对安全的，但是却似的成本增加，磁盘的利用率仅有百分之五十，以4块300G的硬盘而言，能够利用的空间仅有600G，出现故障后的RAID系统也不在可靠了，应当及时更换损坏的硬盘，否则其他的镜像盘也出现问题了，会导致系统的崩溃。</p><p>更换硬盘后需要很长的时间同步镜像，虽然对数据的访问不会受到影响，但是对整个系统的性能是会有所下降的。</p><p>RAID 1在读的速度上要比RAID 0快。</p><p>####数据库中使用的RAID 5级别</p><p>RAID 5又称之为分布式奇偶校验磁盘阵列，通过分布式奇偶校验块把数据分散到多个磁盘上，这样如果任何一个盘数据失效，都可以从奇偶校验块中重建。但是如果两块磁盘失效，则整个卷的数据都无法恢复。</p><p><img src="http://www.maixj.net/wp-content/uploads/2015/02/raid5.gif" alt="RAID 5"></p><p>在RAID 5上随机比较慢，因为每次写都需要两次读和两次写，以计算校验位的数值，比较适合以读为主的数据库业务。</p><p>最大的性能问题，发生在磁盘失效的时候，因为数据需要重新分布到其他磁盘上，这样会严重影响数据库性能，如果要使用RAID 5的话，最好使用在从服务器上。</p><h4 id="数据库中使用的RAID-10级别"><a href="#数据库中使用的RAID-10级别" class="headerlink" title="数据库中使用的RAID 10级别"></a>数据库中使用的RAID 10级别</h4><p>RAID 10又称分片的镜像，她是对磁盘先做RAID 1之后对两组RAID 1的磁盘再做RAID 0，所以对读写都有良好的性能，相对于RAID 5重建起来更简单，速度也更快。</p><p><img src="http://www.maixj.net/wp-content/uploads/2015/02/raid01.jpg" alt="RAID 10"></p><h4 id="RAID级别的选择"><a href="#RAID级别的选择" class="headerlink" title="RAID级别的选择"></a>RAID级别的选择</h4><table><thead><tr><th style="text-align:center">等级</th><th style="text-align:center">特点</th><th style="text-align:center">是否冗余</th><th style="text-align:center">盘数</th><th style="text-align:center">读</th><th style="text-align:center">写</th></tr></thead><tbody><tr><td style="text-align:center">RAID 0</td><td style="text-align:center">便宜，快速，危险</td><td style="text-align:center">无</td><td style="text-align:center">N</td><td style="text-align:center">快</td><td style="text-align:center">快</td></tr><tr><td style="text-align:center">RAID 1</td><td style="text-align:center">高速读，简单，安全</td><td style="text-align:center">有</td><td style="text-align:center">2</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">RAID 5</td><td style="text-align:center">安全，成本这种</td><td style="text-align:center">有</td><td style="text-align:center">N+1</td><td style="text-align:center">快</td><td style="text-align:center">取决于最慢的盘</td></tr><tr><td style="text-align:center">RAID 10</td><td style="text-align:center">贵，告诉，安全</td><td style="text-align:center">有</td><td style="text-align:center">2N</td><td style="text-align:center">快</td><td style="text-align:center">快</td></tr></tbody></table><h3 id="固态存储"><a href="#固态存储" class="headerlink" title="固态存储"></a>固态存储</h3><ol><li>拥有更好的随机读写性能。</li><li>能够更好的支持并发</li><li>更容易损坏</li></ol><p>在数据库存储中，我们常用的固态存储设备是SSD和PCI-E SSD。</p><h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><ol><li>使用SATA接口，可以替换传统磁盘而无需任何改变 </li><li>SATA接口的SSD同样支持RAID技术</li></ol><h4 id="PCI-E-SSD"><a href="#PCI-E-SSD" class="headerlink" title="PCI-E SSD"></a>PCI-E SSD</h4><ol><li>无法使用SATA接口，需要独特的驱动和配置</li><li>价格相比SSD要贵，但是性能比SSD更好</li></ol><p>PCI-E会占用服务器的内存。</p><h4 id="固态存储的使用场景"><a href="#固态存储的使用场景" class="headerlink" title="固态存储的使用场景"></a>固态存储的使用场景</h4><ol><li><p>适用于存在大量随机I/O的场景</p></li><li><p>使用于解决单线程负载的I/O场景</p><p>如果只有一块固态存储设备我们更应该将其放在从服务器上，因为从服务器是单线程的，而主DB是多线程的写入，为了产生更少的延迟，我们应该增加从服务器的I/O性能，而且由于固态设备易损耗，在主服务器上使用存在一定的安全隐患。</p></li></ol><h3 id="网络存储SAN和NAS"><a href="#网络存储SAN和NAS" class="headerlink" title="网络存储SAN和NAS"></a>网络存储SAN和NAS</h3><p><strong>SAN</strong>(Storage Area Network)和<strong>NAS</strong>(Network-Attached Storage)是两种外部文件存储设备加载到服务器上的方法</p><p>SAN设备通过光纤连接到服务器，设备通过块接口访问，服务器可以将其当做硬盘使用。</p><p>NAS设备使用网络连接，通过基于文件的协议如NFS或SMB来访问。</p><h4 id="网络存储适用的场景"><a href="#网络存储适用的场景" class="headerlink" title="网络存储适用的场景"></a>网络存储适用的场景</h4><p>网络存储在随机I/O比较差，并不适合MySQL数据库存储数据，有一些人认为可以使用网络存储实现服务的高可用性，比如两台服务器挂在同一网络环境下的磁盘，当主服务器可以由主备服务器来接管磁盘来提供服务，提高系统的可用性。</p><p>虽然能够在一定条件下能够提高系统的可用性，可是却是以牺牲性能为代价，而且，一旦网络存储设备出现问题，则需要更多的时间进行恢复。</p><p>不过，我们可以利用网络存储设备来存储数据库的备份文件，当一台独立服务器出现故障，短时间内无法恢复的情况下，可以利用网络存储设备上存储的备份文件恢复是实例。</p><h3 id="网络接口设备对数据库性能的影响"><a href="#网络接口设备对数据库性能的影响" class="headerlink" title="网络接口设备对数据库性能的影响"></a>网络接口设备对数据库性能的影响</h3><ol><li>网络带宽对性能的影响</li><li>网络质量对性能的影响</li></ol><p>建议</p><ul><li>采用高性能和高贷款的网络设备和交换机</li><li>对多个网卡进行绑定，增强可用性和带宽</li><li>尽可能的进行网络隔离</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>CPU</p><ul><li>64位的CPU一定要工作在64位的系统下</li><li>对于并发比较高的场景CPU的数量比频率更重要</li><li>对于CPU密集性场景和复杂SQL则频率越高越好</li></ul><p>内存</p><ul><li>选择主板所能使用的最高频率的内存</li><li>内存的大小对性能很重要，所以尽可能的大</li></ul><p>I/O子系统</p><ul><li>PCie -&gt; SSD -&gt; Raid10 &gt; 磁盘 -&gt; SAN</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;影响数据库性能的主要因素有很多，主要包括以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器硬件&lt;/li&gt;
&lt;li&gt;服务器系统&lt;/li&gt;
&lt;li&gt;数据库存储引擎的选择&lt;/li&gt;
&lt;li&gt;数据库参数配置&lt;/li&gt;
&lt;li&gt;数据库结构设计和SQL语句&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id
      
    
    </summary>
    
      <category term="MySQL" scheme="http://www.maksim.website/categories/MySQL/"/>
    
    
  </entry>
  
</feed>
